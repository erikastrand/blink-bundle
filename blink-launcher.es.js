/* Built at: 2024-10-21T09:40:26.236Z */
var jw = Object.defineProperty;
var Bw = (t, e, n) => e in t ? jw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var W = (t, e, n) => Bw(t, typeof e != "symbol" ? e + "" : e, n);
import * as v from "react";
import z, { createContext as ks, useState as tt, useCallback as Fe, useEffect as je, useContext as ht, useId as id, Component as Iw, useLayoutEffect as od, useRef as gt, useInsertionEffect as aA, useMemo as ms, forwardRef as Xr, Fragment as lA, createElement as En, Children as Fw, isValidElement as Vw } from "react";
import * as ad from "react-dom";
import cA from "react-dom";
var uA = { exports: {} }, ha = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function() {
  var t = z, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p = Symbol.iterator, g = "@@iterator";
  function A(P) {
    if (P === null || typeof P != "object")
      return null;
    var I = p && P[p] || P[g];
    return typeof I == "function" ? I : null;
  }
  var b = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function y(P) {
    {
      for (var I = arguments.length, Y = new Array(I > 1 ? I - 1 : 0), ie = 1; ie < I; ie++)
        Y[ie - 1] = arguments[ie];
      w("error", P, Y);
    }
  }
  function w(P, I, Y) {
    {
      var ie = b.ReactDebugCurrentFrame, Te = ie.getStackAddendum();
      Te !== "" && (I += "%s", Y = Y.concat([Te]));
      var Le = Y.map(function(me) {
        return String(me);
      });
      Le.unshift("Warning: " + I), Function.prototype.apply.call(console[P], console, Le);
    }
  }
  var x = !1, S = !1, q = !1, C = !1, E = !1, T;
  T = Symbol.for("react.module.reference");
  function k(P) {
    return !!(typeof P == "string" || typeof P == "function" || P === s || P === i || E || P === r || P === c || P === u || C || P === h || x || S || q || typeof P == "object" && P !== null && (P.$$typeof === f || P.$$typeof === d || P.$$typeof === o || P.$$typeof === a || P.$$typeof === l || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    P.$$typeof === T || P.getModuleId !== void 0));
  }
  function R(P, I, Y) {
    var ie = P.displayName;
    if (ie)
      return ie;
    var Te = I.displayName || I.name || "";
    return Te !== "" ? Y + "(" + Te + ")" : Y;
  }
  function D(P) {
    return P.displayName || "Context";
  }
  function F(P) {
    if (P == null)
      return null;
    if (typeof P.tag == "number" && y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof P == "function")
      return P.displayName || P.name || null;
    if (typeof P == "string")
      return P;
    switch (P) {
      case s:
        return "Fragment";
      case n:
        return "Portal";
      case i:
        return "Profiler";
      case r:
        return "StrictMode";
      case c:
        return "Suspense";
      case u:
        return "SuspenseList";
    }
    if (typeof P == "object")
      switch (P.$$typeof) {
        case a:
          var I = P;
          return D(I) + ".Consumer";
        case o:
          var Y = P;
          return D(Y._context) + ".Provider";
        case l:
          return R(P, P.render, "ForwardRef");
        case d:
          var ie = P.displayName || null;
          return ie !== null ? ie : F(P.type) || "Memo";
        case f: {
          var Te = P, Le = Te._payload, me = Te._init;
          try {
            return F(me(Le));
          } catch {
            return null;
          }
        }
      }
    return null;
  }
  var j = Object.assign, B = 0, L, O, N, H, U, X, G;
  function pe() {
  }
  pe.__reactDisabledLog = !0;
  function Me() {
    {
      if (B === 0) {
        L = console.log, O = console.info, N = console.warn, H = console.error, U = console.group, X = console.groupCollapsed, G = console.groupEnd;
        var P = {
          configurable: !0,
          enumerable: !0,
          value: pe,
          writable: !0
        };
        Object.defineProperties(console, {
          info: P,
          log: P,
          warn: P,
          error: P,
          group: P,
          groupCollapsed: P,
          groupEnd: P
        });
      }
      B++;
    }
  }
  function Ee() {
    {
      if (B--, B === 0) {
        var P = {
          configurable: !0,
          enumerable: !0,
          writable: !0
        };
        Object.defineProperties(console, {
          log: j({}, P, {
            value: L
          }),
          info: j({}, P, {
            value: O
          }),
          warn: j({}, P, {
            value: N
          }),
          error: j({}, P, {
            value: H
          }),
          group: j({}, P, {
            value: U
          }),
          groupCollapsed: j({}, P, {
            value: X
          }),
          groupEnd: j({}, P, {
            value: G
          })
        });
      }
      B < 0 && y("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
  }
  var oe = b.ReactCurrentDispatcher, He;
  function ye(P, I, Y) {
    {
      if (He === void 0)
        try {
          throw Error();
        } catch (Te) {
          var ie = Te.stack.trim().match(/\n( *(at )?)/);
          He = ie && ie[1] || "";
        }
      return `
` + He + P;
    }
  }
  var $ = !1, Xe;
  {
    var Ue = typeof WeakMap == "function" ? WeakMap : Map;
    Xe = new Ue();
  }
  function Jt(P, I) {
    if (!P || $)
      return "";
    {
      var Y = Xe.get(P);
      if (Y !== void 0)
        return Y;
    }
    var ie;
    $ = !0;
    var Te = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    var Le;
    Le = oe.current, oe.current = null, Me();
    try {
      if (I) {
        var me = function() {
          throw Error();
        };
        if (Object.defineProperty(me.prototype, "props", {
          set: function() {
            throw Error();
          }
        }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(me, []);
          } catch (Bt) {
            ie = Bt;
          }
          Reflect.construct(P, [], me);
        } else {
          try {
            me.call();
          } catch (Bt) {
            ie = Bt;
          }
          P.call(me.prototype);
        }
      } else {
        try {
          throw Error();
        } catch (Bt) {
          ie = Bt;
        }
        P();
      }
    } catch (Bt) {
      if (Bt && ie && typeof Bt.stack == "string") {
        for (var fe = Bt.stack.split(`
`), Dt = ie.stack.split(`
`), Je = fe.length - 1, nt = Dt.length - 1; Je >= 1 && nt >= 0 && fe[Je] !== Dt[nt]; )
          nt--;
        for (; Je >= 1 && nt >= 0; Je--, nt--)
          if (fe[Je] !== Dt[nt]) {
            if (Je !== 1 || nt !== 1)
              do
                if (Je--, nt--, nt < 0 || fe[Je] !== Dt[nt]) {
                  var nn = `
` + fe[Je].replace(" at new ", " at ");
                  return P.displayName && nn.includes("<anonymous>") && (nn = nn.replace("<anonymous>", P.displayName)), typeof P == "function" && Xe.set(P, nn), nn;
                }
              while (Je >= 1 && nt >= 0);
            break;
          }
      }
    } finally {
      $ = !1, oe.current = Le, Ee(), Error.prepareStackTrace = Te;
    }
    var fr = P ? P.displayName || P.name : "", Ns = fr ? ye(fr) : "";
    return typeof P == "function" && Xe.set(P, Ns), Ns;
  }
  function Z(P, I, Y) {
    return Jt(P, !1);
  }
  function Ln(P) {
    var I = P.prototype;
    return !!(I && I.isReactComponent);
  }
  function Nt(P, I, Y) {
    if (P == null)
      return "";
    if (typeof P == "function")
      return Jt(P, Ln(P));
    if (typeof P == "string")
      return ye(P);
    switch (P) {
      case c:
        return ye("Suspense");
      case u:
        return ye("SuspenseList");
    }
    if (typeof P == "object")
      switch (P.$$typeof) {
        case l:
          return Z(P.render);
        case d:
          return Nt(P.type, I, Y);
        case f: {
          var ie = P, Te = ie._payload, Le = ie._init;
          try {
            return Nt(Le(Te), I, Y);
          } catch {
          }
        }
      }
    return "";
  }
  var Rt = Object.prototype.hasOwnProperty, ns = {}, ss = b.ReactDebugCurrentFrame;
  function mt(P) {
    if (P) {
      var I = P._owner, Y = Nt(P.type, P._source, I ? I.type : null);
      ss.setExtraStackFrame(Y);
    } else
      ss.setExtraStackFrame(null);
  }
  function J(P, I, Y, ie, Te) {
    {
      var Le = Function.call.bind(Rt);
      for (var me in P)
        if (Le(P, me)) {
          var fe = void 0;
          try {
            if (typeof P[me] != "function") {
              var Dt = Error((ie || "React class") + ": " + Y + " type `" + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof P[me] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
              throw Dt.name = "Invariant Violation", Dt;
            }
            fe = P[me](I, me, ie, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
          } catch (Je) {
            fe = Je;
          }
          fe && !(fe instanceof Error) && (mt(Te), y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ie || "React class", Y, me, typeof fe), mt(null)), fe instanceof Error && !(fe.message in ns) && (ns[fe.message] = !0, mt(Te), y("Failed %s type: %s", Y, fe.message), mt(null));
        }
    }
  }
  var ee = Array.isArray;
  function ge(P) {
    return ee(P);
  }
  function $t(P) {
    {
      var I = typeof Symbol == "function" && Symbol.toStringTag, Y = I && P[Symbol.toStringTag] || P.constructor.name || "Object";
      return Y;
    }
  }
  function ut(P) {
    try {
      return _e(P), !1;
    } catch {
      return !0;
    }
  }
  function _e(P) {
    return "" + P;
  }
  function en(P) {
    if (ut(P))
      return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", $t(P)), _e(P);
  }
  var tn = b.ReactCurrentOwner, Ls = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  }, Wt, ai, kt;
  kt = {};
  function Oo(P) {
    if (Rt.call(P, "ref")) {
      var I = Object.getOwnPropertyDescriptor(P, "ref").get;
      if (I && I.isReactWarning)
        return !1;
    }
    return P.ref !== void 0;
  }
  function ec(P) {
    if (Rt.call(P, "key")) {
      var I = Object.getOwnPropertyDescriptor(P, "key").get;
      if (I && I.isReactWarning)
        return !1;
    }
    return P.key !== void 0;
  }
  function tc(P, I) {
    if (typeof P.ref == "string" && tn.current && I && tn.current.stateNode !== I) {
      var Y = F(tn.current.type);
      kt[Y] || (y('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', F(tn.current.type), P.ref), kt[Y] = !0);
    }
  }
  function nc(P, I) {
    {
      var Y = function() {
        Wt || (Wt = !0, y("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
      };
      Y.isReactWarning = !0, Object.defineProperty(P, "key", {
        get: Y,
        configurable: !0
      });
    }
  }
  function sc(P, I) {
    {
      var Y = function() {
        ai || (ai = !0, y("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
      };
      Y.isReactWarning = !0, Object.defineProperty(P, "ref", {
        get: Y,
        configurable: !0
      });
    }
  }
  var rc = function(P, I, Y, ie, Te, Le, me) {
    var fe = {
      // This tag allows us to uniquely identify this as a React Element
      $$typeof: e,
      // Built-in properties that belong on the element
      type: P,
      key: I,
      ref: Y,
      props: me,
      // Record the component responsible for creating this element.
      _owner: Le
    };
    return fe._store = {}, Object.defineProperty(fe._store, "validated", {
      configurable: !1,
      enumerable: !1,
      writable: !0,
      value: !1
    }), Object.defineProperty(fe, "_self", {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: ie
    }), Object.defineProperty(fe, "_source", {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: Te
    }), Object.freeze && (Object.freeze(fe.props), Object.freeze(fe)), fe;
  };
  function se(P, I, Y, ie, Te) {
    {
      var Le, me = {}, fe = null, Dt = null;
      Y !== void 0 && (en(Y), fe = "" + Y), ec(I) && (en(I.key), fe = "" + I.key), Oo(I) && (Dt = I.ref, tc(I, Te));
      for (Le in I)
        Rt.call(I, Le) && !Ls.hasOwnProperty(Le) && (me[Le] = I[Le]);
      if (P && P.defaultProps) {
        var Je = P.defaultProps;
        for (Le in Je)
          me[Le] === void 0 && (me[Le] = Je[Le]);
      }
      if (fe || Dt) {
        var nt = typeof P == "function" ? P.displayName || P.name || "Unknown" : P;
        fe && nc(me, nt), Dt && sc(me, nt);
      }
      return rc(P, fe, Dt, Te, ie, tn.current, me);
    }
  }
  var ve = b.ReactCurrentOwner, De = b.ReactDebugCurrentFrame;
  function Se(P) {
    if (P) {
      var I = P._owner, Y = Nt(P.type, P._source, I ? I.type : null);
      De.setExtraStackFrame(Y);
    } else
      De.setExtraStackFrame(null);
  }
  var xe;
  xe = !1;
  function vt(P) {
    return typeof P == "object" && P !== null && P.$$typeof === e;
  }
  function dt() {
    {
      if (ve.current) {
        var P = F(ve.current.type);
        if (P)
          return `

Check the render method of \`` + P + "`.";
      }
      return "";
    }
  }
  function Mt(P) {
    return "";
  }
  var jt = {};
  function Nn(P) {
    {
      var I = dt();
      if (!I) {
        var Y = typeof P == "string" ? P : P.displayName || P.name;
        Y && (I = `

Check the top-level render call using <` + Y + ">.");
      }
      return I;
    }
  }
  function ln(P, I) {
    {
      if (!P._store || P._store.validated || P.key != null)
        return;
      P._store.validated = !0;
      var Y = Nn(I);
      if (jt[Y])
        return;
      jt[Y] = !0;
      var ie = "";
      P && P._owner && P._owner !== ve.current && (ie = " It was passed a child from " + F(P._owner.type) + "."), Se(P), y('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ie), Se(null);
    }
  }
  function Ht(P, I) {
    {
      if (typeof P != "object")
        return;
      if (ge(P))
        for (var Y = 0; Y < P.length; Y++) {
          var ie = P[Y];
          vt(ie) && ln(ie, I);
        }
      else if (vt(P))
        P._store && (P._store.validated = !0);
      else if (P) {
        var Te = A(P);
        if (typeof Te == "function" && Te !== P.entries)
          for (var Le = Te.call(P), me; !(me = Le.next()).done; )
            vt(me.value) && ln(me.value, I);
      }
    }
  }
  function dr(P) {
    {
      var I = P.type;
      if (I == null || typeof I == "string")
        return;
      var Y;
      if (typeof I == "function")
        Y = I.propTypes;
      else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
      // Inner props are checked in the reconciler.
      I.$$typeof === d))
        Y = I.propTypes;
      else
        return;
      if (Y) {
        var ie = F(I);
        J(Y, P.props, "prop", ie, P);
      } else if (I.PropTypes !== void 0 && !xe) {
        xe = !0;
        var Te = F(I);
        y("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Te || "Unknown");
      }
      typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && y("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Lo(P) {
    {
      for (var I = Object.keys(P.props), Y = 0; Y < I.length; Y++) {
        var ie = I[Y];
        if (ie !== "children" && ie !== "key") {
          Se(P), y("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ie), Se(null);
          break;
        }
      }
      P.ref !== null && (Se(P), y("Invalid attribute `ref` supplied to `React.Fragment`."), Se(null));
    }
  }
  var th = {};
  function nh(P, I, Y, ie, Te, Le) {
    {
      var me = k(P);
      if (!me) {
        var fe = "";
        (P === void 0 || typeof P == "object" && P !== null && Object.keys(P).length === 0) && (fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
        var Dt = Mt();
        Dt ? fe += Dt : fe += dt();
        var Je;
        P === null ? Je = "null" : ge(P) ? Je = "array" : P !== void 0 && P.$$typeof === e ? (Je = "<" + (F(P.type) || "Unknown") + " />", fe = " Did you accidentally export a JSX literal instead of a component?") : Je = typeof P, y("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Je, fe);
      }
      var nt = se(P, I, Y, Te, Le);
      if (nt == null)
        return nt;
      if (me) {
        var nn = I.children;
        if (nn !== void 0)
          if (ie)
            if (ge(nn)) {
              for (var fr = 0; fr < nn.length; fr++)
                Ht(nn[fr], P);
              Object.freeze && Object.freeze(nn);
            } else
              y("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
          else
            Ht(nn, P);
      }
      if (Rt.call(I, "key")) {
        var Ns = F(P), Bt = Object.keys(I).filter(function(Nw) {
          return Nw !== "key";
        }), ic = Bt.length > 0 ? "{key: someKey, " + Bt.join(": ..., ") + ": ...}" : "{key: someKey}";
        if (!th[Ns + ic]) {
          var Lw = Bt.length > 0 ? "{" + Bt.join(": ..., ") + ": ...}" : "{}";
          y(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ic, Ns, Lw, Ns), th[Ns + ic] = !0;
        }
      }
      return P === s ? Lo(nt) : dr(nt), nt;
    }
  }
  function kw(P, I, Y) {
    return nh(P, I, Y, !0);
  }
  function Mw(P, I, Y) {
    return nh(P, I, Y, !1);
  }
  var Dw = Mw, Ow = kw;
  ha.Fragment = s, ha.jsx = Dw, ha.jsxs = Ow;
})();
uA.exports = ha;
var m = uA.exports, zw = Object.defineProperty, Uw = (t, e, n) => e in t ? zw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, li = (t, e, n) => (Uw(t, typeof e != "symbol" ? e + "" : e, n), n), dA, sh = cA;
{
  var rh = sh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  dA = function(t, e) {
    rh.usingClientEntryPoint = !0;
    try {
      return sh.createRoot(t, e);
    } finally {
      rh.usingClientEntryPoint = !1;
    }
  };
}
const Ww = {
  stringify: (t) => t,
  parse: (t) => t
}, Hw = {
  stringify: (t) => `${t}`,
  parse: (t) => parseFloat(t)
}, Qw = {
  stringify: (t) => t ? "true" : "false",
  parse: (t) => /^[ty1-9]/i.test(t)
}, Yw = {
  stringify: (t) => t.name,
  parse: (t, e) => {
    const n = (() => {
      if (typeof window < "u" && t in window)
        return window[t];
      if (typeof global < "u" && t in global)
        return global[t];
    })();
    return typeof n == "function" ? n.bind(e) : void 0;
  }
}, Kw = {
  stringify: (t) => JSON.stringify(t),
  parse: (t) => typeof t == "string" ? JSON.parse(t) : t
}, Xw = {
  string: Ww,
  number: Hw,
  boolean: Qw,
  function: Yw,
  json: Kw
}, Gw = "__reactProps";
function Zw(t, e, n) {
  e.props || (e.props = t.propTypes ? Object.keys(t.propTypes) : []);
  const s = (Array.isArray(e.props) ? e.props.slice() : Object.keys(e.props)).filter((a) => a !== "container"), r = {}, i = {};
  for (const a of s) {
    r[a] = Array.isArray(e.props) ? "string" : e.props[a];
    const l = _w(a);
    i[a] = l;
  }
  class o extends HTMLElement {
    constructor() {
      super(), li(this, "connected", !1), li(this, "context"), li(this, "_props", {}), li(this, "container"), li(this, "observer"), this.observer = new MutationObserver(
        (l) => this.attributesChanged(l)
      ), this.observer.observe(this, { attributes: !0 }), e.shadow ? this.container = this.attachShadow({
        mode: e.shadow
      }) : this.container = this, this._props.container = this.container;
    }
    set props(l) {
      this._props = {
        ...this._props,
        ...l
      }, this.update();
    }
    get props() {
      return this._props;
    }
    connectedCallback() {
      this.connected = !0;
      for (const l of s)
        this.setProps(l);
      this.mount();
    }
    disconnectedCallback() {
      this.connected = !1, this.observer.disconnect(), this.unmount();
    }
    attributesChanged(l) {
      l.forEach(({ attributeName: c }) => {
        this.setProps(c);
      }), this.update();
    }
    setProps(l) {
      const c = Object.keys(this).find((g) => g.includes(Gw)), u = c ? this[c] : {}, d = i[l], f = u[l] ?? this.getAttribute(d), h = r[l], p = Xw[h];
      l in u ? this._props[l] = f : f && p != null && p.parse && (this._props[l] = p.parse(f, this));
    }
    update() {
      this.connected && this.context && n.update(this.context, this.props);
    }
    mount() {
      if (!this.connected)
        throw new Error(`${t} is not in a DOM`);
      if (this.context)
        throw new Error(`${t} is already mounted`);
      this.context = n.mount(this.container, t, this.props);
    }
    unmount() {
      this.context && n.unmount(this.context);
    }
  }
  return o;
}
function _w(t = "") {
  return t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
const Jw = (t, e, n) => {
  const s = dA(t), r = z.createElement(e, n);
  return s.render(r), {
    root: s,
    ReactComponent: e
  };
}, $w = ({ root: t, ReactComponent: e }, n) => {
  const s = z.createElement(e, n);
  t.render(s);
}, e1 = ({ root: t }) => {
  t.unmount();
}, t1 = (t, e = {}) => Zw(t, e, { mount: Jw, update: $w, unmount: e1 }), fA = ks(void 0);
async function n1() {
  return typeof window < "u" ? sessionStorage.getItem("gameToken") : null;
}
async function s1(t) {
  typeof window < "u" && sessionStorage.setItem("gameToken", t);
}
async function r1() {
  typeof window < "u" && sessionStorage.removeItem("gameToken");
}
const hA = ({ children: t }) => {
  const [e, n] = tt(sessionStorage.getItem("gameToken") || null), [s, r] = tt(!1), i = Fe(async (a) => {
    await s1(a), n(a);
  }, []), o = Fe(async () => {
    await r1(), n(null);
  }, []);
  return je(() => {
    (async () => {
      const l = await n1();
      if (l)
        n(l);
      else if (typeof window < "u") {
        const u = new URLSearchParams(window.location.search).get("token");
        u && (await i(u), window.history.replaceState({}, document.title, window.location.pathname));
      }
      r(!0);
    })();
  }, [i]), /* @__PURE__ */ m.jsx(fA.Provider, { value: { authToken: e, setAuthToken: i, clearAuthToken: o, isInitialized: s }, children: t });
}, vl = () => {
  const t = ht(fA);
  if (t === void 0)
    throw new Error("useAuth must be used within an AuthProvider");
  return t;
}, i1 = {
  type: "logger",
  log(t) {
    this.output("log", t);
  },
  warn(t) {
    this.output("warn", t);
  },
  error(t) {
    this.output("error", t);
  },
  output(t, e) {
    console && console[t] && console[t].apply(console, e);
  }
};
class Na {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, n);
  }
  init(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = n.prefix || "i18next:", this.logger = e || i1, this.options = n, this.debug = n.debug;
  }
  log() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++)
      n[s] = arguments[s];
    return this.forward(n, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++)
      n[s] = arguments[s];
    return this.forward(n, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++)
      n[s] = arguments[s];
    return this.forward(n, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++)
      n[s] = arguments[s];
    return this.forward(n, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, n, s, r) {
    return r && !this.debug ? null : (typeof e[0] == "string" && (e[0] = `${s}${this.prefix} ${e[0]}`), this.logger[n](e));
  }
  create(e) {
    return new Na(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new Na(this.logger, e);
  }
}
var xn = new Na();
class xl {
  constructor() {
    this.observers = {};
  }
  on(e, n) {
    return e.split(" ").forEach((s) => {
      this.observers[s] || (this.observers[s] = /* @__PURE__ */ new Map());
      const r = this.observers[s].get(n) || 0;
      this.observers[s].set(n, r + 1);
    }), this;
  }
  off(e, n) {
    if (this.observers[e]) {
      if (!n) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(n);
    }
  }
  emit(e) {
    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)
      s[r - 1] = arguments[r];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((o) => {
      let [a, l] = o;
      for (let c = 0; c < l; c++)
        a(...s);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((o) => {
      let [a, l] = o;
      for (let c = 0; c < l; c++)
        a.apply(a, [e, ...s]);
    });
  }
}
const ci = () => {
  let t, e;
  const n = new Promise((s, r) => {
    t = s, e = r;
  });
  return n.resolve = t, n.reject = e, n;
}, ih = (t) => t == null ? "" : "" + t, o1 = (t, e, n) => {
  t.forEach((s) => {
    e[s] && (n[s] = e[s]);
  });
}, a1 = /###/g, oh = (t) => t && t.indexOf("###") > -1 ? t.replace(a1, ".") : t, ah = (t) => !t || typeof t == "string", Mi = (t, e, n) => {
  const s = typeof e != "string" ? e : e.split(".");
  let r = 0;
  for (; r < s.length - 1; ) {
    if (ah(t)) return {};
    const i = oh(s[r]);
    !t[i] && n && (t[i] = new n()), Object.prototype.hasOwnProperty.call(t, i) ? t = t[i] : t = {}, ++r;
  }
  return ah(t) ? {} : {
    obj: t,
    k: oh(s[r])
  };
}, lh = (t, e, n) => {
  const {
    obj: s,
    k: r
  } = Mi(t, e, Object);
  if (s !== void 0 || e.length === 1) {
    s[r] = n;
    return;
  }
  let i = e[e.length - 1], o = e.slice(0, e.length - 1), a = Mi(t, o, Object);
  for (; a.obj === void 0 && o.length; )
    i = `${o[o.length - 1]}.${i}`, o = o.slice(0, o.length - 1), a = Mi(t, o, Object), a && a.obj && typeof a.obj[`${a.k}.${i}`] < "u" && (a.obj = void 0);
  a.obj[`${a.k}.${i}`] = n;
}, l1 = (t, e, n, s) => {
  const {
    obj: r,
    k: i
  } = Mi(t, e, Object);
  r[i] = r[i] || [], r[i].push(n);
}, ja = (t, e) => {
  const {
    obj: n,
    k: s
  } = Mi(t, e);
  if (n)
    return n[s];
}, c1 = (t, e, n) => {
  const s = ja(t, n);
  return s !== void 0 ? s : ja(e, n);
}, pA = (t, e, n) => {
  for (const s in e)
    s !== "__proto__" && s !== "constructor" && (s in t ? typeof t[s] == "string" || t[s] instanceof String || typeof e[s] == "string" || e[s] instanceof String ? n && (t[s] = e[s]) : pA(t[s], e[s], n) : t[s] = e[s]);
  return t;
}, hr = (t) => t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var u1 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const d1 = (t) => typeof t == "string" ? t.replace(/[&<>"'\/]/g, (e) => u1[e]) : t;
class f1 {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const n = this.regExpMap.get(e);
    if (n !== void 0)
      return n;
    const s = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, s), this.regExpQueue.push(e), s;
  }
}
const h1 = [" ", ",", "?", "!", ";"], p1 = new f1(20), g1 = (t, e, n) => {
  e = e || "", n = n || "";
  const s = h1.filter((o) => e.indexOf(o) < 0 && n.indexOf(o) < 0);
  if (s.length === 0) return !0;
  const r = p1.getRegExp(`(${s.map((o) => o === "?" ? "\\?" : o).join("|")})`);
  let i = !r.test(t);
  if (!i) {
    const o = t.indexOf(n);
    o > 0 && !r.test(t.substring(0, o)) && (i = !0);
  }
  return i;
}, Jc = function(t, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!t) return;
  if (t[e]) return t[e];
  const s = e.split(n);
  let r = t;
  for (let i = 0; i < s.length; ) {
    if (!r || typeof r != "object")
      return;
    let o, a = "";
    for (let l = i; l < s.length; ++l)
      if (l !== i && (a += n), a += s[l], o = r[a], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && l < s.length - 1)
          continue;
        i += l - i + 1;
        break;
      }
    r = o;
  }
  return r;
}, Ba = (t) => t && t.indexOf("_") > 0 ? t.replace("_", "-") : t;
class ch extends xl {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const n = this.options.ns.indexOf(e);
    n > -1 && this.options.ns.splice(n, 1);
  }
  getResource(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const i = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator, o = r.ignoreJSONStructure !== void 0 ? r.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let a;
    e.indexOf(".") > -1 ? a = e.split(".") : (a = [e, n], s && (Array.isArray(s) ? a.push(...s) : typeof s == "string" && i ? a.push(...s.split(i)) : a.push(s)));
    const l = ja(this.data, a);
    return !l && !n && !s && e.indexOf(".") > -1 && (e = a[0], n = a[1], s = a.slice(2).join(".")), l || !o || typeof s != "string" ? l : Jc(this.data && this.data[e] && this.data[e][n], s, i);
  }
  addResource(e, n, s, r) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator;
    let a = [e, n];
    s && (a = a.concat(o ? s.split(o) : s)), e.indexOf(".") > -1 && (a = e.split("."), r = n, n = a[1]), this.addNamespaces(n), lh(this.data, a, r), i.silent || this.emit("added", e, n, s, r);
  }
  addResources(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const i in s)
      (typeof s[i] == "string" || Array.isArray(s[i])) && this.addResource(e, n, i, s[i], {
        silent: !0
      });
    r.silent || this.emit("added", e, n, s);
  }
  addResourceBundle(e, n, s, r, i) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, a = [e, n];
    e.indexOf(".") > -1 && (a = e.split("."), r = s, s = n, n = a[1]), this.addNamespaces(n);
    let l = ja(this.data, a) || {};
    o.skipCopy || (s = JSON.parse(JSON.stringify(s))), r ? pA(l, s, i) : l = {
      ...l,
      ...s
    }, lh(this.data, a, l), o.silent || this.emit("added", e, n, s);
  }
  removeResourceBundle(e, n) {
    this.hasResourceBundle(e, n) && delete this.data[e][n], this.removeNamespaces(n), this.emit("removed", e, n);
  }
  hasResourceBundle(e, n) {
    return this.getResource(e, n) !== void 0;
  }
  getResourceBundle(e, n) {
    return n || (n = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(e, n)
    } : this.getResource(e, n);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const n = this.getDataByLanguage(e);
    return !!(n && Object.keys(n) || []).find((r) => n[r] && Object.keys(n[r]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var gA = {
  processors: {},
  addPostProcessor(t) {
    this.processors[t.name] = t;
  },
  handle(t, e, n, s, r) {
    return t.forEach((i) => {
      this.processors[i] && (e = this.processors[i].process(e, n, s, r));
    }), e;
  }
};
const uh = {};
class Ia extends xl {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), o1(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = xn.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const s = this.resolve(e, n);
    return s && s.res !== void 0;
  }
  extractFromKey(e, n) {
    let s = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
    s === void 0 && (s = ":");
    const r = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
    let i = n.ns || this.options.defaultNS || [];
    const o = s && e.indexOf(s) > -1, a = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !g1(e, s, r);
    if (o && !a) {
      const l = e.match(this.interpolator.nestingRegexp);
      if (l && l.length > 0)
        return {
          key: e,
          namespaces: i
        };
      const c = e.split(s);
      (s !== r || s === r && this.options.ns.indexOf(c[0]) > -1) && (i = c.shift()), e = c.join(r);
    }
    return typeof i == "string" && (i = [i]), {
      key: e,
      namespaces: i
    };
  }
  translate(e, n, s) {
    if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == "object" && (n = {
      ...n
    }), n || (n = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const r = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails, i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator, {
      key: o,
      namespaces: a
    } = this.extractFromKey(e[e.length - 1], n), l = a[a.length - 1], c = n.lng || this.language, u = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (c && c.toLowerCase() === "cimode") {
      if (u) {
        const x = n.nsSeparator || this.options.nsSeparator;
        return r ? {
          res: `${l}${x}${o}`,
          usedKey: o,
          exactUsedKey: o,
          usedLng: c,
          usedNS: l,
          usedParams: this.getUsedParamsDetails(n)
        } : `${l}${x}${o}`;
      }
      return r ? {
        res: o,
        usedKey: o,
        exactUsedKey: o,
        usedLng: c,
        usedNS: l,
        usedParams: this.getUsedParamsDetails(n)
      } : o;
    }
    const d = this.resolve(e, n);
    let f = d && d.res;
    const h = d && d.usedKey || o, p = d && d.exactUsedKey || o, g = Object.prototype.toString.apply(f), A = ["[object Number]", "[object Function]", "[object RegExp]"], b = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays, y = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (y && f && (typeof f != "string" && typeof f != "boolean" && typeof f != "number") && A.indexOf(g) < 0 && !(typeof b == "string" && Array.isArray(f))) {
      if (!n.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const x = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, f, {
          ...n,
          ns: a
        }) : `key '${o} (${this.language})' returned an object instead of string.`;
        return r ? (d.res = x, d.usedParams = this.getUsedParamsDetails(n), d) : x;
      }
      if (i) {
        const x = Array.isArray(f), S = x ? [] : {}, q = x ? p : h;
        for (const C in f)
          if (Object.prototype.hasOwnProperty.call(f, C)) {
            const E = `${q}${i}${C}`;
            S[C] = this.translate(E, {
              ...n,
              joinArrays: !1,
              ns: a
            }), S[C] === E && (S[C] = f[C]);
          }
        f = S;
      }
    } else if (y && typeof b == "string" && Array.isArray(f))
      f = f.join(b), f && (f = this.extendTranslation(f, e, n, s));
    else {
      let x = !1, S = !1;
      const q = n.count !== void 0 && typeof n.count != "string", C = Ia.hasDefaultValue(n), E = q ? this.pluralResolver.getSuffix(c, n.count, n) : "", T = n.ordinal && q ? this.pluralResolver.getSuffix(c, n.count, {
        ordinal: !1
      }) : "", k = q && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), R = k && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${E}`] || n[`defaultValue${T}`] || n.defaultValue;
      !this.isValidLookup(f) && C && (x = !0, f = R), this.isValidLookup(f) || (S = !0, f = o);
      const F = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && S ? void 0 : f, j = C && R !== f && this.options.updateMissing;
      if (S || x || j) {
        if (this.logger.log(j ? "updateKey" : "missingKey", c, l, o, j ? R : f), i) {
          const N = this.resolve(o, {
            ...n,
            keySeparator: !1
          });
          N && N.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let B = [];
        const L = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && L && L[0])
          for (let N = 0; N < L.length; N++)
            B.push(L[N]);
        else this.options.saveMissingTo === "all" ? B = this.languageUtils.toResolveHierarchy(n.lng || this.language) : B.push(n.lng || this.language);
        const O = (N, H, U) => {
          const X = C && U !== f ? U : F;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(N, l, H, X, j, n) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(N, l, H, X, j, n), this.emit("missingKey", N, l, H, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && q ? B.forEach((N) => {
          const H = this.pluralResolver.getSuffixes(N, n);
          k && n[`defaultValue${this.options.pluralSeparator}zero`] && H.indexOf(`${this.options.pluralSeparator}zero`) < 0 && H.push(`${this.options.pluralSeparator}zero`), H.forEach((U) => {
            O([N], o + U, n[`defaultValue${U}`] || R);
          });
        }) : O(B, o, R));
      }
      f = this.extendTranslation(f, e, n, d, s), S && f === o && this.options.appendNamespaceToMissingKey && (f = `${l}:${o}`), (S || x) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}:${o}` : o, x ? f : void 0) : f = this.options.parseMissingKeyHandler(f));
    }
    return r ? (d.res = f, d.usedParams = this.getUsedParamsDetails(n), d) : f;
  }
  extendTranslation(e, n, s, r, i) {
    var o = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...s
      }, s.lng || this.language || r.usedLng, r.usedNS, r.usedKey, {
        resolved: r
      });
    else if (!s.skipInterpolation) {
      s.interpolation && this.interpolator.init({
        ...s,
        interpolation: {
          ...this.options.interpolation,
          ...s.interpolation
        }
      });
      const c = typeof e == "string" && (s && s.interpolation && s.interpolation.skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let u;
      if (c) {
        const f = e.match(this.interpolator.nestingRegexp);
        u = f && f.length;
      }
      let d = s.replace && typeof s.replace != "string" ? s.replace : s;
      if (this.options.interpolation.defaultVariables && (d = {
        ...this.options.interpolation.defaultVariables,
        ...d
      }), e = this.interpolator.interpolate(e, d, s.lng || this.language || r.usedLng, s), c) {
        const f = e.match(this.interpolator.nestingRegexp), h = f && f.length;
        u < h && (s.nest = !1);
      }
      !s.lng && this.options.compatibilityAPI !== "v1" && r && r.res && (s.lng = this.language || r.usedLng), s.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var f = arguments.length, h = new Array(f), p = 0; p < f; p++)
          h[p] = arguments[p];
        return i && i[0] === h[0] && !s.context ? (o.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${n[0]}`), null) : o.translate(...h, n);
      }, s)), s.interpolation && this.interpolator.reset();
    }
    const a = s.postProcess || this.options.postProcess, l = typeof a == "string" ? [a] : a;
    return e != null && l && l.length && s.applyPostProcessor !== !1 && (e = gA.handle(l, e, n, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...r,
        usedParams: this.getUsedParamsDetails(s)
      },
      ...s
    } : s, this)), e;
  }
  resolve(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s, r, i, o, a;
    return typeof e == "string" && (e = [e]), e.forEach((l) => {
      if (this.isValidLookup(s)) return;
      const c = this.extractFromKey(l, n), u = c.key;
      r = u;
      let d = c.namespaces;
      this.options.fallbackNS && (d = d.concat(this.options.fallbackNS));
      const f = n.count !== void 0 && typeof n.count != "string", h = f && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), p = n.context !== void 0 && (typeof n.context == "string" || typeof n.context == "number") && n.context !== "", g = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
      d.forEach((A) => {
        this.isValidLookup(s) || (a = A, !uh[`${g[0]}-${A}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(a) && (uh[`${g[0]}-${A}`] = !0, this.logger.warn(`key "${r}" for languages "${g.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), g.forEach((b) => {
          if (this.isValidLookup(s)) return;
          o = b;
          const y = [u];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(y, u, b, A, n);
          else {
            let x;
            f && (x = this.pluralResolver.getSuffix(b, n.count, n));
            const S = `${this.options.pluralSeparator}zero`, q = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (f && (y.push(u + x), n.ordinal && x.indexOf(q) === 0 && y.push(u + x.replace(q, this.options.pluralSeparator)), h && y.push(u + S)), p) {
              const C = `${u}${this.options.contextSeparator}${n.context}`;
              y.push(C), f && (y.push(C + x), n.ordinal && x.indexOf(q) === 0 && y.push(C + x.replace(q, this.options.pluralSeparator)), h && y.push(C + S));
            }
          }
          let w;
          for (; w = y.pop(); )
            this.isValidLookup(s) || (i = w, s = this.getResource(b, A, w, n));
        }));
      });
    }), {
      res: s,
      usedKey: r,
      exactUsedKey: i,
      usedLng: o,
      usedNS: a
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, n, s, r) : this.resourceStore.getResource(e, n, s, r);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], s = e.replace && typeof e.replace != "string";
    let r = s ? e.replace : e;
    if (s && typeof e.count < "u" && (r.count = e.count), this.options.interpolation.defaultVariables && (r = {
      ...this.options.interpolation.defaultVariables,
      ...r
    }), !s) {
      r = {
        ...r
      };
      for (const i of n)
        delete r[i];
    }
    return r;
  }
  static hasDefaultValue(e) {
    const n = "defaultValue";
    for (const s in e)
      if (Object.prototype.hasOwnProperty.call(e, s) && n === s.substring(0, n.length) && e[s] !== void 0)
        return !0;
    return !1;
  }
}
const oc = (t) => t.charAt(0).toUpperCase() + t.slice(1);
class dh {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = xn.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = Ba(e), !e || e.indexOf("-") < 0) return null;
    const n = e.split("-");
    return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = Ba(e), !e || e.indexOf("-") < 0) return e;
    const n = e.split("-");
    return this.formatLanguageCode(n[0]);
  }
  formatLanguageCode(e) {
    if (typeof e == "string" && e.indexOf("-") > -1) {
      const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let s = e.split("-");
      return this.options.lowerCaseLng ? s = s.map((r) => r.toLowerCase()) : s.length === 2 ? (s[0] = s[0].toLowerCase(), s[1] = s[1].toUpperCase(), n.indexOf(s[1].toLowerCase()) > -1 && (s[1] = oc(s[1].toLowerCase()))) : s.length === 3 && (s[0] = s[0].toLowerCase(), s[1].length === 2 && (s[1] = s[1].toUpperCase()), s[0] !== "sgn" && s[2].length === 2 && (s[2] = s[2].toUpperCase()), n.indexOf(s[1].toLowerCase()) > -1 && (s[1] = oc(s[1].toLowerCase())), n.indexOf(s[2].toLowerCase()) > -1 && (s[2] = oc(s[2].toLowerCase()))), s.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let n;
    return e.forEach((s) => {
      if (n) return;
      const r = this.formatLanguageCode(s);
      (!this.options.supportedLngs || this.isSupportedCode(r)) && (n = r);
    }), !n && this.options.supportedLngs && e.forEach((s) => {
      if (n) return;
      const r = this.getLanguagePartFromCode(s);
      if (this.isSupportedCode(r)) return n = r;
      n = this.options.supportedLngs.find((i) => {
        if (i === r) return i;
        if (!(i.indexOf("-") < 0 && r.indexOf("-") < 0) && (i.indexOf("-") > 0 && r.indexOf("-") < 0 && i.substring(0, i.indexOf("-")) === r || i.indexOf(r) === 0 && r.length > 1))
          return i;
      });
    }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n;
  }
  getFallbackCodes(e, n) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(n)), typeof e == "string" && (e = [e]), Array.isArray(e)) return e;
    if (!n) return e.default || [];
    let s = e[n];
    return s || (s = e[this.getScriptPartFromCode(n)]), s || (s = e[this.formatLanguageCode(n)]), s || (s = e[this.getLanguagePartFromCode(n)]), s || (s = e.default), s || [];
  }
  toResolveHierarchy(e, n) {
    const s = this.getFallbackCodes(n || this.options.fallbackLng || [], e), r = [], i = (o) => {
      o && (this.isSupportedCode(o) ? r.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`));
    };
    return typeof e == "string" && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && i(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && i(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && i(this.getLanguagePartFromCode(e))) : typeof e == "string" && i(this.formatLanguageCode(e)), s.forEach((o) => {
      r.indexOf(o) < 0 && i(this.formatLanguageCode(o));
    }), r;
  }
}
let m1 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], A1 = {
  1: (t) => +(t > 1),
  2: (t) => +(t != 1),
  3: (t) => 0,
  4: (t) => t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2,
  5: (t) => t == 0 ? 0 : t == 1 ? 1 : t == 2 ? 2 : t % 100 >= 3 && t % 100 <= 10 ? 3 : t % 100 >= 11 ? 4 : 5,
  6: (t) => t == 1 ? 0 : t >= 2 && t <= 4 ? 1 : 2,
  7: (t) => t == 1 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2,
  8: (t) => t == 1 ? 0 : t == 2 ? 1 : t != 8 && t != 11 ? 2 : 3,
  9: (t) => +(t >= 2),
  10: (t) => t == 1 ? 0 : t == 2 ? 1 : t < 7 ? 2 : t < 11 ? 3 : 4,
  11: (t) => t == 1 || t == 11 ? 0 : t == 2 || t == 12 ? 1 : t > 2 && t < 20 ? 2 : 3,
  12: (t) => +(t % 10 != 1 || t % 100 == 11),
  13: (t) => +(t !== 0),
  14: (t) => t == 1 ? 0 : t == 2 ? 1 : t == 3 ? 2 : 3,
  15: (t) => t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2,
  16: (t) => t % 10 == 1 && t % 100 != 11 ? 0 : t !== 0 ? 1 : 2,
  17: (t) => t == 1 || t % 10 == 1 && t % 100 != 11 ? 0 : 1,
  18: (t) => t == 0 ? 0 : t == 1 ? 1 : 2,
  19: (t) => t == 1 ? 0 : t == 0 || t % 100 > 1 && t % 100 < 11 ? 1 : t % 100 > 10 && t % 100 < 20 ? 2 : 3,
  20: (t) => t == 1 ? 0 : t == 0 || t % 100 > 0 && t % 100 < 20 ? 1 : 2,
  21: (t) => t % 100 == 1 ? 1 : t % 100 == 2 ? 2 : t % 100 == 3 || t % 100 == 4 ? 3 : 0,
  22: (t) => t == 1 ? 0 : t == 2 ? 1 : (t < 0 || t > 10) && t % 10 == 0 ? 2 : 3
};
const b1 = ["v1", "v2", "v3"], y1 = ["v4"], fh = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, v1 = () => {
  const t = {};
  return m1.forEach((e) => {
    e.lngs.forEach((n) => {
      t[n] = {
        numbers: e.nr,
        plurals: A1[e.fc]
      };
    });
  }), t;
};
class x1 {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = n, this.logger = xn.create("pluralResolver"), (!this.options.compatibilityJSON || y1.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = v1(), this.pluralRulesCache = {};
  }
  addRule(e, n) {
    this.rules[e] = n;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        const s = Ba(e === "dev" ? "en" : e), r = n.ordinal ? "ordinal" : "cardinal", i = JSON.stringify({
          cleanedCode: s,
          type: r
        });
        if (i in this.pluralRulesCache)
          return this.pluralRulesCache[i];
        const o = new Intl.PluralRules(s, {
          type: r
        });
        return this.pluralRulesCache[i] = o, o;
      } catch {
        return;
      }
    return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)];
  }
  needsPlural(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = this.getRule(e, n);
    return this.shouldUseIntlApi() ? s && s.resolvedOptions().pluralCategories.length > 1 : s && s.numbers.length > 1;
  }
  getPluralFormsOfKey(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, s).map((r) => `${n}${r}`);
  }
  getSuffixes(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = this.getRule(e, n);
    return s ? this.shouldUseIntlApi() ? s.resolvedOptions().pluralCategories.sort((r, i) => fh[r] - fh[i]).map((r) => `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${r}`) : s.numbers.map((r) => this.getSuffix(e, r, n)) : [];
  }
  getSuffix(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = this.getRule(e, s);
    return r ? this.shouldUseIntlApi() ? `${this.options.prepend}${s.ordinal ? `ordinal${this.options.prepend}` : ""}${r.select(n)}` : this.getSuffixRetroCompatible(r, n) : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, n) {
    const s = e.noAbs ? e.plurals(n) : e.plurals(Math.abs(n));
    let r = e.numbers[s];
    this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (r === 2 ? r = "plural" : r === 1 && (r = ""));
    const i = () => this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString();
    return this.options.compatibilityJSON === "v1" ? r === 1 ? "" : typeof r == "number" ? `_plural_${r.toString()}` : i() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? i() : this.options.prepend && s.toString() ? this.options.prepend + s.toString() : s.toString();
  }
  shouldUseIntlApi() {
    return !b1.includes(this.options.compatibilityJSON);
  }
}
const hh = function(t, e, n) {
  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, i = c1(t, e, n);
  return !i && r && typeof n == "string" && (i = Jc(t, n, s), i === void 0 && (i = Jc(e, n, s))), i;
}, ac = (t) => t.replace(/\$/g, "$$$$");
class w1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = xn.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || ((n) => n), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: n,
      escapeValue: s,
      useRawValueToEscape: r,
      prefix: i,
      prefixEscaped: o,
      suffix: a,
      suffixEscaped: l,
      formatSeparator: c,
      unescapeSuffix: u,
      unescapePrefix: d,
      nestingPrefix: f,
      nestingPrefixEscaped: h,
      nestingSuffix: p,
      nestingSuffixEscaped: g,
      nestingOptionsSeparator: A,
      maxReplaces: b,
      alwaysFormat: y
    } = e.interpolation;
    this.escape = n !== void 0 ? n : d1, this.escapeValue = s !== void 0 ? s : !0, this.useRawValueToEscape = r !== void 0 ? r : !1, this.prefix = i ? hr(i) : o || "{{", this.suffix = a ? hr(a) : l || "}}", this.formatSeparator = c || ",", this.unescapePrefix = u ? "" : d || "-", this.unescapeSuffix = this.unescapePrefix ? "" : u || "", this.nestingPrefix = f ? hr(f) : h || hr("$t("), this.nestingSuffix = p ? hr(p) : g || hr(")"), this.nestingOptionsSeparator = A || ",", this.maxReplaces = b || 1e3, this.alwaysFormat = y !== void 0 ? y : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (n, s) => n && n.source === s ? (n.lastIndex = 0, n) : new RegExp(s, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, n, s, r) {
    let i, o, a;
    const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = (h) => {
      if (h.indexOf(this.formatSeparator) < 0) {
        const b = hh(n, l, h, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(b, void 0, s, {
          ...r,
          ...n,
          interpolationkey: h
        }) : b;
      }
      const p = h.split(this.formatSeparator), g = p.shift().trim(), A = p.join(this.formatSeparator).trim();
      return this.format(hh(n, l, g, this.options.keySeparator, this.options.ignoreJSONStructure), A, s, {
        ...r,
        ...n,
        interpolationkey: g
      });
    };
    this.resetRegExp();
    const u = r && r.missingInterpolationHandler || this.options.missingInterpolationHandler, d = r && r.interpolation && r.interpolation.skipOnVariables !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (h) => ac(h)
    }, {
      regex: this.regexp,
      safeValue: (h) => this.escapeValue ? ac(this.escape(h)) : ac(h)
    }].forEach((h) => {
      for (a = 0; i = h.regex.exec(e); ) {
        const p = i[1].trim();
        if (o = c(p), o === void 0)
          if (typeof u == "function") {
            const A = u(e, i, r);
            o = typeof A == "string" ? A : "";
          } else if (r && Object.prototype.hasOwnProperty.call(r, p))
            o = "";
          else if (d) {
            o = i[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${p} for interpolating ${e}`), o = "";
        else typeof o != "string" && !this.useRawValueToEscape && (o = ih(o));
        const g = h.safeValue(o);
        if (e = e.replace(i[0], g), d ? (h.regex.lastIndex += o.length, h.regex.lastIndex -= i[0].length) : h.regex.lastIndex = 0, a++, a >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r, i, o;
    const a = (l, c) => {
      const u = this.nestingOptionsSeparator;
      if (l.indexOf(u) < 0) return l;
      const d = l.split(new RegExp(`${u}[ ]*{`));
      let f = `{${d[1]}`;
      l = d[0], f = this.interpolate(f, o);
      const h = f.match(/'/g), p = f.match(/"/g);
      (h && h.length % 2 === 0 && !p || p.length % 2 !== 0) && (f = f.replace(/'/g, '"'));
      try {
        o = JSON.parse(f), c && (o = {
          ...c,
          ...o
        });
      } catch (g) {
        return this.logger.warn(`failed parsing options string in nesting for key ${l}`, g), `${l}${u}${f}`;
      }
      return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, l;
    };
    for (; r = this.nestingRegexp.exec(e); ) {
      let l = [];
      o = {
        ...s
      }, o = o.replace && typeof o.replace != "string" ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      let c = !1;
      if (r[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(r[1])) {
        const u = r[1].split(this.formatSeparator).map((d) => d.trim());
        r[1] = u.shift(), l = u, c = !0;
      }
      if (i = n(a.call(this, r[1].trim(), o), o), i && r[0] === e && typeof i != "string") return i;
      typeof i != "string" && (i = ih(i)), i || (this.logger.warn(`missed to resolve ${r[1]} for nesting ${e}`), i = ""), c && (i = l.reduce((u, d) => this.format(u, d, s.lng, {
        ...s,
        interpolationkey: r[1].trim()
      }), i.trim())), e = e.replace(r[0], i), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
const S1 = (t) => {
  let e = t.toLowerCase().trim();
  const n = {};
  if (t.indexOf("(") > -1) {
    const s = t.split("(");
    e = s[0].toLowerCase().trim();
    const r = s[1].substring(0, s[1].length - 1);
    e === "currency" && r.indexOf(":") < 0 ? n.currency || (n.currency = r.trim()) : e === "relativetime" && r.indexOf(":") < 0 ? n.range || (n.range = r.trim()) : r.split(";").forEach((o) => {
      if (o) {
        const [a, ...l] = o.split(":"), c = l.join(":").trim().replace(/^'+|'+$/g, ""), u = a.trim();
        n[u] || (n[u] = c), c === "false" && (n[u] = !1), c === "true" && (n[u] = !0), isNaN(c) || (n[u] = parseInt(c, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: n
  };
}, pr = (t) => {
  const e = {};
  return (n, s, r) => {
    let i = r;
    r && r.interpolationkey && r.formatParams && r.formatParams[r.interpolationkey] && r[r.interpolationkey] && (i = {
      ...i,
      [r.interpolationkey]: void 0
    });
    const o = s + JSON.stringify(i);
    let a = e[o];
    return a || (a = t(Ba(s), r), e[o] = a), a(n);
  };
};
class C1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = xn.create("formatter"), this.options = e, this.formats = {
      number: pr((n, s) => {
        const r = new Intl.NumberFormat(n, {
          ...s
        });
        return (i) => r.format(i);
      }),
      currency: pr((n, s) => {
        const r = new Intl.NumberFormat(n, {
          ...s,
          style: "currency"
        });
        return (i) => r.format(i);
      }),
      datetime: pr((n, s) => {
        const r = new Intl.DateTimeFormat(n, {
          ...s
        });
        return (i) => r.format(i);
      }),
      relativetime: pr((n, s) => {
        const r = new Intl.RelativeTimeFormat(n, {
          ...s
        });
        return (i) => r.format(i, s.range || "day");
      }),
      list: pr((n, s) => {
        const r = new Intl.ListFormat(n, {
          ...s
        });
        return (i) => r.format(i);
      })
    }, this.init(e);
  }
  init(e) {
    const s = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = s.formatSeparator ? s.formatSeparator : s.formatSeparator || ",";
  }
  add(e, n) {
    this.formats[e.toLowerCase().trim()] = n;
  }
  addCached(e, n) {
    this.formats[e.toLowerCase().trim()] = pr(n);
  }
  format(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const i = n.split(this.formatSeparator);
    if (i.length > 1 && i[0].indexOf("(") > 1 && i[0].indexOf(")") < 0 && i.find((a) => a.indexOf(")") > -1)) {
      const a = i.findIndex((l) => l.indexOf(")") > -1);
      i[0] = [i[0], ...i.splice(1, a)].join(this.formatSeparator);
    }
    return i.reduce((a, l) => {
      const {
        formatName: c,
        formatOptions: u
      } = S1(l);
      if (this.formats[c]) {
        let d = a;
        try {
          const f = r && r.formatParams && r.formatParams[r.interpolationkey] || {}, h = f.locale || f.lng || r.locale || r.lng || s;
          d = this.formats[c](a, h, {
            ...u,
            ...r,
            ...f
          });
        } catch (f) {
          this.logger.warn(f);
        }
        return d;
      } else
        this.logger.warn(`there was no format function for ${c}`);
      return a;
    }, e);
  }
}
const P1 = (t, e) => {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--);
};
class q1 extends xl {
  constructor(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = n, this.services = s, this.languageUtils = s.languageUtils, this.options = r, this.logger = xn.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = r.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5, this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(s, r.backend, r);
  }
  queueLoad(e, n, s, r) {
    const i = {}, o = {}, a = {}, l = {};
    return e.forEach((c) => {
      let u = !0;
      n.forEach((d) => {
        const f = `${c}|${d}`;
        !s.reload && this.store.hasResourceBundle(c, d) ? this.state[f] = 2 : this.state[f] < 0 || (this.state[f] === 1 ? o[f] === void 0 && (o[f] = !0) : (this.state[f] = 1, u = !1, o[f] === void 0 && (o[f] = !0), i[f] === void 0 && (i[f] = !0), l[d] === void 0 && (l[d] = !0)));
      }), u || (a[c] = !0);
    }), (Object.keys(i).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: r
    }), {
      toLoad: Object.keys(i),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(a),
      toLoadNamespaces: Object.keys(l)
    };
  }
  loaded(e, n, s) {
    const r = e.split("|"), i = r[0], o = r[1];
    n && this.emit("failedLoading", i, o, n), !n && s && this.store.addResourceBundle(i, o, s, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = n ? -1 : 2, n && s && (this.state[e] = 0);
    const a = {};
    this.queue.forEach((l) => {
      l1(l.loaded, [i], o), P1(l, e), n && l.errors.push(n), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach((c) => {
        a[c] || (a[c] = {});
        const u = l.loaded[c];
        u.length && u.forEach((d) => {
          a[c][d] === void 0 && (a[c][d] = !0);
        });
      }), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback());
    }), this.emit("loaded", a), this.queue = this.queue.filter((l) => !l.done);
  }
  read(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, o = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: n,
        fcName: s,
        tried: r,
        wait: i,
        callback: o
      });
      return;
    }
    this.readingCalls++;
    const a = (c, u) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const d = this.waitingReads.shift();
        this.read(d.lng, d.ns, d.fcName, d.tried, d.wait, d.callback);
      }
      if (c && u && r < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, n, s, r + 1, i * 2, o);
        }, i);
        return;
      }
      o(c, u);
    }, l = this.backend[s].bind(this.backend);
    if (l.length === 2) {
      try {
        const c = l(e, n);
        c && typeof c.then == "function" ? c.then((u) => a(null, u)).catch(a) : a(null, c);
      } catch (c) {
        a(c);
      }
      return;
    }
    return l(e, n, a);
  }
  prepareLoading(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), r && r();
    typeof e == "string" && (e = this.languageUtils.toResolveHierarchy(e)), typeof n == "string" && (n = [n]);
    const i = this.queueLoad(e, n, s, r);
    if (!i.toLoad.length)
      return i.pending.length || r(), null;
    i.toLoad.forEach((o) => {
      this.loadOne(o);
    });
  }
  load(e, n, s) {
    this.prepareLoading(e, n, {}, s);
  }
  reload(e, n, s) {
    this.prepareLoading(e, n, {
      reload: !0
    }, s);
  }
  loadOne(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = e.split("|"), r = s[0], i = s[1];
    this.read(r, i, "read", void 0, void 0, (o, a) => {
      o && this.logger.warn(`${n}loading namespace ${i} for language ${r} failed`, o), !o && a && this.logger.log(`${n}loaded namespace ${i} for language ${r}`, a), this.loaded(e, o, a);
    });
  }
  saveMissing(e, n, s, r, i) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(n)) {
      this.logger.warn(`did not save key "${s}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(s == null || s === "")) {
      if (this.backend && this.backend.create) {
        const l = {
          ...o,
          isUpdate: i
        }, c = this.backend.create.bind(this.backend);
        if (c.length < 6)
          try {
            let u;
            c.length === 5 ? u = c(e, n, s, r, l) : u = c(e, n, s, r), u && typeof u.then == "function" ? u.then((d) => a(null, d)).catch(a) : a(null, u);
          } catch (u) {
            a(u);
          }
        else
          c(e, n, s, r, a, l);
      }
      !e || !e[0] || this.store.addResource(e[0], n, s, r);
    }
  }
}
const ph = () => ({
  debug: !1,
  initImmediate: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (t) => {
    let e = {};
    if (typeof t[1] == "object" && (e = t[1]), typeof t[1] == "string" && (e.defaultValue = t[1]), typeof t[2] == "string" && (e.tDescription = t[2]), typeof t[2] == "object" || typeof t[3] == "object") {
      const n = t[3] || t[2];
      Object.keys(n).forEach((s) => {
        e[s] = n[s];
      });
    }
    return e;
  },
  interpolation: {
    escapeValue: !0,
    format: (t) => t,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), gh = (t) => (typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t), No = () => {
}, E1 = (t) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach((n) => {
    typeof t[n] == "function" && (t[n] = t[n].bind(t));
  });
};
class zi extends xl {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = gh(e), this.services = {}, this.logger = xn, this.modules = {
      external: []
    }, E1(this), n && !this.isInitialized && !e.isClone) {
      if (!this.options.initImmediate)
        return this.init(e, n), this;
      setTimeout(() => {
        this.init(e, n);
      }, 0);
    }
  }
  init() {
    var e = this;
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof n == "function" && (s = n, n = {}), !n.defaultNS && n.defaultNS !== !1 && n.ns && (typeof n.ns == "string" ? n.defaultNS = n.ns : n.ns.indexOf("translation") < 0 && (n.defaultNS = n.ns[0]));
    const r = ph();
    this.options = {
      ...r,
      ...this.options,
      ...gh(n)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...r.interpolation,
      ...this.options.interpolation
    }), n.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = n.keySeparator), n.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = n.nsSeparator);
    const i = (u) => u ? typeof u == "function" ? new u() : u : null;
    if (!this.options.isClone) {
      this.modules.logger ? xn.init(i(this.modules.logger), this.options) : xn.init(null, this.options);
      let u;
      this.modules.formatter ? u = this.modules.formatter : typeof Intl < "u" && (u = C1);
      const d = new dh(this.options);
      this.store = new ch(this.options.resources, this.options);
      const f = this.services;
      f.logger = xn, f.resourceStore = this.store, f.languageUtils = d, f.pluralResolver = new x1(d, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), u && (!this.options.interpolation.format || this.options.interpolation.format === r.interpolation.format) && (f.formatter = i(u), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new w1(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new q1(i(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(h) {
        for (var p = arguments.length, g = new Array(p > 1 ? p - 1 : 0), A = 1; A < p; A++)
          g[A - 1] = arguments[A];
        e.emit(h, ...g);
      }), this.modules.languageDetector && (f.languageDetector = i(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = i(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new Ia(this.services, this.options), this.translator.on("*", function(h) {
        for (var p = arguments.length, g = new Array(p > 1 ? p - 1 : 0), A = 1; A < p; A++)
          g[A - 1] = arguments[A];
        e.emit(h, ...g);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, s || (s = No), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((u) => {
      this[u] = function() {
        return e.store[u](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((u) => {
      this[u] = function() {
        return e.store[u](...arguments), e;
      };
    });
    const l = ci(), c = () => {
      const u = (d, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), l.resolve(f), s(d, f);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return u(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, u);
    };
    return this.options.resources || !this.options.initImmediate ? c() : setTimeout(c, 0), l;
  }
  loadResources(e) {
    let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : No;
    const r = typeof e == "string" ? e : this.language;
    if (typeof e == "function" && (s = e), !this.options.resources || this.options.partialBundledLanguages) {
      if (r && r.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return s();
      const i = [], o = (a) => {
        if (!a || a === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(a).forEach((c) => {
          c !== "cimode" && i.indexOf(c) < 0 && i.push(c);
        });
      };
      r ? o(r) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((l) => o(l)), this.options.preload && this.options.preload.forEach((a) => o(a)), this.services.backendConnector.load(i, this.options.ns, (a) => {
        !a && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), s(a);
      });
    } else
      s(null);
  }
  reloadResources(e, n, s) {
    const r = ci();
    return typeof e == "function" && (s = e, e = void 0), typeof n == "function" && (s = n, n = void 0), e || (e = this.languages), n || (n = this.options.ns), s || (s = No), this.services.backendConnector.reload(e, n, (i) => {
      r.resolve(), s(i);
    }), r;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && gA.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let n = 0; n < this.languages.length; n++) {
        const s = this.languages[n];
        if (!(["cimode", "dev"].indexOf(s) > -1) && this.store.hasLanguageSomeTranslations(s)) {
          this.resolvedLanguage = s;
          break;
        }
      }
  }
  changeLanguage(e, n) {
    var s = this;
    this.isLanguageChangingTo = e;
    const r = ci();
    this.emit("languageChanging", e);
    const i = (l) => {
      this.language = l, this.languages = this.services.languageUtils.toResolveHierarchy(l), this.resolvedLanguage = void 0, this.setResolvedLanguage(l);
    }, o = (l, c) => {
      c ? (i(c), this.translator.changeLanguage(c), this.isLanguageChangingTo = void 0, this.emit("languageChanged", c), this.logger.log("languageChanged", c)) : this.isLanguageChangingTo = void 0, r.resolve(function() {
        return s.t(...arguments);
      }), n && n(l, function() {
        return s.t(...arguments);
      });
    }, a = (l) => {
      !e && !l && this.services.languageDetector && (l = []);
      const c = typeof l == "string" ? l : this.services.languageUtils.getBestMatchFromCodes(l);
      c && (this.language || i(c), this.translator.language || this.translator.changeLanguage(c), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(c)), this.loadResources(c, (u) => {
        o(u, c);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(e), r;
  }
  getFixedT(e, n, s) {
    var r = this;
    const i = function(o, a) {
      let l;
      if (typeof a != "object") {
        for (var c = arguments.length, u = new Array(c > 2 ? c - 2 : 0), d = 2; d < c; d++)
          u[d - 2] = arguments[d];
        l = r.options.overloadTranslationOptionHandler([o, a].concat(u));
      } else
        l = {
          ...a
        };
      l.lng = l.lng || i.lng, l.lngs = l.lngs || i.lngs, l.ns = l.ns || i.ns, l.keyPrefix !== "" && (l.keyPrefix = l.keyPrefix || s || i.keyPrefix);
      const f = r.options.keySeparator || ".";
      let h;
      return l.keyPrefix && Array.isArray(o) ? h = o.map((p) => `${l.keyPrefix}${f}${p}`) : h = l.keyPrefix ? `${l.keyPrefix}${f}${o}` : o, r.t(h, l);
    };
    return typeof e == "string" ? i.lng = e : i.lngs = e, i.ns = n, i.keyPrefix = s, i;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const s = n.lng || this.resolvedLanguage || this.languages[0], r = this.options ? this.options.fallbackLng : !1, i = this.languages[this.languages.length - 1];
    if (s.toLowerCase() === "cimode") return !0;
    const o = (a, l) => {
      const c = this.services.backendConnector.state[`${a}|${l}`];
      return c === -1 || c === 0 || c === 2;
    };
    if (n.precheck) {
      const a = n.precheck(this, o);
      if (a !== void 0) return a;
    }
    return !!(this.hasResourceBundle(s, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(s, e) && (!r || o(i, e)));
  }
  loadNamespaces(e, n) {
    const s = ci();
    return this.options.ns ? (typeof e == "string" && (e = [e]), e.forEach((r) => {
      this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
    }), this.loadResources((r) => {
      s.resolve(), n && n(r);
    }), s) : (n && n(), Promise.resolve());
  }
  loadLanguages(e, n) {
    const s = ci();
    typeof e == "string" && (e = [e]);
    const r = this.options.preload || [], i = e.filter((o) => r.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o));
    return i.length ? (this.options.preload = r.concat(i), this.loadResources((o) => {
      s.resolve(), n && n(o);
    }), s) : (n && n(), Promise.resolve());
  }
  dir(e) {
    if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], s = this.services && this.services.languageUtils || new dh(ph());
    return n.indexOf(s.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    return new zi(e, n);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : No;
    const s = e.forkResourceStore;
    s && delete e.forkResourceStore;
    const r = {
      ...this.options,
      ...e,
      isClone: !0
    }, i = new zi(r);
    return (e.debug !== void 0 || e.prefix !== void 0) && (i.logger = i.logger.clone(e)), ["store", "services", "language"].forEach((a) => {
      i[a] = this[a];
    }), i.services = {
      ...this.services
    }, i.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, s && (i.store = new ch(this.store.data, r), i.services.resourceStore = i.store), i.translator = new Ia(i.services, r), i.translator.on("*", function(a) {
      for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), u = 1; u < l; u++)
        c[u - 1] = arguments[u];
      i.emit(a, ...c);
    }), i.init(r, n), i.translator.options = r, i.translator.backendConnector.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, i;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const Et = zi.createInstance();
Et.createInstance = zi.createInstance;
Et.createInstance;
Et.dir;
Et.init;
Et.loadResources;
Et.reloadResources;
Et.use;
Et.changeLanguage;
Et.getFixedT;
const st = Et.t;
Et.exists;
Et.setDefaultNamespace;
Et.hasLoadedNamespace;
Et.loadNamespaces;
Et.loadLanguages;
function T1(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function er(t) {
  "@babel/helpers - typeof";
  return er = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, er(t);
}
function R1(t, e) {
  if (er(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var s = n.call(t, e);
    if (er(s) != "object") return s;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function mA(t) {
  var e = R1(t, "string");
  return er(e) == "symbol" ? e : e + "";
}
function k1(t, e) {
  for (var n = 0; n < e.length; n++) {
    var s = e[n];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, mA(s.key), s);
  }
}
function M1(t, e, n) {
  return e && k1(t.prototype, e), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function D1(t, e, n) {
  return (e = mA(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
var AA = [], O1 = AA.forEach, L1 = AA.slice;
function N1(t) {
  return O1.call(L1.call(arguments, 1), function(e) {
    if (e)
      for (var n in e)
        t[n] === void 0 && (t[n] = e[n]);
  }), t;
}
function mh(t, e) {
  if (e && er(e) === "object") {
    var n = "", s = encodeURIComponent;
    for (var r in e)
      n += "&" + s(r) + "=" + s(e[r]);
    if (!n)
      return t;
    t = t + (t.indexOf("?") !== -1 ? "&" : "?") + n.slice(1);
  }
  return t;
}
function j1(t, e, n, s, r) {
  s && er(s) === "object" && (r || (s._t = /* @__PURE__ */ new Date()), s = mh("", s).slice(1)), e.queryStringParams && (t = mh(t, e.queryStringParams));
  try {
    var i;
    XMLHttpRequest ? i = new XMLHttpRequest() : i = new ActiveXObject("MSXML2.XMLHTTP.3.0"), i.open(s ? "POST" : "GET", t, 1), e.crossDomain || i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), i.withCredentials = !!e.withCredentials, s && i.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), i.overrideMimeType && i.overrideMimeType("application/json");
    var o = e.customHeaders;
    if (o = typeof o == "function" ? o() : o, o)
      for (var a in o)
        i.setRequestHeader(a, o[a]);
    i.onreadystatechange = function() {
      i.readyState > 3 && n && n(i.responseText, i);
    }, i.send(s);
  } catch (l) {
    console && console.log(l);
  }
}
function B1() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: JSON.parse,
    parsePayload: function(e, n, s) {
      return D1({}, n, s || "");
    },
    crossDomain: !1,
    ajax: j1
  };
}
var bA = /* @__PURE__ */ function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    T1(this, t), this.init(e, n), this.type = "backend";
  }
  return M1(t, [{
    key: "init",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.services = n, this.options = N1(s, this.options || {}, B1());
    }
  }, {
    key: "readMulti",
    value: function(n, s, r) {
      var i = this.options.loadPath;
      typeof this.options.loadPath == "function" && (i = this.options.loadPath(n, s));
      var o = this.services.interpolator.interpolate(i, {
        lng: n.join("+"),
        ns: s.join("+")
      });
      this.loadUrl(o, r);
    }
  }, {
    key: "read",
    value: function(n, s, r) {
      var i = this.options.loadPath;
      typeof this.options.loadPath == "function" && (i = this.options.loadPath([n], [s]));
      var o = this.services.interpolator.interpolate(i, {
        lng: n,
        ns: s
      });
      this.loadUrl(o, r);
    }
  }, {
    key: "loadUrl",
    value: function(n, s) {
      var r = this;
      this.options.ajax(n, this.options, function(i, o) {
        if (o.status >= 500 && o.status < 600) return s(
          "failed loading " + n,
          !0
          /* retry */
        );
        if (o.status >= 400 && o.status < 500) return s(
          "failed loading " + n,
          !1
          /* no retry */
        );
        var a, l;
        try {
          a = r.options.parse(i, n);
        } catch {
          l = "failed parsing " + n + " to json";
        }
        if (l) return s(l, !1);
        s(null, a);
      });
    }
  }, {
    key: "create",
    value: function(n, s, r, i) {
      var o = this;
      typeof n == "string" && (n = [n]);
      var a = this.options.parsePayload(s, r, i);
      n.forEach(function(l) {
        var c = o.services.interpolator.interpolate(o.options.addPath, {
          lng: l,
          ns: s
        });
        o.options.ajax(c, o.options, function(u, d) {
        }, a);
      });
    }
  }]), t;
}();
bA.type = "backend";
async function I1(t) {
  var s;
  const n = new URL(document.URL).origin + "/";
  try {
    await Et.use(bA).init({
      debug: !1,
      lng: t,
      fallbackLng: "en",
      backend: {
        crossDomain: !0,
        loadPath: n + "/translations/{{lng}}.json"
      }
    });
  } catch (r) {
    console.error("Unable to initialize i18n", r), (s = document.location) == null || s.reload();
  }
}
const Ah = (t) => {
  let e;
  const n = /* @__PURE__ */ new Set(), s = (c, u) => {
    const d = typeof c == "function" ? c(e) : c;
    if (!Object.is(d, e)) {
      const f = e;
      e = u ?? (typeof d != "object" || d === null) ? d : Object.assign({}, e, d), n.forEach((h) => h(e, f));
    }
  }, r = () => e, a = { setState: s, getState: r, getInitialState: () => l, subscribe: (c) => (n.add(c), () => n.delete(c)) }, l = e = t(s, r, a);
  return a;
}, F1 = (t) => t ? Ah(t) : Ah, V1 = (t) => t;
function z1(t, e = V1) {
  const n = z.useSyncExternalStore(
    t.subscribe,
    () => e(t.getState()),
    () => e(t.getInitialState())
  );
  return z.useDebugValue(n), n;
}
const bh = (t) => {
  const e = F1(t), n = (s) => z1(e, s);
  return Object.assign(n, e), n;
}, Gr = (t) => t ? bh(t) : bh, yh = {
  result: null,
  totalProfit: 0,
  multiplier: 0
}, yA = Gr((t) => ({
  // Initial state
  ...yh,
  // Actions
  setResult: (e) => t({ result: e }),
  setTotalProfit: (e) => t({ totalProfit: e }),
  setMultiplier: (e) => t({ multiplier: e }),
  resetGame: () => t({ ...yh })
})), U1 = { BASE_URL: "/", DEV: !1, IS_WEB_COMPONENT: !0, MODE: "web-component-prod", PROD: !0, SSR: !1, VITE_DEV_API_BASE_URL: "http://localhost:3000", VITE_DEV_BASE_URL: "/", VITE_PROD_API_BASE_URL: "https://eu.blink.run", VITE_PROD_BASE_URL: "/games/blink-games/", VITE_STAGING_API_BASE_URL: "http://localhost:8080", VITE_STAGING_BASE_URL: "/games/blink-games/", VITE_WC_API_BASE_URL: "http://localhost:8080", VITE_WC_BASE_URL: "/", VITE_WC_BUILD_TYPE: "web-component", VITE_WC_PROD_API_BASE_URL: "http://localhost:8080", VITE_WC_PROD_BASE_URL: "/", VITE_WC_PROD_BUILD_TYPE: "web-component" };
function Zr() {
  const [t, e] = tt(!1);
  return je(() => {
    function n() {
      e(window.innerWidth < 1024);
    }
    return window.addEventListener("resize", n), n(), () => window.removeEventListener("resize", n);
  }, []), t;
}
function W1(t) {
  const n = `VITE_PROD_${t}`;
  return U1[n] || "";
}
const H1 = (t, e) => e / t, Q1 = (t, e) => {
  const s = 25 - t;
  if (t < 0 || t >= 25 || e < 0 || e > s)
    throw new Error("Invalid input: 'minesCount' should be between 0 and 24, 'turn' should be between 0 and (25 - minesCount).");
  let r = 0.99;
  for (let i = 0; i < e; i++) {
    const o = 25 - i, a = s - i, l = H1(o, a);
    r *= 1 / l;
  }
  return parseFloat(r.toFixed(2));
};
function vA(t) {
  var e, n, s = "";
  if (typeof t == "string" || typeof t == "number") s += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var r = t.length;
    for (e = 0; e < r; e++) t[e] && (n = vA(t[e])) && (s && (s += " "), s += n);
  } else for (n in t) t[n] && (s && (s += " "), s += n);
  return s;
}
function Y1() {
  for (var t, e, n = 0, s = "", r = arguments.length; n < r; n++) (t = arguments[n]) && (e = vA(t)) && (s && (s += " "), s += e);
  return s;
}
const ld = "-", K1 = (t) => {
  const e = G1(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: s
  } = t;
  return {
    getClassGroupId: (o) => {
      const a = o.split(ld);
      return a[0] === "" && a.length !== 1 && a.shift(), xA(a, e) || X1(o);
    },
    getConflictingClassGroupIds: (o, a) => {
      const l = n[o] || [];
      return a && s[o] ? [...l, ...s[o]] : l;
    }
  };
}, xA = (t, e) => {
  var o;
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], s = e.nextPart.get(n), r = s ? xA(t.slice(1), s) : void 0;
  if (r)
    return r;
  if (e.validators.length === 0)
    return;
  const i = t.join(ld);
  return (o = e.validators.find(({
    validator: a
  }) => a(i))) == null ? void 0 : o.classGroupId;
}, vh = /^\[(.+)\]$/, X1 = (t) => {
  if (vh.test(t)) {
    const e = vh.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, G1 = (t) => {
  const {
    theme: e,
    prefix: n
  } = t, s = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return _1(Object.entries(t.classGroups), n).forEach(([i, o]) => {
    $c(o, s, i, e);
  }), s;
}, $c = (t, e, n, s) => {
  t.forEach((r) => {
    if (typeof r == "string") {
      const i = r === "" ? e : xh(e, r);
      i.classGroupId = n;
      return;
    }
    if (typeof r == "function") {
      if (Z1(r)) {
        $c(r(s), e, n, s);
        return;
      }
      e.validators.push({
        validator: r,
        classGroupId: n
      });
      return;
    }
    Object.entries(r).forEach(([i, o]) => {
      $c(o, xh(e, i), n, s);
    });
  });
}, xh = (t, e) => {
  let n = t;
  return e.split(ld).forEach((s) => {
    n.nextPart.has(s) || n.nextPart.set(s, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(s);
  }), n;
}, Z1 = (t) => t.isThemeGetter, _1 = (t, e) => e ? t.map(([n, s]) => {
  const r = s.map((i) => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, a]) => [e + o, a])) : i);
  return [n, r];
}) : t, J1 = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  const r = (i, o) => {
    n.set(i, o), e++, e > t && (e = 0, s = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let o = n.get(i);
      if (o !== void 0)
        return o;
      if ((o = s.get(i)) !== void 0)
        return r(i, o), o;
    },
    set(i, o) {
      n.has(i) ? n.set(i, o) : r(i, o);
    }
  };
}, wA = "!", $1 = (t) => {
  const {
    separator: e,
    experimentalParseClassName: n
  } = t, s = e.length === 1, r = e[0], i = e.length, o = (a) => {
    const l = [];
    let c = 0, u = 0, d;
    for (let A = 0; A < a.length; A++) {
      let b = a[A];
      if (c === 0) {
        if (b === r && (s || a.slice(A, A + i) === e)) {
          l.push(a.slice(u, A)), u = A + i;
          continue;
        }
        if (b === "/") {
          d = A;
          continue;
        }
      }
      b === "[" ? c++ : b === "]" && c--;
    }
    const f = l.length === 0 ? a : a.substring(u), h = f.startsWith(wA), p = h ? f.substring(1) : f, g = d && d > u ? d - u : void 0;
    return {
      modifiers: l,
      hasImportantModifier: h,
      baseClassName: p,
      maybePostfixModifierPosition: g
    };
  };
  return n ? (a) => n({
    className: a,
    parseClassName: o
  }) : o;
}, eS = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let n = [];
  return t.forEach((s) => {
    s[0] === "[" ? (e.push(...n.sort(), s), n = []) : n.push(s);
  }), e.push(...n.sort()), e;
}, tS = (t) => ({
  cache: J1(t.cacheSize),
  parseClassName: $1(t),
  ...K1(t)
}), nS = /\s+/, sS = (t, e) => {
  const {
    parseClassName: n,
    getClassGroupId: s,
    getConflictingClassGroupIds: r
  } = e, i = [], o = t.trim().split(nS);
  let a = "";
  for (let l = o.length - 1; l >= 0; l -= 1) {
    const c = o[l], {
      modifiers: u,
      hasImportantModifier: d,
      baseClassName: f,
      maybePostfixModifierPosition: h
    } = n(c);
    let p = !!h, g = s(p ? f.substring(0, h) : f);
    if (!g) {
      if (!p) {
        a = c + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (g = s(f), !g) {
        a = c + (a.length > 0 ? " " + a : a);
        continue;
      }
      p = !1;
    }
    const A = eS(u).join(":"), b = d ? A + wA : A, y = b + g;
    if (i.includes(y))
      continue;
    i.push(y);
    const w = r(g, p);
    for (let x = 0; x < w.length; ++x) {
      const S = w[x];
      i.push(b + S);
    }
    a = c + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function rS() {
  let t = 0, e, n, s = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = SA(e)) && (s && (s += " "), s += n);
  return s;
}
const SA = (t) => {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let s = 0; s < t.length; s++)
    t[s] && (e = SA(t[s])) && (n && (n += " "), n += e);
  return n;
};
function iS(t, ...e) {
  let n, s, r, i = o;
  function o(l) {
    const c = e.reduce((u, d) => d(u), t());
    return n = tS(c), s = n.cache.get, r = n.cache.set, i = a, a(l);
  }
  function a(l) {
    const c = s(l);
    if (c)
      return c;
    const u = sS(l, n);
    return r(l, u), u;
  }
  return function() {
    return i(rS.apply(null, arguments));
  };
}
const Ie = (t) => {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}, CA = /^\[(?:([a-z-]+):)?(.+)\]$/i, oS = /^\d+\/\d+$/, aS = /* @__PURE__ */ new Set(["px", "full", "screen"]), lS = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, cS = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, uS = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, dS = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, fS = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, jn = (t) => Er(t) || aS.has(t) || oS.test(t), rs = (t) => _r(t, "length", vS), Er = (t) => !!t && !Number.isNaN(Number(t)), lc = (t) => _r(t, "number", Er), ui = (t) => !!t && Number.isInteger(Number(t)), hS = (t) => t.endsWith("%") && Er(t.slice(0, -1)), ue = (t) => CA.test(t), is = (t) => lS.test(t), pS = /* @__PURE__ */ new Set(["length", "size", "percentage"]), gS = (t) => _r(t, pS, PA), mS = (t) => _r(t, "position", PA), AS = /* @__PURE__ */ new Set(["image", "url"]), bS = (t) => _r(t, AS, wS), yS = (t) => _r(t, "", xS), di = () => !0, _r = (t, e, n) => {
  const s = CA.exec(t);
  return s ? s[1] ? typeof e == "string" ? s[1] === e : e.has(s[1]) : n(s[2]) : !1;
}, vS = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  cS.test(t) && !uS.test(t)
), PA = () => !1, xS = (t) => dS.test(t), wS = (t) => fS.test(t), SS = () => {
  const t = Ie("colors"), e = Ie("spacing"), n = Ie("blur"), s = Ie("brightness"), r = Ie("borderColor"), i = Ie("borderRadius"), o = Ie("borderSpacing"), a = Ie("borderWidth"), l = Ie("contrast"), c = Ie("grayscale"), u = Ie("hueRotate"), d = Ie("invert"), f = Ie("gap"), h = Ie("gradientColorStops"), p = Ie("gradientColorStopPositions"), g = Ie("inset"), A = Ie("margin"), b = Ie("opacity"), y = Ie("padding"), w = Ie("saturate"), x = Ie("scale"), S = Ie("sepia"), q = Ie("skew"), C = Ie("space"), E = Ie("translate"), T = () => ["auto", "contain", "none"], k = () => ["auto", "hidden", "clip", "visible", "scroll"], R = () => ["auto", ue, e], D = () => [ue, e], F = () => ["", jn, rs], j = () => ["auto", Er, ue], B = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], L = () => ["solid", "dashed", "dotted", "double", "none"], O = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], N = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], H = () => ["", "0", ue], U = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], X = () => [Er, ue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [di],
      spacing: [jn, rs],
      blur: ["none", "", is, ue],
      brightness: X(),
      borderColor: [t],
      borderRadius: ["none", "", "full", is, ue],
      borderSpacing: D(),
      borderWidth: F(),
      contrast: X(),
      grayscale: H(),
      hueRotate: X(),
      invert: H(),
      gap: D(),
      gradientColorStops: [t],
      gradientColorStopPositions: [hS, rs],
      inset: R(),
      margin: R(),
      opacity: X(),
      padding: D(),
      saturate: X(),
      scale: X(),
      sepia: H(),
      skew: X(),
      space: D(),
      translate: D()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [is]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": U()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": U()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...B(), ue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: k()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": k()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": k()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: T()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": T()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": T()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ui, ue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: R()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: H()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: H()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ui, ue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [di]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", ui, ue]
        }, ue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": j()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": j()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [di]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ui, ue]
        }, ue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": j()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": j()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...N()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...N(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...N(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [y]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [y]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [y]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [y]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [y]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [y]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [y]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [y]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [y]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [A]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [A]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [A]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [A]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [A]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [A]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [A]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [A]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [A]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [C]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [C]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ue, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ue, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ue, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [is]
        }, is]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ue, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ue, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ue, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ue, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", is, rs]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", lc]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [di]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Er, lc]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", jn, ue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [b]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [b]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...L(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", jn, rs]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", jn, ue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: D()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [b]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...B(), mS]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", gS]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, bS]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [b]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...L(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [b]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: L()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [r]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [r]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [r]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [r]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [r]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [r]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [r]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [r]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...L()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [jn, ue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [jn, rs]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: F()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [b]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [jn, rs]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", is, yS]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [di]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [b]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...O(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": O()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [s]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", is, ue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [w]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [s]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [b]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [w]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: X()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: X()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [x]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [x]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [x]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ui, ue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [E]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [E]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [q]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [q]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": D()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": D()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": D()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": D()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": D()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": D()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": D()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": D()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": D()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": D()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": D()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": D()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": D()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": D()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": D()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": D()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": D()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": D()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [jn, rs, lc]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, CS = /* @__PURE__ */ iS(SS);
function Be(...t) {
  return CS(Y1(t));
}
const qA = ({
  className: t,
  size: e = 200,
  duration: n = 15,
  anchor: s = 90,
  borderWidth: r = 1.5,
  colorFrom: i = "#ffaa40",
  colorTo: o = "#9c40ff",
  delay: a = 0
}) => /* @__PURE__ */ m.jsx(
  "div",
  {
    style: {
      "--size": e,
      "--duration": n,
      "--anchor": s,
      "--border-width": r,
      "--color-from": i,
      "--color-to": o,
      "--delay": `-${a}s`
    },
    className: Be(
      "pointer-events-none absolute inset-0 rounded-[inherit] [border:calc(var(--border-width)*1px)_solid_transparent]",
      // mask styles
      "![mask-clip:padding-box,border-box] ![mask-composite:intersect] [mask:linear-gradient(transparent,transparent),linear-gradient(white,white)]",
      // pseudo styles
      "after:absolute after:aspect-square after:w-[calc(var(--size)*1px)] after:animate-border-beam after:[animation-delay:var(--delay)] after:[background:linear-gradient(to_left,var(--color-from),var(--color-to),transparent)] after:[offset-anchor:calc(var(--anchor)*1%)_50%] after:[offset-path:rect(0_auto_auto_0_round_calc(var(--size)*1px))]",
      t
    )
  }
);
function EA(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: PS } = Object.prototype, { getPrototypeOf: cd } = Object, wl = /* @__PURE__ */ ((t) => (e) => {
  const n = PS.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), mn = (t) => (t = t.toLowerCase(), (e) => wl(e) === t), Sl = (t) => (e) => typeof e === t, { isArray: Jr } = Array, Ui = Sl("undefined");
function qS(t) {
  return t !== null && !Ui(t) && t.constructor !== null && !Ui(t.constructor) && Xt(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const TA = mn("ArrayBuffer");
function ES(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && TA(t.buffer), e;
}
const TS = Sl("string"), Xt = Sl("function"), RA = Sl("number"), Cl = (t) => t !== null && typeof t == "object", RS = (t) => t === !0 || t === !1, pa = (t) => {
  if (wl(t) !== "object")
    return !1;
  const e = cd(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, kS = mn("Date"), MS = mn("File"), DS = mn("Blob"), OS = mn("FileList"), LS = (t) => Cl(t) && Xt(t.pipe), NS = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Xt(t.append) && ((e = wl(t)) === "formdata" || // detect form-data instance
  e === "object" && Xt(t.toString) && t.toString() === "[object FormData]"));
}, jS = mn("URLSearchParams"), [BS, IS, FS, VS] = ["ReadableStream", "Request", "Response", "Headers"].map(mn), zS = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function vo(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let s, r;
  if (typeof t != "object" && (t = [t]), Jr(t))
    for (s = 0, r = t.length; s < r; s++)
      e.call(null, t[s], s, t);
  else {
    const i = n ? Object.getOwnPropertyNames(t) : Object.keys(t), o = i.length;
    let a;
    for (s = 0; s < o; s++)
      a = i[s], e.call(null, t[a], a, t);
  }
}
function kA(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let s = n.length, r;
  for (; s-- > 0; )
    if (r = n[s], e === r.toLowerCase())
      return r;
  return null;
}
const Ys = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, MA = (t) => !Ui(t) && t !== Ys;
function eu() {
  const { caseless: t } = MA(this) && this || {}, e = {}, n = (s, r) => {
    const i = t && kA(e, r) || r;
    pa(e[i]) && pa(s) ? e[i] = eu(e[i], s) : pa(s) ? e[i] = eu({}, s) : Jr(s) ? e[i] = s.slice() : e[i] = s;
  };
  for (let s = 0, r = arguments.length; s < r; s++)
    arguments[s] && vo(arguments[s], n);
  return e;
}
const US = (t, e, n, { allOwnKeys: s } = {}) => (vo(e, (r, i) => {
  n && Xt(r) ? t[i] = EA(r, n) : t[i] = r;
}, { allOwnKeys: s }), t), WS = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), HS = (t, e, n, s) => {
  t.prototype = Object.create(e.prototype, s), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, QS = (t, e, n, s) => {
  let r, i, o;
  const a = {};
  if (e = e || {}, t == null) return e;
  do {
    for (r = Object.getOwnPropertyNames(t), i = r.length; i-- > 0; )
      o = r[i], (!s || s(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
    t = n !== !1 && cd(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, YS = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const s = t.indexOf(e, n);
  return s !== -1 && s === n;
}, KS = (t) => {
  if (!t) return null;
  if (Jr(t)) return t;
  let e = t.length;
  if (!RA(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, XS = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && cd(Uint8Array)), GS = (t, e) => {
  const s = (t && t[Symbol.iterator]).call(t);
  let r;
  for (; (r = s.next()) && !r.done; ) {
    const i = r.value;
    e.call(t, i[0], i[1]);
  }
}, ZS = (t, e) => {
  let n;
  const s = [];
  for (; (n = t.exec(e)) !== null; )
    s.push(n);
  return s;
}, _S = mn("HTMLFormElement"), JS = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, s, r) {
    return s.toUpperCase() + r;
  }
), wh = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), $S = mn("RegExp"), DA = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), s = {};
  vo(n, (r, i) => {
    let o;
    (o = e(r, i, t)) !== !1 && (s[i] = o || r);
  }), Object.defineProperties(t, s);
}, eC = (t) => {
  DA(t, (e, n) => {
    if (Xt(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const s = t[n];
    if (Xt(s)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, tC = (t, e) => {
  const n = {}, s = (r) => {
    r.forEach((i) => {
      n[i] = !0;
    });
  };
  return Jr(t) ? s(t) : s(String(t).split(e)), n;
}, nC = () => {
}, sC = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, cc = "abcdefghijklmnopqrstuvwxyz", Sh = "0123456789", OA = {
  DIGIT: Sh,
  ALPHA: cc,
  ALPHA_DIGIT: cc + cc.toUpperCase() + Sh
}, rC = (t = 16, e = OA.ALPHA_DIGIT) => {
  let n = "";
  const { length: s } = e;
  for (; t--; )
    n += e[Math.random() * s | 0];
  return n;
};
function iC(t) {
  return !!(t && Xt(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const oC = (t) => {
  const e = new Array(10), n = (s, r) => {
    if (Cl(s)) {
      if (e.indexOf(s) >= 0)
        return;
      if (!("toJSON" in s)) {
        e[r] = s;
        const i = Jr(s) ? [] : {};
        return vo(s, (o, a) => {
          const l = n(o, r + 1);
          !Ui(l) && (i[a] = l);
        }), e[r] = void 0, i;
      }
    }
    return s;
  };
  return n(t, 0);
}, aC = mn("AsyncFunction"), lC = (t) => t && (Cl(t) || Xt(t)) && Xt(t.then) && Xt(t.catch), LA = ((t, e) => t ? setImmediate : e ? ((n, s) => (Ys.addEventListener("message", ({ source: r, data: i }) => {
  r === Ys && i === n && s.length && s.shift()();
}, !1), (r) => {
  s.push(r), Ys.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Xt(Ys.postMessage)
), cC = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ys) : typeof process < "u" && process.nextTick || LA, M = {
  isArray: Jr,
  isArrayBuffer: TA,
  isBuffer: qS,
  isFormData: NS,
  isArrayBufferView: ES,
  isString: TS,
  isNumber: RA,
  isBoolean: RS,
  isObject: Cl,
  isPlainObject: pa,
  isReadableStream: BS,
  isRequest: IS,
  isResponse: FS,
  isHeaders: VS,
  isUndefined: Ui,
  isDate: kS,
  isFile: MS,
  isBlob: DS,
  isRegExp: $S,
  isFunction: Xt,
  isStream: LS,
  isURLSearchParams: jS,
  isTypedArray: XS,
  isFileList: OS,
  forEach: vo,
  merge: eu,
  extend: US,
  trim: zS,
  stripBOM: WS,
  inherits: HS,
  toFlatObject: QS,
  kindOf: wl,
  kindOfTest: mn,
  endsWith: YS,
  toArray: KS,
  forEachEntry: GS,
  matchAll: ZS,
  isHTMLForm: _S,
  hasOwnProperty: wh,
  hasOwnProp: wh,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: DA,
  freezeMethods: eC,
  toObjectSet: tC,
  toCamelCase: JS,
  noop: nC,
  toFiniteNumber: sC,
  findKey: kA,
  global: Ys,
  isContextDefined: MA,
  ALPHABET: OA,
  generateString: rC,
  isSpecCompliantForm: iC,
  toJSONObject: oC,
  isAsyncFn: aC,
  isThenable: lC,
  setImmediate: LA,
  asap: cC
};
function ae(t, e, n, s, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), s && (this.request = s), r && (this.response = r, this.status = r.status ? r.status : null);
}
M.inherits(ae, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: M.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const NA = ae.prototype, jA = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  jA[t] = { value: t };
});
Object.defineProperties(ae, jA);
Object.defineProperty(NA, "isAxiosError", { value: !0 });
ae.from = (t, e, n, s, r, i) => {
  const o = Object.create(NA);
  return M.toFlatObject(t, o, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), ae.call(o, t.message, e, n, s, r), o.cause = t, o.name = t.name, i && Object.assign(o, i), o;
};
const uC = null;
function tu(t) {
  return M.isPlainObject(t) || M.isArray(t);
}
function BA(t) {
  return M.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function Ch(t, e, n) {
  return t ? t.concat(e).map(function(r, i) {
    return r = BA(r), !n && i ? "[" + r + "]" : r;
  }).join(n ? "." : "") : e;
}
function dC(t) {
  return M.isArray(t) && !t.some(tu);
}
const fC = M.toFlatObject(M, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Pl(t, e, n) {
  if (!M.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = M.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, A) {
    return !M.isUndefined(A[g]);
  });
  const s = n.metaTokens, r = n.visitor || u, i = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && M.isSpecCompliantForm(e);
  if (!M.isFunction(r))
    throw new TypeError("visitor must be a function");
  function c(p) {
    if (p === null) return "";
    if (M.isDate(p))
      return p.toISOString();
    if (!l && M.isBlob(p))
      throw new ae("Blob is not supported. Use a Buffer instead.");
    return M.isArrayBuffer(p) || M.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function u(p, g, A) {
    let b = p;
    if (p && !A && typeof p == "object") {
      if (M.endsWith(g, "{}"))
        g = s ? g : g.slice(0, -2), p = JSON.stringify(p);
      else if (M.isArray(p) && dC(p) || (M.isFileList(p) || M.endsWith(g, "[]")) && (b = M.toArray(p)))
        return g = BA(g), b.forEach(function(w, x) {
          !(M.isUndefined(w) || w === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Ch([g], x, i) : o === null ? g : g + "[]",
            c(w)
          );
        }), !1;
    }
    return tu(p) ? !0 : (e.append(Ch(A, g, i), c(p)), !1);
  }
  const d = [], f = Object.assign(fC, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: tu
  });
  function h(p, g) {
    if (!M.isUndefined(p)) {
      if (d.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      d.push(p), M.forEach(p, function(b, y) {
        (!(M.isUndefined(b) || b === null) && r.call(
          e,
          b,
          M.isString(y) ? y.trim() : y,
          g,
          f
        )) === !0 && h(b, g ? g.concat(y) : [y]);
      }), d.pop();
    }
  }
  if (!M.isObject(t))
    throw new TypeError("data must be an object");
  return h(t), e;
}
function Ph(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(s) {
    return e[s];
  });
}
function ud(t, e) {
  this._pairs = [], t && Pl(t, this, e);
}
const IA = ud.prototype;
IA.append = function(e, n) {
  this._pairs.push([e, n]);
};
IA.toString = function(e) {
  const n = e ? function(s) {
    return e.call(this, s, Ph);
  } : Ph;
  return this._pairs.map(function(r) {
    return n(r[0]) + "=" + n(r[1]);
  }, "").join("&");
};
function hC(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function FA(t, e, n) {
  if (!e)
    return t;
  const s = n && n.encode || hC, r = n && n.serialize;
  let i;
  if (r ? i = r(e, n) : i = M.isURLSearchParams(e) ? e.toString() : new ud(e, n).toString(s), i) {
    const o = t.indexOf("#");
    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return t;
}
class qh {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, s) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: s ? s.synchronous : !1,
      runWhen: s ? s.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    M.forEach(this.handlers, function(s) {
      s !== null && e(s);
    });
  }
}
const VA = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, pC = typeof URLSearchParams < "u" ? URLSearchParams : ud, gC = typeof FormData < "u" ? FormData : null, mC = typeof Blob < "u" ? Blob : null, AC = {
  isBrowser: !0,
  classes: {
    URLSearchParams: pC,
    FormData: gC,
    Blob: mC
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, dd = typeof window < "u" && typeof document < "u", nu = typeof navigator == "object" && navigator || void 0, bC = dd && (!nu || ["ReactNative", "NativeScript", "NS"].indexOf(nu.product) < 0), yC = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", vC = dd && window.location.href || "http://localhost", xC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: dd,
  hasStandardBrowserEnv: bC,
  hasStandardBrowserWebWorkerEnv: yC,
  navigator: nu,
  origin: vC
}, Symbol.toStringTag, { value: "Module" })), zt = {
  ...xC,
  ...AC
};
function wC(t, e) {
  return Pl(t, new zt.classes.URLSearchParams(), Object.assign({
    visitor: function(n, s, r, i) {
      return zt.isNode && M.isBuffer(n) ? (this.append(s, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function SC(t) {
  return M.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function CC(t) {
  const e = {}, n = Object.keys(t);
  let s;
  const r = n.length;
  let i;
  for (s = 0; s < r; s++)
    i = n[s], e[i] = t[i];
  return e;
}
function zA(t) {
  function e(n, s, r, i) {
    let o = n[i++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), l = i >= n.length;
    return o = !o && M.isArray(r) ? r.length : o, l ? (M.hasOwnProp(r, o) ? r[o] = [r[o], s] : r[o] = s, !a) : ((!r[o] || !M.isObject(r[o])) && (r[o] = []), e(n, s, r[o], i) && M.isArray(r[o]) && (r[o] = CC(r[o])), !a);
  }
  if (M.isFormData(t) && M.isFunction(t.entries)) {
    const n = {};
    return M.forEachEntry(t, (s, r) => {
      e(SC(s), r, n, 0);
    }), n;
  }
  return null;
}
function PC(t, e, n) {
  if (M.isString(t))
    try {
      return (e || JSON.parse)(t), M.trim(t);
    } catch (s) {
      if (s.name !== "SyntaxError")
        throw s;
    }
  return (0, JSON.stringify)(t);
}
const xo = {
  transitional: VA,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const s = n.getContentType() || "", r = s.indexOf("application/json") > -1, i = M.isObject(e);
    if (i && M.isHTMLForm(e) && (e = new FormData(e)), M.isFormData(e))
      return r ? JSON.stringify(zA(e)) : e;
    if (M.isArrayBuffer(e) || M.isBuffer(e) || M.isStream(e) || M.isFile(e) || M.isBlob(e) || M.isReadableStream(e))
      return e;
    if (M.isArrayBufferView(e))
      return e.buffer;
    if (M.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (i) {
      if (s.indexOf("application/x-www-form-urlencoded") > -1)
        return wC(e, this.formSerializer).toString();
      if ((a = M.isFileList(e)) || s.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Pl(
          a ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return i || r ? (n.setContentType("application/json", !1), PC(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || xo.transitional, s = n && n.forcedJSONParsing, r = this.responseType === "json";
    if (M.isResponse(e) || M.isReadableStream(e))
      return e;
    if (e && M.isString(e) && (s && !this.responseType || r)) {
      const o = !(n && n.silentJSONParsing) && r;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? ae.from(a, ae.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: zt.classes.FormData,
    Blob: zt.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
M.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  xo.headers[t] = {};
});
const qC = M.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), EC = (t) => {
  const e = {};
  let n, s, r;
  return t && t.split(`
`).forEach(function(o) {
    r = o.indexOf(":"), n = o.substring(0, r).trim().toLowerCase(), s = o.substring(r + 1).trim(), !(!n || e[n] && qC[n]) && (n === "set-cookie" ? e[n] ? e[n].push(s) : e[n] = [s] : e[n] = e[n] ? e[n] + ", " + s : s);
  }), e;
}, Eh = Symbol("internals");
function fi(t) {
  return t && String(t).trim().toLowerCase();
}
function ga(t) {
  return t === !1 || t == null ? t : M.isArray(t) ? t.map(ga) : String(t);
}
function TC(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let s;
  for (; s = n.exec(t); )
    e[s[1]] = s[2];
  return e;
}
const RC = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function uc(t, e, n, s, r) {
  if (M.isFunction(s))
    return s.call(this, e, n);
  if (r && (e = n), !!M.isString(e)) {
    if (M.isString(s))
      return e.indexOf(s) !== -1;
    if (M.isRegExp(s))
      return s.test(e);
  }
}
function kC(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, s) => n.toUpperCase() + s);
}
function MC(t, e) {
  const n = M.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((s) => {
    Object.defineProperty(t, s + n, {
      value: function(r, i, o) {
        return this[s].call(this, e, r, i, o);
      },
      configurable: !0
    });
  });
}
class Ut {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, s) {
    const r = this;
    function i(a, l, c) {
      const u = fi(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = M.findKey(r, u);
      (!d || r[d] === void 0 || c === !0 || c === void 0 && r[d] !== !1) && (r[d || l] = ga(a));
    }
    const o = (a, l) => M.forEach(a, (c, u) => i(c, u, l));
    if (M.isPlainObject(e) || e instanceof this.constructor)
      o(e, n);
    else if (M.isString(e) && (e = e.trim()) && !RC(e))
      o(EC(e), n);
    else if (M.isHeaders(e))
      for (const [a, l] of e.entries())
        i(l, a, s);
    else
      e != null && i(n, e, s);
    return this;
  }
  get(e, n) {
    if (e = fi(e), e) {
      const s = M.findKey(this, e);
      if (s) {
        const r = this[s];
        if (!n)
          return r;
        if (n === !0)
          return TC(r);
        if (M.isFunction(n))
          return n.call(this, r, s);
        if (M.isRegExp(n))
          return n.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = fi(e), e) {
      const s = M.findKey(this, e);
      return !!(s && this[s] !== void 0 && (!n || uc(this, this[s], s, n)));
    }
    return !1;
  }
  delete(e, n) {
    const s = this;
    let r = !1;
    function i(o) {
      if (o = fi(o), o) {
        const a = M.findKey(s, o);
        a && (!n || uc(s, s[a], a, n)) && (delete s[a], r = !0);
      }
    }
    return M.isArray(e) ? e.forEach(i) : i(e), r;
  }
  clear(e) {
    const n = Object.keys(this);
    let s = n.length, r = !1;
    for (; s--; ) {
      const i = n[s];
      (!e || uc(this, this[i], i, e, !0)) && (delete this[i], r = !0);
    }
    return r;
  }
  normalize(e) {
    const n = this, s = {};
    return M.forEach(this, (r, i) => {
      const o = M.findKey(s, i);
      if (o) {
        n[o] = ga(r), delete n[i];
        return;
      }
      const a = e ? kC(i) : String(i).trim();
      a !== i && delete n[i], n[a] = ga(r), s[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return M.forEach(this, (s, r) => {
      s != null && s !== !1 && (n[r] = e && M.isArray(s) ? s.join(", ") : s);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const s = new this(e);
    return n.forEach((r) => s.set(r)), s;
  }
  static accessor(e) {
    const s = (this[Eh] = this[Eh] = {
      accessors: {}
    }).accessors, r = this.prototype;
    function i(o) {
      const a = fi(o);
      s[a] || (MC(r, o), s[a] = !0);
    }
    return M.isArray(e) ? e.forEach(i) : i(e), this;
  }
}
Ut.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
M.reduceDescriptors(Ut.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(s) {
      this[n] = s;
    }
  };
});
M.freezeMethods(Ut);
function dc(t, e) {
  const n = this || xo, s = e || n, r = Ut.from(s.headers);
  let i = s.data;
  return M.forEach(t, function(a) {
    i = a.call(n, i, r.normalize(), e ? e.status : void 0);
  }), r.normalize(), i;
}
function UA(t) {
  return !!(t && t.__CANCEL__);
}
function $r(t, e, n) {
  ae.call(this, t ?? "canceled", ae.ERR_CANCELED, e, n), this.name = "CanceledError";
}
M.inherits($r, ae, {
  __CANCEL__: !0
});
function WA(t, e, n) {
  const s = n.config.validateStatus;
  !n.status || !s || s(n.status) ? t(n) : e(new ae(
    "Request failed with status code " + n.status,
    [ae.ERR_BAD_REQUEST, ae.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function DC(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function OC(t, e) {
  t = t || 10;
  const n = new Array(t), s = new Array(t);
  let r = 0, i = 0, o;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const c = Date.now(), u = s[i];
    o || (o = c), n[r] = l, s[r] = c;
    let d = i, f = 0;
    for (; d !== r; )
      f += n[d++], d = d % t;
    if (r = (r + 1) % t, r === i && (i = (i + 1) % t), c - o < e)
      return;
    const h = u && c - u;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function LC(t, e) {
  let n = 0, s = 1e3 / e, r, i;
  const o = (c, u = Date.now()) => {
    n = u, r = null, i && (clearTimeout(i), i = null), t.apply(null, c);
  };
  return [(...c) => {
    const u = Date.now(), d = u - n;
    d >= s ? o(c, u) : (r = c, i || (i = setTimeout(() => {
      i = null, o(r);
    }, s - d)));
  }, () => r && o(r)];
}
const Fa = (t, e, n = 3) => {
  let s = 0;
  const r = OC(50, 250);
  return LC((i) => {
    const o = i.loaded, a = i.lengthComputable ? i.total : void 0, l = o - s, c = r(l), u = o <= a;
    s = o;
    const d = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && a && u ? (a - o) / c : void 0,
      event: i,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    t(d);
  }, n);
}, Th = (t, e) => {
  const n = t != null;
  return [(s) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: s
  }), e[1]];
}, Rh = (t) => (...e) => M.asap(() => t(...e)), NC = zt.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = zt.navigator && /(msie|trident)/i.test(zt.navigator.userAgent), n = document.createElement("a");
    let s;
    function r(i) {
      let o = i;
      return e && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return s = r(window.location.href), function(o) {
      const a = M.isString(o) ? r(o) : o;
      return a.protocol === s.protocol && a.host === s.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), jC = zt.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, s, r, i) {
      const o = [t + "=" + encodeURIComponent(e)];
      M.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), M.isString(s) && o.push("path=" + s), M.isString(r) && o.push("domain=" + r), i === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function BC(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function IC(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function HA(t, e) {
  return t && !BC(e) ? IC(t, e) : e;
}
const kh = (t) => t instanceof Ut ? { ...t } : t;
function tr(t, e) {
  e = e || {};
  const n = {};
  function s(c, u, d) {
    return M.isPlainObject(c) && M.isPlainObject(u) ? M.merge.call({ caseless: d }, c, u) : M.isPlainObject(u) ? M.merge({}, u) : M.isArray(u) ? u.slice() : u;
  }
  function r(c, u, d) {
    if (M.isUndefined(u)) {
      if (!M.isUndefined(c))
        return s(void 0, c, d);
    } else return s(c, u, d);
  }
  function i(c, u) {
    if (!M.isUndefined(u))
      return s(void 0, u);
  }
  function o(c, u) {
    if (M.isUndefined(u)) {
      if (!M.isUndefined(c))
        return s(void 0, c);
    } else return s(void 0, u);
  }
  function a(c, u, d) {
    if (d in e)
      return s(c, u);
    if (d in t)
      return s(void 0, c);
  }
  const l = {
    url: i,
    method: i,
    data: i,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, u) => r(kh(c), kh(u), !0)
  };
  return M.forEach(Object.keys(Object.assign({}, t, e)), function(u) {
    const d = l[u] || r, f = d(t[u], e[u], u);
    M.isUndefined(f) && d !== a || (n[u] = f);
  }), n;
}
const QA = (t) => {
  const e = tr({}, t);
  let { data: n, withXSRFToken: s, xsrfHeaderName: r, xsrfCookieName: i, headers: o, auth: a } = e;
  e.headers = o = Ut.from(o), e.url = FA(HA(e.baseURL, e.url), t.params, t.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let l;
  if (M.isFormData(n)) {
    if (zt.hasStandardBrowserEnv || zt.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((l = o.getContentType()) !== !1) {
      const [c, ...u] = l ? l.split(";").map((d) => d.trim()).filter(Boolean) : [];
      o.setContentType([c || "multipart/form-data", ...u].join("; "));
    }
  }
  if (zt.hasStandardBrowserEnv && (s && M.isFunction(s) && (s = s(e)), s || s !== !1 && NC(e.url))) {
    const c = r && i && jC.read(i);
    c && o.set(r, c);
  }
  return e;
}, FC = typeof XMLHttpRequest < "u", VC = FC && function(t) {
  return new Promise(function(n, s) {
    const r = QA(t);
    let i = r.data;
    const o = Ut.from(r.headers).normalize();
    let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = r, u, d, f, h, p;
    function g() {
      h && h(), p && p(), r.cancelToken && r.cancelToken.unsubscribe(u), r.signal && r.signal.removeEventListener("abort", u);
    }
    let A = new XMLHttpRequest();
    A.open(r.method.toUpperCase(), r.url, !0), A.timeout = r.timeout;
    function b() {
      if (!A)
        return;
      const w = Ut.from(
        "getAllResponseHeaders" in A && A.getAllResponseHeaders()
      ), S = {
        data: !a || a === "text" || a === "json" ? A.responseText : A.response,
        status: A.status,
        statusText: A.statusText,
        headers: w,
        config: t,
        request: A
      };
      WA(function(C) {
        n(C), g();
      }, function(C) {
        s(C), g();
      }, S), A = null;
    }
    "onloadend" in A ? A.onloadend = b : A.onreadystatechange = function() {
      !A || A.readyState !== 4 || A.status === 0 && !(A.responseURL && A.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, A.onabort = function() {
      A && (s(new ae("Request aborted", ae.ECONNABORTED, t, A)), A = null);
    }, A.onerror = function() {
      s(new ae("Network Error", ae.ERR_NETWORK, t, A)), A = null;
    }, A.ontimeout = function() {
      let x = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const S = r.transitional || VA;
      r.timeoutErrorMessage && (x = r.timeoutErrorMessage), s(new ae(
        x,
        S.clarifyTimeoutError ? ae.ETIMEDOUT : ae.ECONNABORTED,
        t,
        A
      )), A = null;
    }, i === void 0 && o.setContentType(null), "setRequestHeader" in A && M.forEach(o.toJSON(), function(x, S) {
      A.setRequestHeader(S, x);
    }), M.isUndefined(r.withCredentials) || (A.withCredentials = !!r.withCredentials), a && a !== "json" && (A.responseType = r.responseType), c && ([f, p] = Fa(c, !0), A.addEventListener("progress", f)), l && A.upload && ([d, h] = Fa(l), A.upload.addEventListener("progress", d), A.upload.addEventListener("loadend", h)), (r.cancelToken || r.signal) && (u = (w) => {
      A && (s(!w || w.type ? new $r(null, t, A) : w), A.abort(), A = null);
    }, r.cancelToken && r.cancelToken.subscribe(u), r.signal && (r.signal.aborted ? u() : r.signal.addEventListener("abort", u)));
    const y = DC(r.url);
    if (y && zt.protocols.indexOf(y) === -1) {
      s(new ae("Unsupported protocol " + y + ":", ae.ERR_BAD_REQUEST, t));
      return;
    }
    A.send(i || null);
  });
}, zC = (t, e) => {
  const { length: n } = t = t ? t.filter(Boolean) : [];
  if (e || n) {
    let s = new AbortController(), r;
    const i = function(c) {
      if (!r) {
        r = !0, a();
        const u = c instanceof Error ? c : this.reason;
        s.abort(u instanceof ae ? u : new $r(u instanceof Error ? u.message : u));
      }
    };
    let o = e && setTimeout(() => {
      o = null, i(new ae(`timeout ${e} of ms exceeded`, ae.ETIMEDOUT));
    }, e);
    const a = () => {
      t && (o && clearTimeout(o), o = null, t.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(i) : c.removeEventListener("abort", i);
      }), t = null);
    };
    t.forEach((c) => c.addEventListener("abort", i));
    const { signal: l } = s;
    return l.unsubscribe = () => M.asap(a), l;
  }
}, UC = function* (t, e) {
  let n = t.byteLength;
  if (n < e) {
    yield t;
    return;
  }
  let s = 0, r;
  for (; s < n; )
    r = s + e, yield t.slice(s, r), s = r;
}, WC = async function* (t, e) {
  for await (const n of HC(t))
    yield* UC(n, e);
}, HC = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: n, value: s } = await e.read();
      if (n)
        break;
      yield s;
    }
  } finally {
    await e.cancel();
  }
}, Mh = (t, e, n, s) => {
  const r = WC(t, e);
  let i = 0, o, a = (l) => {
    o || (o = !0, s && s(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: u } = await r.next();
        if (c) {
          a(), l.close();
          return;
        }
        let d = u.byteLength;
        if (n) {
          let f = i += d;
          n(f);
        }
        l.enqueue(new Uint8Array(u));
      } catch (c) {
        throw a(c), c;
      }
    },
    cancel(l) {
      return a(l), r.return();
    }
  }, {
    highWaterMark: 2
  });
}, ql = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", YA = ql && typeof ReadableStream == "function", QC = ql && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), KA = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, YC = YA && KA(() => {
  let t = !1;
  const e = new Request(zt.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), Dh = 64 * 1024, su = YA && KA(() => M.isReadableStream(new Response("").body)), Va = {
  stream: su && ((t) => t.body)
};
ql && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Va[e] && (Va[e] = M.isFunction(t[e]) ? (n) => n[e]() : (n, s) => {
      throw new ae(`Response type '${e}' is not supported`, ae.ERR_NOT_SUPPORT, s);
    });
  });
})(new Response());
const KC = async (t) => {
  if (t == null)
    return 0;
  if (M.isBlob(t))
    return t.size;
  if (M.isSpecCompliantForm(t))
    return (await new Request(zt.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (M.isArrayBufferView(t) || M.isArrayBuffer(t))
    return t.byteLength;
  if (M.isURLSearchParams(t) && (t = t + ""), M.isString(t))
    return (await QC(t)).byteLength;
}, XC = async (t, e) => {
  const n = M.toFiniteNumber(t.getContentLength());
  return n ?? KC(e);
}, GC = ql && (async (t) => {
  let {
    url: e,
    method: n,
    data: s,
    signal: r,
    cancelToken: i,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: l,
    responseType: c,
    headers: u,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = QA(t);
  c = c ? (c + "").toLowerCase() : "text";
  let h = zC([r, i && i.toAbortSignal()], o), p;
  const g = h && h.unsubscribe && (() => {
    h.unsubscribe();
  });
  let A;
  try {
    if (l && YC && n !== "get" && n !== "head" && (A = await XC(u, s)) !== 0) {
      let S = new Request(e, {
        method: "POST",
        body: s,
        duplex: "half"
      }), q;
      if (M.isFormData(s) && (q = S.headers.get("content-type")) && u.setContentType(q), S.body) {
        const [C, E] = Th(
          A,
          Fa(Rh(l))
        );
        s = Mh(S.body, Dh, C, E);
      }
    }
    M.isString(d) || (d = d ? "include" : "omit");
    const b = "credentials" in Request.prototype;
    p = new Request(e, {
      ...f,
      signal: h,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: s,
      duplex: "half",
      credentials: b ? d : void 0
    });
    let y = await fetch(p);
    const w = su && (c === "stream" || c === "response");
    if (su && (a || w && g)) {
      const S = {};
      ["status", "statusText", "headers"].forEach((T) => {
        S[T] = y[T];
      });
      const q = M.toFiniteNumber(y.headers.get("content-length")), [C, E] = a && Th(
        q,
        Fa(Rh(a), !0)
      ) || [];
      y = new Response(
        Mh(y.body, Dh, C, () => {
          E && E(), g && g();
        }),
        S
      );
    }
    c = c || "text";
    let x = await Va[M.findKey(Va, c) || "text"](y, t);
    return !w && g && g(), await new Promise((S, q) => {
      WA(S, q, {
        data: x,
        headers: Ut.from(y.headers),
        status: y.status,
        statusText: y.statusText,
        config: t,
        request: p
      });
    });
  } catch (b) {
    throw g && g(), b && b.name === "TypeError" && /fetch/i.test(b.message) ? Object.assign(
      new ae("Network Error", ae.ERR_NETWORK, t, p),
      {
        cause: b.cause || b
      }
    ) : ae.from(b, b && b.code, t, p);
  }
}), ru = {
  http: uC,
  xhr: VC,
  fetch: GC
};
M.forEach(ru, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const Oh = (t) => `- ${t}`, ZC = (t) => M.isFunction(t) || t === null || t === !1, XA = {
  getAdapter: (t) => {
    t = M.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, s;
    const r = {};
    for (let i = 0; i < e; i++) {
      n = t[i];
      let o;
      if (s = n, !ZC(n) && (s = ru[(o = String(n)).toLowerCase()], s === void 0))
        throw new ae(`Unknown adapter '${o}'`);
      if (s)
        break;
      r[o || "#" + i] = s;
    }
    if (!s) {
      const i = Object.entries(r).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? i.length > 1 ? `since :
` + i.map(Oh).join(`
`) : " " + Oh(i[0]) : "as no adapter specified";
      throw new ae(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return s;
  },
  adapters: ru
};
function fc(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new $r(null, t);
}
function Lh(t) {
  return fc(t), t.headers = Ut.from(t.headers), t.data = dc.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), XA.getAdapter(t.adapter || xo.adapter)(t).then(function(s) {
    return fc(t), s.data = dc.call(
      t,
      t.transformResponse,
      s
    ), s.headers = Ut.from(s.headers), s;
  }, function(s) {
    return UA(s) || (fc(t), s && s.response && (s.response.data = dc.call(
      t,
      t.transformResponse,
      s.response
    ), s.response.headers = Ut.from(s.response.headers))), Promise.reject(s);
  });
}
const GA = "1.7.7", fd = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  fd[t] = function(s) {
    return typeof s === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const Nh = {};
fd.transitional = function(e, n, s) {
  function r(i, o) {
    return "[Axios v" + GA + "] Transitional option '" + i + "'" + o + (s ? ". " + s : "");
  }
  return (i, o, a) => {
    if (e === !1)
      throw new ae(
        r(o, " has been removed" + (n ? " in " + n : "")),
        ae.ERR_DEPRECATED
      );
    return n && !Nh[o] && (Nh[o] = !0, console.warn(
      r(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(i, o, a) : !0;
  };
};
function _C(t, e, n) {
  if (typeof t != "object")
    throw new ae("options must be an object", ae.ERR_BAD_OPTION_VALUE);
  const s = Object.keys(t);
  let r = s.length;
  for (; r-- > 0; ) {
    const i = s[r], o = e[i];
    if (o) {
      const a = t[i], l = a === void 0 || o(a, i, t);
      if (l !== !0)
        throw new ae("option " + i + " must be " + l, ae.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new ae("Unknown option " + i, ae.ERR_BAD_OPTION);
  }
}
const iu = {
  assertOptions: _C,
  validators: fd
}, os = iu.validators;
class Gs {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new qh(),
      response: new qh()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (s) {
      if (s instanceof Error) {
        let r;
        Error.captureStackTrace ? Error.captureStackTrace(r = {}) : r = new Error();
        const i = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          s.stack ? i && !String(s.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (s.stack += `
` + i) : s.stack = i;
        } catch {
        }
      }
      throw s;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = tr(this.defaults, n);
    const { transitional: s, paramsSerializer: r, headers: i } = n;
    s !== void 0 && iu.assertOptions(s, {
      silentJSONParsing: os.transitional(os.boolean),
      forcedJSONParsing: os.transitional(os.boolean),
      clarifyTimeoutError: os.transitional(os.boolean)
    }, !1), r != null && (M.isFunction(r) ? n.paramsSerializer = {
      serialize: r
    } : iu.assertOptions(r, {
      encode: os.function,
      serialize: os.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o = i && M.merge(
      i.common,
      i[n.method]
    );
    i && M.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete i[p];
      }
    ), n.headers = Ut.concat(o, i);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (l = l && g.synchronous, a.unshift(g.fulfilled, g.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(g) {
      c.push(g.fulfilled, g.rejected);
    });
    let u, d = 0, f;
    if (!l) {
      const p = [Lh.bind(this), void 0];
      for (p.unshift.apply(p, a), p.push.apply(p, c), f = p.length, u = Promise.resolve(n); d < f; )
        u = u.then(p[d++], p[d++]);
      return u;
    }
    f = a.length;
    let h = n;
    for (d = 0; d < f; ) {
      const p = a[d++], g = a[d++];
      try {
        h = p(h);
      } catch (A) {
        g.call(this, A);
        break;
      }
    }
    try {
      u = Lh.call(this, h);
    } catch (p) {
      return Promise.reject(p);
    }
    for (d = 0, f = c.length; d < f; )
      u = u.then(c[d++], c[d++]);
    return u;
  }
  getUri(e) {
    e = tr(this.defaults, e);
    const n = HA(e.baseURL, e.url);
    return FA(n, e.params, e.paramsSerializer);
  }
}
M.forEach(["delete", "get", "head", "options"], function(e) {
  Gs.prototype[e] = function(n, s) {
    return this.request(tr(s || {}, {
      method: e,
      url: n,
      data: (s || {}).data
    }));
  };
});
M.forEach(["post", "put", "patch"], function(e) {
  function n(s) {
    return function(i, o, a) {
      return this.request(tr(a || {}, {
        method: e,
        headers: s ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: i,
        data: o
      }));
    };
  }
  Gs.prototype[e] = n(), Gs.prototype[e + "Form"] = n(!0);
});
class hd {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(i) {
      n = i;
    });
    const s = this;
    this.promise.then((r) => {
      if (!s._listeners) return;
      let i = s._listeners.length;
      for (; i-- > 0; )
        s._listeners[i](r);
      s._listeners = null;
    }), this.promise.then = (r) => {
      let i;
      const o = new Promise((a) => {
        s.subscribe(a), i = a;
      }).then(r);
      return o.cancel = function() {
        s.unsubscribe(i);
      }, o;
    }, e(function(i, o, a) {
      s.reason || (s.reason = new $r(i, o, a), n(s.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), n = (s) => {
      e.abort(s);
    };
    return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new hd(function(r) {
        e = r;
      }),
      cancel: e
    };
  }
}
function JC(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function $C(t) {
  return M.isObject(t) && t.isAxiosError === !0;
}
const ou = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(ou).forEach(([t, e]) => {
  ou[e] = t;
});
function ZA(t) {
  const e = new Gs(t), n = EA(Gs.prototype.request, e);
  return M.extend(n, Gs.prototype, e, { allOwnKeys: !0 }), M.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(r) {
    return ZA(tr(t, r));
  }, n;
}
const Ce = ZA(xo);
Ce.Axios = Gs;
Ce.CanceledError = $r;
Ce.CancelToken = hd;
Ce.isCancel = UA;
Ce.VERSION = GA;
Ce.toFormData = Pl;
Ce.AxiosError = ae;
Ce.Cancel = Ce.CanceledError;
Ce.all = function(e) {
  return Promise.all(e);
};
Ce.spread = JC;
Ce.isAxiosError = $C;
Ce.mergeConfig = tr;
Ce.AxiosHeaders = Ut;
Ce.formToJSON = (t) => zA(M.isHTMLForm(t) ? new FormData(t) : t);
Ce.getAdapter = XA.getAdapter;
Ce.HttpStatusCode = ou;
Ce.default = Ce;
const jh = /* @__PURE__ */ new Set();
function pd(t, e, n) {
  t || jh.has(e) || (console.warn(e), jh.add(e));
}
function e2(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), n = (...s) => (pd(!1, "motion() is deprecated. Use motion.create() instead."), t(...s));
  return new Proxy(n, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (s, r) => r === "create" ? t : (e.has(r) || e.set(r, t(r)), e.get(r))
  });
}
function Wi(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const au = (t) => Array.isArray(t);
function _A(t, e) {
  if (!Array.isArray(e))
    return !1;
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let s = 0; s < n; s++)
    if (e[s] !== t[s])
      return !1;
  return !0;
}
function Hi(t) {
  return typeof t == "string" || Array.isArray(t);
}
function Bh(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((n, s) => {
    e[0][s] = n.get(), e[1][s] = n.getVelocity();
  }), e;
}
function gd(t, e, n, s) {
  if (typeof e == "function") {
    const [r, i] = Bh(s);
    e = e(n !== void 0 ? n : t.custom, r, i);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [r, i] = Bh(s);
    e = e(n !== void 0 ? n : t.custom, r, i);
  }
  return e;
}
function El(t, e, n) {
  const s = t.getProps();
  return gd(s, e, n !== void 0 ? n : s.custom, t);
}
const md = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Ad = ["initial", ...md], wo = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Ms = new Set(wo), wn = (t) => t * 1e3, Kn = (t) => t / 1e3, t2 = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, n2 = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), s2 = {
  type: "keyframes",
  duration: 0.8
}, r2 = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, i2 = (t, { keyframes: e }) => e.length > 2 ? s2 : Ms.has(t) ? t.startsWith("scale") ? n2(e[1]) : t2 : r2;
function bd(t, e) {
  return t[e] || t.default || t;
}
const o2 = {
  skipAnimations: !1,
  useManualTiming: !1
}, a2 = (t) => t !== null;
function Tl(t, { repeat: e, repeatType: n = "loop" }, s) {
  const r = t.filter(a2), i = e && n !== "loop" && e % 2 === 1 ? 0 : r.length - 1;
  return !i || s === void 0 ? r[i] : s;
}
const yt = (t) => t;
function l2(t) {
  let e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), s = !1, r = !1;
  const i = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(c) {
    i.has(c) && (l.schedule(c), t()), c(o);
  }
  const l = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, u = !1, d = !1) => {
      const h = d && s ? e : n;
      return u && i.add(c), h.has(c) || h.add(c), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      n.delete(c), i.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (o = c, s) {
        r = !0;
        return;
      }
      s = !0, [e, n] = [n, e], n.clear(), e.forEach(a), s = !1, r && (r = !1, l.process(c));
    }
  };
  return l;
}
const jo = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], c2 = 40;
function JA(t, e) {
  let n = !1, s = !0;
  const r = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, i = () => n = !0, o = jo.reduce((b, y) => (b[y] = l2(i), b), {}), { read: a, resolveKeyframes: l, update: c, preRender: u, render: d, postRender: f } = o, h = () => {
    const b = performance.now();
    n = !1, r.delta = s ? 1e3 / 60 : Math.max(Math.min(b - r.timestamp, c2), 1), r.timestamp = b, r.isProcessing = !0, a.process(r), l.process(r), c.process(r), u.process(r), d.process(r), f.process(r), r.isProcessing = !1, n && e && (s = !1, t(h));
  }, p = () => {
    n = !0, s = !0, r.isProcessing || t(h);
  };
  return { schedule: jo.reduce((b, y) => {
    const w = o[y];
    return b[y] = (x, S = !1, q = !1) => (n || p(), w.schedule(x, S, q)), b;
  }, {}), cancel: (b) => {
    for (let y = 0; y < jo.length; y++)
      o[jo[y]].cancel(b);
  }, state: r, steps: o };
}
const { schedule: Oe, cancel: As, state: At, steps: hc } = JA(typeof requestAnimationFrame < "u" ? requestAnimationFrame : yt, !0), $A = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, u2 = 1e-7, d2 = 12;
function f2(t, e, n, s, r) {
  let i, o, a = 0;
  do
    o = e + (n - e) / 2, i = $A(o, s, r) - t, i > 0 ? n = o : e = o;
  while (Math.abs(i) > u2 && ++a < d2);
  return o;
}
function So(t, e, n, s) {
  if (t === e && n === s)
    return yt;
  const r = (i) => f2(i, 0, 1, t, n);
  return (i) => i === 0 || i === 1 ? i : $A(r(i), e, s);
}
const e0 = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, t0 = (t) => (e) => 1 - t(1 - e), n0 = /* @__PURE__ */ So(0.33, 1.53, 0.69, 0.99), yd = /* @__PURE__ */ t0(n0), s0 = /* @__PURE__ */ e0(yd), r0 = (t) => (t *= 2) < 1 ? 0.5 * yd(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), vd = (t) => 1 - Math.sin(Math.acos(t)), i0 = t0(vd), o0 = e0(vd), a0 = (t) => /^0[^.\s]+$/u.test(t);
function h2(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || a0(t) : !0;
}
let ei = yt, Zn = yt;
ei = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, Zn = (t, e) => {
  if (!t)
    throw new Error(e);
};
const l0 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), c0 = (t) => (e) => typeof e == "string" && e.startsWith(t), u0 = /* @__PURE__ */ c0("--"), p2 = /* @__PURE__ */ c0("var(--"), xd = (t) => p2(t) ? g2.test(t.split("/*")[0].trim()) : !1, g2 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, m2 = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function A2(t) {
  const e = m2.exec(t);
  if (!e)
    return [,];
  const [, n, s, r] = e;
  return [`--${n ?? s}`, r];
}
const b2 = 4;
function d0(t, e, n = 1) {
  Zn(n <= b2, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [s, r] = A2(t);
  if (!s)
    return;
  const i = window.getComputedStyle(e).getPropertyValue(s);
  if (i) {
    const o = i.trim();
    return l0(o) ? parseFloat(o) : o;
  }
  return xd(r) ? d0(r, e, n + 1) : r;
}
const bs = (t, e, n) => n > e ? e : n < t ? t : n, ti = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Qi = {
  ...ti,
  transform: (t) => bs(0, 1, t)
}, Bo = {
  ...ti,
  default: 1
}, Co = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), as = /* @__PURE__ */ Co("deg"), Sn = /* @__PURE__ */ Co("%"), te = /* @__PURE__ */ Co("px"), y2 = /* @__PURE__ */ Co("vh"), v2 = /* @__PURE__ */ Co("vw"), Ih = {
  ...Sn,
  parse: (t) => Sn.parse(t) / 100,
  transform: (t) => Sn.transform(t * 100)
}, x2 = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), Fh = (t) => t === ti || t === te, Vh = (t, e) => parseFloat(t.split(", ")[e]), zh = (t, e) => (n, { transform: s }) => {
  if (s === "none" || !s)
    return 0;
  const r = s.match(/^matrix3d\((.+)\)$/u);
  if (r)
    return Vh(r[1], e);
  {
    const i = s.match(/^matrix\((.+)\)$/u);
    return i ? Vh(i[1], t) : 0;
  }
}, w2 = /* @__PURE__ */ new Set(["x", "y", "z"]), S2 = wo.filter((t) => !w2.has(t));
function C2(t) {
  const e = [];
  return S2.forEach((n) => {
    const s = t.getValue(n);
    s !== void 0 && (e.push([n, s.get()]), s.set(n.startsWith("scale") ? 1 : 0));
  }), e;
}
const Nr = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: zh(4, 13),
  y: zh(5, 14)
};
Nr.translateX = Nr.x;
Nr.translateY = Nr.y;
const f0 = (t) => (e) => e.test(t), P2 = {
  test: (t) => t === "auto",
  parse: (t) => t
}, h0 = [ti, te, Sn, as, v2, y2, P2], Uh = (t) => h0.find(f0(t)), Zs = /* @__PURE__ */ new Set();
let lu = !1, cu = !1;
function p0() {
  if (cu) {
    const t = Array.from(Zs).filter((s) => s.needsMeasurement), e = new Set(t.map((s) => s.element)), n = /* @__PURE__ */ new Map();
    e.forEach((s) => {
      const r = C2(s);
      r.length && (n.set(s, r), s.render());
    }), t.forEach((s) => s.measureInitialState()), e.forEach((s) => {
      s.render();
      const r = n.get(s);
      r && r.forEach(([i, o]) => {
        var a;
        (a = s.getValue(i)) === null || a === void 0 || a.set(o);
      });
    }), t.forEach((s) => s.measureEndState()), t.forEach((s) => {
      s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY);
    });
  }
  cu = !1, lu = !1, Zs.forEach((t) => t.complete()), Zs.clear();
}
function g0() {
  Zs.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (cu = !0);
  });
}
function q2() {
  g0(), p0();
}
class wd {
  constructor(e, n, s, r, i, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = s, this.motionValue = r, this.element = i, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (Zs.add(this), lu || (lu = !0, Oe.read(g0), Oe.resolveKeyframes(p0))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: n, element: s, motionValue: r } = this;
    for (let i = 0; i < e.length; i++)
      if (e[i] === null)
        if (i === 0) {
          const o = r == null ? void 0 : r.get(), a = e[e.length - 1];
          if (o !== void 0)
            e[0] = o;
          else if (s && n) {
            const l = s.readValue(n, a);
            l != null && (e[0] = l);
          }
          e[0] === void 0 && (e[0] = a), r && o === void 0 && r.set(e[0]);
        } else
          e[i] = e[i - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Zs.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, Zs.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const Di = (t) => Math.round(t * 1e5) / 1e5, Sd = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function E2(t) {
  return t == null;
}
const T2 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Cd = (t, e) => (n) => !!(typeof n == "string" && T2.test(n) && n.startsWith(t) || e && !E2(n) && Object.prototype.hasOwnProperty.call(n, e)), m0 = (t, e, n) => (s) => {
  if (typeof s != "string")
    return s;
  const [r, i, o, a] = s.match(Sd);
  return {
    [t]: parseFloat(r),
    [e]: parseFloat(i),
    [n]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, R2 = (t) => bs(0, 255, t), pc = {
  ...ti,
  transform: (t) => Math.round(R2(t))
}, Ks = {
  test: /* @__PURE__ */ Cd("rgb", "red"),
  parse: /* @__PURE__ */ m0("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: n, alpha: s = 1 }) => "rgba(" + pc.transform(t) + ", " + pc.transform(e) + ", " + pc.transform(n) + ", " + Di(Qi.transform(s)) + ")"
};
function k2(t) {
  let e = "", n = "", s = "", r = "";
  return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), s = t.substring(5, 7), r = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), s = t.substring(3, 4), r = t.substring(4, 5), e += e, n += n, s += s, r += r), {
    red: parseInt(e, 16),
    green: parseInt(n, 16),
    blue: parseInt(s, 16),
    alpha: r ? parseInt(r, 16) / 255 : 1
  };
}
const uu = {
  test: /* @__PURE__ */ Cd("#"),
  parse: k2,
  transform: Ks.transform
}, xr = {
  test: /* @__PURE__ */ Cd("hsl", "hue"),
  parse: /* @__PURE__ */ m0("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: n, alpha: s = 1 }) => "hsla(" + Math.round(t) + ", " + Sn.transform(Di(e)) + ", " + Sn.transform(Di(n)) + ", " + Di(Qi.transform(s)) + ")"
}, wt = {
  test: (t) => Ks.test(t) || uu.test(t) || xr.test(t),
  parse: (t) => Ks.test(t) ? Ks.parse(t) : xr.test(t) ? xr.parse(t) : uu.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? Ks.transform(t) : xr.transform(t)
}, M2 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function D2(t) {
  var e, n;
  return isNaN(t) && typeof t == "string" && (((e = t.match(Sd)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(M2)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const A0 = "number", b0 = "color", O2 = "var", L2 = "var(", Wh = "${}", N2 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Yi(t) {
  const e = t.toString(), n = [], s = {
    color: [],
    number: [],
    var: []
  }, r = [];
  let i = 0;
  const a = e.replace(N2, (l) => (wt.test(l) ? (s.color.push(i), r.push(b0), n.push(wt.parse(l))) : l.startsWith(L2) ? (s.var.push(i), r.push(O2), n.push(l)) : (s.number.push(i), r.push(A0), n.push(parseFloat(l))), ++i, Wh)).split(Wh);
  return { values: n, split: a, indexes: s, types: r };
}
function y0(t) {
  return Yi(t).values;
}
function v0(t) {
  const { split: e, types: n } = Yi(t), s = e.length;
  return (r) => {
    let i = "";
    for (let o = 0; o < s; o++)
      if (i += e[o], r[o] !== void 0) {
        const a = n[o];
        a === A0 ? i += Di(r[o]) : a === b0 ? i += wt.transform(r[o]) : i += r[o];
      }
    return i;
  };
}
const j2 = (t) => typeof t == "number" ? 0 : t;
function B2(t) {
  const e = y0(t);
  return v0(t)(e.map(j2));
}
const ys = {
  test: D2,
  parse: y0,
  createTransformer: v0,
  getAnimatableNone: B2
}, I2 = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function F2(t) {
  const [e, n] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [s] = n.match(Sd) || [];
  if (!s)
    return t;
  const r = n.replace(s, "");
  let i = I2.has(e) ? 1 : 0;
  return s !== n && (i *= 100), e + "(" + i + r + ")";
}
const V2 = /\b([a-z-]*)\(.*?\)/gu, du = {
  ...ys,
  getAnimatableNone: (t) => {
    const e = t.match(V2);
    return e ? e.map(F2).join(" ") : t;
  }
}, z2 = {
  // Border props
  borderWidth: te,
  borderTopWidth: te,
  borderRightWidth: te,
  borderBottomWidth: te,
  borderLeftWidth: te,
  borderRadius: te,
  radius: te,
  borderTopLeftRadius: te,
  borderTopRightRadius: te,
  borderBottomRightRadius: te,
  borderBottomLeftRadius: te,
  // Positioning props
  width: te,
  maxWidth: te,
  height: te,
  maxHeight: te,
  top: te,
  right: te,
  bottom: te,
  left: te,
  // Spacing props
  padding: te,
  paddingTop: te,
  paddingRight: te,
  paddingBottom: te,
  paddingLeft: te,
  margin: te,
  marginTop: te,
  marginRight: te,
  marginBottom: te,
  marginLeft: te,
  // Misc
  backgroundPositionX: te,
  backgroundPositionY: te
}, U2 = {
  rotate: as,
  rotateX: as,
  rotateY: as,
  rotateZ: as,
  scale: Bo,
  scaleX: Bo,
  scaleY: Bo,
  scaleZ: Bo,
  skew: as,
  skewX: as,
  skewY: as,
  distance: te,
  translateX: te,
  translateY: te,
  translateZ: te,
  x: te,
  y: te,
  z: te,
  perspective: te,
  transformPerspective: te,
  opacity: Qi,
  originX: Ih,
  originY: Ih,
  originZ: te
}, Hh = {
  ...ti,
  transform: Math.round
}, Pd = {
  ...z2,
  ...U2,
  zIndex: Hh,
  size: te,
  // SVG
  fillOpacity: Qi,
  strokeOpacity: Qi,
  numOctaves: Hh
}, W2 = {
  ...Pd,
  // Color props
  color: wt,
  backgroundColor: wt,
  outlineColor: wt,
  fill: wt,
  stroke: wt,
  // Border props
  borderColor: wt,
  borderTopColor: wt,
  borderRightColor: wt,
  borderBottomColor: wt,
  borderLeftColor: wt,
  filter: du,
  WebkitFilter: du
}, qd = (t) => W2[t];
function x0(t, e) {
  let n = qd(t);
  return n !== du && (n = ys), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;
}
const H2 = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function Q2(t, e, n) {
  let s = 0, r;
  for (; s < t.length && !r; ) {
    const i = t[s];
    typeof i == "string" && !H2.has(i) && Yi(i).values.length && (r = t[s]), s++;
  }
  if (r && n)
    for (const i of e)
      t[i] = x0(n, r);
}
class w0 extends wd {
  constructor(e, n, s, r, i) {
    super(e, n, s, r, i, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: n, name: s } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (typeof c == "string" && (c = c.trim(), xd(c))) {
        const u = d0(c, n.current);
        u !== void 0 && (e[l] = u), l === e.length - 1 && (this.finalKeyframe = c);
      }
    }
    if (this.resolveNoneKeyframes(), !x2.has(s) || e.length !== 2)
      return;
    const [r, i] = e, o = Uh(r), a = Uh(i);
    if (o !== a)
      if (Fh(o) && Fh(a))
        for (let l = 0; l < e.length; l++) {
          const c = e[l];
          typeof c == "string" && (e[l] = parseFloat(c));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: n } = this, s = [];
    for (let r = 0; r < e.length; r++)
      h2(e[r]) && s.push(r);
    s.length && Q2(e, s, n);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: n, name: s } = this;
    if (!e || !e.current)
      return;
    s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Nr[s](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin;
    const r = n[n.length - 1];
    r !== void 0 && e.getValue(s, r).jump(r, !1);
  }
  measureEndState() {
    var e;
    const { element: n, name: s, unresolvedKeyframes: r } = this;
    if (!n || !n.current)
      return;
    const i = n.getValue(s);
    i && i.jump(this.measuredOrigin, !1);
    const o = r.length - 1, a = r[o];
    r[o] = Nr[s](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([l, c]) => {
      n.getValue(l).set(c);
    }), this.resolveNoneKeyframes();
  }
}
function Ed(t) {
  return typeof t == "function";
}
let ma;
function Y2() {
  ma = void 0;
}
const Cn = {
  now: () => (ma === void 0 && Cn.set(At.isProcessing || o2.useManualTiming ? At.timestamp : performance.now()), ma),
  set: (t) => {
    ma = t, queueMicrotask(Y2);
  }
}, Qh = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(ys.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function K2(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e)
      return !0;
}
function X2(t, e, n, s) {
  const r = t[0];
  if (r === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const i = t[t.length - 1], o = Qh(r, e), a = Qh(i, e);
  return ei(o === a, `You are trying to animate ${e} from "${r}" to "${i}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${i} via the \`style\` property.`), !o || !a ? !1 : K2(t) || (n === "spring" || Ed(n)) && s;
}
const G2 = 40;
class S0 {
  constructor({ autoplay: e = !0, delay: n = 0, type: s = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Cn.now(), this.options = {
      autoplay: e,
      delay: n,
      type: s,
      repeat: r,
      repeatDelay: i,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > G2 ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && q2(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, n) {
    this.resolvedAt = Cn.now(), this.hasAttemptedResolve = !0;
    const { name: s, type: r, velocity: i, delay: o, onComplete: a, onUpdate: l, isGenerator: c } = this.options;
    if (!c && !X2(e, s, r, i))
      if (o)
        this.options.duration = 0;
      else {
        l == null || l(Tl(e, this.options, n)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const u = this.initPlayback(e, n);
    u !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: n,
      ...u
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, n) {
    return this.currentFinishedPromise.then(e, n);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function C0(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const Z2 = 5;
function P0(t, e, n) {
  const s = Math.max(e - Z2, 0);
  return C0(n - t(s), e - s);
}
const gc = 1e-3, _2 = 0.01, Yh = 10, J2 = 0.05, $2 = 1;
function eP({ duration: t = 800, bounce: e = 0.25, velocity: n = 0, mass: s = 1 }) {
  let r, i;
  ei(t <= wn(Yh), "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = bs(J2, $2, o), t = bs(_2, Yh, Kn(t)), o < 1 ? (r = (c) => {
    const u = c * o, d = u * t, f = u - n, h = fu(c, o), p = Math.exp(-d);
    return gc - f / h * p;
  }, i = (c) => {
    const d = c * o * t, f = d * n + n, h = Math.pow(o, 2) * Math.pow(c, 2) * t, p = Math.exp(-d), g = fu(Math.pow(c, 2), o);
    return (-r(c) + gc > 0 ? -1 : 1) * ((f - h) * p) / g;
  }) : (r = (c) => {
    const u = Math.exp(-c * t), d = (c - n) * t + 1;
    return -gc + u * d;
  }, i = (c) => {
    const u = Math.exp(-c * t), d = (n - c) * (t * t);
    return u * d;
  });
  const a = 5 / t, l = nP(r, i, a);
  if (t = wn(t), isNaN(l))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const c = Math.pow(l, 2) * s;
    return {
      stiffness: c,
      damping: o * 2 * Math.sqrt(s * c),
      duration: t
    };
  }
}
const tP = 12;
function nP(t, e, n) {
  let s = n;
  for (let r = 1; r < tP; r++)
    s = s - t(s) / e(s);
  return s;
}
function fu(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const sP = ["duration", "bounce"], rP = ["stiffness", "damping", "mass"];
function Kh(t, e) {
  return e.some((n) => t[n] !== void 0);
}
function iP(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!Kh(t, rP) && Kh(t, sP)) {
    const n = eP(t);
    e = {
      ...e,
      ...n,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function q0({ keyframes: t, restDelta: e, restSpeed: n, ...s }) {
  const r = t[0], i = t[t.length - 1], o = { done: !1, value: r }, { stiffness: a, damping: l, mass: c, duration: u, velocity: d, isResolvedFromDuration: f } = iP({
    ...s,
    velocity: -Kn(s.velocity || 0)
  }), h = d || 0, p = l / (2 * Math.sqrt(a * c)), g = i - r, A = Kn(Math.sqrt(a / c)), b = Math.abs(g) < 5;
  n || (n = b ? 0.01 : 2), e || (e = b ? 5e-3 : 0.5);
  let y;
  if (p < 1) {
    const w = fu(A, p);
    y = (x) => {
      const S = Math.exp(-p * A * x);
      return i - S * ((h + p * A * g) / w * Math.sin(w * x) + g * Math.cos(w * x));
    };
  } else if (p === 1)
    y = (w) => i - Math.exp(-A * w) * (g + (h + A * g) * w);
  else {
    const w = A * Math.sqrt(p * p - 1);
    y = (x) => {
      const S = Math.exp(-p * A * x), q = Math.min(w * x, 300);
      return i - S * ((h + p * A * g) * Math.sinh(q) + w * g * Math.cosh(q)) / w;
    };
  }
  return {
    calculatedDuration: f && u || null,
    next: (w) => {
      const x = y(w);
      if (f)
        o.done = w >= u;
      else {
        let S = 0;
        p < 1 && (S = w === 0 ? wn(h) : P0(y, w, x));
        const q = Math.abs(S) <= n, C = Math.abs(i - x) <= e;
        o.done = q && C;
      }
      return o.value = o.done ? i : x, o;
    }
  };
}
function Xh({ keyframes: t, velocity: e = 0, power: n = 0.8, timeConstant: s = 325, bounceDamping: r = 10, bounceStiffness: i = 500, modifyTarget: o, min: a, max: l, restDelta: c = 0.5, restSpeed: u }) {
  const d = t[0], f = {
    done: !1,
    value: d
  }, h = (E) => a !== void 0 && E < a || l !== void 0 && E > l, p = (E) => a === void 0 ? l : l === void 0 || Math.abs(a - E) < Math.abs(l - E) ? a : l;
  let g = n * e;
  const A = d + g, b = o === void 0 ? A : o(A);
  b !== A && (g = b - d);
  const y = (E) => -g * Math.exp(-E / s), w = (E) => b + y(E), x = (E) => {
    const T = y(E), k = w(E);
    f.done = Math.abs(T) <= c, f.value = f.done ? b : k;
  };
  let S, q;
  const C = (E) => {
    h(f.value) && (S = E, q = q0({
      keyframes: [f.value, p(f.value)],
      velocity: P0(w, E, f.value),
      // TODO: This should be passing * 1000
      damping: r,
      stiffness: i,
      restDelta: c,
      restSpeed: u
    }));
  };
  return C(0), {
    calculatedDuration: null,
    next: (E) => {
      let T = !1;
      return !q && S === void 0 && (T = !0, x(E), C(E)), S !== void 0 && E >= S ? q.next(E - S) : (!T && x(E), f);
    }
  };
}
const oP = /* @__PURE__ */ So(0.42, 0, 1, 1), aP = /* @__PURE__ */ So(0, 0, 0.58, 1), E0 = /* @__PURE__ */ So(0.42, 0, 0.58, 1), lP = (t) => Array.isArray(t) && typeof t[0] != "number", Gh = {
  linear: yt,
  easeIn: oP,
  easeInOut: E0,
  easeOut: aP,
  circIn: vd,
  circInOut: o0,
  circOut: i0,
  backIn: yd,
  backInOut: s0,
  backOut: n0,
  anticipate: r0
}, Zh = (t) => {
  if (Array.isArray(t)) {
    Zn(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, n, s, r] = t;
    return So(e, n, s, r);
  } else if (typeof t == "string")
    return Zn(Gh[t] !== void 0, `Invalid easing type '${t}'`), Gh[t];
  return t;
}, cP = (t, e) => (n) => e(t(n)), Xn = (...t) => t.reduce(cP), jr = (t, e, n) => {
  const s = e - t;
  return s === 0 ? 1 : (n - t) / s;
}, Ke = (t, e, n) => t + (e - t) * n;
function mc(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function uP({ hue: t, saturation: e, lightness: n, alpha: s }) {
  t /= 360, e /= 100, n /= 100;
  let r = 0, i = 0, o = 0;
  if (!e)
    r = i = o = n;
  else {
    const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;
    r = mc(l, a, t + 1 / 3), i = mc(l, a, t), o = mc(l, a, t - 1 / 3);
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(i * 255),
    blue: Math.round(o * 255),
    alpha: s
  };
}
function za(t, e) {
  return (n) => n > 0 ? e : t;
}
const Ac = (t, e, n) => {
  const s = t * t, r = n * (e * e - s) + s;
  return r < 0 ? 0 : Math.sqrt(r);
}, dP = [uu, Ks, xr], fP = (t) => dP.find((e) => e.test(t));
function _h(t) {
  const e = fP(t);
  if (ei(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let n = e.parse(t);
  return e === xr && (n = uP(n)), n;
}
const Jh = (t, e) => {
  const n = _h(t), s = _h(e);
  if (!n || !s)
    return za(t, e);
  const r = { ...n };
  return (i) => (r.red = Ac(n.red, s.red, i), r.green = Ac(n.green, s.green, i), r.blue = Ac(n.blue, s.blue, i), r.alpha = Ke(n.alpha, s.alpha, i), Ks.transform(r));
}, hu = /* @__PURE__ */ new Set(["none", "hidden"]);
function hP(t, e) {
  return hu.has(t) ? (n) => n <= 0 ? t : e : (n) => n >= 1 ? e : t;
}
function pP(t, e) {
  return (n) => Ke(t, e, n);
}
function Td(t) {
  return typeof t == "number" ? pP : typeof t == "string" ? xd(t) ? za : wt.test(t) ? Jh : AP : Array.isArray(t) ? T0 : typeof t == "object" ? wt.test(t) ? Jh : gP : za;
}
function T0(t, e) {
  const n = [...t], s = n.length, r = t.map((i, o) => Td(i)(i, e[o]));
  return (i) => {
    for (let o = 0; o < s; o++)
      n[o] = r[o](i);
    return n;
  };
}
function gP(t, e) {
  const n = { ...t, ...e }, s = {};
  for (const r in n)
    t[r] !== void 0 && e[r] !== void 0 && (s[r] = Td(t[r])(t[r], e[r]));
  return (r) => {
    for (const i in s)
      n[i] = s[i](r);
    return n;
  };
}
function mP(t, e) {
  var n;
  const s = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < e.values.length; i++) {
    const o = e.types[i], a = t.indexes[o][r[o]], l = (n = t.values[a]) !== null && n !== void 0 ? n : 0;
    s[i] = l, r[o]++;
  }
  return s;
}
const AP = (t, e) => {
  const n = ys.createTransformer(e), s = Yi(t), r = Yi(e);
  return s.indexes.var.length === r.indexes.var.length && s.indexes.color.length === r.indexes.color.length && s.indexes.number.length >= r.indexes.number.length ? hu.has(t) && !r.values.length || hu.has(e) && !s.values.length ? hP(t, e) : Xn(T0(mP(s, r), r.values), n) : (ei(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), za(t, e));
};
function R0(t, e, n) {
  return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Ke(t, e, n) : Td(t)(t, e);
}
function bP(t, e, n) {
  const s = [], r = n || R0, i = t.length - 1;
  for (let o = 0; o < i; o++) {
    let a = r(t[o], t[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] || yt : e;
      a = Xn(l, a);
    }
    s.push(a);
  }
  return s;
}
function yP(t, e, { clamp: n = !0, ease: s, mixer: r } = {}) {
  const i = t.length;
  if (Zn(i === e.length, "Both input and output ranges must be the same length"), i === 1)
    return () => e[0];
  if (i === 2 && t[0] === t[1])
    return () => e[1];
  t[0] > t[i - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const o = bP(e, s, r), a = o.length, l = (c) => {
    let u = 0;
    if (a > 1)
      for (; u < t.length - 2 && !(c < t[u + 1]); u++)
        ;
    const d = jr(t[u], t[u + 1], c);
    return o[u](d);
  };
  return n ? (c) => l(bs(t[0], t[i - 1], c)) : l;
}
function vP(t, e) {
  const n = t[t.length - 1];
  for (let s = 1; s <= e; s++) {
    const r = jr(0, e, s);
    t.push(Ke(n, 1, r));
  }
}
function xP(t) {
  const e = [0];
  return vP(e, t.length - 1), e;
}
function wP(t, e) {
  return t.map((n) => n * e);
}
function SP(t, e) {
  return t.map(() => e || E0).splice(0, t.length - 1);
}
function Ua({ duration: t = 300, keyframes: e, times: n, ease: s = "easeInOut" }) {
  const r = lP(s) ? s.map(Zh) : Zh(s), i = {
    done: !1,
    value: e[0]
  }, o = wP(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === e.length ? n : xP(e),
    t
  ), a = yP(o, e, {
    ease: Array.isArray(r) ? r : SP(e, r)
  });
  return {
    calculatedDuration: t,
    next: (l) => (i.value = a(l), i.done = l >= t, i)
  };
}
const $h = 2e4;
function CP(t) {
  let e = 0;
  const n = 50;
  let s = t.next(e);
  for (; !s.done && e < $h; )
    e += n, s = t.next(e);
  return e >= $h ? 1 / 0 : e;
}
const PP = (t) => {
  const e = ({ timestamp: n }) => t(n);
  return {
    start: () => Oe.update(e, !0),
    stop: () => As(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => At.isProcessing ? At.timestamp : Cn.now()
  };
}, qP = {
  decay: Xh,
  inertia: Xh,
  tween: Ua,
  keyframes: Ua,
  spring: q0
}, EP = (t) => t / 100;
class Rd extends S0 {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: l } = this.options;
      l && l();
    };
    const { name: n, motionValue: s, element: r, keyframes: i } = this.options, o = (r == null ? void 0 : r.KeyframeResolver) || wd, a = (l, c) => this.onKeyframesResolved(l, c);
    this.resolver = new o(i, a, n, s, r), this.resolver.scheduleResolve();
  }
  initPlayback(e) {
    const { type: n = "keyframes", repeat: s = 0, repeatDelay: r = 0, repeatType: i, velocity: o = 0 } = this.options, a = Ed(n) ? n : qP[n] || Ua;
    let l, c;
    a !== Ua && typeof e[0] != "number" && (Zn(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), l = Xn(EP, R0(e[0], e[1])), e = [0, 100]);
    const u = a({ ...this.options, keyframes: e });
    i === "mirror" && (c = a({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -o
    })), u.calculatedDuration === null && (u.calculatedDuration = CP(u));
    const { calculatedDuration: d } = u, f = d + r, h = f * (s + 1) - r;
    return {
      generator: u,
      mirroredGenerator: c,
      mapPercentToKeyframes: l,
      calculatedDuration: d,
      resolvedDuration: f,
      totalDuration: h
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, n = !1) {
    const { resolved: s } = this;
    if (!s) {
      const { keyframes: E } = this.options;
      return { done: !0, value: E[E.length - 1] };
    }
    const { finalKeyframe: r, generator: i, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: c, totalDuration: u, resolvedDuration: d } = s;
    if (this.startTime === null)
      return i.next(0);
    const { delay: f, repeat: h, repeatType: p, repeatDelay: g, onUpdate: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - u / this.speed, this.startTime)), n ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const b = this.currentTime - f * (this.speed >= 0 ? 1 : -1), y = this.speed >= 0 ? b < 0 : b > u;
    this.currentTime = Math.max(b, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u);
    let w = this.currentTime, x = i;
    if (h) {
      const E = Math.min(this.currentTime, u) / d;
      let T = Math.floor(E), k = E % 1;
      !k && E >= 1 && (k = 1), k === 1 && T--, T = Math.min(T, h + 1), !!(T % 2) && (p === "reverse" ? (k = 1 - k, g && (k -= g / d)) : p === "mirror" && (x = o)), w = bs(0, 1, k) * d;
    }
    const S = y ? { done: !1, value: l[0] } : x.next(w);
    a && (S.value = a(S.value));
    let { done: q } = S;
    !y && c !== null && (q = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
    const C = this.holdTime === null && (this.state === "finished" || this.state === "running" && q);
    return C && r !== void 0 && (S.value = Tl(l, this.options, r)), A && A(S.value), C && this.finish(), S;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? Kn(e.calculatedDuration) : 0;
  }
  get time() {
    return Kn(this.currentTime);
  }
  set time(e) {
    e = wn(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const n = this.playbackSpeed !== e;
    this.playbackSpeed = e, n && (this.time = Kn(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = PP, onPlay: n, startTime: s } = this.options;
    this.driver || (this.driver = e((i) => this.tick(i))), n && n();
    const r = this.driver.now();
    this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = r) : this.startTime = s ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const k0 = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), M0 = (t) => Array.isArray(t) && typeof t[0] == "number", TP = 10, RP = (t, e) => {
  let n = "";
  const s = Math.max(Math.round(e / TP), 2);
  for (let r = 0; r < s; r++)
    n += t(jr(0, s - 1, r)) + ", ";
  return `linear(${n.substring(0, n.length - 2)})`;
};
function kd(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const kP = {
  linearEasing: void 0
};
function MP(t, e) {
  const n = kd(t);
  return () => {
    var s;
    return (s = kP[e]) !== null && s !== void 0 ? s : n();
  };
}
const Wa = /* @__PURE__ */ MP(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function D0(t) {
  return !!(typeof t == "function" && Wa() || !t || typeof t == "string" && (t in pu || Wa()) || M0(t) || Array.isArray(t) && t.every(D0));
}
const xi = ([t, e, n, s]) => `cubic-bezier(${t}, ${e}, ${n}, ${s})`, pu = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ xi([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ xi([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ xi([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ xi([0.33, 1.53, 0.69, 0.99])
};
function O0(t, e) {
  if (t)
    return typeof t == "function" && Wa() ? RP(t, e) : M0(t) ? xi(t) : Array.isArray(t) ? t.map((n) => O0(n, e) || pu.easeOut) : pu[t];
}
function DP(t, e, n, { delay: s = 0, duration: r = 300, repeat: i = 0, repeatType: o = "loop", ease: a, times: l } = {}) {
  const c = { [e]: n };
  l && (c.offset = l);
  const u = O0(a, r);
  return Array.isArray(u) && (c.easing = u), t.animate(c, {
    delay: s,
    duration: r,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: i + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
function ep(t, e) {
  t.timeline = e, t.onfinish = null;
}
const OP = /* @__PURE__ */ kd(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Ha = 10, LP = 2e4;
function NP(t) {
  return Ed(t.type) || t.type === "spring" || !D0(t.ease);
}
function jP(t, e) {
  const n = new Rd({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let s = { done: !1, value: t[0] };
  const r = [];
  let i = 0;
  for (; !s.done && i < LP; )
    s = n.sample(i), r.push(s.value), i += Ha;
  return {
    times: void 0,
    keyframes: r,
    duration: i - Ha,
    ease: "linear"
  };
}
const L0 = {
  anticipate: r0,
  backInOut: s0,
  circInOut: o0
};
function BP(t) {
  return t in L0;
}
class tp extends S0 {
  constructor(e) {
    super(e);
    const { name: n, motionValue: s, element: r, keyframes: i } = this.options;
    this.resolver = new w0(i, (o, a) => this.onKeyframesResolved(o, a), n, s, r), this.resolver.scheduleResolve();
  }
  initPlayback(e, n) {
    var s;
    let { duration: r = 300, times: i, ease: o, type: a, motionValue: l, name: c, startTime: u } = this.options;
    if (!(!((s = l.owner) === null || s === void 0) && s.current))
      return !1;
    if (typeof o == "string" && Wa() && BP(o) && (o = L0[o]), NP(this.options)) {
      const { onComplete: f, onUpdate: h, motionValue: p, element: g, ...A } = this.options, b = jP(e, A);
      e = b.keyframes, e.length === 1 && (e[1] = e[0]), r = b.duration, i = b.times, o = b.ease, a = "keyframes";
    }
    const d = DP(l.owner.current, c, e, { ...this.options, duration: r, times: i, ease: o });
    return d.startTime = u ?? this.calcStartTime(), this.pendingTimeline ? (ep(d, this.pendingTimeline), this.pendingTimeline = void 0) : d.onfinish = () => {
      const { onComplete: f } = this.options;
      l.set(Tl(e, this.options, n)), f && f(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: d,
      duration: r,
      times: i,
      type: a,
      ease: o,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: n } = e;
    return Kn(n);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: n } = e;
    return Kn(n.currentTime || 0);
  }
  set time(e) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: s } = n;
    s.currentTime = wn(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: n } = e;
    return n.playbackRate;
  }
  set speed(e) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: s } = n;
    s.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: n } = e;
    return n.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: n } = e;
    return n.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: n } = this;
      if (!n)
        return yt;
      const { animation: s } = n;
      ep(s, e);
    }
    return yt;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n } = e;
    n.playState === "finished" && this.updateFinishedPromise(), n.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n } = e;
    n.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n, keyframes: s, duration: r, type: i, ease: o, times: a } = e;
    if (n.playState === "idle" || n.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: c, onUpdate: u, onComplete: d, element: f, ...h } = this.options, p = new Rd({
        ...h,
        keyframes: s,
        duration: r,
        type: i,
        ease: o,
        times: a,
        isGenerator: !0
      }), g = wn(this.time);
      c.setWithVelocity(p.sample(g - Ha).value, p.sample(g).value, Ha);
    }
    const { onStop: l } = this.options;
    l && l(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: n, name: s, repeatDelay: r, repeatType: i, damping: o, type: a } = e;
    return OP() && s && k0.has(s) && n && n.owner && n.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !n.owner.getProps().onUpdate && !r && i !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const IP = kd(() => window.ScrollTimeline !== void 0);
class FP {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  then(e, n) {
    return Promise.all(this.animations).then(e).catch(n);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, n) {
    for (let s = 0; s < this.animations.length; s++)
      this.animations[s][e] = n;
  }
  attachTimeline(e, n) {
    const s = this.animations.map((r) => IP() && r.attachTimeline ? r.attachTimeline(e) : n(r));
    return () => {
      s.forEach((r, i) => {
        r && r(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let n = 0; n < this.animations.length; n++)
      e = Math.max(e, this.animations[n].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((n) => n[e]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function VP({ when: t, delay: e, delayChildren: n, staggerChildren: s, staggerDirection: r, repeat: i, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...u }) {
  return !!Object.keys(u).length;
}
const Md = (t, e, n, s = {}, r, i) => (o) => {
  const a = bd(s, t) || {}, l = a.delay || s.delay || 0;
  let { elapsed: c = 0 } = s;
  c = c - wn(l);
  let u = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -c,
    onUpdate: (f) => {
      e.set(f), a.onUpdate && a.onUpdate(f);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: i ? void 0 : r
  };
  VP(a) || (u = {
    ...u,
    ...i2(t, u)
  }), u.duration && (u.duration = wn(u.duration)), u.repeatDelay && (u.repeatDelay = wn(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from);
  let d = !1;
  if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0, u.delay === 0 && (d = !0)), d && !i && e.get() !== void 0) {
    const f = Tl(u.keyframes, a);
    if (f !== void 0)
      return Oe.update(() => {
        u.onUpdate(f), u.onComplete();
      }), new FP([]);
  }
  return !i && tp.supports(u) ? new tp(u) : new Rd(u);
}, zP = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), UP = (t) => au(t) ? t[t.length - 1] || 0 : t;
function Po(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function Dd(t, e) {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}
class Od {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return Po(this.subscriptions, e), () => Dd(this.subscriptions, e);
  }
  notify(e, n, s) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1)
        this.subscriptions[0](e, n, s);
      else
        for (let i = 0; i < r; i++) {
          const o = this.subscriptions[i];
          o && o(e, n, s);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const np = 30, WP = (t) => !isNaN(parseFloat(t));
class N0 {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, n = {}) {
    this.version = "11.9.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (s, r = !0) => {
      const i = Cn.now();
      this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), r && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Cn.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = WP(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return pd(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, n) {
    this.events[e] || (this.events[e] = new Od());
    const s = this.events[e].add(n);
    return e === "change" ? () => {
      s(), Oe.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : s;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, n) {
    this.passiveEffect = e, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, n, s) {
    this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - s;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, n = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Cn.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > np)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, np);
    return C0(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Ki(t, e) {
  return new N0(t, e);
}
function HP(t, e, n) {
  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Ki(n));
}
function QP(t, e) {
  const n = El(t, e);
  let { transitionEnd: s = {}, transition: r = {}, ...i } = n || {};
  i = { ...i, ...s };
  for (const o in i) {
    const a = UP(i[o]);
    HP(t, o, a);
  }
}
const Rl = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), YP = "framerAppearId", j0 = "data-" + Rl(YP);
function B0(t) {
  return t.props[j0];
}
function I0(t) {
  if (Ms.has(t))
    return "transform";
  if (k0.has(t))
    return Rl(t);
}
class KP extends N0 {
  constructor() {
    super(...arguments), this.values = [];
  }
  add(e) {
    const n = I0(e);
    n && (Po(this.values, n), this.update());
  }
  update() {
    this.set(this.values.length ? this.values.join(", ") : "auto");
  }
}
const St = (t) => !!(t && t.getVelocity);
function XP(t) {
  return !!(St(t) && t.add);
}
function gu(t, e) {
  var n;
  if (!t.applyWillChange)
    return;
  let s = t.getValue("willChange");
  if (!s && !(!((n = t.props.style) === null || n === void 0) && n.willChange) && (s = new KP("auto"), t.addValue("willChange", s)), XP(s))
    return s.add(e);
}
function GP({ protectedKeys: t, needsAnimating: e }, n) {
  const s = t.hasOwnProperty(n) && e[n] !== !0;
  return e[n] = !1, s;
}
function F0(t, e, { delay: n = 0, transitionOverride: s, type: r } = {}) {
  var i;
  let { transition: o = t.getDefaultTransition(), transitionEnd: a, ...l } = e;
  s && (o = s);
  const c = [], u = r && t.animationState && t.animationState.getState()[r];
  for (const d in l) {
    const f = t.getValue(d, (i = t.latestValues[d]) !== null && i !== void 0 ? i : null), h = l[d];
    if (h === void 0 || u && GP(u, d))
      continue;
    const p = {
      delay: n,
      ...bd(o || {}, d)
    };
    let g = !1;
    if (window.MotionHandoffAnimation) {
      const b = B0(t);
      if (b) {
        const y = window.MotionHandoffAnimation(b, d, Oe);
        y !== null && (p.startTime = y, g = !0);
      }
    }
    gu(t, d), f.start(Md(d, f, h, t.shouldReduceMotion && Ms.has(d) ? { type: !1 } : p, t, g));
    const A = f.animation;
    A && c.push(A);
  }
  return a && Promise.all(c).then(() => {
    Oe.update(() => {
      a && QP(t, a);
    });
  }), c;
}
function mu(t, e, n = {}) {
  var s;
  const r = El(t, e, n.type === "exit" ? (s = t.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0);
  let { transition: i = t.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (i = n.transitionOverride);
  const o = r ? () => Promise.all(F0(t, r, n)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (c = 0) => {
    const { delayChildren: u = 0, staggerChildren: d, staggerDirection: f } = i;
    return ZP(t, e, u + c, d, f, n);
  } : () => Promise.resolve(), { when: l } = i;
  if (l) {
    const [c, u] = l === "beforeChildren" ? [o, a] : [a, o];
    return c().then(() => u());
  } else
    return Promise.all([o(), a(n.delay)]);
}
function ZP(t, e, n = 0, s = 0, r = 1, i) {
  const o = [], a = (t.variantChildren.size - 1) * s, l = r === 1 ? (c = 0) => c * s : (c = 0) => a - c * s;
  return Array.from(t.variantChildren).sort(_P).forEach((c, u) => {
    c.notify("AnimationStart", e), o.push(mu(c, e, {
      ...i,
      delay: n + l(u)
    }).then(() => c.notify("AnimationComplete", e)));
  }), Promise.all(o);
}
function _P(t, e) {
  return t.sortNodePosition(e);
}
function JP(t, e, n = {}) {
  t.notify("AnimationStart", e);
  let s;
  if (Array.isArray(e)) {
    const r = e.map((i) => mu(t, i, n));
    s = Promise.all(r);
  } else if (typeof e == "string")
    s = mu(t, e, n);
  else {
    const r = typeof e == "function" ? El(t, e, n.custom) : e;
    s = Promise.all(F0(t, r, n));
  }
  return s.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const $P = Ad.length;
function V0(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const n = t.parent ? V0(t.parent) || {} : {};
    return t.props.initial !== void 0 && (n.initial = t.props.initial), n;
  }
  const e = {};
  for (let n = 0; n < $P; n++) {
    const s = Ad[n], r = t.props[s];
    (Hi(r) || r === !1) && (e[s] = r);
  }
  return e;
}
const eq = [...md].reverse(), tq = md.length;
function nq(t) {
  return (e) => Promise.all(e.map(({ animation: n, options: s }) => JP(t, n, s)));
}
function sq(t) {
  let e = nq(t), n = sp(), s = !0;
  const r = (l) => (c, u) => {
    var d;
    const f = El(t, u, l === "exit" ? (d = t.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0);
    if (f) {
      const { transition: h, transitionEnd: p, ...g } = f;
      c = { ...c, ...g, ...p };
    }
    return c;
  };
  function i(l) {
    e = l(t);
  }
  function o(l) {
    const { props: c } = t, u = V0(t.parent) || {}, d = [], f = /* @__PURE__ */ new Set();
    let h = {}, p = 1 / 0;
    for (let A = 0; A < tq; A++) {
      const b = eq[A], y = n[b], w = c[b] !== void 0 ? c[b] : u[b], x = Hi(w), S = b === l ? y.isActive : null;
      S === !1 && (p = A);
      let q = w === u[b] && w !== c[b] && x;
      if (q && s && t.manuallyAnimateOnMount && (q = !1), y.protectedKeys = { ...h }, // If it isn't active and hasn't *just* been set as inactive
      !y.isActive && S === null || // If we didn't and don't have any defined prop for this animation type
      !w && !y.prevProp || // Or if the prop doesn't define an animation
      Wi(w) || typeof w == "boolean")
        continue;
      const C = rq(y.prevProp, w);
      let E = C || // If we're making this variant active, we want to always make it active
      b === l && y.isActive && !q && x || // If we removed a higher-priority variant (i is in reverse order)
      A > p && x, T = !1;
      const k = Array.isArray(w) ? w : [w];
      let R = k.reduce(r(b), {});
      S === !1 && (R = {});
      const { prevResolvedValues: D = {} } = y, F = {
        ...D,
        ...R
      }, j = (O) => {
        E = !0, f.has(O) && (T = !0, f.delete(O)), y.needsAnimating[O] = !0;
        const N = t.getValue(O);
        N && (N.liveStyle = !1);
      };
      for (const O in F) {
        const N = R[O], H = D[O];
        if (h.hasOwnProperty(O))
          continue;
        let U = !1;
        au(N) && au(H) ? U = !_A(N, H) : U = N !== H, U ? N != null ? j(O) : f.add(O) : N !== void 0 && f.has(O) ? j(O) : y.protectedKeys[O] = !0;
      }
      y.prevProp = w, y.prevResolvedValues = R, y.isActive && (h = { ...h, ...R }), s && t.blockInitialAnimation && (E = !1), E && (!(q && C) || T) && d.push(...k.map((O) => ({
        animation: O,
        options: { type: b }
      })));
    }
    if (f.size) {
      const A = {};
      f.forEach((b) => {
        const y = t.getBaseTarget(b), w = t.getValue(b);
        w && (w.liveStyle = !0), A[b] = y ?? null;
      }), d.push({ animation: A });
    }
    let g = !!d.length;
    return s && (c.initial === !1 || c.initial === c.animate) && !t.manuallyAnimateOnMount && (g = !1), s = !1, g ? e(d) : Promise.resolve();
  }
  function a(l, c) {
    var u;
    if (n[l].isActive === c)
      return Promise.resolve();
    (u = t.variantChildren) === null || u === void 0 || u.forEach((f) => {
      var h;
      return (h = f.animationState) === null || h === void 0 ? void 0 : h.setActive(l, c);
    }), n[l].isActive = c;
    const d = o(l);
    for (const f in n)
      n[f].protectedKeys = {};
    return d;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: i,
    getState: () => n,
    reset: () => {
      n = sp(), s = !0;
    }
  };
}
function rq(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !_A(e, t) : !1;
}
function js(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function sp() {
  return {
    animate: js(!0),
    whileInView: js(),
    whileHover: js(),
    whileTap: js(),
    whileDrag: js(),
    whileFocus: js(),
    exit: js()
  };
}
class Ds {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class iq extends Ds {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = sq(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    Wi(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    e !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let oq = 0;
class aq extends Ds {
  constructor() {
    super(...arguments), this.id = oq++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === s)
      return;
    const r = this.node.animationState.setActive("exit", !e);
    n && !e && r.then(() => n(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const lq = {
  animation: {
    Feature: iq
  },
  exit: {
    Feature: aq
  }
}, z0 = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function kl(t, e = "page") {
  return {
    point: {
      x: t[`${e}X`],
      y: t[`${e}Y`]
    }
  };
}
const cq = (t) => (e) => z0(e) && t(e, kl(e));
function Wn(t, e, n, s = { passive: !0 }) {
  return t.addEventListener(e, n, s), () => t.removeEventListener(e, n);
}
function Gn(t, e, n, s) {
  return Wn(t, e, cq(n), s);
}
const rp = (t, e) => Math.abs(t - e);
function uq(t, e) {
  const n = rp(t.x, e.x), s = rp(t.y, e.y);
  return Math.sqrt(n ** 2 + s ** 2);
}
class U0 {
  constructor(e, n, { transformPagePoint: s, contextWindow: r, dragSnapToOrigin: i = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const d = yc(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, h = uq(d.offset, { x: 0, y: 0 }) >= 3;
      if (!f && !h)
        return;
      const { point: p } = d, { timestamp: g } = At;
      this.history.push({ ...p, timestamp: g });
      const { onStart: A, onMove: b } = this.handlers;
      f || (A && A(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), b && b(this.lastMoveEvent, d);
    }, this.handlePointerMove = (d, f) => {
      this.lastMoveEvent = d, this.lastMoveEventInfo = bc(f, this.transformPagePoint), Oe.update(this.updatePoint, !0);
    }, this.handlePointerUp = (d, f) => {
      this.end();
      const { onEnd: h, onSessionEnd: p, resumeAnimation: g } = this.handlers;
      if (this.dragSnapToOrigin && g && g(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const A = yc(d.type === "pointercancel" ? this.lastMoveEventInfo : bc(f, this.transformPagePoint), this.history);
      this.startEvent && h && h(d, A), p && p(d, A);
    }, !z0(e))
      return;
    this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = s, this.contextWindow = r || window;
    const o = kl(e), a = bc(o, this.transformPagePoint), { point: l } = a, { timestamp: c } = At;
    this.history = [{ ...l, timestamp: c }];
    const { onSessionStart: u } = n;
    u && u(e, yc(a, this.history)), this.removeListeners = Xn(Gn(this.contextWindow, "pointermove", this.handlePointerMove), Gn(this.contextWindow, "pointerup", this.handlePointerUp), Gn(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), As(this.updatePoint);
  }
}
function bc(t, e) {
  return e ? { point: e(t.point) } : t;
}
function ip(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function yc({ point: t }, e) {
  return {
    point: t,
    delta: ip(t, W0(e)),
    offset: ip(t, dq(e)),
    velocity: fq(e, 0.1)
  };
}
function dq(t) {
  return t[0];
}
function W0(t) {
  return t[t.length - 1];
}
function fq(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let n = t.length - 1, s = null;
  const r = W0(t);
  for (; n >= 0 && (s = t[n], !(r.timestamp - s.timestamp > wn(e))); )
    n--;
  if (!s)
    return { x: 0, y: 0 };
  const i = Kn(r.timestamp - s.timestamp);
  if (i === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (r.x - s.x) / i,
    y: (r.y - s.y) / i
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function H0(t) {
  let e = null;
  return () => {
    const n = () => {
      e = null;
    };
    return e === null ? (e = t, n) : !1;
  };
}
const op = H0("dragHorizontal"), ap = H0("dragVertical");
function Q0(t) {
  let e = !1;
  if (t === "y")
    e = ap();
  else if (t === "x")
    e = op();
  else {
    const n = op(), s = ap();
    n && s ? e = () => {
      n(), s();
    } : (n && n(), s && s());
  }
  return e;
}
function Y0() {
  const t = Q0(!0);
  return t ? (t(), !1) : !0;
}
function wr(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
const K0 = 1e-4, hq = 1 - K0, pq = 1 + K0, X0 = 0.01, gq = 0 - X0, mq = 0 + X0;
function _t(t) {
  return t.max - t.min;
}
function Aq(t, e, n) {
  return Math.abs(t - e) <= n;
}
function lp(t, e, n, s = 0.5) {
  t.origin = s, t.originPoint = Ke(e.min, e.max, t.origin), t.scale = _t(n) / _t(e), t.translate = Ke(n.min, n.max, t.origin) - t.originPoint, (t.scale >= hq && t.scale <= pq || isNaN(t.scale)) && (t.scale = 1), (t.translate >= gq && t.translate <= mq || isNaN(t.translate)) && (t.translate = 0);
}
function Oi(t, e, n, s) {
  lp(t.x, e.x, n.x, s ? s.originX : void 0), lp(t.y, e.y, n.y, s ? s.originY : void 0);
}
function cp(t, e, n) {
  t.min = n.min + e.min, t.max = t.min + _t(e);
}
function bq(t, e, n) {
  cp(t.x, e.x, n.x), cp(t.y, e.y, n.y);
}
function up(t, e, n) {
  t.min = e.min - n.min, t.max = t.min + _t(e);
}
function Li(t, e, n) {
  up(t.x, e.x, n.x), up(t.y, e.y, n.y);
}
function yq(t, { min: e, max: n }, s) {
  return e !== void 0 && t < e ? t = s ? Ke(e, t, s.min) : Math.max(t, e) : n !== void 0 && t > n && (t = s ? Ke(n, t, s.max) : Math.min(t, n)), t;
}
function dp(t, e, n) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
  };
}
function vq(t, { top: e, left: n, bottom: s, right: r }) {
  return {
    x: dp(t.x, n, r),
    y: dp(t.y, e, s)
  };
}
function fp(t, e) {
  let n = e.min - t.min, s = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([n, s] = [s, n]), { min: n, max: s };
}
function xq(t, e) {
  return {
    x: fp(t.x, e.x),
    y: fp(t.y, e.y)
  };
}
function wq(t, e) {
  let n = 0.5;
  const s = _t(t), r = _t(e);
  return r > s ? n = jr(e.min, e.max - s, t.min) : s > r && (n = jr(t.min, t.max - r, e.min)), bs(0, 1, n);
}
function Sq(t, e) {
  const n = {};
  return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
}
const Au = 0.35;
function Cq(t = Au) {
  return t === !1 ? t = 0 : t === !0 && (t = Au), {
    x: hp(t, "left", "right"),
    y: hp(t, "top", "bottom")
  };
}
function hp(t, e, n) {
  return {
    min: pp(t, e),
    max: pp(t, n)
  };
}
function pp(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const gp = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Sr = () => ({
  x: gp(),
  y: gp()
}), mp = () => ({ min: 0, max: 0 }), $e = () => ({
  x: mp(),
  y: mp()
});
function on(t) {
  return [t("x"), t("y")];
}
function G0({ top: t, left: e, right: n, bottom: s }) {
  return {
    x: { min: e, max: n },
    y: { min: t, max: s }
  };
}
function Pq({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function qq(t, e) {
  if (!e)
    return t;
  const n = e({ x: t.left, y: t.top }), s = e({ x: t.right, y: t.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: s.y,
    right: s.x
  };
}
function vc(t) {
  return t === void 0 || t === 1;
}
function bu({ scale: t, scaleX: e, scaleY: n }) {
  return !vc(t) || !vc(e) || !vc(n);
}
function Us(t) {
  return bu(t) || Z0(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function Z0(t) {
  return Ap(t.x) || Ap(t.y);
}
function Ap(t) {
  return t && t !== "0%";
}
function Qa(t, e, n) {
  const s = t - n, r = e * s;
  return n + r;
}
function bp(t, e, n, s, r) {
  return r !== void 0 && (t = Qa(t, r, s)), Qa(t, n, s) + e;
}
function yu(t, e = 0, n = 1, s, r) {
  t.min = bp(t.min, e, n, s, r), t.max = bp(t.max, e, n, s, r);
}
function _0(t, { x: e, y: n }) {
  yu(t.x, e.translate, e.scale, e.originPoint), yu(t.y, n.translate, n.scale, n.originPoint);
}
const yp = 0.999999999999, vp = 1.0000000000001;
function Eq(t, e, n, s = !1) {
  const r = n.length;
  if (!r)
    return;
  e.x = e.y = 1;
  let i, o;
  for (let a = 0; a < r; a++) {
    i = n[a], o = i.projectionDelta;
    const { visualElement: l } = i.options;
    l && l.props.style && l.props.style.display === "contents" || (s && i.options.layoutScroll && i.scroll && i !== i.root && Pr(t, {
      x: -i.scroll.offset.x,
      y: -i.scroll.offset.y
    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, _0(t, o)), s && Us(i.latestValues) && Pr(t, i.latestValues));
  }
  e.x < vp && e.x > yp && (e.x = 1), e.y < vp && e.y > yp && (e.y = 1);
}
function Cr(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function xp(t, e, n, s, r = 0.5) {
  const i = Ke(t.min, t.max, r);
  yu(t, e, n, i, s);
}
function Pr(t, e) {
  xp(t.x, e.x, e.scaleX, e.scale, e.originX), xp(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function J0(t, e) {
  return G0(qq(t.getBoundingClientRect(), e));
}
function Tq(t, e, n) {
  const s = J0(t, n), { scroll: r } = e;
  return r && (Cr(s.x, r.offset.x), Cr(s.y, r.offset.y)), s;
}
const $0 = ({ current: t }) => t ? t.ownerDocument.defaultView : null, Rq = /* @__PURE__ */ new WeakMap();
class kq {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = $e(), this.visualElement = e;
  }
  start(e, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: s } = this.visualElement;
    if (s && s.isPresent === !1)
      return;
    const r = (u) => {
      const { dragSnapToOrigin: d } = this.getProps();
      d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(kl(u, "page").point);
    }, i = (u, d) => {
      const { drag: f, dragPropagation: h, onDragStart: p } = this.getProps();
      if (f && !h && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Q0(f), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), on((A) => {
        let b = this.getAxisMotionValue(A).get() || 0;
        if (Sn.test(b)) {
          const { projection: y } = this.visualElement;
          if (y && y.layout) {
            const w = y.layout.layoutBox[A];
            w && (b = _t(w) * (parseFloat(b) / 100));
          }
        }
        this.originPoint[A] = b;
      }), p && Oe.postRender(() => p(u, d)), gu(this.visualElement, "transform");
      const { animationState: g } = this.visualElement;
      g && g.setActive("whileDrag", !0);
    }, o = (u, d) => {
      const { dragPropagation: f, dragDirectionLock: h, onDirectionLock: p, onDrag: g } = this.getProps();
      if (!f && !this.openGlobalLock)
        return;
      const { offset: A } = d;
      if (h && this.currentDirection === null) {
        this.currentDirection = Mq(A), this.currentDirection !== null && p && p(this.currentDirection);
        return;
      }
      this.updateAxis("x", d.point, A), this.updateAxis("y", d.point, A), this.visualElement.render(), g && g(u, d);
    }, a = (u, d) => this.stop(u, d), l = () => on((u) => {
      var d;
      return this.getAnimationState(u) === "paused" && ((d = this.getAxisMotionValue(u).animation) === null || d === void 0 ? void 0 : d.play());
    }), { dragSnapToOrigin: c } = this.getProps();
    this.panSession = new U0(e, {
      onSessionStart: r,
      onStart: i,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: l
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: c,
      contextWindow: $0(this.visualElement)
    });
  }
  stop(e, n) {
    const s = this.isDragging;
    if (this.cancel(), !s)
      return;
    const { velocity: r } = n;
    this.startAnimation(r);
    const { onDragEnd: i } = this.getProps();
    i && Oe.postRender(() => i(e, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: n } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: s } = this.getProps();
    !s && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(e, n, s) {
    const { drag: r } = this.getProps();
    if (!s || !Io(e, r, this.currentDirection))
      return;
    const i = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + s[e];
    this.constraints && this.constraints[e] && (o = yq(o, this.constraints[e], this.elastic[e])), i.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: n, dragElastic: s } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, i = this.constraints;
    n && wr(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && r ? this.constraints = vq(r.layoutBox, n) : this.constraints = !1, this.elastic = Cq(s), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && on((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = Sq(r.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps();
    if (!e || !wr(e))
      return !1;
    const s = e.current;
    Zn(s !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: r } = this.visualElement;
    if (!r || !r.layout)
      return !1;
    const i = Tq(s, r.root, this.visualElement.getTransformPagePoint());
    let o = xq(r.layout.layoutBox, i);
    if (n) {
      const a = n(Pq(o));
      this.hasMutatedConstraints = !!a, a && (o = G0(a));
    }
    return o;
  }
  startAnimation(e) {
    const { drag: n, dragMomentum: s, dragElastic: r, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = on((u) => {
      if (!Io(u, n, this.currentDirection))
        return;
      let d = l && l[u] || {};
      o && (d = { min: 0, max: 0 });
      const f = r ? 200 : 1e6, h = r ? 40 : 1e7, p = {
        type: "inertia",
        velocity: s ? e[u] : 0,
        bounceStiffness: f,
        bounceDamping: h,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...i,
        ...d
      };
      return this.startAxisValueAnimation(u, p);
    });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(e, n) {
    const s = this.getAxisMotionValue(e);
    return gu(this.visualElement, e), s.start(Md(e, s, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    on((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    on((e) => {
      var n;
      return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(e) {
    var n;
    return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const n = `_drag${e.toUpperCase()}`, s = this.visualElement.getProps(), r = s[n];
    return r || this.visualElement.getValue(e, (s.initial ? s.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    on((n) => {
      const { drag: s } = this.getProps();
      if (!Io(n, s, this.currentDirection))
        return;
      const { projection: r } = this.visualElement, i = this.getAxisMotionValue(n);
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[n];
        i.set(e[n] - Ke(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: n } = this.getProps(), { projection: s } = this.visualElement;
    if (!wr(n) || !s || !this.constraints)
      return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    on((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const l = a.get();
        r[o] = wq({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: i } = this.visualElement.getProps();
    this.visualElement.current.style.transform = i ? i({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), on((o) => {
      if (!Io(o, e, null))
        return;
      const a = this.getAxisMotionValue(o), { min: l, max: c } = this.constraints[o];
      a.set(Ke(l, c, r[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    Rq.set(this.visualElement, this);
    const e = this.visualElement.current, n = Gn(e, "pointerdown", (l) => {
      const { drag: c, dragListener: u = !0 } = this.getProps();
      c && u && this.start(l);
    }), s = () => {
      const { dragConstraints: l } = this.getProps();
      wr(l) && l.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: r } = this.visualElement, i = r.addEventListener("measure", s);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), Oe.read(s);
    const o = Wn(window, "resize", () => this.scalePositionWithinConstraints()), a = r.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => {
      this.isDragging && c && (on((u) => {
        const d = this.getAxisMotionValue(u);
        d && (this.originPoint[u] += l[u].translate, d.set(d.get() + l[u].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), n(), i(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: s = !1, dragPropagation: r = !1, dragConstraints: i = !1, dragElastic: o = Au, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: n,
      dragDirectionLock: s,
      dragPropagation: r,
      dragConstraints: i,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function Io(t, e, n) {
  return (e === !0 || e === t) && (n === null || n === t);
}
function Mq(t, e = 10) {
  let n = null;
  return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
}
class Dq extends Ds {
  constructor(e) {
    super(e), this.removeGroupControls = yt, this.removeListeners = yt, this.controls = new kq(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || yt;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const wp = (t) => (e, n) => {
  t && Oe.postRender(() => t(e, n));
};
class Oq extends Ds {
  constructor() {
    super(...arguments), this.removePointerDownListener = yt;
  }
  onPointerDown(e) {
    this.session = new U0(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: $0(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: n, onPan: s, onPanEnd: r } = this.node.getProps();
    return {
      onSessionStart: wp(e),
      onStart: wp(n),
      onMove: s,
      onEnd: (i, o) => {
        delete this.session, r && Oe.postRender(() => r(i, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Gn(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Ml = ks(null);
function Lq() {
  const t = ht(Ml);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: n, register: s } = t, r = id();
  je(() => s(r), []);
  const i = Fe(() => n && n(r), [r, n]);
  return !e && n ? [!1, i] : [!0];
}
const Ld = ks({}), eb = ks({}), Aa = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function Sp(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const hi = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (te.test(t))
        t = parseFloat(t);
      else
        return t;
    const n = Sp(t, e.target.x), s = Sp(t, e.target.y);
    return `${n}% ${s}%`;
  }
}, Nq = {
  correct: (t, { treeScale: e, projectionDelta: n }) => {
    const s = t, r = ys.parse(t);
    if (r.length > 5)
      return s;
    const i = ys.createTransformer(t), o = typeof r[0] != "number" ? 1 : 0, a = n.x.scale * e.x, l = n.y.scale * e.y;
    r[0 + o] /= a, r[1 + o] /= l;
    const c = Ke(a, l, 0.5);
    return typeof r[2 + o] == "number" && (r[2 + o] /= c), typeof r[3 + o] == "number" && (r[3 + o] /= c), i(r);
  }
}, Ya = {};
function jq(t) {
  Object.assign(Ya, t);
}
const { schedule: Nd, cancel: G9 } = JA(queueMicrotask, !1);
class Bq extends Iw {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: s, layoutId: r } = this.props, { projection: i } = e;
    jq(Iq), i && (n.group && n.group.add(i), s && s.register && r && s.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), i.setOptions({
      ...i.options,
      onExitComplete: () => this.safeToRemove()
    })), Aa.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: n, visualElement: s, drag: r, isPresent: i } = this.props, o = s.projection;
    return o && (o.isPresent = i, r || e.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? o.promote() : o.relegate() || Oe.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), Nd.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: s } = this.props, { projection: r } = e;
    r && (r.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(r), s && s.deregister && s.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function tb(t) {
  const [e, n] = Lq(), s = ht(Ld);
  return m.jsx(Bq, { ...t, layoutGroup: s, switchLayoutGroup: ht(eb), isPresent: e, safeToRemove: n });
}
const Iq = {
  borderRadius: {
    ...hi,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: hi,
  borderTopRightRadius: hi,
  borderBottomLeftRadius: hi,
  borderBottomRightRadius: hi,
  boxShadow: Nq
}, nb = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Fq = nb.length, Cp = (t) => typeof t == "string" ? parseFloat(t) : t, Pp = (t) => typeof t == "number" || te.test(t);
function Vq(t, e, n, s, r, i) {
  r ? (t.opacity = Ke(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    zq(s)
  ), t.opacityExit = Ke(e.opacity !== void 0 ? e.opacity : 1, 0, Uq(s))) : i && (t.opacity = Ke(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, s));
  for (let o = 0; o < Fq; o++) {
    const a = `border${nb[o]}Radius`;
    let l = qp(e, a), c = qp(n, a);
    if (l === void 0 && c === void 0)
      continue;
    l || (l = 0), c || (c = 0), l === 0 || c === 0 || Pp(l) === Pp(c) ? (t[a] = Math.max(Ke(Cp(l), Cp(c), s), 0), (Sn.test(c) || Sn.test(l)) && (t[a] += "%")) : t[a] = c;
  }
  (e.rotate || n.rotate) && (t.rotate = Ke(e.rotate || 0, n.rotate || 0, s));
}
function qp(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const zq = /* @__PURE__ */ sb(0, 0.5, i0), Uq = /* @__PURE__ */ sb(0.5, 0.95, yt);
function sb(t, e, n) {
  return (s) => s < t ? 0 : s > e ? 1 : n(jr(t, e, s));
}
function Ep(t, e) {
  t.min = e.min, t.max = e.max;
}
function sn(t, e) {
  Ep(t.x, e.x), Ep(t.y, e.y);
}
function Tp(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function Rp(t, e, n, s, r) {
  return t -= e, t = Qa(t, 1 / n, s), r !== void 0 && (t = Qa(t, 1 / r, s)), t;
}
function Wq(t, e = 0, n = 1, s = 0.5, r, i = t, o = t) {
  if (Sn.test(e) && (e = parseFloat(e), e = Ke(o.min, o.max, e / 100) - o.min), typeof e != "number")
    return;
  let a = Ke(i.min, i.max, s);
  t === i && (a -= e), t.min = Rp(t.min, e, n, a, r), t.max = Rp(t.max, e, n, a, r);
}
function kp(t, e, [n, s, r], i, o) {
  Wq(t, e[n], e[s], e[r], e.scale, i, o);
}
const Hq = ["x", "scaleX", "originX"], Qq = ["y", "scaleY", "originY"];
function Mp(t, e, n, s) {
  kp(t.x, e, Hq, n ? n.x : void 0, s ? s.x : void 0), kp(t.y, e, Qq, n ? n.y : void 0, s ? s.y : void 0);
}
function Dp(t) {
  return t.translate === 0 && t.scale === 1;
}
function rb(t) {
  return Dp(t.x) && Dp(t.y);
}
function Op(t, e) {
  return t.min === e.min && t.max === e.max;
}
function Yq(t, e) {
  return Op(t.x, e.x) && Op(t.y, e.y);
}
function Lp(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function ib(t, e) {
  return Lp(t.x, e.x) && Lp(t.y, e.y);
}
function Np(t) {
  return _t(t.x) / _t(t.y);
}
function jp(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class Kq {
  constructor() {
    this.members = [];
  }
  add(e) {
    Po(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (Dd(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(e) {
    const n = this.members.findIndex((r) => e === r);
    if (n === 0)
      return !1;
    let s;
    for (let r = n; r >= 0; r--) {
      const i = this.members[r];
      if (i.isPresent !== !1) {
        s = i;
        break;
      }
    }
    return s ? (this.promote(s), !0) : !1;
  }
  promote(e, n) {
    const s = this.lead;
    if (e !== s && (this.prevLead = s, this.lead = e, e.show(), s)) {
      s.instance && s.scheduleRender(), e.scheduleRender(), e.resumeFrom = s, n && (e.resumeFrom.preserveOpacity = !0), s.snapshot && (e.snapshot = s.snapshot, e.snapshot.latestValues = s.animationValues || s.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && s.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: n, resumingFrom: s } = e;
      n.onExitComplete && n.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function Xq(t, e, n) {
  let s = "";
  const r = t.x.translate / e.x, i = t.y.translate / e.y, o = (n == null ? void 0 : n.z) || 0;
  if ((r || i || o) && (s = `translate3d(${r}px, ${i}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (s += `scale(${1 / e.x}, ${1 / e.y}) `), n) {
    const { transformPerspective: c, rotate: u, rotateX: d, rotateY: f, skewX: h, skewY: p } = n;
    c && (s = `perspective(${c}px) ${s}`), u && (s += `rotate(${u}deg) `), d && (s += `rotateX(${d}deg) `), f && (s += `rotateY(${f}deg) `), h && (s += `skewX(${h}deg) `), p && (s += `skewY(${p}deg) `);
  }
  const a = t.x.scale * e.x, l = t.y.scale * e.y;
  return (a !== 1 || l !== 1) && (s += `scale(${a}, ${l})`), s || "none";
}
const Gq = (t, e) => t.depth - e.depth;
class Zq {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    Po(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    Dd(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(Gq), this.isDirty = !1, this.children.forEach(e);
  }
}
function ba(t) {
  const e = St(t) ? t.get() : t;
  return zP(e) ? e.toValue() : e;
}
function _q(t, e) {
  const n = Cn.now(), s = ({ timestamp: r }) => {
    const i = r - n;
    i >= e && (As(s), t(i - e));
  };
  return Oe.read(s, !0), () => As(s);
}
function Jq(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function $q(t, e, n) {
  const s = St(t) ? t : Ki(t);
  return s.start(Md("", s, e, n)), s.animation;
}
const Ws = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, wi = typeof window < "u" && window.MotionDebug !== void 0, xc = ["", "X", "Y", "Z"], eE = { visibility: "hidden" }, Bp = 1e3;
let tE = 0;
function wc(t, e, n, s) {
  const { latestValues: r } = e;
  r[t] && (n[t] = r[t], e.setStaticValue(t, 0), s && (s[t] = 0));
}
function ob(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const n = B0(e);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: r, layoutId: i } = t.options;
    window.MotionCancelOptimisedAnimation(n, "transform", Oe, !(r || i));
  }
  const { parent: s } = t;
  s && !s.hasCheckedOptimisedAppear && ob(s);
}
function ab({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: s, resetTransform: r }) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      this.id = tE++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, wi && (Ws.totalNodes = Ws.resolvedTargetDeltas = Ws.recalculatedProjection = 0), this.nodes.forEach(rE), this.nodes.forEach(cE), this.nodes.forEach(uE), this.nodes.forEach(iE), wi && window.MotionDebug.record(Ws);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Zq());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Od()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = Jq(o), this.instance = o;
      const { layoutId: l, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), t) {
        let d;
        const f = () => this.root.updateBlockedByResize = !1;
        t(o, () => {
          this.root.updateBlockedByResize = !0, d && d(), d = _q(f, 250), Aa.hasAnimatedSinceResize && (Aa.hasAnimatedSinceResize = !1, this.nodes.forEach(Fp));
        });
      }
      l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: h, layout: p }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const g = this.options.transition || u.getDefaultTransition() || gE, { onLayoutAnimationStart: A, onLayoutAnimationComplete: b } = u.getProps(), y = !this.targetLayout || !ib(this.targetLayout, p) || h, w = !f && h;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || w || f && (y || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, w);
          const x = {
            ...bd(g, "layout"),
            onPlay: A,
            onComplete: b
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0, x.type = !1), this.startAnimation(x);
        } else
          f || Fp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = p;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, As(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(dE), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && ob(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const d = this.path[u];
        d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l)
        return;
      const c = this.getTransformTemplate();
      this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Ip);
        return;
      }
      this.isUpdating || this.nodes.forEach(aE), this.isUpdating = !1, this.nodes.forEach(lE), this.nodes.forEach(nE), this.nodes.forEach(sE), this.clearAllSnapshots();
      const a = Cn.now();
      At.delta = bs(0, 1e3 / 60, a - At.timestamp), At.timestamp = a, At.isProcessing = !0, hc.update.process(At), hc.preRender.process(At), hc.render.process(At), At.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Nd.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(oE), this.sharedNodes.forEach(fE);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Oe.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Oe.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++)
          this.path[l].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = $e(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const l = s(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l
        };
      }
    }
    resetTransform() {
      if (!r)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !rb(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue;
      o && (a || Us(this.latestValues) || u) && (r(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return o && (l = this.removeTransform(l)), mE(l), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: l,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return $e();
      const l = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(AE))) {
        const { scroll: u } = this.root;
        u && (Cr(l.x, u.offset.x), Cr(l.y, u.offset.y));
      }
      return l;
    }
    removeElementScroll(o) {
      var a;
      const l = $e();
      if (sn(l, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return l;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c], { scroll: d, options: f } = u;
        u !== this.root && d && f.layoutScroll && (d.wasRoot && sn(l, o), Cr(l.x, d.offset.x), Cr(l.y, d.offset.y));
      }
      return l;
    }
    applyTransform(o, a = !1) {
      const l = $e();
      sn(l, o);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && Pr(l, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), Us(u.latestValues) && Pr(l, u.latestValues);
      }
      return Us(this.latestValues) && Pr(l, this.latestValues), l;
    }
    removeTransform(o) {
      const a = $e();
      sn(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !Us(c.latestValues))
          continue;
        bu(c.latestValues) && c.updateSnapshot();
        const u = $e(), d = c.measurePageBox();
        sn(u, d), Mp(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u);
      }
      return Us(this.latestValues) && Mp(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== At.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: d, layoutId: f } = this.options;
      if (!(!this.layout || !(d || f))) {
        if (this.resolvedRelativeTargetAt = At.timestamp, !this.targetDelta && !this.relativeTarget) {
          const h = this.getClosestProjectingParent();
          h && h.layout && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = $e(), this.relativeTargetOrigin = $e(), Li(this.relativeTargetOrigin, this.layout.layoutBox, h.layout.layoutBox), sn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = $e(), this.targetWithTransforms = $e()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), bq(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : sn(this.target, this.layout.layoutBox), _0(this.target, this.targetDelta)) : sn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const h = this.getClosestProjectingParent();
            h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = $e(), this.relativeTargetOrigin = $e(), Li(this.relativeTargetOrigin, this.target, h.target), sn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          wi && Ws.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || bu(this.parent.latestValues) || Z0(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), l = !!this.resumingFrom || this !== a;
      let c = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === At.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: d } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d))
        return;
      sn(this.layoutCorrected, this.layout.layoutBox);
      const f = this.treeScale.x, h = this.treeScale.y;
      Eq(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = $e());
      const { target: p } = a;
      if (!p) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Tp(this.prevProjectionDelta.x, this.projectionDelta.x), Tp(this.prevProjectionDelta.y, this.projectionDelta.y)), Oi(this.projectionDelta, this.layoutCorrected, p, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== h || !jp(this.projectionDelta.x, this.prevProjectionDelta.x) || !jp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)), wi && Ws.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Sr(), this.projectionDelta = Sr(), this.projectionDeltaWithTransform = Sr();
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, d = Sr();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const f = $e(), h = l ? l.source : void 0, p = this.layout ? this.layout.source : void 0, g = h !== p, A = this.getStack(), b = !A || A.members.length <= 1, y = !!(g && !b && this.options.crossfade === !0 && !this.path.some(pE));
      this.animationProgress = 0;
      let w;
      this.mixTargetDelta = (x) => {
        const S = x / 1e3;
        Vp(d.x, o.x, S), Vp(d.y, o.y, S), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Li(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), hE(this.relativeTarget, this.relativeTargetOrigin, f, S), w && Yq(this.relativeTarget, w) && (this.isProjectionDirty = !1), w || (w = $e()), sn(w, this.relativeTarget)), g && (this.animationValues = u, Vq(u, c, this.latestValues, S, y, b)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = S;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (As(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Oe.update(() => {
        Aa.hasAnimatedSinceResize = !0, this.currentAnimation = $q(0, Bp, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Bp), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = o;
      if (!(!a || !l || !c)) {
        if (this !== o && this.layout && c && lb(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
          l = this.target || $e();
          const d = _t(this.layout.layoutBox.x);
          l.x.min = o.target.x.min, l.x.max = l.x.min + d;
          const f = _t(this.layout.layoutBox.y);
          l.y.min = o.target.y.min, l.y.max = l.y.min + f;
        }
        sn(a, l), Pr(a, u), Oi(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new Kq()), this.sharedNodes.get(o).add(a);
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: l } = o;
      if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a)
        return;
      const c = {};
      l.z && wc("z", o, c, this.animationValues);
      for (let u = 0; u < xc.length; u++)
        wc(`rotate${xc[u]}`, o, c, this.animationValues), wc(`skew${xc[u]}`, o, c, this.animationValues);
      o.render();
      for (const u in c)
        o.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, l;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return eE;
      const c = {
        visibility: ""
      }, u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, c.opacity = "", c.pointerEvents = ba(o == null ? void 0 : o.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c;
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const g = {};
        return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, g.pointerEvents = ba(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !Us(this.latestValues) && (g.transform = u ? u({}, "") : "none", this.hasProjected = !1), g;
      }
      const f = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(), c.transform = Xq(this.projectionDeltaWithTransform, this.treeScale, f), u && (c.transform = u(f, c.transform));
      const { x: h, y: p } = this.projectionDelta;
      c.transformOrigin = `${h.origin * 100}% ${p.origin * 100}% 0`, d.animationValues ? c.opacity = d === this ? (l = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : c.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
      for (const g in Ya) {
        if (f[g] === void 0)
          continue;
        const { correct: A, applyTo: b } = Ya[g], y = c.transform === "none" ? f[g] : A(f[g], d);
        if (b) {
          const w = b.length;
          for (let x = 0; x < w; x++)
            c[b[x]] = y;
        } else
          c[g] = y;
      }
      return this.options.layoutId && (c.pointerEvents = d === this ? ba(o == null ? void 0 : o.pointerEvents) || "" : "none"), c;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(Ip), this.root.sharedNodes.clear();
    }
  };
}
function nE(t) {
  t.updateLayout();
}
function sE(t) {
  var e;
  const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
    const { layoutBox: s, measuredBox: r } = t.layout, { animationType: i } = t.options, o = n.source !== t.layout.source;
    i === "size" ? on((d) => {
      const f = o ? n.measuredBox[d] : n.layoutBox[d], h = _t(f);
      f.min = s[d].min, f.max = f.min + h;
    }) : lb(i, n.layoutBox, s) && on((d) => {
      const f = o ? n.measuredBox[d] : n.layoutBox[d], h = _t(s[d]);
      f.max = f.min + h, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[d].max = t.relativeTarget[d].min + h);
    });
    const a = Sr();
    Oi(a, s, n.layoutBox);
    const l = Sr();
    o ? Oi(l, t.applyTransform(r, !0), n.measuredBox) : Oi(l, s, n.layoutBox);
    const c = !rb(a);
    let u = !1;
    if (!t.resumeFrom) {
      const d = t.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: f, layout: h } = d;
        if (f && h) {
          const p = $e();
          Li(p, n.layoutBox, f.layoutBox);
          const g = $e();
          Li(g, s, h.layoutBox), ib(p, g) || (u = !0), d.options.layoutRoot && (t.relativeTarget = g, t.relativeTargetOrigin = p, t.relativeParent = d);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: s,
      snapshot: n,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeTargetChanged: u
    });
  } else if (t.isLead()) {
    const { onExitComplete: s } = t.options;
    s && s();
  }
  t.options.transition = void 0;
}
function rE(t) {
  wi && Ws.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function iE(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function oE(t) {
  t.clearSnapshot();
}
function Ip(t) {
  t.clearMeasurements();
}
function aE(t) {
  t.isLayoutDirty = !1;
}
function lE(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function Fp(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function cE(t) {
  t.resolveTargetDelta();
}
function uE(t) {
  t.calcProjection();
}
function dE(t) {
  t.resetSkewAndRotation();
}
function fE(t) {
  t.removeLeadSnapshot();
}
function Vp(t, e, n) {
  t.translate = Ke(e.translate, 0, n), t.scale = Ke(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
}
function zp(t, e, n, s) {
  t.min = Ke(e.min, n.min, s), t.max = Ke(e.max, n.max, s);
}
function hE(t, e, n, s) {
  zp(t.x, e.x, n.x, s), zp(t.y, e.y, n.y, s);
}
function pE(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const gE = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, Up = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), Wp = Up("applewebkit/") && !Up("chrome/") ? Math.round : yt;
function Hp(t) {
  t.min = Wp(t.min), t.max = Wp(t.max);
}
function mE(t) {
  Hp(t.x), Hp(t.y);
}
function lb(t, e, n) {
  return t === "position" || t === "preserve-aspect" && !Aq(Np(e), Np(n), 0.2);
}
function AE(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const bE = ab({
  attachResizeListener: (t, e) => Wn(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), Sc = {
  current: void 0
}, cb = ab({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!Sc.current) {
      const t = new bE({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), Sc.current = t;
    }
    return Sc.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), yE = {
  pan: {
    Feature: Oq
  },
  drag: {
    Feature: Dq,
    ProjectionNode: cb,
    MeasureLayout: tb
  }
};
function Qp(t, e) {
  const n = e ? "pointerenter" : "pointerleave", s = e ? "onHoverStart" : "onHoverEnd", r = (i, o) => {
    if (i.pointerType === "touch" || Y0())
      return;
    const a = t.getProps();
    t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
    const l = a[s];
    l && Oe.postRender(() => l(i, o));
  };
  return Gn(t.current, n, r, {
    passive: !t.getProps()[s]
  });
}
class vE extends Ds {
  mount() {
    this.unmount = Xn(Qp(this.node, !0), Qp(this.node, !1));
  }
  unmount() {
  }
}
class xE extends Ds {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Xn(Wn(this.node.current, "focus", () => this.onFocus()), Wn(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const ub = (t, e) => e ? t === e ? !0 : ub(t, e.parentElement) : !1;
function Cc(t, e) {
  if (!e)
    return;
  const n = new PointerEvent("pointer" + t);
  e(n, kl(n));
}
class wE extends Ds {
  constructor() {
    super(...arguments), this.removeStartListeners = yt, this.removeEndListeners = yt, this.removeAccessibleListeners = yt, this.startPointerPress = (e, n) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const s = this.node.getProps(), i = Gn(window, "pointerup", (a, l) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: c, onTapCancel: u, globalTapTarget: d } = this.node.getProps(), f = !d && !ub(this.node.current, a.target) ? u : c;
        f && Oe.update(() => f(a, l));
      }, {
        passive: !(s.onTap || s.onPointerUp)
      }), o = Gn(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
        passive: !(s.onTapCancel || s.onPointerCancel)
      });
      this.removeEndListeners = Xn(i, o), this.startPress(e, n);
    }, this.startAccessiblePress = () => {
      const e = (i) => {
        if (i.key !== "Enter" || this.isPressing)
          return;
        const o = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || Cc("up", (l, c) => {
            const { onTap: u } = this.node.getProps();
            u && Oe.postRender(() => u(l, c));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Wn(this.node.current, "keyup", o), Cc("down", (a, l) => {
          this.startPress(a, l);
        });
      }, n = Wn(this.node.current, "keydown", e), s = () => {
        this.isPressing && Cc("cancel", (i, o) => this.cancelPress(i, o));
      }, r = Wn(this.node.current, "blur", s);
      this.removeAccessibleListeners = Xn(n, r);
    };
  }
  startPress(e, n) {
    this.isPressing = !0;
    const { onTapStart: s, whileTap: r } = this.node.getProps();
    r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), s && Oe.postRender(() => s(e, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Y0();
  }
  cancelPress(e, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: s } = this.node.getProps();
    s && Oe.postRender(() => s(e, n));
  }
  mount() {
    const e = this.node.getProps(), n = Gn(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(e.onTapStart || e.onPointerStart)
    }), s = Wn(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Xn(n, s);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const vu = /* @__PURE__ */ new WeakMap(), Pc = /* @__PURE__ */ new WeakMap(), SE = (t) => {
  const e = vu.get(t.target);
  e && e(t);
}, CE = (t) => {
  t.forEach(SE);
};
function PE({ root: t, ...e }) {
  const n = t || document;
  Pc.has(n) || Pc.set(n, {});
  const s = Pc.get(n), r = JSON.stringify(e);
  return s[r] || (s[r] = new IntersectionObserver(CE, { root: t, ...e })), s[r];
}
function qE(t, e, n) {
  const s = PE(e);
  return vu.set(t, n), s.observe(t), () => {
    vu.delete(t), s.unobserve(t);
  };
}
const EE = {
  some: 0,
  all: 1
};
class TE extends Ds {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: n, margin: s, amount: r = "some", once: i } = e, o = {
      root: n ? n.current : void 0,
      rootMargin: s,
      threshold: typeof r == "number" ? r : EE[r]
    }, a = (l) => {
      const { isIntersecting: c } = l;
      if (this.isInView === c || (this.isInView = c, i && !c && this.hasEnteredView))
        return;
      c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
      const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(), f = c ? u : d;
      f && f(l);
    };
    return qE(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(RE(e, n)) && this.startObserver();
  }
  unmount() {
  }
}
function RE({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n];
}
const kE = {
  inView: {
    Feature: TE
  },
  tap: {
    Feature: wE
  },
  focus: {
    Feature: xE
  },
  hover: {
    Feature: vE
  }
}, ME = {
  layout: {
    ProjectionNode: cb,
    MeasureLayout: tb
  }
}, jd = ks({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), Dl = ks({}), Bd = typeof window < "u", db = Bd ? od : je, fb = ks({ strict: !1 });
let Yp = !1;
function DE(t, e, n, s, r) {
  var i;
  const { visualElement: o } = ht(Dl), a = ht(fb), l = ht(Ml), c = ht(jd).reducedMotion, u = gt();
  s = s || a.renderer, !u.current && s && (u.current = s(t, {
    visualState: e,
    parent: o,
    props: n,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: c
  }));
  const d = u.current, f = ht(eb);
  d && !d.projection && r && (d.type === "html" || d.type === "svg") && LE(u.current, n, r, f), aA(() => {
    d && d.update(n, l);
  });
  const h = n[j0], p = gt(!!h && !window.MotionHandoffIsComplete && ((i = window.MotionHasOptimisedAnimation) === null || i === void 0 ? void 0 : i.call(window, h)));
  return db(() => {
    d && (d.updateFeatures(), Nd.render(d.render), p.current && d.animationState && d.animationState.animateChanges());
  }), je(() => {
    d && (!p.current && d.animationState && d.animationState.animateChanges(), p.current = !1, Yp || (Yp = !0, queueMicrotask(OE)));
  }), d;
}
function OE() {
  window.MotionHandoffIsComplete = !0;
}
function LE(t, e, n, s) {
  const { layoutId: r, layout: i, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: c } = e;
  t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : hb(t.parent)), t.projection.setOptions({
    layoutId: r,
    layout: i,
    alwaysMeasureLayout: !!o || a && wr(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof i == "string" ? i : "both",
    initialPromotionConfig: s,
    layoutScroll: l,
    layoutRoot: c
  });
}
function hb(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : hb(t.parent);
}
function NE(t, e, n) {
  return Fe(
    (s) => {
      s && t.mount && t.mount(s), e && (s ? e.mount(s) : e.unmount()), n && (typeof n == "function" ? n(s) : wr(n) && (n.current = s));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function Ol(t) {
  return Wi(t.animate) || Ad.some((e) => Hi(t[e]));
}
function pb(t) {
  return !!(Ol(t) || t.variants);
}
function jE(t, e) {
  if (Ol(t)) {
    const { initial: n, animate: s } = t;
    return {
      initial: n === !1 || Hi(n) ? n : void 0,
      animate: Hi(s) ? s : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function BE(t) {
  const { initial: e, animate: n } = jE(t, ht(Dl));
  return ms(() => ({ initial: e, animate: n }), [Kp(e), Kp(n)]);
}
function Kp(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const Xp = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Br = {};
for (const t in Xp)
  Br[t] = {
    isEnabled: (e) => Xp[t].some((n) => !!e[n])
  };
function IE(t) {
  for (const e in t)
    Br[e] = {
      ...Br[e],
      ...t[e]
    };
}
const FE = Symbol.for("motionComponentSymbol");
function VE({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: s, Component: r }) {
  t && IE(t);
  function i(a, l) {
    let c;
    const u = {
      ...ht(jd),
      ...a,
      layoutId: zE(a)
    }, { isStatic: d } = u, f = BE(a), h = s(a, d);
    if (!d && Bd) {
      UE(u, t);
      const p = WE(u);
      c = p.MeasureLayout, f.visualElement = DE(r, h, u, e, p.ProjectionNode);
    }
    return m.jsxs(Dl.Provider, { value: f, children: [c && f.visualElement ? m.jsx(c, { visualElement: f.visualElement, ...u }) : null, n(r, a, NE(h, f.visualElement, l), h, d, f.visualElement)] });
  }
  const o = Xr(i);
  return o[FE] = r, o;
}
function zE({ layoutId: t }) {
  const e = ht(Ld).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function UE(t, e) {
  const n = ht(fb).strict;
  if (e && n) {
    const s = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? ei(!1, s) : Zn(!1, s);
  }
}
function WE(t) {
  const { drag: e, layout: n } = Br;
  if (!e && !n)
    return {};
  const s = { ...e, ...n };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || n != null && n.isEnabled(t) ? s.MeasureLayout : void 0,
    ProjectionNode: s.ProjectionNode
  };
}
const HE = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Id(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(HE.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function gb(t, { style: e, vars: n }, s, r) {
  Object.assign(t.style, e, r && r.getProjectionStyles(s));
  for (const i in n)
    t.style.setProperty(i, n[i]);
}
const mb = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function Ab(t, e, n, s) {
  gb(t, e, void 0, s);
  for (const r in e.attrs)
    t.setAttribute(mb.has(r) ? r : Rl(r), e.attrs[r]);
}
function bb(t, { layout: e, layoutId: n }) {
  return Ms.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!Ya[t] || t === "opacity");
}
function Fd(t, e, n) {
  var s;
  const { style: r } = t, i = {};
  for (const o in r)
    (St(r[o]) || e.style && St(e.style[o]) || bb(o, t) || ((s = n == null ? void 0 : n.getValue(o)) === null || s === void 0 ? void 0 : s.liveStyle) !== void 0) && (i[o] = r[o]);
  return n && r && typeof r.willChange == "string" && (n.applyWillChange = !1), i;
}
function yb(t, e, n) {
  const s = Fd(t, e, n);
  for (const r in t)
    if (St(t[r]) || St(e[r])) {
      const i = wo.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
      s[i] = t[r];
    }
  return s;
}
function Vd(t) {
  const e = gt(null);
  return e.current === null && (e.current = t()), e.current;
}
function QE({ applyWillChange: t = !1, scrapeMotionValuesFromProps: e, createRenderState: n, onMount: s }, r, i, o, a) {
  const l = {
    latestValues: KE(r, i, o, a ? !1 : t, e),
    renderState: n()
  };
  return s && (l.mount = (c) => s(r, c, l)), l;
}
const vb = (t) => (e, n) => {
  const s = ht(Dl), r = ht(Ml), i = () => QE(t, e, s, r, n);
  return n ? i() : Vd(i);
};
function YE(t, e) {
  const n = I0(e);
  n && Po(t, n);
}
function Gp(t, e, n) {
  const s = Array.isArray(e) ? e : [e];
  for (let r = 0; r < s.length; r++) {
    const i = gd(t, s[r]);
    if (i) {
      const { transitionEnd: o, transition: a, ...l } = i;
      n(l, o);
    }
  }
}
function KE(t, e, n, s, r) {
  var i;
  const o = {}, a = [], l = s && ((i = t.style) === null || i === void 0 ? void 0 : i.willChange) === void 0, c = r(t, {});
  for (const A in c)
    o[A] = ba(c[A]);
  let { initial: u, animate: d } = t;
  const f = Ol(t), h = pb(t);
  e && h && !f && t.inherit !== !1 && (u === void 0 && (u = e.initial), d === void 0 && (d = e.animate));
  let p = n ? n.initial === !1 : !1;
  p = p || u === !1;
  const g = p ? d : u;
  return g && typeof g != "boolean" && !Wi(g) && Gp(t, g, (A, b) => {
    for (const y in A) {
      let w = A[y];
      if (Array.isArray(w)) {
        const x = p ? w.length - 1 : 0;
        w = w[x];
      }
      w !== null && (o[y] = w);
    }
    for (const y in b)
      o[y] = b[y];
  }), l && (d && u !== !1 && !Wi(d) && Gp(t, d, (A) => {
    for (const b in A)
      YE(a, b);
  }), a.length && (o.willChange = a.join(","))), o;
}
const zd = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), xb = () => ({
  ...zd(),
  attrs: {}
}), wb = (t, e) => e && typeof t == "number" ? e.transform(t) : t, XE = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, GE = wo.length;
function ZE(t, e, n) {
  let s = "", r = !0;
  for (let i = 0; i < GE; i++) {
    const o = wo[i], a = t[o];
    if (a === void 0)
      continue;
    let l = !0;
    if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {
      const c = wb(a, Pd[o]);
      if (!l) {
        r = !1;
        const u = XE[o] || o;
        s += `${u}(${c}) `;
      }
      n && (e[o] = c);
    }
  }
  return s = s.trim(), n ? s = n(e, r ? "" : s) : r && (s = "none"), s;
}
function Ud(t, e, n) {
  const { style: s, vars: r, transformOrigin: i } = t;
  let o = !1, a = !1;
  for (const l in e) {
    const c = e[l];
    if (Ms.has(l)) {
      o = !0;
      continue;
    } else if (u0(l)) {
      r[l] = c;
      continue;
    } else {
      const u = wb(c, Pd[l]);
      l.startsWith("origin") ? (a = !0, i[l] = u) : s[l] = u;
    }
  }
  if (e.transform || (o || n ? s.transform = ZE(e, t.transform, n) : s.transform && (s.transform = "none")), a) {
    const { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = i;
    s.transformOrigin = `${l} ${c} ${u}`;
  }
}
function Zp(t, e, n) {
  return typeof t == "string" ? t : te.transform(e + n * t);
}
function _E(t, e, n) {
  const s = Zp(e, t.x, t.width), r = Zp(n, t.y, t.height);
  return `${s} ${r}`;
}
const JE = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, $E = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function eT(t, e, n = 1, s = 0, r = !0) {
  t.pathLength = 1;
  const i = r ? JE : $E;
  t[i.offset] = te.transform(-s);
  const o = te.transform(e), a = te.transform(n);
  t[i.array] = `${o} ${a}`;
}
function Wd(t, {
  attrX: e,
  attrY: n,
  attrScale: s,
  originX: r,
  originY: i,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...c
}, u, d) {
  if (Ud(t, c, d), u) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: f, style: h, dimensions: p } = t;
  f.transform && (p && (h.transform = f.transform), delete f.transform), p && (r !== void 0 || i !== void 0 || h.transform) && (h.transformOrigin = _E(p, r !== void 0 ? r : 0.5, i !== void 0 ? i : 0.5)), e !== void 0 && (f.x = e), n !== void 0 && (f.y = n), s !== void 0 && (f.scale = s), o !== void 0 && eT(f, o, a, l, !1);
}
const Hd = (t) => typeof t == "string" && t.toLowerCase() === "svg", tT = {
  useVisualState: vb({
    scrapeMotionValuesFromProps: yb,
    createRenderState: xb,
    onMount: (t, e, { renderState: n, latestValues: s }) => {
      Oe.read(() => {
        try {
          n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          n.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Oe.render(() => {
        Wd(n, s, Hd(e.tagName), t.transformTemplate), Ab(e, n);
      });
    }
  })
}, nT = {
  useVisualState: vb({
    applyWillChange: !0,
    scrapeMotionValuesFromProps: Fd,
    createRenderState: zd
  })
};
function Sb(t, e, n) {
  for (const s in e)
    !St(e[s]) && !bb(s, n) && (t[s] = e[s]);
}
function sT({ transformTemplate: t }, e) {
  return ms(() => {
    const n = zd();
    return Ud(n, e, t), Object.assign({}, n.vars, n.style);
  }, [e]);
}
function rT(t, e) {
  const n = t.style || {}, s = {};
  return Sb(s, n, t), Object.assign(s, sT(t, e)), s;
}
function iT(t, e) {
  const n = {}, s = rT(t, e);
  return t.drag && t.dragListener !== !1 && (n.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = s, n;
}
const oT = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Ka(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || oT.has(t);
}
let Cb = (t) => !Ka(t);
function aT(t) {
  t && (Cb = (e) => e.startsWith("on") ? !Ka(e) : t(e));
}
try {
  aT(require("@emotion/is-prop-valid").default);
} catch {
}
function lT(t, e, n) {
  const s = {};
  for (const r in t)
    r === "values" && typeof t.values == "object" || (Cb(r) || n === !0 && Ka(r) || !e && !Ka(r) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && r.startsWith("onDrag")) && (s[r] = t[r]);
  return s;
}
function cT(t, e, n, s) {
  const r = ms(() => {
    const i = xb();
    return Wd(i, e, Hd(s), t.transformTemplate), {
      ...i.attrs,
      style: { ...i.style }
    };
  }, [e]);
  if (t.style) {
    const i = {};
    Sb(i, t.style, t), r.style = { ...i, ...r.style };
  }
  return r;
}
function uT(t = !1) {
  return (n, s, r, { latestValues: i }, o) => {
    const l = (Id(n) ? cT : iT)(s, i, o, n), c = lT(s, typeof n == "string", t), u = n !== lA ? { ...c, ...l, ref: r } : {}, { children: d } = s, f = ms(() => St(d) ? d.get() : d, [d]);
    return En(n, {
      ...u,
      children: f
    });
  };
}
function dT(t, e) {
  return function(s, { forwardMotionProps: r } = { forwardMotionProps: !1 }) {
    const o = {
      ...Id(s) ? tT : nT,
      preloadedFeatures: t,
      useRender: uT(r),
      createVisualElement: e,
      Component: s
    };
    return VE(o);
  };
}
const xu = { current: null }, Pb = { current: !1 };
function fT() {
  if (Pb.current = !0, !!Bd)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => xu.current = t.matches;
      t.addListener(e), e();
    } else
      xu.current = !1;
}
function hT(t, e, n) {
  for (const s in e) {
    const r = e[s], i = n[s];
    if (St(r))
      t.addValue(s, r);
    else if (St(i))
      t.addValue(s, Ki(r, { owner: t }));
    else if (i !== r)
      if (t.hasValue(s)) {
        const o = t.getValue(s);
        o.liveStyle === !0 ? o.jump(r) : o.hasAnimated || o.set(r);
      } else {
        const o = t.getStaticValue(s);
        t.addValue(s, Ki(o !== void 0 ? o : r, { owner: t }));
      }
  }
  for (const s in n)
    e[s] === void 0 && t.removeValue(s);
  return e;
}
const _p = /* @__PURE__ */ new WeakMap(), pT = [...h0, wt, ys], gT = (t) => pT.find(f0(t)), Jp = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class mT {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, n, s) {
    return {};
  }
  constructor({ parent: e, props: n, presenceContext: s, reducedMotionConfig: r, blockInitialAnimation: i, visualState: o }, a = {}) {
    this.applyWillChange = !1, this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = wd, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const f = Cn.now();
      this.renderScheduledAt < f && (this.renderScheduledAt = f, Oe.render(this.render, !1, !0));
    };
    const { latestValues: l, renderState: c } = o;
    this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = e, this.props = n, this.presenceContext = s, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = a, this.blockInitialAnimation = !!i, this.isControllingVariants = Ol(n), this.isVariantNode = pb(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: u, ...d } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const f in d) {
      const h = d[f];
      l[f] !== void 0 && St(h) && h.set(l[f], !1);
    }
  }
  mount(e) {
    this.current = e, _p.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, s) => this.bindToMotionValue(s, n)), Pb.current || fT(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : xu.current, pd(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    _p.delete(this.current), this.projection && this.projection.unmount(), As(this.notifyUpdate), As(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const n = this.features[e];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, n) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const s = Ms.has(e), r = n.on("change", (a) => {
      this.latestValues[e] = a, this.props.onUpdate && Oe.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0);
    }), i = n.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => {
      r(), i(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in Br) {
      const n = Br[e];
      if (!n)
        continue;
      const { isEnabled: s, Feature: r } = n;
      if (!this.features[e] && r && s(this.props) && (this.features[e] = new r(this)), this.features[e]) {
        const i = this.features[e];
        i.isMounted ? i.update() : (i.mount(), i.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : $e();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, n) {
    this.latestValues[e] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, n) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let s = 0; s < Jp.length; s++) {
      const r = Jp[s];
      this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]);
      const i = "on" + r, o = e[i];
      o && (this.propEventSubscriptions[r] = this.on(r, o));
    }
    this.prevMotionValues = hT(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, n) {
    const s = this.values.get(e);
    n !== s && (s && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const n = this.valueSubscriptions.get(e);
    n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, n) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let s = this.values.get(e);
    return s === void 0 && n !== void 0 && (s = Ki(n === null ? void 0 : n, { owner: this }), this.addValue(e, s)), s;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, n) {
    var s;
    let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (s = this.getBaseTargetFromProps(this.props, e)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, e, this.options);
    return r != null && (typeof r == "string" && (l0(r) || a0(r)) ? r = parseFloat(r) : !gT(r) && ys.test(n) && (r = x0(e, n)), this.setBaseTarget(e, St(r) ? r.get() : r)), St(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, n) {
    this.baseTarget[e] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var n;
    const { initial: s } = this.props;
    let r;
    if (typeof s == "string" || typeof s == "object") {
      const o = gd(this.props, s, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
      o && (r = o[e]);
    }
    if (s && r !== void 0)
      return r;
    const i = this.getBaseTargetFromProps(this.props, e);
    return i !== void 0 && !St(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, n) {
    return this.events[e] || (this.events[e] = new Od()), this.events[e].add(n);
  }
  notify(e, ...n) {
    this.events[e] && this.events[e].notify(...n);
  }
}
class qb extends mT {
  constructor() {
    super(...arguments), this.KeyframeResolver = w0;
  }
  sortInstanceNodePosition(e, n) {
    return e.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, n) {
    return e.style ? e.style[n] : void 0;
  }
  removeValueFromRenderState(e, { vars: n, style: s }) {
    delete n[e], delete s[e];
  }
}
function AT(t) {
  return window.getComputedStyle(t);
}
class bT extends qb {
  constructor() {
    super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = gb;
  }
  readValueFromInstance(e, n) {
    if (Ms.has(n)) {
      const s = qd(n);
      return s && s.default || 0;
    } else {
      const s = AT(e), r = (u0(n) ? s.getPropertyValue(n) : s[n]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: n }) {
    return J0(e, n);
  }
  build(e, n, s) {
    Ud(e, n, s.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, n, s) {
    return Fd(e, n, s);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    St(e) && (this.childSubscription = e.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class yT extends qb {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = $e;
  }
  getBaseTargetFromProps(e, n) {
    return e[n];
  }
  readValueFromInstance(e, n) {
    if (Ms.has(n)) {
      const s = qd(n);
      return s && s.default || 0;
    }
    return n = mb.has(n) ? n : Rl(n), e.getAttribute(n);
  }
  scrapeMotionValuesFromProps(e, n, s) {
    return yb(e, n, s);
  }
  build(e, n, s) {
    Wd(e, n, this.isSVGTag, s.transformTemplate);
  }
  renderInstance(e, n, s, r) {
    Ab(e, n, s, r);
  }
  mount(e) {
    this.isSVGTag = Hd(e.tagName), super.mount(e);
  }
}
const vT = (t, e) => Id(t) ? new yT(e) : new bT(e, {
  allowProjection: t !== lA
}), xT = /* @__PURE__ */ dT({
  ...lq,
  ...kE,
  ...yE,
  ...ME
}, vT), Tr = /* @__PURE__ */ e2(xT);
class wT extends v.Component {
  getSnapshotBeforeUpdate(e) {
    const n = this.props.childRef.current;
    if (n && e.isPresent && !this.props.isPresent) {
      const s = this.props.sizeRef.current;
      s.height = n.offsetHeight || 0, s.width = n.offsetWidth || 0, s.top = n.offsetTop, s.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function ST({ children: t, isPresent: e }) {
  const n = id(), s = gt(null), r = gt({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: i } = ht(jd);
  return aA(() => {
    const { width: o, height: a, top: l, left: c } = r.current;
    if (e || !s.current || !o || !a)
      return;
    s.current.dataset.motionPopId = n;
    const u = document.createElement("style");
    return i && (u.nonce = i), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => {
      document.head.removeChild(u);
    };
  }, [e]), m.jsx(wT, { isPresent: e, childRef: s, sizeRef: r, children: v.cloneElement(t, { ref: s }) });
}
const CT = ({ children: t, initial: e, isPresent: n, onExitComplete: s, custom: r, presenceAffectsLayout: i, mode: o }) => {
  const a = Vd(PT), l = id(), c = ms(
    () => ({
      id: l,
      initial: e,
      isPresent: n,
      custom: r,
      onExitComplete: (u) => {
        a.set(u, !0);
        for (const d of a.values())
          if (!d)
            return;
        s && s();
      },
      register: (u) => (a.set(u, !1), () => a.delete(u))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    i ? [Math.random()] : [n]
  );
  return ms(() => {
    a.forEach((u, d) => a.set(d, !1));
  }, [n]), v.useEffect(() => {
    !n && !a.size && s && s();
  }, [n]), o === "popLayout" && (t = m.jsx(ST, { isPresent: n, children: t })), m.jsx(Ml.Provider, { value: c, children: t });
};
function PT() {
  return /* @__PURE__ */ new Map();
}
const Fo = (t) => t.key || "";
function $p(t) {
  const e = [];
  return Fw.forEach(t, (n) => {
    Vw(n) && e.push(n);
  }), e;
}
const wu = ({ children: t, exitBeforeEnter: e, custom: n, initial: s = !0, onExitComplete: r, presenceAffectsLayout: i = !0, mode: o = "sync" }) => {
  Zn(!e, "Replace exitBeforeEnter with mode='wait'");
  const a = ms(() => $p(t), [t]), l = a.map(Fo), c = gt(!0), u = gt(a), d = Vd(() => /* @__PURE__ */ new Map()), [f, h] = tt(a), [p, g] = tt(a);
  db(() => {
    c.current = !1, u.current = a;
    for (let y = 0; y < p.length; y++) {
      const w = Fo(p[y]);
      l.includes(w) ? d.delete(w) : d.get(w) !== !0 && d.set(w, !1);
    }
  }, [p, l.length, l.join("-")]);
  const A = [];
  if (a !== f) {
    let y = [...a];
    for (let w = 0; w < p.length; w++) {
      const x = p[w], S = Fo(x);
      l.includes(S) || (y.splice(w, 0, x), A.push(x));
    }
    o === "wait" && A.length && (y = A), g($p(y)), h(a);
    return;
  }
  o === "wait" && p.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: b } = ht(Ld);
  return m.jsx(m.Fragment, { children: p.map((y) => {
    const w = Fo(y), x = a === p || l.includes(w), S = () => {
      if (d.has(w))
        d.set(w, !0);
      else
        return;
      let q = !0;
      d.forEach((C) => {
        C || (q = !1);
      }), q && (b == null || b(), g(u.current), r && r());
    };
    return m.jsx(CT, { isPresent: x, initial: !c.current || s ? void 0 : !1, custom: x ? void 0 : n, presenceAffectsLayout: i, mode: o, onExitComplete: x ? void 0 : S, children: y }, w);
  }) });
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qT = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Eb = (...t) => t.filter((e, n, s) => !!e && s.indexOf(e) === n).join(" ");
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var ET = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TT = Xr(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: s,
    className: r = "",
    children: i,
    iconNode: o,
    ...a
  }, l) => En(
    "svg",
    {
      ref: l,
      ...ET,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: s ? Number(n) * 24 / Number(e) : n,
      className: Eb("lucide", r),
      ...a
    },
    [
      ...o.map(([c, u]) => En(c, u)),
      ...Array.isArray(i) ? i : [i]
    ]
  )
);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Tt = (t, e) => {
  const n = Xr(
    ({ className: s, ...r }, i) => En(TT, {
      ref: i,
      iconNode: e,
      className: Eb(`lucide-${qT(t)}`, s),
      ...r
    })
  );
  return n.displayName = `${t}`, n;
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Tb = Tt("ChartLine", [
  ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }],
  ["path", { d: "m19 9-5 5-4-4-3 3", key: "2osh9i" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RT = Tt("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kT = Tt("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eg = Tt("CircleHelp", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MT = Tt("Info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const DT = Tt("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const OT = Tt("Loader", [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LT = Tt("Nut", [
  ["path", { d: "M12 4V2", key: "1k5q1u" }],
  [
    "path",
    {
      d: "M5 10v4a7.004 7.004 0 0 0 5.277 6.787c.412.104.802.292 1.102.592L12 22l.621-.621c.3-.3.69-.488 1.102-.592A7.003 7.003 0 0 0 19 14v-4",
      key: "1tgyif"
    }
  ],
  [
    "path",
    {
      d: "M12 4C8 4 4.5 6 4 8c-.243.97-.919 1.952-2 3 1.31-.082 1.972-.29 3-1 .54.92.982 1.356 2 2 1.452-.647 1.954-1.098 2.5-2 .595.995 1.151 1.427 2.5 2 1.31-.621 1.862-1.058 2.5-2 .629.977 1.162 1.423 2.5 2 1.209-.548 1.68-.967 2-2 1.032.916 1.683 1.157 3 1-1.297-1.036-1.758-2.03-2-3-.5-2-4-4-8-4Z",
      key: "tnsqj"
    }
  ]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const NT = Tt("RefreshCcw", [
  ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
  ["path", { d: "M16 16h5v5", key: "ccwih5" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const jT = Tt("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BT = Tt("Repeat", [
  ["path", { d: "m17 2 4 4-4 4", key: "nntrym" }],
  ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14", key: "84bu3i" }],
  ["path", { d: "m7 22-4-4 4-4", key: "1wqhfi" }],
  ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3", key: "1rx37r" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const IT = Tt("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FT = Tt("TriangleAlert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VT = Tt("Volume2", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
  ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zT = Tt("VolumeX", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["line", { x1: "22", x2: "16", y1: "9", y2: "15", key: "1ewh16" }],
  ["line", { x1: "16", x2: "22", y1: "9", y2: "15", key: "5ykzw1" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Rb = Tt("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), kb = ks(void 0), Qd = () => {
  const t = ht(kb);
  if (!t)
    throw new Error("useToast must be used within a ToastProvider");
  return t;
};
class UT {
  constructor() {
    this.listeners = [];
  }
  addToast(e) {
    this.listeners.forEach((n) => n(e));
  }
  addListener(e) {
    this.listeners.push(e);
  }
  removeListener(e) {
    this.listeners = this.listeners.filter((n) => n !== e);
  }
}
const Xa = new UT(), WT = ({
  children: t
}) => {
  const [e, n] = tt([]), s = Fe(
    ({ variant: i, message: o, duration: a, limit: l, errorCode: c }) => {
      n((u) => l !== void 0 && u.filter(
        (f) => f.variant === i && f.message === o
      ).length >= l ? u : [
        ...u,
        { id: Date.now(), variant: i, message: o, duration: a, limit: l, errorCode: c }
      ]);
    },
    []
  ), r = Fe((i) => {
    n((o) => o.filter((a) => a.id !== i));
  }, []);
  return je(() => {
    const i = (o) => {
      s(o);
    };
    return Xa.addListener(i), () => {
      Xa.removeListener(i);
    };
  }, [s]), /* @__PURE__ */ m.jsx(kb.Provider, { value: { addToast: s, removeToast: r }, children: /* @__PURE__ */ m.jsxs("div", { className: "relative", children: [
    t,
    /* @__PURE__ */ m.jsx(HT, { toasts: e })
  ] }) });
}, HT = ({ toasts: t }) => /* @__PURE__ */ m.jsx("div", { className: "absolute top-4 left-4 z-50 flex flex-col space-y-2", children: /* @__PURE__ */ m.jsx(wu, { children: t.map((e) => /* @__PURE__ */ m.jsx(QT, { toast: e }, e.id)) }) }), QT = ({ toast: t }) => {
  const { removeToast: e } = Qd(), [n, s] = tt(100), [r, i] = tt(!1), o = gt(null), a = gt(Date.now()), l = gt(t.duration);
  je(() => {
    if (!t.duration) return;
    const f = () => {
      if (!r && t.duration) {
        const h = Date.now() - a.current;
        l.current = Math.max(0, t.duration - h);
        const p = l.current / t.duration * 100;
        s(p), p <= 0 && (o.current && clearInterval(o.current), e(t.id));
      }
    };
    return o.current = setInterval(f, 10), () => {
      o.current && clearInterval(o.current);
    };
  }, [r, e, t.duration, t.id]);
  const c = () => {
    e(t.id);
  }, u = () => {
    switch (t.variant) {
      case "success":
        return /* @__PURE__ */ m.jsx(kT, { size: 18 });
      case "error":
        return /* @__PURE__ */ m.jsx(FT, { size: 30 });
      case "notice":
        return /* @__PURE__ */ m.jsx(BT, { size: 18 });
      case "loading":
        return /* @__PURE__ */ m.jsx(
          Tr.div,
          {
            animate: { rotate: 360 },
            transition: { duration: 1, repeat: 1 / 0, ease: "linear" },
            children: /* @__PURE__ */ m.jsx(DT, { size: 18 })
          }
        );
      case "info":
      case "warning":
        return /* @__PURE__ */ m.jsx(MT, { size: 18 });
      default:
        return /* @__PURE__ */ m.jsx(RT, { size: 18 });
    }
  }, d = {
    success: {
      background: "bg-green-500",
      progress: "bg-white"
    },
    error: {
      background: "bg-brand",
      progress: "bg-white/40"
    },
    loading: {
      background: "bg-blue-500",
      progress: "bg-white"
    },
    info: {
      background: "bg-blue-500",
      progress: "bg-white0"
    },
    warning: {
      background: "bg-yellow-500",
      progress: "bg-white0"
    },
    notice: {
      background: "bg-primary",
      progress: "bg-green-500"
    }
  }[t.variant];
  return /* @__PURE__ */ m.jsxs(
    Tr.div,
    {
      initial: { opacity: 0, y: -50, scale: 0.3 },
      animate: { opacity: 1, y: 0, scale: 1 },
      exit: { opacity: 0, scale: 0.5, transition: { duration: 0.2 } },
      className: `${d.background} text-white p-4 rounded-lg shadow-lg flex flex-col justify-between items-stretch relative overflow-hidden w-[90vw] lg:w-[23rem]`,
      style: {
        boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 -2px 0 0 rgba(255, 255, 255, 0.1) inset"
      },
      onMouseEnter: () => i(!0),
      onMouseLeave: () => i(!1),
      children: [
        /* @__PURE__ */ m.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
          u(),
          /* @__PURE__ */ m.jsxs("div", { className: "ml-2 flex-grow text-sm", children: [
            /* @__PURE__ */ m.jsx("span", { children: t.message }),
            t.variant === "error" && t.errorCode !== void 0 && /* @__PURE__ */ m.jsxs("div", { className: "mt-1 text-xs", children: [
              "Error code: ",
              t.errorCode
            ] })
          ] }),
          /* @__PURE__ */ m.jsx("button", { onClick: c, className: "ml-4 focus:outline-none", children: /* @__PURE__ */ m.jsx(Rb, { size: 18 }) })
        ] }),
        t.duration && /* @__PURE__ */ m.jsx(
          Tr.div,
          {
            className: `h-1 ${d.progress} absolute bottom-0 left-0 right-0`,
            initial: { scaleX: 1 },
            animate: { scaleX: n / 100 },
            transition: { duration: 0.01, ease: "linear" },
            style: { originX: 0 }
          }
        )
      ]
    }
  );
}, lr = W1("API_BASE_URL"), YT = {
  400: "Bad request: Missing currency information.",
  401: "Unauthorized: Your session has expired. Please log in again.",
  402: "Insufficient balance: Please add funds to continue.",
  416: "Betting limit exceeded: Please lower your bet amount.",
  417: "Action forbidden due to active bonus. Please check bonus terms.",
  500: "An unexpected error occurred. Please try again later."
}, KT = (t) => YT[t] || "An unknown error occurred. Please try again.", cr = (t) => {
  var e;
  if (Ce.isAxiosError(t)) {
    const n = (e = t.response) == null ? void 0 : e.status, s = n ? KT(n) : "An unexpected error occurred.";
    Xa.addToast({
      variant: "error",
      errorCode: n,
      message: s,
      limit: 1
    }), console.error("API Error:", t.response);
  } else
    Xa.addToast({
      variant: "error",
      message: "An unexpected error occurred. Please try again.",
      duration: 1e4,
      limit: 1
    }), console.error("Unexpected Error:", t);
};
async function XT(t) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ce.get(
      `${lr}/api/fair/current`,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (e) {
    throw cr(e), new Error(`Failed to get current seed: ${e}`);
  }
}
async function GT(t, e) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ce.get(
      `${lr}/api/fair/rotate/${e}`,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (n) {
    throw cr(n), new Error(`Failed to rotate seed: ${n}`);
  }
}
async function Mb(t, e) {
  if (!t || !e) throw new Error("No token or currencyCode found");
  try {
    return (await Ce.post(
      `${lr}/api/player/currency-change`,
      { currency: e },
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (n) {
    throw Ce.isAxiosError(n) && (console.log(n.status), console.error(n.response), cr(n)), new Error(`Failed to perform game action 'currency-change': ${n}`);
  }
}
async function Db(t, e) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ce.get(
      `${lr}/api/game/${e}/config`,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (n) {
    throw cr(n), new Error(`Failed to perform game action 'game-config': ${n}`);
  }
}
async function Ga(t, e, n) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ce.post(
      `${lr}/api/game/${e}/bet`,
      n,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (s) {
    throw Ce.isAxiosError(s) && (console.log(s.status), console.error(s.response), cr(s)), new Error(`Failed to perform game action 'bet': ${s}`);
  }
}
class ZT {
  constructor() {
    this.queue = [], this.processing = !1, this.gameActive = !0, this.processedIndexes = /* @__PURE__ */ new Set();
  }
  enqueue(e, n) {
    return new Promise((s, r) => {
      if (!this.gameActive) {
        r(new Error("Game has ended"));
        return;
      }
      const i = n.filter((o) => !this.processedIndexes.has(o));
      if (i.length === 0) {
        r(new Error("Duplicate request"));
        return;
      }
      this.queue.push({ request: e, resolve: s, reject: r, indexes: i }), i.forEach((o) => this.processedIndexes.add(o)), this.processing || this.processNext();
    });
  }
  async processNext() {
    if (this.processing || this.queue.length === 0 || !this.gameActive) return;
    this.processing = !0;
    const { request: e, resolve: n, reject: s } = this.queue.shift();
    try {
      const r = await e();
      "active" in r && r.active === !1 && (this.gameActive = !1, this.clearRemainingQueue()), n(r);
    } catch (r) {
      s(r);
    }
    this.processing = !1, this.gameActive && setTimeout(() => this.processNext(), 100);
  }
  clearRemainingQueue() {
    const e = new Error("Game has ended");
    this.queue.forEach(({ reject: n }) => n(e)), this.queue = [];
  }
  resetQueue() {
    this.clearRemainingQueue(), this.gameActive = !0, this.processedIndexes.clear();
  }
}
const Ob = new ZT();
async function tg(t, e, n) {
  if (!t) throw new Error("No authentication token found");
  const s = n.custom.selected;
  return Ob.enqueue(async () => {
    try {
      return (await Ce.post(
        `${lr}/api/game/${e}/play`,
        n,
        {
          headers: {
            "Content-Type": "application/json",
            "x-token": t
          }
        }
      )).data;
    } catch (r) {
      throw Ce.isAxiosError(r) && (console.log(r.status), console.error(r.response), cr(r)), new Error(`Failed to perform game action 'play': ${r}`);
    }
  }, s);
}
function _T() {
  Ob.resetQueue();
}
async function JT(t, e, n) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ce.post(
      `${lr}/api/game/${e}/play`,
      {
        gameRoundId: n,
        custom: { cashout: !0 }
      },
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (s) {
    throw Ce.isAxiosError(s) && (console.log(s.status), console.error(s.response), cr(s)), new Error(`Failed to perform game action 'cashout': ${s}`);
  }
}
const $T = {
  prefixSymbol: "",
  name: "",
  currencyCode: "",
  fractionalDigits: 0,
  crypto: !1,
  enabled: !0
}, eR = {
  minBet: "0",
  maxBet: "0"
}, it = Gr((t, e) => ({
  // Initial state
  balance: 0,
  isGameActive: !1,
  selectedCurrency: $T,
  betRanges: eR,
  initializing: !0,
  theme: "default",
  isAutoPlaying: !1,
  isFinishingBet: !1,
  currentAutoBet: 0,
  isSoundMuted: !1,
  isHelpDialogOpen: !1,
  currentServerSeed: "",
  currentClientSeed: "",
  currentNonce: "0",
  newServerSeed: "",
  newClientSeed: "",
  newNonce: "0",
  isProvablyFairDialogOpen: !1,
  isLiveStatsOpen: !1,
  isLoadingCurrentSeed: !1,
  // Actions
  setBalance: (n) => t({ balance: n }),
  setIsGameActive: (n) => t({ isGameActive: n }),
  setCurrency: (n) => t({ selectedCurrency: n }),
  setBetRanges: (n) => t({ betRanges: n }),
  setInitializing: (n) => t({ initializing: n }),
  setTheme: (n) => t({ theme: n }),
  setIsAutoPlaying: (n) => t({ isAutoPlaying: n }),
  setIsFinishingBet: (n) => t({ isFinishingBet: n }),
  setCurrentAutoBet: (n) => t((s) => ({
    currentAutoBet: typeof n == "function" ? n(s.currentAutoBet) : n
  })),
  setIsSoundMuted: (n) => t({ isSoundMuted: n }),
  setIsHelpDialogOpen: (n) => t({ isHelpDialogOpen: n }),
  setCurrentServerSeed: (n) => t({ currentServerSeed: n }),
  setCurrentClientSeed: (n) => t({ currentClientSeed: n }),
  setCurrentNonce: (n) => t({ currentNonce: n }),
  setNewServerSeed: (n) => t({ newServerSeed: n }),
  setNewClientSeed: (n) => t({ newClientSeed: n }),
  setNewNonce: (n) => t({ newNonce: n }),
  setLiveStatsOpen: (n) => t({ isLiveStatsOpen: n }),
  useNewSeeds: async (n) => {
    t({ isLoadingCurrentSeed: !0 });
    try {
      const s = e(), r = await GT(n, s.newClientSeed);
      t({
        currentServerSeed: r.hash,
        currentClientSeed: r.clientSeed,
        currentNonce: r.nonce.toString(),
        newServerSeed: r.nextHash,
        newClientSeed: "",
        newNonce: "0",
        isLoadingCurrentSeed: !1
      });
    } catch (s) {
      console.error("Failed to rotate seed:", s), t({ isLoadingCurrentSeed: !1 });
    }
  },
  setIsLoadingCurrentSeed: (n) => t({ isLoadingCurrentSeed: n }),
  fetchCurrentSeed: async (n) => {
    t({ isLoadingCurrentSeed: !0 });
    try {
      const s = await XT(n);
      t({
        currentServerSeed: s.hash,
        currentClientSeed: s.clientSeed,
        currentNonce: s.nonce.toString(),
        newServerSeed: s.nextHash,
        isLoadingCurrentSeed: !1
      });
    } catch (s) {
      console.error("Failed to fetch current seed:", s), t({ isLoadingCurrentSeed: !1 });
    }
  },
  setIsProvablyFairDialogOpen: (n) => t({ isProvablyFairDialogOpen: n }),
  finishAutoPlay: () => t({ isFinishingBet: !1, isAutoPlaying: !1 })
}));
function Lb({ multiplier: t, amount: e }) {
  const { selectedCurrency: n } = it();
  return /* @__PURE__ */ m.jsx("div", { className: "absolute inset-0 flex items-center justify-center z-20", children: /* @__PURE__ */ m.jsx("div", { className: "bg-primary rounded-md border-2 border-green-500 text-center animate-pop-in inline-flex flex-col justify-center", children: /* @__PURE__ */ m.jsx("div", { className: "px-4 py-3 select-none", children: t && e && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs("div", { className: "text-4xl font-extrabold text-green-500 leading-none mb-2", children: [
      t == null ? void 0 : t.toFixed(2),
      "x"
    ] }),
    /* @__PURE__ */ m.jsx("div", { className: "w-full h-px bg-green-500/30 mb-2" }),
    /* @__PURE__ */ m.jsxs("div", { className: "text-lg text-green-500 flex items-center justify-center font-extrabold", children: [
      "+",
      n.prefixSymbol,
      e.toFixed(n.fractionalDigits)
    ] })
  ] }) }) }) });
}
const tR = () => {
  const { result: t, totalProfit: e, multiplier: n } = yA(), { theme: s } = it(), r = () => {
    const o = {
      width: "80%",
      height: "80%",
      maxWidth: "300px",
      maxHeight: "300px",
      borderRadius: "50%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "2rem",
      fontWeight: "bold",
      color: "white",
      textTransform: "uppercase",
      boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)"
    };
    return t === "HEADS" ? { ...o, backgroundColor: "#FFD700" } : t === "TAILS" ? { ...o, backgroundColor: "#C0C0C0" } : { ...o, borderColor: "#ffffff", borderWidth: "2px" };
  }, i = Zr();
  return /* @__PURE__ */ m.jsxs("div", { className: "w-full h-full flex items-center justify-center", children: [
    /* @__PURE__ */ m.jsx("div", { style: r(), children: t || "?" }),
    n !== 0 && e !== 0 && /* @__PURE__ */ m.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ m.jsx(Lb, { multiplier: n, amount: e }) }),
    !i && /* @__PURE__ */ m.jsx(
      qA,
      {
        size: 600,
        duration: 8,
        colorFrom: s === "betpanda" ? "#1fe88a" : "#dc146e",
        colorTo: "#08080800",
        borderWidth: 1.5
      }
    )
  ] });
};
function nR(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function Nb(...t) {
  return (e) => t.forEach((n) => nR(n, e));
}
function Pe(...t) {
  return v.useCallback(Nb(...t), t);
}
var Ir = v.forwardRef((t, e) => {
  const { children: n, ...s } = t, r = v.Children.toArray(n), i = r.find(sR);
  if (i) {
    const o = i.props.children, a = r.map((l) => l === i ? v.Children.count(o) > 1 ? v.Children.only(null) : v.isValidElement(o) ? o.props.children : null : l);
    return /* @__PURE__ */ m.jsx(Su, { ...s, ref: e, children: v.isValidElement(o) ? v.cloneElement(o, void 0, a) : null });
  }
  return /* @__PURE__ */ m.jsx(Su, { ...s, ref: e, children: n });
});
Ir.displayName = "Slot";
var Su = v.forwardRef((t, e) => {
  const { children: n, ...s } = t;
  if (v.isValidElement(n)) {
    const r = iR(n);
    return v.cloneElement(n, {
      ...rR(s, n.props),
      // @ts-ignore
      ref: e ? Nb(e, r) : r
    });
  }
  return v.Children.count(n) > 1 ? v.Children.only(null) : null;
});
Su.displayName = "SlotClone";
var jb = ({ children: t }) => /* @__PURE__ */ m.jsx(m.Fragment, { children: t });
function sR(t) {
  return v.isValidElement(t) && t.type === jb;
}
function rR(t, e) {
  const n = { ...e };
  for (const s in e) {
    const r = t[s], i = e[s];
    /^on[A-Z]/.test(s) ? r && i ? n[s] = (...a) => {
      i(...a), r(...a);
    } : r && (n[s] = r) : s === "style" ? n[s] = { ...r, ...i } : s === "className" && (n[s] = [r, i].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function iR(t) {
  var s, r;
  let e = (s = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (r = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
function Bb(t) {
  var e, n, s = "";
  if (typeof t == "string" || typeof t == "number") s += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (n = Bb(t[e])) && (s && (s += " "), s += n);
  else for (e in t) t[e] && (s && (s += " "), s += e);
  return s;
}
function oR() {
  for (var t, e, n = 0, s = ""; n < arguments.length; ) (t = arguments[n++]) && (e = Bb(t)) && (s && (s += " "), s += e);
  return s;
}
const ng = (t) => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, sg = oR, Yd = (t, e) => (n) => {
  var s;
  if ((e == null ? void 0 : e.variants) == null) return sg(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: r, defaultVariants: i } = e, o = Object.keys(r).map((c) => {
    const u = n == null ? void 0 : n[c], d = i == null ? void 0 : i[c];
    if (u === null) return null;
    const f = ng(u) || ng(d);
    return r[c][f];
  }), a = n && Object.entries(n).reduce((c, u) => {
    let [d, f] = u;
    return f === void 0 || (c[d] = f), c;
  }, {}), l = e == null || (s = e.compoundVariants) === null || s === void 0 ? void 0 : s.reduce((c, u) => {
    let { class: d, className: f, ...h } = u;
    return Object.entries(h).every((p) => {
      let [g, A] = p;
      return Array.isArray(A) ? A.includes({
        ...i,
        ...a
      }[g]) : {
        ...i,
        ...a
      }[g] === A;
    }) ? [
      ...c,
      d,
      f
    ] : c;
  }, []);
  return sg(t, o, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
}, aR = Yd(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), lt = v.forwardRef(
  ({ className: t, variant: e, size: n, asChild: s = !1, ...r }, i) => {
    const o = s ? Ir : "button";
    return /* @__PURE__ */ m.jsx(
      o,
      {
        className: Be(aR({ variant: e, size: n, className: t })),
        ref: i,
        ...r
      }
    );
  }
);
lt.displayName = "Button";
const ft = v.forwardRef(
  ({ className: t, type: e, ...n }, s) => /* @__PURE__ */ m.jsx(
    "input",
    {
      type: e,
      className: Be(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        t
      ),
      ref: s,
      ...n
    }
  )
);
ft.displayName = "Input";
var lR = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], qe = lR.reduce((t, e) => {
  const n = v.forwardRef((s, r) => {
    const { asChild: i, ...o } = s, a = i ? Ir : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m.jsx(a, { ...o, ref: r });
  });
  return n.displayName = `Primitive.${e}`, { ...t, [e]: n };
}, {});
function Ib(t, e) {
  t && ad.flushSync(() => t.dispatchEvent(e));
}
var cR = "Label", Fb = v.forwardRef((t, e) => /* @__PURE__ */ m.jsx(
  qe.label,
  {
    ...t,
    ref: e,
    onMouseDown: (n) => {
      var r;
      n.target.closest("button, input, select, textarea") || ((r = t.onMouseDown) == null || r.call(t, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
Fb.displayName = cR;
var Vb = Fb;
const uR = Yd(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
), rt = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  Vb,
  {
    ref: n,
    className: Be(uR(), t),
    ...e
  }
));
rt.displayName = Vb.displayName;
function ps({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ m.jsx(
    "div",
    {
      className: Be("animate-pulse rounded-md bg-muted", t),
      ...e
    }
  );
}
const dR = "data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//PkAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAANAAAaQAAkJCQkJCQkNjY2NjY2NjZJSUlJSUlJSVtbW1tbW1ttbW1tbW1tbYCAgICAgICAkpKSkpKSkqSkpKSkpKSktra2tra2trbJycnJycnJ29vb29vb29vt7e3t7e3t7f////////8AAAAATGF2ZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGkC8X/5HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//PkZAAf2b0AAqw8AJqYpdn3RzAAWB/H8hyq4agaK6Ram6xGcO5ZlcP25Q/jD0E4BGZ0mtJnKWvb9wAM4C2AtgEYB2BDCRi5lzOiKf5bzrfF8C8BUACsAjAOwVYh5L1HH34CsQxkqxoeo1YrE4oFYyTKcnYagTAyGR4wHIQQTQDODnEzLmh6vZ52A01HOwIYhiGODeaCggp850PUavQ8uB0OEN+/3il73veG/fv3jx48ePHjyI/fv379+/fv3jx48ePHkSke973fv38d48ePHjx48iP379+/fv37948ePHjx48iP379+/fv396UpSlKU1u973ve8d48ePHjwAAw8PDw8AAAAAAw8PDw8AAAAAAw8PDw/UBgG5LdMMmf5588bg8EggVBeAGAGAWL3toIEIcmAAAEEEAQBAHwfB8HwcBAEPygIO/KAgchh/9APg+D4PgQEAQDEDg++j/ygIBgHwfB8HygIAgGI8Hw/QoMf/5dAIAgCEeD4PvlAQOYnD6rDCAwKAyqBDVRbNfoL/MPAoIMppY3m0of/mCw8ZaGRluvGW83/mEsAWYIoNhh0BJGEEROYpRihmepS/5YhIMNIFpWowMgHjALALPHBKQy2RmzImFyMUoDMrhG//KgDhgQA//PkZGEsydkgAs54ACJ5rdQBlbAAEFACoXAIMB4AgxcwCjE2BGMPoJcw5wgjCqAz///wgDxFYwHgCggDxcQOAQML4KswbwljBGBvMG4JcwHwlgqDf///+EAeLjSICAFGLooBAChgZBBmAUDcYGYN4UBbMDIEYwRwWzALAz////9FfJTj/XB3/MEYDIwRwRzAfALMEYAowRwMwgD8wMgCjAzAfCAP///////////1//4QB4YD4BaK4QAoiuo2ioo2o2o0o2ir////////+v///X/v/1/qNKNoqqNKNqNqNIrqNoqIrqcqcIrorBACv//////////7/WX///r///////0VgFmA+A8YNwIxgZgjmBkA+FQClG0VVGlG/8GF4DLxf7gYtXwGLV/giFwOIDDAFgDBYQcDF8ZoDM2nfCPlAMOgLBlgGAmIgedk7AZURfgZBhfAwXwMd51PwYL8DDoCwDDoC0DDqCwGAs/SfgYdAWgYLQWAYLAWgYLAWhEFgRBb//AwWAtCILAiC0IgtAwWAsAwWgtCILf//BgLAMFoLYMBYDAW1f////////90VcvggsCQA5OIwDgCvMDgAlxYBxMEHCuDD2w7ww7EXqMo/5fgMWTJbQMY0DeQMFEAigME//PkZDsUUbsMAO/cABz7VaAD17AAHBGAMEHAyAGALMDAMgD8DAOACEMCCNAbiEbf//npd//oNUyQ+j3///8/8/1f/8slv////////y1//+RUio3Q9UAkAOAwCEA4AwHcCoAwFkREAwA8AIAqAHAYBCAQAYAcAEiaFgtkWrD///hEBvAwG4BvgYH2EKAYZaFQAYVCJoAZA3ZoAcRfHgc0FQgY/A3AYbx9AY+w3IgYbg3gYbg3mL///wiG7//X//9+zf/wiG/t1frvhENyP1b6/stFf3/2b/+EQ3fX8GBv//qwYG+BhvDcBhvZYuv/9+79akxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq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", fR = "data:audio/mpeg;base64,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", hR = "data:audio/mpeg;base64,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x5riuJYyxljyUECT8ggOWsLQCvtVgWbeGHHhTFlM+/k3nIKCS3qanmfllSGHYkMgm4P1K37ZJGXCVRL4sRiTPUwX9pZX9LhH4zyTWOXavL8np8qGzj3sMOxLOxOH71SzYpL3/////////6wucQhqGY0/0zDUBw8f/lAkkPBMCk1VKzbu8nbeKlvdHYaAgCAQ6oo+D1hQCH2ClwlpHixmAgAtGxLCBobAMWuIjBINKwY8IDDQUATElQUpTNqE35VrBhhdNerLUtVVktHlMVZmlxcqRRmCqnibIWuvc5LLx4ZaNE+zGFtImshgaGotACQbzK4U0byIOVKHbTBZ1D8Zik/g8jM4DehHtZ9qVblcZjNmWODJo08aJSYqvYDazalkopJU4DiPfGHElNLW5KmRXqCN8n6eQ41M4ai7O3nllDSYWHjf9la74mymQqypIwRyRKZJGtAjFFD/bkptXqkdvxehf+fxhu52tep3bb+J5rmjMed7kWYFSyaD7sMswe2L4T+diluQRP2aSxZxqWpZylf9gkU5FJZZvbq//////////ulx9n6pp6O5XaXmWX/////////9ntX99/eGVhY3mTfdTN5mEAAFCpIh4DWYxgCFICSzqPKYxjEn0o6XFaYzaGX8FegEgbB80oHIqKrQcjhZimZyQ5NhiUsVFTYOloaaX1hnWA6Bs6sLHCCIvtLEmlCxzSrT/K7bcrqqszTUrRQqkiqjAbB8cUHQjKUDYRiRUbRQs5qkiodB9arTM1MzNJKwSKisEiqyvHs1rRRyrRRQsLDAqEgaDgNPWEg0mHfyKPuXubETbooCEIBgZIKrApiOlio+GBUOQCrELNMzQA2JNA0CklAEICYfkViUmuSTUm7WtptORNadO1rW7paxsO5qHXomtcOlukeRpzvRJtS1rdzade2kr/////lrZadqW1Lfcida33Xba/na1sftc6+t1t///mnW7h3LalFvKNondGpNTUqNEQlAIwO9n8qqDmAAAFIlVXyAAAAH0d4MC6KP/////////q1sd//29SZMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uQZDAP8DoASqAAAAoYgFioPSEAAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq", pR = "data:audio/mpeg;base64,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";
let Rr = null;
const Za = {}, gR = {
  diamond: dR,
  bomb: fR,
  tick: hR,
  win: pR
};
async function mR(t, e) {
  if (!Rr) {
    const n = window.AudioContext || window.webkitAudioContext;
    if (!n) {
      console.error("AudioContext is not supported in this browser");
      return;
    }
    Rr = new n();
  }
  if (!Za[t])
    try {
      const s = await (await fetch(e)).arrayBuffer(), r = await Rr.decodeAudioData(s);
      Za[t] = r;
    } catch (n) {
      console.error(`Failed to load sound ${t}:`, n);
    }
}
async function zb() {
  await Promise.all(Object.entries(gR).map(([t, e]) => mR(t, e)));
}
function Ft(t) {
  const e = it.getState().isSoundMuted;
  if (!Rr || !Za[t] || e) return;
  const n = Rr.createBufferSource();
  n.buffer = Za[t], n.connect(Rr.destination), n.start();
}
var Ae;
(function(t) {
  t.assertEqual = (r) => r;
  function e(r) {
  }
  t.assertIs = e;
  function n(r) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (r) => {
    const i = {};
    for (const o of r)
      i[o] = o;
    return i;
  }, t.getValidEnumValues = (r) => {
    const i = t.objectKeys(r).filter((a) => typeof r[r[a]] != "number"), o = {};
    for (const a of i)
      o[a] = r[a];
    return t.objectValues(o);
  }, t.objectValues = (r) => t.objectKeys(r).map(function(i) {
    return r[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (r) => Object.keys(r) : (r) => {
    const i = [];
    for (const o in r)
      Object.prototype.hasOwnProperty.call(r, o) && i.push(o);
    return i;
  }, t.find = (r, i) => {
    for (const o of r)
      if (i(o))
        return o;
  }, t.isInteger = typeof Number.isInteger == "function" ? (r) => Number.isInteger(r) : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r;
  function s(r, i = " | ") {
    return r.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
  }
  t.joinValues = s, t.jsonStringifyReplacer = (r, i) => typeof i == "bigint" ? i.toString() : i;
})(Ae || (Ae = {}));
var Cu;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
    // second overwrites first
  });
})(Cu || (Cu = {}));
const K = Ae.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), cs = (t) => {
  switch (typeof t) {
    case "undefined":
      return K.undefined;
    case "string":
      return K.string;
    case "number":
      return isNaN(t) ? K.nan : K.number;
    case "boolean":
      return K.boolean;
    case "function":
      return K.function;
    case "bigint":
      return K.bigint;
    case "symbol":
      return K.symbol;
    case "object":
      return Array.isArray(t) ? K.array : t === null ? K.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? K.promise : typeof Map < "u" && t instanceof Map ? K.map : typeof Set < "u" && t instanceof Set ? K.set : typeof Date < "u" && t instanceof Date ? K.date : K.object;
    default:
      return K.unknown;
  }
}, V = Ae.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), AR = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class Gt extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (s) => {
      this.issues = [...this.issues, s];
    }, this.addIssues = (s = []) => {
      this.issues = [...this.issues, ...s];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, s = { _errors: [] }, r = (i) => {
      for (const o of i.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(r);
        else if (o.code === "invalid_return_type")
          r(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          r(o.argumentsError);
        else if (o.path.length === 0)
          s._errors.push(n(o));
        else {
          let a = s, l = 0;
          for (; l < o.path.length; ) {
            const c = o.path[l];
            l === o.path.length - 1 ? (a[c] = a[c] || { _errors: [] }, a[c]._errors.push(n(o))) : a[c] = a[c] || { _errors: [] }, a = a[c], l++;
          }
        }
    };
    return r(this), s;
  }
  static assert(e) {
    if (!(e instanceof Gt))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Ae.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, s = [];
    for (const r of this.issues)
      r.path.length > 0 ? (n[r.path[0]] = n[r.path[0]] || [], n[r.path[0]].push(e(r))) : s.push(e(r));
    return { formErrors: s, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Gt.create = (t) => new Gt(t);
const Fr = (t, e) => {
  let n;
  switch (t.code) {
    case V.invalid_type:
      t.received === K.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case V.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, Ae.jsonStringifyReplacer)}`;
      break;
    case V.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Ae.joinValues(t.keys, ", ")}`;
      break;
    case V.invalid_union:
      n = "Invalid input";
      break;
    case V.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Ae.joinValues(t.options)}`;
      break;
    case V.invalid_enum_value:
      n = `Invalid enum value. Expected ${Ae.joinValues(t.options)}, received '${t.received}'`;
      break;
    case V.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case V.invalid_return_type:
      n = "Invalid function return type";
      break;
    case V.invalid_date:
      n = "Invalid date";
      break;
    case V.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : Ae.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case V.too_small:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
      break;
    case V.too_big:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
      break;
    case V.custom:
      n = "Invalid input";
      break;
    case V.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case V.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case V.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = e.defaultError, Ae.assertNever(t);
  }
  return { message: n };
};
let Ub = Fr;
function bR(t) {
  Ub = t;
}
function _a() {
  return Ub;
}
const Ja = (t) => {
  const { data: e, path: n, errorMaps: s, issueData: r } = t, i = [...n, ...r.path || []], o = {
    ...r,
    path: i
  };
  if (r.message !== void 0)
    return {
      ...r,
      path: i,
      message: r.message
    };
  let a = "";
  const l = s.filter((c) => !!c).slice().reverse();
  for (const c of l)
    a = c(o, { data: e, defaultError: a }).message;
  return {
    ...r,
    path: i,
    message: a
  };
}, yR = [];
function Q(t, e) {
  const n = _a(), s = Ja({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      n,
      n === Fr ? void 0 : Fr
      // then global default map
    ].filter((r) => !!r)
  });
  t.common.issues.push(s);
}
class Pt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const s = [];
    for (const r of n) {
      if (r.status === "aborted")
        return re;
      r.status === "dirty" && e.dirty(), s.push(r.value);
    }
    return { status: e.value, value: s };
  }
  static async mergeObjectAsync(e, n) {
    const s = [];
    for (const r of n) {
      const i = await r.key, o = await r.value;
      s.push({
        key: i,
        value: o
      });
    }
    return Pt.mergeObjectSync(e, s);
  }
  static mergeObjectSync(e, n) {
    const s = {};
    for (const r of n) {
      const { key: i, value: o } = r;
      if (i.status === "aborted" || o.status === "aborted")
        return re;
      i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof o.value < "u" || r.alwaysSet) && (s[i.value] = o.value);
    }
    return { status: e.value, value: s };
  }
}
const re = Object.freeze({
  status: "aborted"
}), qr = (t) => ({ status: "dirty", value: t }), Ot = (t) => ({ status: "valid", value: t }), Pu = (t) => t.status === "aborted", qu = (t) => t.status === "dirty", Xi = (t) => t.status === "valid", Gi = (t) => typeof Promise < "u" && t instanceof Promise;
function $a(t, e, n, s) {
  if (typeof e == "function" ? t !== e || !s : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e.get(t);
}
function Wb(t, e, n, s, r) {
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(t, n), n;
}
var _;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(_ || (_ = {}));
var Si, Ci;
class Tn {
  constructor(e, n, s, r) {
    this._cachedPath = [], this.parent = e, this.data = n, this._path = s, this._key = r;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const rg = (t, e) => {
  if (Xi(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Gt(t.common.issues);
      return this._error = n, this._error;
    }
  };
};
function ce(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: s, description: r } = t;
  if (e && (n || s))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: r } : { errorMap: (o, a) => {
    var l, c;
    const { message: u } = t;
    return o.code === "invalid_enum_value" ? { message: u ?? a.defaultError } : typeof a.data > "u" ? { message: (l = u ?? s) !== null && l !== void 0 ? l : a.defaultError } : o.code !== "invalid_type" ? { message: a.defaultError } : { message: (c = u ?? n) !== null && c !== void 0 ? c : a.defaultError };
  }, description: r };
}
class de {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return cs(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: cs(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Pt(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: cs(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Gi(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const s = this.safeParse(e, n);
    if (s.success)
      return s.data;
    throw s.error;
  }
  safeParse(e, n) {
    var s;
    const r = {
      common: {
        issues: [],
        async: (s = n == null ? void 0 : n.async) !== null && s !== void 0 ? s : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: cs(e)
    }, i = this._parseSync({ data: e, path: r.path, parent: r });
    return rg(r, i);
  }
  async parseAsync(e, n) {
    const s = await this.safeParseAsync(e, n);
    if (s.success)
      return s.data;
    throw s.error;
  }
  async safeParseAsync(e, n) {
    const s = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: cs(e)
    }, r = this._parse({ data: e, path: s.path, parent: s }), i = await (Gi(r) ? r : Promise.resolve(r));
    return rg(s, i);
  }
  refine(e, n) {
    const s = (r) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(r) : n;
    return this._refinement((r, i) => {
      const o = e(r), a = () => i.addIssue({
        code: V.custom,
        ...s(r)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((s, r) => e(s) ? !0 : (r.addIssue(typeof n == "function" ? n(s, r) : n), !1));
  }
  _refinement(e) {
    return new hn({
      schema: this,
      typeName: ne.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return Pn.create(this, this._def);
  }
  nullable() {
    return Ss.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return dn.create(this, this._def);
  }
  promise() {
    return zr.create(this, this._def);
  }
  or(e) {
    return $i.create([this, e], this._def);
  }
  and(e) {
    return eo.create(this, e, this._def);
  }
  transform(e) {
    return new hn({
      ...ce(this._def),
      schema: this,
      typeName: ne.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new io({
      ...ce(this._def),
      innerType: this,
      defaultValue: n,
      typeName: ne.ZodDefault
    });
  }
  brand() {
    return new Kd({
      typeName: ne.ZodBranded,
      type: this,
      ...ce(this._def)
    });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new oo({
      ...ce(this._def),
      innerType: this,
      catchValue: n,
      typeName: ne.ZodCatch
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return qo.create(this, e);
  }
  readonly() {
    return ao.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const vR = /^c[^\s-]{8,}$/i, xR = /^[0-9a-z]+$/, wR = /^[0-9A-HJKMNP-TV-Z]{26}$/, SR = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, CR = /^[a-z0-9_-]{21}$/i, PR = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, qR = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, ER = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let qc;
const TR = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, RR = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, kR = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Hb = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", MR = new RegExp(`^${Hb}$`);
function Qb(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function DR(t) {
  return new RegExp(`^${Qb(t)}$`);
}
function Yb(t) {
  let e = `${Hb}T${Qb(t)}`;
  const n = [];
  return n.push(t.local ? "Z?" : "Z"), t.offset && n.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${n.join("|")})`, new RegExp(`^${e}$`);
}
function OR(t, e) {
  return !!((e === "v4" || !e) && TR.test(t) || (e === "v6" || !e) && RR.test(t));
}
class cn extends de {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== K.string) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: V.invalid_type,
        expected: K.string,
        received: i.parsedType
      }), re;
    }
    const s = new Pt();
    let r;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (r = this._getOrReturnCtx(e, r), Q(r, {
          code: V.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), s.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (r = this._getOrReturnCtx(e, r), Q(r, {
          code: V.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), s.dirty());
      else if (i.kind === "length") {
        const o = e.data.length > i.value, a = e.data.length < i.value;
        (o || a) && (r = this._getOrReturnCtx(e, r), o ? Q(r, {
          code: V.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : a && Q(r, {
          code: V.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), s.dirty());
      } else if (i.kind === "email")
        qR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
          validation: "email",
          code: V.invalid_string,
          message: i.message
        }), s.dirty());
      else if (i.kind === "emoji")
        qc || (qc = new RegExp(ER, "u")), qc.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
          validation: "emoji",
          code: V.invalid_string,
          message: i.message
        }), s.dirty());
      else if (i.kind === "uuid")
        SR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
          validation: "uuid",
          code: V.invalid_string,
          message: i.message
        }), s.dirty());
      else if (i.kind === "nanoid")
        CR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
          validation: "nanoid",
          code: V.invalid_string,
          message: i.message
        }), s.dirty());
      else if (i.kind === "cuid")
        vR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
          validation: "cuid",
          code: V.invalid_string,
          message: i.message
        }), s.dirty());
      else if (i.kind === "cuid2")
        xR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
          validation: "cuid2",
          code: V.invalid_string,
          message: i.message
        }), s.dirty());
      else if (i.kind === "ulid")
        wR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
          validation: "ulid",
          code: V.invalid_string,
          message: i.message
        }), s.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          r = this._getOrReturnCtx(e, r), Q(r, {
            validation: "url",
            code: V.invalid_string,
            message: i.message
          }), s.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        validation: "regex",
        code: V.invalid_string,
        message: i.message
      }), s.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), s.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), s.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), s.dirty()) : i.kind === "datetime" ? Yb(i).test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.invalid_string,
        validation: "datetime",
        message: i.message
      }), s.dirty()) : i.kind === "date" ? MR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.invalid_string,
        validation: "date",
        message: i.message
      }), s.dirty()) : i.kind === "time" ? DR(i).test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.invalid_string,
        validation: "time",
        message: i.message
      }), s.dirty()) : i.kind === "duration" ? PR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        validation: "duration",
        code: V.invalid_string,
        message: i.message
      }), s.dirty()) : i.kind === "ip" ? OR(e.data, i.version) || (r = this._getOrReturnCtx(e, r), Q(r, {
        validation: "ip",
        code: V.invalid_string,
        message: i.message
      }), s.dirty()) : i.kind === "base64" ? kR.test(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        validation: "base64",
        code: V.invalid_string,
        message: i.message
      }), s.dirty()) : Ae.assertNever(i);
    return { status: s.value, value: e.data };
  }
  _regex(e, n, s) {
    return this.refinement((r) => e.test(r), {
      validation: n,
      code: V.invalid_string,
      ..._.errToObj(s)
    });
  }
  _addCheck(e) {
    return new cn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ..._.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ..._.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ..._.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ..._.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ..._.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ..._.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ..._.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ..._.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ..._.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ..._.errToObj(e) });
  }
  datetime(e) {
    var n, s;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (n = e == null ? void 0 : e.offset) !== null && n !== void 0 ? n : !1,
      local: (s = e == null ? void 0 : e.local) !== null && s !== void 0 ? s : !1,
      ..._.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ..._.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ..._.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ..._.errToObj(n)
    });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n == null ? void 0 : n.position,
      ..._.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ..._.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ..._.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ..._.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ..._.errToObj(n)
    });
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ..._.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e) {
    return this.min(1, _.errToObj(e));
  }
  trim() {
    return new cn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new cn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new cn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
cn.create = (t) => {
  var e;
  return new cn({
    checks: [],
    typeName: ne.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...ce(t)
  });
};
function LR(t, e) {
  const n = (t.toString().split(".")[1] || "").length, s = (e.toString().split(".")[1] || "").length, r = n > s ? n : s, i = parseInt(t.toFixed(r).replace(".", "")), o = parseInt(e.toFixed(r).replace(".", ""));
  return i % o / Math.pow(10, r);
}
class vs extends de {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== K.number) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: V.invalid_type,
        expected: K.number,
        received: i.parsedType
      }), re;
    }
    let s;
    const r = new Pt();
    for (const i of this._def.checks)
      i.kind === "int" ? Ae.isInteger(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), r.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), r.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), r.dirty()) : i.kind === "multipleOf" ? LR(e.data, i.value) !== 0 && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), r.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.not_finite,
        message: i.message
      }), r.dirty()) : Ae.assertNever(i);
    return { status: r.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, _.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, _.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, _.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, _.toString(n));
  }
  setLimit(e, n, s, r) {
    return new vs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: s,
          message: _.toString(r)
        }
      ]
    });
  }
  _addCheck(e) {
    return new vs({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: _.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: _.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: _.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: _.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: _.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: _.toString(n)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: _.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: _.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: _.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Ae.isInteger(e.value));
  }
  get isFinite() {
    let e = null, n = null;
    for (const s of this._def.checks) {
      if (s.kind === "finite" || s.kind === "int" || s.kind === "multipleOf")
        return !0;
      s.kind === "min" ? (n === null || s.value > n) && (n = s.value) : s.kind === "max" && (e === null || s.value < e) && (e = s.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
vs.create = (t) => new vs({
  checks: [],
  typeName: ne.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...ce(t)
});
class xs extends de {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== K.bigint) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: V.invalid_type,
        expected: K.bigint,
        received: i.parsedType
      }), re;
    }
    let s;
    const r = new Pt();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: V.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), r.dirty()) : Ae.assertNever(i);
    return { status: r.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, _.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, _.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, _.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, _.toString(n));
  }
  setLimit(e, n, s, r) {
    return new xs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: s,
          message: _.toString(r)
        }
      ]
    });
  }
  _addCheck(e) {
    return new xs({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: _.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: _.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: _.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: _.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: _.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
xs.create = (t) => {
  var e;
  return new xs({
    checks: [],
    typeName: ne.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...ce(t)
  });
};
class Zi extends de {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== K.boolean) {
      const s = this._getOrReturnCtx(e);
      return Q(s, {
        code: V.invalid_type,
        expected: K.boolean,
        received: s.parsedType
      }), re;
    }
    return Ot(e.data);
  }
}
Zi.create = (t) => new Zi({
  typeName: ne.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...ce(t)
});
class nr extends de {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== K.date) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: V.invalid_type,
        expected: K.date,
        received: i.parsedType
      }), re;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: V.invalid_date
      }), re;
    }
    const s = new Pt();
    let r;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), s.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: V.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), s.dirty()) : Ae.assertNever(i);
    return {
      status: s.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new nr({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: _.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: _.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
nr.create = (t) => new nr({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: ne.ZodDate,
  ...ce(t)
});
class el extends de {
  _parse(e) {
    if (this._getType(e) !== K.symbol) {
      const s = this._getOrReturnCtx(e);
      return Q(s, {
        code: V.invalid_type,
        expected: K.symbol,
        received: s.parsedType
      }), re;
    }
    return Ot(e.data);
  }
}
el.create = (t) => new el({
  typeName: ne.ZodSymbol,
  ...ce(t)
});
class _i extends de {
  _parse(e) {
    if (this._getType(e) !== K.undefined) {
      const s = this._getOrReturnCtx(e);
      return Q(s, {
        code: V.invalid_type,
        expected: K.undefined,
        received: s.parsedType
      }), re;
    }
    return Ot(e.data);
  }
}
_i.create = (t) => new _i({
  typeName: ne.ZodUndefined,
  ...ce(t)
});
class Ji extends de {
  _parse(e) {
    if (this._getType(e) !== K.null) {
      const s = this._getOrReturnCtx(e);
      return Q(s, {
        code: V.invalid_type,
        expected: K.null,
        received: s.parsedType
      }), re;
    }
    return Ot(e.data);
  }
}
Ji.create = (t) => new Ji({
  typeName: ne.ZodNull,
  ...ce(t)
});
class Vr extends de {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Ot(e.data);
  }
}
Vr.create = (t) => new Vr({
  typeName: ne.ZodAny,
  ...ce(t)
});
class _s extends de {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Ot(e.data);
  }
}
_s.create = (t) => new _s({
  typeName: ne.ZodUnknown,
  ...ce(t)
});
class _n extends de {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return Q(n, {
      code: V.invalid_type,
      expected: K.never,
      received: n.parsedType
    }), re;
  }
}
_n.create = (t) => new _n({
  typeName: ne.ZodNever,
  ...ce(t)
});
class tl extends de {
  _parse(e) {
    if (this._getType(e) !== K.undefined) {
      const s = this._getOrReturnCtx(e);
      return Q(s, {
        code: V.invalid_type,
        expected: K.void,
        received: s.parsedType
      }), re;
    }
    return Ot(e.data);
  }
}
tl.create = (t) => new tl({
  typeName: ne.ZodVoid,
  ...ce(t)
});
class dn extends de {
  _parse(e) {
    const { ctx: n, status: s } = this._processInputParams(e), r = this._def;
    if (n.parsedType !== K.array)
      return Q(n, {
        code: V.invalid_type,
        expected: K.array,
        received: n.parsedType
      }), re;
    if (r.exactLength !== null) {
      const o = n.data.length > r.exactLength.value, a = n.data.length < r.exactLength.value;
      (o || a) && (Q(n, {
        code: o ? V.too_big : V.too_small,
        minimum: a ? r.exactLength.value : void 0,
        maximum: o ? r.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: r.exactLength.message
      }), s.dirty());
    }
    if (r.minLength !== null && n.data.length < r.minLength.value && (Q(n, {
      code: V.too_small,
      minimum: r.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.minLength.message
    }), s.dirty()), r.maxLength !== null && n.data.length > r.maxLength.value && (Q(n, {
      code: V.too_big,
      maximum: r.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: r.maxLength.message
    }), s.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, a) => r.type._parseAsync(new Tn(n, o, n.path, a)))).then((o) => Pt.mergeArray(s, o));
    const i = [...n.data].map((o, a) => r.type._parseSync(new Tn(n, o, n.path, a)));
    return Pt.mergeArray(s, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new dn({
      ...this._def,
      minLength: { value: e, message: _.toString(n) }
    });
  }
  max(e, n) {
    return new dn({
      ...this._def,
      maxLength: { value: e, message: _.toString(n) }
    });
  }
  length(e, n) {
    return new dn({
      ...this._def,
      exactLength: { value: e, message: _.toString(n) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
dn.create = (t, e) => new dn({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ne.ZodArray,
  ...ce(e)
});
function vr(t) {
  if (t instanceof Ye) {
    const e = {};
    for (const n in t.shape) {
      const s = t.shape[n];
      e[n] = Pn.create(vr(s));
    }
    return new Ye({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof dn ? new dn({
    ...t._def,
    type: vr(t.element)
  }) : t instanceof Pn ? Pn.create(vr(t.unwrap())) : t instanceof Ss ? Ss.create(vr(t.unwrap())) : t instanceof Rn ? Rn.create(t.items.map((e) => vr(e))) : t;
}
class Ye extends de {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = Ae.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== K.object) {
      const c = this._getOrReturnCtx(e);
      return Q(c, {
        code: V.invalid_type,
        expected: K.object,
        received: c.parsedType
      }), re;
    }
    const { status: s, ctx: r } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof _n && this._def.unknownKeys === "strip"))
      for (const c in r.data)
        o.includes(c) || a.push(c);
    const l = [];
    for (const c of o) {
      const u = i[c], d = r.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new Tn(r, d, r.path, c)),
        alwaysSet: c in r.data
      });
    }
    if (this._def.catchall instanceof _n) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of a)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: r.data[u] }
          });
      else if (c === "strict")
        a.length > 0 && (Q(r, {
          code: V.unrecognized_keys,
          keys: a
        }), s.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of a) {
        const d = r.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new Tn(r, d, r.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const d = await u.key, f = await u.value;
        c.push({
          key: d,
          value: f,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => Pt.mergeObjectSync(s, c)) : Pt.mergeObjectSync(s, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return _.errToObj, new Ye({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, s) => {
          var r, i, o, a;
          const l = (o = (i = (r = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(r, n, s).message) !== null && o !== void 0 ? o : s.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = _.errToObj(e).message) !== null && a !== void 0 ? a : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new Ye({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Ye({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new Ye({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new Ye({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: ne.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new Ye({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return Ae.objectKeys(e).forEach((s) => {
      e[s] && this.shape[s] && (n[s] = this.shape[s]);
    }), new Ye({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return Ae.objectKeys(this.shape).forEach((s) => {
      e[s] || (n[s] = this.shape[s]);
    }), new Ye({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return vr(this);
  }
  partial(e) {
    const n = {};
    return Ae.objectKeys(this.shape).forEach((s) => {
      const r = this.shape[s];
      e && !e[s] ? n[s] = r : n[s] = r.optional();
    }), new Ye({
      ...this._def,
      shape: () => n
    });
  }
  required(e) {
    const n = {};
    return Ae.objectKeys(this.shape).forEach((s) => {
      if (e && !e[s])
        n[s] = this.shape[s];
      else {
        let i = this.shape[s];
        for (; i instanceof Pn; )
          i = i._def.innerType;
        n[s] = i;
      }
    }), new Ye({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Kb(Ae.objectKeys(this.shape));
  }
}
Ye.create = (t, e) => new Ye({
  shape: () => t,
  unknownKeys: "strip",
  catchall: _n.create(),
  typeName: ne.ZodObject,
  ...ce(e)
});
Ye.strictCreate = (t, e) => new Ye({
  shape: () => t,
  unknownKeys: "strict",
  catchall: _n.create(),
  typeName: ne.ZodObject,
  ...ce(e)
});
Ye.lazycreate = (t, e) => new Ye({
  shape: t,
  unknownKeys: "strip",
  catchall: _n.create(),
  typeName: ne.ZodObject,
  ...ce(e)
});
class $i extends de {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), s = this._def.options;
    function r(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new Gt(a.ctx.common.issues));
      return Q(n, {
        code: V.invalid_union,
        unionErrors: o
      }), re;
    }
    if (n.common.async)
      return Promise.all(s.map(async (i) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(r);
    {
      let i;
      const o = [];
      for (const l of s) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !i && (i = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((l) => new Gt(l));
      return Q(n, {
        code: V.invalid_union,
        unionErrors: a
      }), re;
    }
  }
  get options() {
    return this._def.options;
  }
}
$i.create = (t, e) => new $i({
  options: t,
  typeName: ne.ZodUnion,
  ...ce(e)
});
const In = (t) => t instanceof no ? In(t.schema) : t instanceof hn ? In(t.innerType()) : t instanceof so ? [t.value] : t instanceof ws ? t.options : t instanceof ro ? Ae.objectValues(t.enum) : t instanceof io ? In(t._def.innerType) : t instanceof _i ? [void 0] : t instanceof Ji ? [null] : t instanceof Pn ? [void 0, ...In(t.unwrap())] : t instanceof Ss ? [null, ...In(t.unwrap())] : t instanceof Kd || t instanceof ao ? In(t.unwrap()) : t instanceof oo ? In(t._def.innerType) : [];
class Ll extends de {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== K.object)
      return Q(n, {
        code: V.invalid_type,
        expected: K.object,
        received: n.parsedType
      }), re;
    const s = this.discriminator, r = n.data[s], i = this.optionsMap.get(r);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (Q(n, {
      code: V.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [s]
    }), re);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, n, s) {
    const r = /* @__PURE__ */ new Map();
    for (const i of n) {
      const o = In(i.shape[e]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const a of o) {
        if (r.has(a))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
        r.set(a, i);
      }
    }
    return new Ll({
      typeName: ne.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: r,
      ...ce(s)
    });
  }
}
function Eu(t, e) {
  const n = cs(t), s = cs(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === K.object && s === K.object) {
    const r = Ae.objectKeys(e), i = Ae.objectKeys(t).filter((a) => r.indexOf(a) !== -1), o = { ...t, ...e };
    for (const a of i) {
      const l = Eu(t[a], e[a]);
      if (!l.valid)
        return { valid: !1 };
      o[a] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === K.array && s === K.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const r = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i], l = Eu(o, a);
      if (!l.valid)
        return { valid: !1 };
      r.push(l.data);
    }
    return { valid: !0, data: r };
  } else return n === K.date && s === K.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class eo extends de {
  _parse(e) {
    const { status: n, ctx: s } = this._processInputParams(e), r = (i, o) => {
      if (Pu(i) || Pu(o))
        return re;
      const a = Eu(i.value, o.value);
      return a.valid ? ((qu(i) || qu(o)) && n.dirty(), { status: n.value, value: a.data }) : (Q(s, {
        code: V.invalid_intersection_types
      }), re);
    };
    return s.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      }),
      this._def.right._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      })
    ]).then(([i, o]) => r(i, o)) : r(this._def.left._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }), this._def.right._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }));
  }
}
eo.create = (t, e, n) => new eo({
  left: t,
  right: e,
  typeName: ne.ZodIntersection,
  ...ce(n)
});
class Rn extends de {
  _parse(e) {
    const { status: n, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== K.array)
      return Q(s, {
        code: V.invalid_type,
        expected: K.array,
        received: s.parsedType
      }), re;
    if (s.data.length < this._def.items.length)
      return Q(s, {
        code: V.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), re;
    !this._def.rest && s.data.length > this._def.items.length && (Q(s, {
      code: V.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...s.data].map((o, a) => {
      const l = this._def.items[a] || this._def.rest;
      return l ? l._parse(new Tn(s, o, s.path, a)) : null;
    }).filter((o) => !!o);
    return s.common.async ? Promise.all(i).then((o) => Pt.mergeArray(n, o)) : Pt.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Rn({
      ...this._def,
      rest: e
    });
  }
}
Rn.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Rn({
    items: t,
    typeName: ne.ZodTuple,
    rest: null,
    ...ce(e)
  });
};
class to extends de {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== K.object)
      return Q(s, {
        code: V.invalid_type,
        expected: K.object,
        received: s.parsedType
      }), re;
    const r = [], i = this._def.keyType, o = this._def.valueType;
    for (const a in s.data)
      r.push({
        key: i._parse(new Tn(s, a, s.path, a)),
        value: o._parse(new Tn(s, s.data[a], s.path, a)),
        alwaysSet: a in s.data
      });
    return s.common.async ? Pt.mergeObjectAsync(n, r) : Pt.mergeObjectSync(n, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, s) {
    return n instanceof de ? new to({
      keyType: e,
      valueType: n,
      typeName: ne.ZodRecord,
      ...ce(s)
    }) : new to({
      keyType: cn.create(),
      valueType: e,
      typeName: ne.ZodRecord,
      ...ce(n)
    });
  }
}
class nl extends de {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== K.map)
      return Q(s, {
        code: V.invalid_type,
        expected: K.map,
        received: s.parsedType
      }), re;
    const r = this._def.keyType, i = this._def.valueType, o = [...s.data.entries()].map(([a, l], c) => ({
      key: r._parse(new Tn(s, a, s.path, [c, "key"])),
      value: i._parse(new Tn(s, l, s.path, [c, "value"]))
    }));
    if (s.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return re;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const l of o) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return re;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value);
      }
      return { status: n.value, value: a };
    }
  }
}
nl.create = (t, e, n) => new nl({
  valueType: e,
  keyType: t,
  typeName: ne.ZodMap,
  ...ce(n)
});
class sr extends de {
  _parse(e) {
    const { status: n, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== K.set)
      return Q(s, {
        code: V.invalid_type,
        expected: K.set,
        received: s.parsedType
      }), re;
    const r = this._def;
    r.minSize !== null && s.data.size < r.minSize.value && (Q(s, {
      code: V.too_small,
      minimum: r.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.minSize.message
    }), n.dirty()), r.maxSize !== null && s.data.size > r.maxSize.value && (Q(s, {
      code: V.too_big,
      maximum: r.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: r.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function o(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return re;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    const a = [...s.data.values()].map((l, c) => i._parse(new Tn(s, l, s.path, c)));
    return s.common.async ? Promise.all(a).then((l) => o(l)) : o(a);
  }
  min(e, n) {
    return new sr({
      ...this._def,
      minSize: { value: e, message: _.toString(n) }
    });
  }
  max(e, n) {
    return new sr({
      ...this._def,
      maxSize: { value: e, message: _.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
sr.create = (t, e) => new sr({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: ne.ZodSet,
  ...ce(e)
});
class kr extends de {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== K.function)
      return Q(n, {
        code: V.invalid_type,
        expected: K.function,
        received: n.parsedType
      }), re;
    function s(a, l) {
      return Ja({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          _a(),
          Fr
        ].filter((c) => !!c),
        issueData: {
          code: V.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function r(a, l) {
      return Ja({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          _a(),
          Fr
        ].filter((c) => !!c),
        issueData: {
          code: V.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof zr) {
      const a = this;
      return Ot(async function(...l) {
        const c = new Gt([]), u = await a._def.args.parseAsync(l, i).catch((h) => {
          throw c.addIssue(s(l, h)), c;
        }), d = await Reflect.apply(o, this, u);
        return await a._def.returns._def.type.parseAsync(d, i).catch((h) => {
          throw c.addIssue(r(d, h)), c;
        });
      });
    } else {
      const a = this;
      return Ot(function(...l) {
        const c = a._def.args.safeParse(l, i);
        if (!c.success)
          throw new Gt([s(l, c.error)]);
        const u = Reflect.apply(o, this, c.data), d = a._def.returns.safeParse(u, i);
        if (!d.success)
          throw new Gt([r(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new kr({
      ...this._def,
      args: Rn.create(e).rest(_s.create())
    });
  }
  returns(e) {
    return new kr({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, s) {
    return new kr({
      args: e || Rn.create([]).rest(_s.create()),
      returns: n || _s.create(),
      typeName: ne.ZodFunction,
      ...ce(s)
    });
  }
}
class no extends de {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
no.create = (t, e) => new no({
  getter: t,
  typeName: ne.ZodLazy,
  ...ce(e)
});
class so extends de {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return Q(n, {
        received: n.data,
        code: V.invalid_literal,
        expected: this._def.value
      }), re;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
so.create = (t, e) => new so({
  value: t,
  typeName: ne.ZodLiteral,
  ...ce(e)
});
function Kb(t, e) {
  return new ws({
    values: t,
    typeName: ne.ZodEnum,
    ...ce(e)
  });
}
class ws extends de {
  constructor() {
    super(...arguments), Si.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), s = this._def.values;
      return Q(n, {
        expected: Ae.joinValues(s),
        received: n.parsedType,
        code: V.invalid_type
      }), re;
    }
    if ($a(this, Si) || Wb(this, Si, new Set(this._def.values)), !$a(this, Si).has(e.data)) {
      const n = this._getOrReturnCtx(e), s = this._def.values;
      return Q(n, {
        received: n.data,
        code: V.invalid_enum_value,
        options: s
      }), re;
    }
    return Ot(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  extract(e, n = this._def) {
    return ws.create(e, {
      ...this._def,
      ...n
    });
  }
  exclude(e, n = this._def) {
    return ws.create(this.options.filter((s) => !e.includes(s)), {
      ...this._def,
      ...n
    });
  }
}
Si = /* @__PURE__ */ new WeakMap();
ws.create = Kb;
class ro extends de {
  constructor() {
    super(...arguments), Ci.set(this, void 0);
  }
  _parse(e) {
    const n = Ae.getValidEnumValues(this._def.values), s = this._getOrReturnCtx(e);
    if (s.parsedType !== K.string && s.parsedType !== K.number) {
      const r = Ae.objectValues(n);
      return Q(s, {
        expected: Ae.joinValues(r),
        received: s.parsedType,
        code: V.invalid_type
      }), re;
    }
    if ($a(this, Ci) || Wb(this, Ci, new Set(Ae.getValidEnumValues(this._def.values))), !$a(this, Ci).has(e.data)) {
      const r = Ae.objectValues(n);
      return Q(s, {
        received: s.data,
        code: V.invalid_enum_value,
        options: r
      }), re;
    }
    return Ot(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Ci = /* @__PURE__ */ new WeakMap();
ro.create = (t, e) => new ro({
  values: t,
  typeName: ne.ZodNativeEnum,
  ...ce(e)
});
class zr extends de {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== K.promise && n.common.async === !1)
      return Q(n, {
        code: V.invalid_type,
        expected: K.promise,
        received: n.parsedType
      }), re;
    const s = n.parsedType === K.promise ? n.data : Promise.resolve(n.data);
    return Ot(s.then((r) => this._def.type.parseAsync(r, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
zr.create = (t, e) => new zr({
  type: t,
  typeName: ne.ZodPromise,
  ...ce(e)
});
class hn extends de {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ne.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: s } = this._processInputParams(e), r = this._def.effect || null, i = {
      addIssue: (o) => {
        Q(s, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return s.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), r.type === "preprocess") {
      const o = r.transform(s.data, i);
      if (s.common.async)
        return Promise.resolve(o).then(async (a) => {
          if (n.value === "aborted")
            return re;
          const l = await this._def.schema._parseAsync({
            data: a,
            path: s.path,
            parent: s
          });
          return l.status === "aborted" ? re : l.status === "dirty" || n.value === "dirty" ? qr(l.value) : l;
        });
      {
        if (n.value === "aborted")
          return re;
        const a = this._def.schema._parseSync({
          data: o,
          path: s.path,
          parent: s
        });
        return a.status === "aborted" ? re : a.status === "dirty" || n.value === "dirty" ? qr(a.value) : a;
      }
    }
    if (r.type === "refinement") {
      const o = (a) => {
        const l = r.refinement(a, i);
        if (s.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (s.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return a.status === "aborted" ? re : (a.status === "dirty" && n.dirty(), o(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((a) => a.status === "aborted" ? re : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (r.type === "transform")
      if (s.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        if (!Xi(o))
          return o;
        const a = r.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((o) => Xi(o) ? Promise.resolve(r.transform(o.value, i)).then((a) => ({ status: n.value, value: a })) : o);
    Ae.assertNever(r);
  }
}
hn.create = (t, e, n) => new hn({
  schema: t,
  typeName: ne.ZodEffects,
  effect: e,
  ...ce(n)
});
hn.createWithPreprocess = (t, e, n) => new hn({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: ne.ZodEffects,
  ...ce(n)
});
class Pn extends de {
  _parse(e) {
    return this._getType(e) === K.undefined ? Ot(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Pn.create = (t, e) => new Pn({
  innerType: t,
  typeName: ne.ZodOptional,
  ...ce(e)
});
class Ss extends de {
  _parse(e) {
    return this._getType(e) === K.null ? Ot(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ss.create = (t, e) => new Ss({
  innerType: t,
  typeName: ne.ZodNullable,
  ...ce(e)
});
class io extends de {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let s = n.data;
    return n.parsedType === K.undefined && (s = this._def.defaultValue()), this._def.innerType._parse({
      data: s,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
io.create = (t, e) => new io({
  innerType: t,
  typeName: ne.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...ce(e)
});
class oo extends de {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), s = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, r = this._def.innerType._parse({
      data: s.data,
      path: s.path,
      parent: {
        ...s
      }
    });
    return Gi(r) ? r.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Gt(s.common.issues);
        },
        input: s.data
      })
    })) : {
      status: "valid",
      value: r.status === "valid" ? r.value : this._def.catchValue({
        get error() {
          return new Gt(s.common.issues);
        },
        input: s.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
oo.create = (t, e) => new oo({
  innerType: t,
  typeName: ne.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...ce(e)
});
class sl extends de {
  _parse(e) {
    if (this._getType(e) !== K.nan) {
      const s = this._getOrReturnCtx(e);
      return Q(s, {
        code: V.invalid_type,
        expected: K.nan,
        received: s.parsedType
      }), re;
    }
    return { status: "valid", value: e.data };
  }
}
sl.create = (t) => new sl({
  typeName: ne.ZodNaN,
  ...ce(t)
});
const NR = Symbol("zod_brand");
class Kd extends de {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), s = n.data;
    return this._def.type._parse({
      data: s,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class qo extends de {
  _parse(e) {
    const { status: n, ctx: s } = this._processInputParams(e);
    if (s.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return i.status === "aborted" ? re : i.status === "dirty" ? (n.dirty(), qr(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: s.path,
          parent: s
        });
      })();
    {
      const r = this._def.in._parseSync({
        data: s.data,
        path: s.path,
        parent: s
      });
      return r.status === "aborted" ? re : r.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: r.value
      }) : this._def.out._parseSync({
        data: r.value,
        path: s.path,
        parent: s
      });
    }
  }
  static create(e, n) {
    return new qo({
      in: e,
      out: n,
      typeName: ne.ZodPipeline
    });
  }
}
class ao extends de {
  _parse(e) {
    const n = this._def.innerType._parse(e), s = (r) => (Xi(r) && (r.value = Object.freeze(r.value)), r);
    return Gi(n) ? n.then((r) => s(r)) : s(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ao.create = (t, e) => new ao({
  innerType: t,
  typeName: ne.ZodReadonly,
  ...ce(e)
});
function Xb(t, e = {}, n) {
  return t ? Vr.create().superRefine((s, r) => {
    var i, o;
    if (!t(s)) {
      const a = typeof e == "function" ? e(s) : typeof e == "string" ? { message: e } : e, l = (o = (i = a.fatal) !== null && i !== void 0 ? i : n) !== null && o !== void 0 ? o : !0, c = typeof a == "string" ? { message: a } : a;
      r.addIssue({ code: "custom", ...c, fatal: l });
    }
  }) : Vr.create();
}
const jR = {
  object: Ye.lazycreate
};
var ne;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(ne || (ne = {}));
const BR = (t, e = {
  message: `Input not instance of ${t.name}`
}) => Xb((n) => n instanceof t, e), Gb = cn.create, Zb = vs.create, IR = sl.create, FR = xs.create, _b = Zi.create, VR = nr.create, zR = el.create, UR = _i.create, WR = Ji.create, HR = Vr.create, QR = _s.create, YR = _n.create, KR = tl.create, XR = dn.create, GR = Ye.create, ZR = Ye.strictCreate, _R = $i.create, JR = Ll.create, $R = eo.create, ek = Rn.create, tk = to.create, nk = nl.create, sk = sr.create, rk = kr.create, ik = no.create, ok = so.create, ak = ws.create, lk = ro.create, ck = zr.create, ig = hn.create, uk = Pn.create, dk = Ss.create, fk = hn.createWithPreprocess, hk = qo.create, pk = () => Gb().optional(), gk = () => Zb().optional(), mk = () => _b().optional(), Ak = {
  string: (t) => cn.create({ ...t, coerce: !0 }),
  number: (t) => vs.create({ ...t, coerce: !0 }),
  boolean: (t) => Zi.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => xs.create({ ...t, coerce: !0 }),
  date: (t) => nr.create({ ...t, coerce: !0 })
}, bk = re;
var Re = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Fr,
  setErrorMap: bR,
  getErrorMap: _a,
  makeIssue: Ja,
  EMPTY_PATH: yR,
  addIssueToContext: Q,
  ParseStatus: Pt,
  INVALID: re,
  DIRTY: qr,
  OK: Ot,
  isAborted: Pu,
  isDirty: qu,
  isValid: Xi,
  isAsync: Gi,
  get util() {
    return Ae;
  },
  get objectUtil() {
    return Cu;
  },
  ZodParsedType: K,
  getParsedType: cs,
  ZodType: de,
  datetimeRegex: Yb,
  ZodString: cn,
  ZodNumber: vs,
  ZodBigInt: xs,
  ZodBoolean: Zi,
  ZodDate: nr,
  ZodSymbol: el,
  ZodUndefined: _i,
  ZodNull: Ji,
  ZodAny: Vr,
  ZodUnknown: _s,
  ZodNever: _n,
  ZodVoid: tl,
  ZodArray: dn,
  ZodObject: Ye,
  ZodUnion: $i,
  ZodDiscriminatedUnion: Ll,
  ZodIntersection: eo,
  ZodTuple: Rn,
  ZodRecord: to,
  ZodMap: nl,
  ZodSet: sr,
  ZodFunction: kr,
  ZodLazy: no,
  ZodLiteral: so,
  ZodEnum: ws,
  ZodNativeEnum: ro,
  ZodPromise: zr,
  ZodEffects: hn,
  ZodTransformer: hn,
  ZodOptional: Pn,
  ZodNullable: Ss,
  ZodDefault: io,
  ZodCatch: oo,
  ZodNaN: sl,
  BRAND: NR,
  ZodBranded: Kd,
  ZodPipeline: qo,
  ZodReadonly: ao,
  custom: Xb,
  Schema: de,
  ZodSchema: de,
  late: jR,
  get ZodFirstPartyTypeKind() {
    return ne;
  },
  coerce: Ak,
  any: HR,
  array: XR,
  bigint: FR,
  boolean: _b,
  date: VR,
  discriminatedUnion: JR,
  effect: ig,
  enum: ak,
  function: rk,
  instanceof: BR,
  intersection: $R,
  lazy: ik,
  literal: ok,
  map: nk,
  nan: IR,
  nativeEnum: lk,
  never: YR,
  null: WR,
  nullable: dk,
  number: Zb,
  object: GR,
  oboolean: mk,
  onumber: gk,
  optional: uk,
  ostring: pk,
  pipeline: hk,
  preprocess: fk,
  promise: ck,
  record: tk,
  set: sk,
  strictObject: ZR,
  string: Gb,
  symbol: zR,
  transformer: ig,
  tuple: ek,
  undefined: UR,
  union: _R,
  unknown: QR,
  void: KR,
  NEVER: bk,
  ZodIssueCode: V,
  quotelessJson: AR,
  ZodError: Gt
});
const og = {
  mode: "manual",
  betAmount: 0,
  coinSide: "HEADS",
  stopOnWin: 0,
  stopOnLoss: 0,
  numberOfBets: "∞",
  onWinMode: "reset",
  onLossMode: "reset",
  onWinValue: 0,
  onLossValue: 0
}, ya = Gr((t, e) => ({
  ...og,
  errors: {},
  updateSettings: (n) => t((s) => {
    const r = { ...s, ...n };
    return n.onWinMode === "reset" && s.onWinMode !== "reset" && (r.onWinValue = 0), n.onLossMode === "reset" && s.onLossMode !== "reset" && (r.onLossValue = 0), r;
  }),
  resetSettings: () => t(og),
  validateSettings: () => {
    const { betRanges: n, selectedCurrency: s, balance: r } = it.getState(), i = e(), o = Re.object({
      mode: Re.enum(["manual", "auto"]),
      betAmount: Re.number().min(parseFloat(n.minBet), `Your bet must be at least ${s.prefixSymbol} ${n.minBet}`).max(parseFloat(n.maxBet), `Your bet can max be ${s.prefixSymbol} ${n.maxBet}`).max(r, "You don't have enough balance."),
      coinSide: Re.enum(["HEADS", "TAILS", "EDGE"]),
      stopOnWin: Re.number().nonnegative("Stop on win must be non-negative").max(r, "You don't have enough balance."),
      stopOnLoss: Re.number().nonnegative("Stop on loss must be non-negative"),
      numberOfBets: Re.union([
        Re.literal("∞"),
        Re.string().refine(
          (a) => !isNaN(Number(a)) && Number(a) > 0 && Number(a) <= 1e3,
          {
            message: "Number of bets must be a positive number up to 1000 or '∞'"
          }
        ),
        Re.number().int().positive().max(1e3, "Maximum 1000")
      ]).transform((a) => a === "∞" ? a : Number(a)),
      onWinMode: Re.enum(["reset", "increase"]),
      onLossMode: Re.enum(["reset", "increase"]),
      onWinValue: Re.number().nonnegative("Cannot be less than 0"),
      onLossValue: Re.number().nonnegative("Cannot be less than 0")
    });
    try {
      return o.parse(i), t({ errors: {} }), !0;
    } catch (a) {
      if (a instanceof Re.ZodError) {
        const l = {};
        a.issues.forEach((c) => {
          c.path[0] && (l[c.path[0]] = c.message, console.log("newErrors", c.message));
        }), t({ errors: l });
      }
      return !1;
    }
  },
  setErrors: (n) => t({ errors: n })
}));
function yk({ handleStartGame: t }) {
  const {
    isGameActive: e,
    selectedCurrency: n,
    initializing: s,
    isAutoPlaying: r,
    currentAutoBet: i,
    setIsAutoPlaying: o,
    setIsFinishingBet: a,
    betRanges: l
  } = it(), {
    updateSettings: c,
    mode: u,
    betAmount: d,
    stopOnWin: f,
    stopOnLoss: h,
    numberOfBets: p,
    onWinMode: g,
    onLossMode: A,
    onWinValue: b,
    onLossValue: y,
    coinSide: w,
    errors: x,
    validateSettings: S
  } = ya(), q = (G) => G.toFixed(n.fractionalDigits), [C, E] = tt(
    q(d)
  ), [T, k] = tt(null);
  je(() => {
    d > Number(l.minBet) ? E(q(d)) : l.minBet && E(q(Number(l.minBet)));
  }, [
    n,
    d,
    E,
    l.minBet,
    q
  ]);
  const R = (G, pe, Me = !1) => {
    Me && Ft("tick"), c({ [G]: pe });
  }, D = (G) => {
    E(G.target.value);
  }, F = () => {
    const G = parseFloat(C);
    isNaN(G) ? E(q(d)) : (R("betAmount", G), E(q(G))), k(null);
  }, j = () => {
    r ? (o(!1), a(!0)) : S() && t();
  }, B = () => r ? p === "∞" ? st("blink.common.stopAutoBet") : `${st(
    "blink.common.stopAutoBet"
  )} (${i} / ${p})` : st(u === "auto" ? "blink.common.startAutoBet" : e ? "blink.cointoss.flipping" : "blink.common.placeBet"), L = (G) => `
      flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200
      ${T === G ? "ring-1 ring-brand" : ""}`, O = "flex-grow bg-transparent border-none text-white text-base h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0", N = "h-9 w-16 px-2 text-sm bg-pills text-white hover:bg-opacity-80 font-bold", H = "flex items-center space-x-1 bg-primary rounded-md p-1 h-11 w-1/2", U = "flex-1 px-1 py-2 rounded text-xs font-bold whitespace-nowrap overflow-hidden", X = e || r;
  return /* @__PURE__ */ m.jsxs("div", { className: "bg-secondary flex flex-col no-scrollbar w-full lg:w-1/3 p-4 space-y-4 order-2 lg:order-1 overflow-y-auto", children: [
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: `bg-primary order-last lg:order-first p-2 rounded-md flex mt-4 lg:mb-4 lg:mt-0 ${X ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ m.jsx(
            "button",
            {
              onClick: () => R("mode", "manual", !0),
              disabled: e && u !== "manual",
              className: `flex-1 py-2 px-4 text-sm font-bold rounded-md transition-all ${u === "manual" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: st("blink.common.manual")
            }
          ),
          /* @__PURE__ */ m.jsx(
            "button",
            {
              onClick: () => R("mode", "auto", !0),
              disabled: e && u !== "auto",
              className: `flex-1 py-2 px-4 text-sm font-bold rounded-md transition-all ${u === "auto" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: st("blink.common.auto")
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: `space-y-2 ${X ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ m.jsx(rt, { htmlFor: "betAmount", className: "text-sm text-gray-400", children: st("blink.common.betAmount") }),
          /* @__PURE__ */ m.jsx("div", { className: L("betAmount"), children: s ? /* @__PURE__ */ m.jsxs("div", { className: "flex items-center w-full space-x-2", children: [
            /* @__PURE__ */ m.jsx(ps, { className: "h-9 w-full bg-gray-700" }),
            /* @__PURE__ */ m.jsx(ps, { className: "h-9 w-16 bg-gray-700" }),
            /* @__PURE__ */ m.jsx(ps, { className: "h-9 w-16 bg-gray-700" })
          ] }) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
            /* @__PURE__ */ m.jsxs("div", { className: "flex items-center w-full bg-primary rounded-md px-2", children: [
              /* @__PURE__ */ m.jsx("span", { className: "text-gray-400 mr-1", children: n.prefixSymbol }),
              /* @__PURE__ */ m.jsx(
                ft,
                {
                  id: "betAmount",
                  type: "number",
                  value: C,
                  onChange: D,
                  onFocus: () => k("betAmount"),
                  onBlur: F,
                  className: O,
                  style: {
                    WebkitAppearance: "none",
                    MozAppearance: "textfield"
                  },
                  step: `0.${"0".repeat(
                    n.fractionalDigits - 1
                  )}1`
                }
              )
            ] }),
            /* @__PURE__ */ m.jsx(
              lt,
              {
                variant: "ghost",
                size: "sm",
                className: N,
                onClick: () => {
                  const G = Math.max(Number(C) / 2, 0);
                  R("betAmount", G, !0), E(q(G));
                },
                children: "½"
              }
            ),
            /* @__PURE__ */ m.jsx(
              lt,
              {
                variant: "ghost",
                size: "sm",
                className: N,
                onClick: () => {
                  const G = Number(C) * 2;
                  R("betAmount", G, !0), E(q(G));
                },
                children: "2×"
              }
            )
          ] }) }),
          x.betAmount && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: x.betAmount })
        ]
      }
    ),
    /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ m.jsx(rt, { className: "text-sm text-gray-400", children: "Coin Side" }),
      /* @__PURE__ */ m.jsx("div", { className: "flex items-center space-x-2 w-full", children: /* @__PURE__ */ m.jsxs("div", { className: `${H} w-full`, children: [
        /* @__PURE__ */ m.jsx(
          "button",
          {
            onClick: () => R("coinSide", "HEADS", !0),
            className: `${U} ${w === "HEADS" ? "bg-pills text-white" : "text-gray-400"}`,
            children: st("blink.cointoss.heads")
          }
        ),
        /* @__PURE__ */ m.jsx(
          "button",
          {
            onClick: () => R("coinSide", "EDGE", !0),
            className: `${U} ${w === "EDGE" ? "bg-pills text-white" : "text-gray-400"}`,
            children: st("blink.cointoss.edge")
          }
        ),
        /* @__PURE__ */ m.jsx(
          "button",
          {
            onClick: () => R("coinSide", "TAILS", !0),
            className: `${U} ${w === "TAILS" ? "bg-pills text-white" : "text-gray-400"}`,
            children: st("blink.cointoss.tails")
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ m.jsx(
      "div",
      {
        className: "space-y-4 transition-all duration-300 ease-in-out",
        style: {
          maxHeight: u === "auto" ? "100%" : "0%",
          overflow: u === "auto" ? "visible" : "hidden"
        },
        children: u === "auto" && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              className: `space-y-2 ${X ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ m.jsx(rt, { htmlFor: "numberOfBets", className: "text-sm text-gray-400", children: st("blink.common.numberOfBets") }),
                /* @__PURE__ */ m.jsxs("div", { className: L("numberOfBets"), children: [
                  /* @__PURE__ */ m.jsx(
                    ft,
                    {
                      id: "numberOfBets",
                      value: p,
                      onChange: (G) => R("numberOfBets", G.target.value, !1),
                      onFocus: () => k("numberOfBets"),
                      onBlur: () => k(null),
                      className: O
                    }
                  ),
                  ["∞", "10", "100"].map((G) => /* @__PURE__ */ m.jsx(
                    lt,
                    {
                      variant: p === G ? "secondary" : "ghost",
                      onClick: () => R("numberOfBets", G, !0),
                      className: N,
                      children: G
                    },
                    G
                  ))
                ] }),
                x.numberOfBets && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: x.numberOfBets })
              ]
            }
          ),
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              className: `space-y-2 ${X ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ m.jsxs(rt, { className: "text-sm text-gray-400", children: [
                  " ",
                  st("blink.common.onWin"),
                  " "
                ] }),
                /* @__PURE__ */ m.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ m.jsxs("div", { className: H, children: [
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => R("onWinMode", "reset", !0),
                        className: `${U} ${g === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: st("blink.common.reset")
                      }
                    ),
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => R("onWinMode", "increase", !0),
                        className: `${U} ${g === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: st("blink.common.increaseBy")
                      }
                    )
                  ] }),
                  /* @__PURE__ */ m.jsxs(
                    "div",
                    {
                      className: `${L("onWinValue")} ${g === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ m.jsx(
                          ft,
                          {
                            type: "number",
                            value: b,
                            onChange: (G) => R(
                              "onWinValue",
                              parseFloat(G.target.value)
                            ),
                            onFocus: () => k("onWinValue"),
                            onBlur: () => k(null),
                            className: O,
                            disabled: g === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ m.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                x.onWinValue && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: x.onWinValue })
              ]
            }
          ),
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              className: `space-y-2 ${X ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ m.jsxs(rt, { className: "text-sm text-gray-400", children: [
                  " ",
                  st("blink.common.onLoss"),
                  " "
                ] }),
                /* @__PURE__ */ m.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ m.jsxs("div", { className: H, children: [
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => R("onLossMode", "reset", !0),
                        className: `${U} ${A === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: st("blink.common.reset")
                      }
                    ),
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => R("onLossMode", "increase", !0),
                        className: `${U} ${A === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: st("blink.common.increaseBy")
                      }
                    )
                  ] }),
                  /* @__PURE__ */ m.jsxs(
                    "div",
                    {
                      className: `${L("onLossValue")} ${A === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ m.jsx(
                          ft,
                          {
                            type: "number",
                            value: y,
                            onChange: (G) => R(
                              "onLossValue",
                              parseFloat(G.target.value)
                            ),
                            onFocus: () => k("onLossValue"),
                            onBlur: () => k(null),
                            className: O,
                            disabled: A === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ m.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                x.onLossValue && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: x.onLossValue })
              ]
            }
          ),
          /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ m.jsx(rt, { htmlFor: "stopOnWin", className: "text-sm text-gray-400", children: st("blink.common.stopOnWin") }),
            /* @__PURE__ */ m.jsx("div", { className: L("stopOnWin"), children: /* @__PURE__ */ m.jsx(
              ft,
              {
                id: "stopOnWin",
                type: "number",
                value: f,
                onChange: (G) => R("stopOnWin", parseFloat(G.target.value)),
                onFocus: () => k("stopOnWin"),
                onBlur: () => k(null),
                className: O,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] }),
          /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ m.jsx(rt, { htmlFor: "stopOnLoss", className: "text-sm text-gray-400", children: st("blink.common.stopOnLoss") }),
            /* @__PURE__ */ m.jsx("div", { className: L("stopOnLoss"), children: /* @__PURE__ */ m.jsx(
              ft,
              {
                id: "stopOnLoss",
                type: "number",
                value: h,
                onChange: (G) => R(
                  "stopOnLoss",
                  parseFloat(G.target.value)
                ),
                onFocus: () => k("stopOnLoss"),
                onBlur: () => k(null),
                className: O,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ m.jsx("div", { className: "lg:sticky lg:bottom-0 order-first lg:order-last bg-gray-850", children: /* @__PURE__ */ m.jsx(
      lt,
      {
        className: "w-full bg-gradient-to-b from-brand-gradient-start to-brand-gradient-end hover:from-brand hover:to-brand disabled:opacity-80 text-brand-cta-text text-sm font-bold py-4 rounded-lg h-11",
        onClick: j,
        children: B()
      }
    ) })
  ] });
}
function we(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(r) {
    if (t == null || t(r), n === !1 || !r.defaultPrevented)
      return e == null ? void 0 : e(r);
  };
}
function vk(t, e) {
  const n = v.createContext(e), s = (i) => {
    const { children: o, ...a } = i, l = v.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ m.jsx(n.Provider, { value: l, children: o });
  };
  s.displayName = t + "Provider";
  function r(i) {
    const o = v.useContext(n);
    if (o) return o;
    if (e !== void 0) return e;
    throw new Error(`\`${i}\` must be used within \`${t}\``);
  }
  return [s, r];
}
function xk(t, e = []) {
  let n = [];
  function s(i, o) {
    const a = v.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, g = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[l]) || a, A = v.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ m.jsx(g.Provider, { value: A, children: h });
    };
    c.displayName = i + "Provider";
    function u(d, f) {
      var g;
      const h = ((g = f == null ? void 0 : f[t]) == null ? void 0 : g[l]) || a, p = v.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const r = () => {
    const i = n.map((o) => v.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[t]) || i;
      return v.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return r.scopeName = t, [s, wk(r, ...e)];
}
function wk(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const s = t.map((r) => ({
      useScope: r(),
      scopeName: r.scopeName
    }));
    return function(i) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return v.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
var Lt = globalThis != null && globalThis.document ? v.useLayoutEffect : () => {
}, Sk = v.useId || (() => {
}), Ck = 0;
function Mr(t) {
  const [e, n] = v.useState(Sk());
  return Lt(() => {
    n((s) => s ?? String(Ck++));
  }, [t]), e ? `radix-${e}` : "";
}
function bt(t) {
  const e = v.useRef(t);
  return v.useEffect(() => {
    e.current = t;
  }), v.useMemo(() => (...n) => {
    var s;
    return (s = e.current) == null ? void 0 : s.call(e, ...n);
  }, []);
}
function ni({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  }
}) {
  const [s, r] = Pk({ defaultProp: e, onChange: n }), i = t !== void 0, o = i ? t : s, a = bt(n), l = v.useCallback(
    (c) => {
      if (i) {
        const d = typeof c == "function" ? c(t) : c;
        d !== t && a(d);
      } else
        r(c);
    },
    [i, t, r, a]
  );
  return [o, l];
}
function Pk({
  defaultProp: t,
  onChange: e
}) {
  const n = v.useState(t), [s] = n, r = v.useRef(s), i = bt(e);
  return v.useEffect(() => {
    r.current !== s && (i(s), r.current = s);
  }, [s, r, i]), n;
}
function Jb(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = bt(t);
  v.useEffect(() => {
    const s = (r) => {
      r.key === "Escape" && n(r);
    };
    return e.addEventListener("keydown", s, { capture: !0 }), () => e.removeEventListener("keydown", s, { capture: !0 });
  }, [n, e]);
}
var qk = "DismissableLayer", Tu = "dismissableLayer.update", Ek = "dismissableLayer.pointerDownOutside", Tk = "dismissableLayer.focusOutside", ag, $b = v.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), ey = v.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: s,
      onPointerDownOutside: r,
      onFocusOutside: i,
      onInteractOutside: o,
      onDismiss: a,
      ...l
    } = t, c = v.useContext($b), [u, d] = v.useState(null), f = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = v.useState({}), p = Pe(e, (C) => d(C)), g = Array.from(c.layers), [A] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), b = g.indexOf(A), y = u ? g.indexOf(u) : -1, w = c.layersWithOutsidePointerEventsDisabled.size > 0, x = y >= b, S = Mk((C) => {
      const E = C.target, T = [...c.branches].some((k) => k.contains(E));
      !x || T || (r == null || r(C), o == null || o(C), C.defaultPrevented || a == null || a());
    }, f), q = Dk((C) => {
      const E = C.target;
      [...c.branches].some((k) => k.contains(E)) || (i == null || i(C), o == null || o(C), C.defaultPrevented || a == null || a());
    }, f);
    return Jb((C) => {
      y === c.layers.size - 1 && (s == null || s(C), !C.defaultPrevented && a && (C.preventDefault(), a()));
    }, f), v.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (ag = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), lg(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = ag);
        };
    }, [u, f, n, c]), v.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), lg());
    }, [u, c]), v.useEffect(() => {
      const C = () => h({});
      return document.addEventListener(Tu, C), () => document.removeEventListener(Tu, C);
    }, []), /* @__PURE__ */ m.jsx(
      qe.div,
      {
        ...l,
        ref: p,
        style: {
          pointerEvents: w ? x ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: we(t.onFocusCapture, q.onFocusCapture),
        onBlurCapture: we(t.onBlurCapture, q.onBlurCapture),
        onPointerDownCapture: we(
          t.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
ey.displayName = qk;
var Rk = "DismissableLayerBranch", kk = v.forwardRef((t, e) => {
  const n = v.useContext($b), s = v.useRef(null), r = Pe(e, s);
  return v.useEffect(() => {
    const i = s.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ m.jsx(qe.div, { ...t, ref: r });
});
kk.displayName = Rk;
function Mk(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = bt(t), s = v.useRef(!1), r = v.useRef(() => {
  });
  return v.useEffect(() => {
    const i = (a) => {
      if (a.target && !s.current) {
        let l = function() {
          ty(
            Ek,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (e.removeEventListener("click", r.current), r.current = l, e.addEventListener("click", r.current, { once: !0 })) : l();
      } else
        e.removeEventListener("click", r.current);
      s.current = !1;
    }, o = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(o), e.removeEventListener("pointerdown", i), e.removeEventListener("click", r.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => s.current = !0
  };
}
function Dk(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = bt(t), s = v.useRef(!1);
  return v.useEffect(() => {
    const r = (i) => {
      i.target && !s.current && ty(Tk, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", r), () => e.removeEventListener("focusin", r);
  }, [e, n]), {
    onFocusCapture: () => s.current = !0,
    onBlurCapture: () => s.current = !1
  };
}
function lg() {
  const t = new CustomEvent(Tu);
  document.dispatchEvent(t);
}
function ty(t, e, n, { discrete: s }) {
  const r = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && r.addEventListener(t, e, { once: !0 }), s ? Ib(r, i) : r.dispatchEvent(i);
}
var Ec = "focusScope.autoFocusOnMount", Tc = "focusScope.autoFocusOnUnmount", cg = { bubbles: !1, cancelable: !0 }, Ok = "FocusScope", ny = v.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: s = !1,
    onMountAutoFocus: r,
    onUnmountAutoFocus: i,
    ...o
  } = t, [a, l] = v.useState(null), c = bt(r), u = bt(i), d = v.useRef(null), f = Pe(e, (g) => l(g)), h = v.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  v.useEffect(() => {
    if (s) {
      let g = function(w) {
        if (h.paused || !a) return;
        const x = w.target;
        a.contains(x) ? d.current = x : ls(d.current, { select: !0 });
      }, A = function(w) {
        if (h.paused || !a) return;
        const x = w.relatedTarget;
        x !== null && (a.contains(x) || ls(d.current, { select: !0 }));
      }, b = function(w) {
        if (document.activeElement === document.body)
          for (const S of w)
            S.removedNodes.length > 0 && ls(a);
      };
      document.addEventListener("focusin", g), document.addEventListener("focusout", A);
      const y = new MutationObserver(b);
      return a && y.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", g), document.removeEventListener("focusout", A), y.disconnect();
      };
    }
  }, [s, a, h.paused]), v.useEffect(() => {
    if (a) {
      dg.add(h);
      const g = document.activeElement;
      if (!a.contains(g)) {
        const b = new CustomEvent(Ec, cg);
        a.addEventListener(Ec, c), a.dispatchEvent(b), b.defaultPrevented || (Lk(Fk(sy(a)), { select: !0 }), document.activeElement === g && ls(a));
      }
      return () => {
        a.removeEventListener(Ec, c), setTimeout(() => {
          const b = new CustomEvent(Tc, cg);
          a.addEventListener(Tc, u), a.dispatchEvent(b), b.defaultPrevented || ls(g ?? document.body, { select: !0 }), a.removeEventListener(Tc, u), dg.remove(h);
        }, 0);
      };
    }
  }, [a, c, u, h]);
  const p = v.useCallback(
    (g) => {
      if (!n && !s || h.paused) return;
      const A = g.key === "Tab" && !g.altKey && !g.ctrlKey && !g.metaKey, b = document.activeElement;
      if (A && b) {
        const y = g.currentTarget, [w, x] = Nk(y);
        w && x ? !g.shiftKey && b === x ? (g.preventDefault(), n && ls(w, { select: !0 })) : g.shiftKey && b === w && (g.preventDefault(), n && ls(x, { select: !0 })) : b === y && g.preventDefault();
      }
    },
    [n, s, h.paused]
  );
  return /* @__PURE__ */ m.jsx(qe.div, { tabIndex: -1, ...o, ref: f, onKeyDown: p });
});
ny.displayName = Ok;
function Lk(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const s of t)
    if (ls(s, { select: e }), document.activeElement !== n) return;
}
function Nk(t) {
  const e = sy(t), n = ug(e, t), s = ug(e.reverse(), t);
  return [n, s];
}
function sy(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (s) => {
      const r = s.tagName === "INPUT" && s.type === "hidden";
      return s.disabled || s.hidden || r ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function ug(t, e) {
  for (const n of t)
    if (!jk(n, { upTo: e })) return n;
}
function jk(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function Bk(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function ls(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && Bk(t) && e && t.select();
  }
}
var dg = Ik();
function Ik() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), t = fg(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = fg(t, e), (n = t[0]) == null || n.resume();
    }
  };
}
function fg(t, e) {
  const n = [...t], s = n.indexOf(e);
  return s !== -1 && n.splice(s, 1), n;
}
function Fk(t) {
  return t.filter((e) => e.tagName !== "A");
}
var Vk = "Portal", ry = v.forwardRef((t, e) => {
  var a;
  const { container: n, ...s } = t, [r, i] = v.useState(!1);
  Lt(() => i(!0), []);
  const o = n || r && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
  return o ? cA.createPortal(/* @__PURE__ */ m.jsx(qe.div, { ...s, ref: e }), o) : null;
});
ry.displayName = Vk;
function zk(t, e) {
  return v.useReducer((n, s) => e[n][s] ?? n, t);
}
var Nl = (t) => {
  const { present: e, children: n } = t, s = Uk(e), r = typeof n == "function" ? n({ present: s.isPresent }) : v.Children.only(n), i = Pe(s.ref, Wk(r));
  return typeof n == "function" || s.isPresent ? v.cloneElement(r, { ref: i }) : null;
};
Nl.displayName = "Presence";
function Uk(t) {
  const [e, n] = v.useState(), s = v.useRef({}), r = v.useRef(t), i = v.useRef("none"), o = t ? "mounted" : "unmounted", [a, l] = zk(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return v.useEffect(() => {
    const c = Vo(s.current);
    i.current = a === "mounted" ? c : "none";
  }, [a]), Lt(() => {
    const c = s.current, u = r.current;
    if (u !== t) {
      const f = i.current, h = Vo(c);
      t ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), r.current = t;
    }
  }, [t, l]), Lt(() => {
    if (e) {
      let c;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const g = Vo(s.current).includes(h.animationName);
        if (h.target === e && g && (l("ANIMATION_END"), !r.current)) {
          const A = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = A);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = Vo(s.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(c), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [e, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: v.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function Vo(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function Wk(t) {
  var s, r;
  let e = (s = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (r = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var Rc = 0;
function Hk() {
  v.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? hg()), document.body.insertAdjacentElement("beforeend", t[1] ?? hg()), Rc++, () => {
      Rc === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), Rc--;
    };
  }, []);
}
function hg() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var vn = function() {
  return vn = Object.assign || function(e) {
    for (var n, s = 1, r = arguments.length; s < r; s++) {
      n = arguments[s];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, vn.apply(this, arguments);
};
function iy(t, e) {
  var n = {};
  for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && e.indexOf(s) < 0 && (n[s] = t[s]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, s = Object.getOwnPropertySymbols(t); r < s.length; r++)
      e.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[r]) && (n[s[r]] = t[s[r]]);
  return n;
}
function Qk(t, e, n) {
  if (n || arguments.length === 2) for (var s = 0, r = e.length, i; s < r; s++)
    (i || !(s in e)) && (i || (i = Array.prototype.slice.call(e, 0, s)), i[s] = e[s]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var va = "right-scroll-bar-position", xa = "width-before-scroll-bar", Yk = "with-scroll-bars-hidden", Kk = "--removed-body-scroll-bar-size";
function kc(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function Xk(t, e) {
  var n = tt(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(s) {
          var r = n.value;
          r !== s && (n.value = s, n.callback(s, r));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var Gk = typeof window < "u" ? v.useLayoutEffect : v.useEffect, pg = /* @__PURE__ */ new WeakMap();
function Zk(t, e) {
  var n = Xk(null, function(s) {
    return t.forEach(function(r) {
      return kc(r, s);
    });
  });
  return Gk(function() {
    var s = pg.get(n);
    if (s) {
      var r = new Set(s), i = new Set(t), o = n.current;
      r.forEach(function(a) {
        i.has(a) || kc(a, null);
      }), i.forEach(function(a) {
        r.has(a) || kc(a, o);
      });
    }
    pg.set(n, t);
  }, [t]), n;
}
function _k(t) {
  return t;
}
function Jk(t, e) {
  e === void 0 && (e = _k);
  var n = [], s = !1, r = {
    read: function() {
      if (s)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(i) {
      var o = e(i, s);
      return n.push(o), function() {
        n = n.filter(function(a) {
          return a !== o;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (s = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(i);
      }
      n = {
        push: function(a) {
          return i(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      s = !0;
      var o = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(i), o = n;
      }
      var l = function() {
        var u = o;
        o = [], u.forEach(i);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          o.push(u), c();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return r;
}
function $k(t) {
  t === void 0 && (t = {});
  var e = Jk(null);
  return e.options = vn({ async: !0, ssr: !1 }, t), e;
}
var oy = function(t) {
  var e = t.sideCar, n = iy(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var s = e.read();
  if (!s)
    throw new Error("Sidecar medium not found");
  return v.createElement(s, vn({}, n));
};
oy.isSideCarExport = !0;
function eM(t, e) {
  return t.useMedium(e), oy;
}
var ay = $k(), Mc = function() {
}, jl = v.forwardRef(function(t, e) {
  var n = v.useRef(null), s = v.useState({
    onScrollCapture: Mc,
    onWheelCapture: Mc,
    onTouchMoveCapture: Mc
  }), r = s[0], i = s[1], o = t.forwardProps, a = t.children, l = t.className, c = t.removeScrollBar, u = t.enabled, d = t.shards, f = t.sideCar, h = t.noIsolation, p = t.inert, g = t.allowPinchZoom, A = t.as, b = A === void 0 ? "div" : A, y = t.gapMode, w = iy(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x = f, S = Zk([n, e]), q = vn(vn({}, w), r);
  return v.createElement(
    v.Fragment,
    null,
    u && v.createElement(x, { sideCar: ay, removeScrollBar: c, shards: d, noIsolation: h, inert: p, setCallbacks: i, allowPinchZoom: !!g, lockRef: n, gapMode: y }),
    o ? v.cloneElement(v.Children.only(a), vn(vn({}, q), { ref: S })) : v.createElement(b, vn({}, q, { className: l, ref: S }), a)
  );
});
jl.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
jl.classNames = {
  fullWidth: xa,
  zeroRight: va
};
var tM = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function nM() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = tM();
  return e && t.setAttribute("nonce", e), t;
}
function sM(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function rM(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var iM = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = nM()) && (sM(e, n), rM(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, oM = function() {
  var t = iM();
  return function(e, n) {
    v.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, ly = function() {
  var t = oM(), e = function(n) {
    var s = n.styles, r = n.dynamic;
    return t(s, r), null;
  };
  return e;
}, aM = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Dc = function(t) {
  return parseInt(t || "", 10) || 0;
}, lM = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], s = e[t === "padding" ? "paddingTop" : "marginTop"], r = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [Dc(n), Dc(s), Dc(r)];
}, cM = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return aM;
  var e = lM(t), n = document.documentElement.clientWidth, s = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, s - n + e[2] - e[0])
  };
}, uM = ly(), Dr = "data-scroll-locked", dM = function(t, e, n, s) {
  var r = t.left, i = t.top, o = t.right, a = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Yk, ` {
   overflow: hidden `).concat(s, `;
   padding-right: `).concat(a, "px ").concat(s, `;
  }
  body[`).concat(Dr, `] {
    overflow: hidden `).concat(s, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(s, ";"),
    n === "margin" && `
    padding-left: `.concat(r, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(s, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(s, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(va, ` {
    right: `).concat(a, "px ").concat(s, `;
  }
  
  .`).concat(xa, ` {
    margin-right: `).concat(a, "px ").concat(s, `;
  }
  
  .`).concat(va, " .").concat(va, ` {
    right: 0 `).concat(s, `;
  }
  
  .`).concat(xa, " .").concat(xa, ` {
    margin-right: 0 `).concat(s, `;
  }
  
  body[`).concat(Dr, `] {
    `).concat(Kk, ": ").concat(a, `px;
  }
`);
}, gg = function() {
  var t = parseInt(document.body.getAttribute(Dr) || "0", 10);
  return isFinite(t) ? t : 0;
}, fM = function() {
  v.useEffect(function() {
    return document.body.setAttribute(Dr, (gg() + 1).toString()), function() {
      var t = gg() - 1;
      t <= 0 ? document.body.removeAttribute(Dr) : document.body.setAttribute(Dr, t.toString());
    };
  }, []);
}, hM = function(t) {
  var e = t.noRelative, n = t.noImportant, s = t.gapMode, r = s === void 0 ? "margin" : s;
  fM();
  var i = v.useMemo(function() {
    return cM(r);
  }, [r]);
  return v.createElement(uM, { styles: dM(i, !e, r, n ? "" : "!important") });
}, Ru = !1;
if (typeof window < "u")
  try {
    var zo = Object.defineProperty({}, "passive", {
      get: function() {
        return Ru = !0, !0;
      }
    });
    window.addEventListener("test", zo, zo), window.removeEventListener("test", zo, zo);
  } catch {
    Ru = !1;
  }
var gr = Ru ? { passive: !1 } : !1, pM = function(t) {
  return t.tagName === "TEXTAREA";
}, cy = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !pM(t) && n[e] === "visible")
  );
}, gM = function(t) {
  return cy(t, "overflowY");
}, mM = function(t) {
  return cy(t, "overflowX");
}, mg = function(t, e) {
  var n = e.ownerDocument, s = e;
  do {
    typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host);
    var r = uy(t, s);
    if (r) {
      var i = dy(t, s), o = i[1], a = i[2];
      if (o > a)
        return !0;
    }
    s = s.parentNode;
  } while (s && s !== n.body);
  return !1;
}, AM = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, s = t.clientHeight;
  return [
    e,
    n,
    s
  ];
}, bM = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, s = t.clientWidth;
  return [
    e,
    n,
    s
  ];
}, uy = function(t, e) {
  return t === "v" ? gM(e) : mM(e);
}, dy = function(t, e) {
  return t === "v" ? AM(e) : bM(e);
}, yM = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, vM = function(t, e, n, s, r) {
  var i = yM(t, window.getComputedStyle(e).direction), o = i * s, a = n.target, l = e.contains(a), c = !1, u = o > 0, d = 0, f = 0;
  do {
    var h = dy(t, a), p = h[0], g = h[1], A = h[2], b = g - A - i * p;
    (p || b) && uy(t, a) && (d += b, f += p), a instanceof ShadowRoot ? a = a.host : a = a.parentNode;
  } while (
    // portaled content
    !l && a !== document.body || // self content
    l && (e.contains(a) || e === a)
  );
  return (u && (Math.abs(d) < 1 || !r) || !u && (Math.abs(f) < 1 || !r)) && (c = !0), c;
}, Uo = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, Ag = function(t) {
  return [t.deltaX, t.deltaY];
}, bg = function(t) {
  return t && "current" in t ? t.current : t;
}, xM = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, wM = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, SM = 0, mr = [];
function CM(t) {
  var e = v.useRef([]), n = v.useRef([0, 0]), s = v.useRef(), r = v.useState(SM++)[0], i = v.useState(ly)[0], o = v.useRef(t);
  v.useEffect(function() {
    o.current = t;
  }, [t]), v.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(r));
      var g = Qk([t.lockRef.current], (t.shards || []).map(bg), !0).filter(Boolean);
      return g.forEach(function(A) {
        return A.classList.add("allow-interactivity-".concat(r));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(r)), g.forEach(function(A) {
          return A.classList.remove("allow-interactivity-".concat(r));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = v.useCallback(function(g, A) {
    if ("touches" in g && g.touches.length === 2 || g.type === "wheel" && g.ctrlKey)
      return !o.current.allowPinchZoom;
    var b = Uo(g), y = n.current, w = "deltaX" in g ? g.deltaX : y[0] - b[0], x = "deltaY" in g ? g.deltaY : y[1] - b[1], S, q = g.target, C = Math.abs(w) > Math.abs(x) ? "h" : "v";
    if ("touches" in g && C === "h" && q.type === "range")
      return !1;
    var E = mg(C, q);
    if (!E)
      return !0;
    if (E ? S = C : (S = C === "v" ? "h" : "v", E = mg(C, q)), !E)
      return !1;
    if (!s.current && "changedTouches" in g && (w || x) && (s.current = S), !S)
      return !0;
    var T = s.current || S;
    return vM(T, A, g, T === "h" ? w : x, !0);
  }, []), l = v.useCallback(function(g) {
    var A = g;
    if (!(!mr.length || mr[mr.length - 1] !== i)) {
      var b = "deltaY" in A ? Ag(A) : Uo(A), y = e.current.filter(function(S) {
        return S.name === A.type && (S.target === A.target || A.target === S.shadowParent) && xM(S.delta, b);
      })[0];
      if (y && y.should) {
        A.cancelable && A.preventDefault();
        return;
      }
      if (!y) {
        var w = (o.current.shards || []).map(bg).filter(Boolean).filter(function(S) {
          return S.contains(A.target);
        }), x = w.length > 0 ? a(A, w[0]) : !o.current.noIsolation;
        x && A.cancelable && A.preventDefault();
      }
    }
  }, []), c = v.useCallback(function(g, A, b, y) {
    var w = { name: g, delta: A, target: b, should: y, shadowParent: PM(b) };
    e.current.push(w), setTimeout(function() {
      e.current = e.current.filter(function(x) {
        return x !== w;
      });
    }, 1);
  }, []), u = v.useCallback(function(g) {
    n.current = Uo(g), s.current = void 0;
  }, []), d = v.useCallback(function(g) {
    c(g.type, Ag(g), g.target, a(g, t.lockRef.current));
  }, []), f = v.useCallback(function(g) {
    c(g.type, Uo(g), g.target, a(g, t.lockRef.current));
  }, []);
  v.useEffect(function() {
    return mr.push(i), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", l, gr), document.addEventListener("touchmove", l, gr), document.addEventListener("touchstart", u, gr), function() {
      mr = mr.filter(function(g) {
        return g !== i;
      }), document.removeEventListener("wheel", l, gr), document.removeEventListener("touchmove", l, gr), document.removeEventListener("touchstart", u, gr);
    };
  }, []);
  var h = t.removeScrollBar, p = t.inert;
  return v.createElement(
    v.Fragment,
    null,
    p ? v.createElement(i, { styles: wM(r) }) : null,
    h ? v.createElement(hM, { gapMode: t.gapMode }) : null
  );
}
function PM(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const qM = eM(ay, CM);
var fy = v.forwardRef(function(t, e) {
  return v.createElement(jl, vn({}, t, { ref: e, sideCar: qM }));
});
fy.classNames = jl.classNames;
var EM = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, Ar = /* @__PURE__ */ new WeakMap(), Wo = /* @__PURE__ */ new WeakMap(), Ho = {}, Oc = 0, hy = function(t) {
  return t && (t.host || hy(t.parentNode));
}, TM = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var s = hy(n);
    return s && t.contains(s) ? s : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, RM = function(t, e, n, s) {
  var r = TM(e, Array.isArray(t) ? t : [t]);
  Ho[n] || (Ho[n] = /* @__PURE__ */ new WeakMap());
  var i = Ho[n], o = [], a = /* @__PURE__ */ new Set(), l = new Set(r), c = function(d) {
    !d || a.has(d) || (a.add(d), c(d.parentNode));
  };
  r.forEach(c);
  var u = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (a.has(f))
        u(f);
      else
        try {
          var h = f.getAttribute(s), p = h !== null && h !== "false", g = (Ar.get(f) || 0) + 1, A = (i.get(f) || 0) + 1;
          Ar.set(f, g), i.set(f, A), o.push(f), g === 1 && p && Wo.set(f, !0), A === 1 && f.setAttribute(n, "true"), p || f.setAttribute(s, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", f, b);
        }
    });
  };
  return u(e), a.clear(), Oc++, function() {
    o.forEach(function(d) {
      var f = Ar.get(d) - 1, h = i.get(d) - 1;
      Ar.set(d, f), i.set(d, h), f || (Wo.has(d) || d.removeAttribute(s), Wo.delete(d)), h || d.removeAttribute(n);
    }), Oc--, Oc || (Ar = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), Wo = /* @__PURE__ */ new WeakMap(), Ho = {});
  };
}, kM = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var s = Array.from(Array.isArray(t) ? t : [t]), r = EM(t);
  return r ? (s.push.apply(s, Array.from(r.querySelectorAll("[aria-live]"))), RM(s, r, n, "aria-hidden")) : function() {
    return null;
  };
}, Xd = "Dialog", [py, _9] = xk(Xd), [MM, An] = py(Xd), gy = (t) => {
  const {
    __scopeDialog: e,
    children: n,
    open: s,
    defaultOpen: r,
    onOpenChange: i,
    modal: o = !0
  } = t, a = v.useRef(null), l = v.useRef(null), [c = !1, u] = ni({
    prop: s,
    defaultProp: r,
    onChange: i
  });
  return /* @__PURE__ */ m.jsx(
    MM,
    {
      scope: e,
      triggerRef: a,
      contentRef: l,
      contentId: Mr(),
      titleId: Mr(),
      descriptionId: Mr(),
      open: c,
      onOpenChange: u,
      onOpenToggle: v.useCallback(() => u((d) => !d), [u]),
      modal: o,
      children: n
    }
  );
};
gy.displayName = Xd;
var my = "DialogTrigger", Ay = v.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...s } = t, r = An(my, n), i = Pe(e, r.triggerRef);
    return /* @__PURE__ */ m.jsx(
      qe.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": r.open,
        "aria-controls": r.contentId,
        "data-state": _d(r.open),
        ...s,
        ref: i,
        onClick: we(t.onClick, r.onOpenToggle)
      }
    );
  }
);
Ay.displayName = my;
var Gd = "DialogPortal", [DM, by] = py(Gd, {
  forceMount: void 0
}), yy = (t) => {
  const { __scopeDialog: e, forceMount: n, children: s, container: r } = t, i = An(Gd, e);
  return /* @__PURE__ */ m.jsx(DM, { scope: e, forceMount: n, children: v.Children.map(s, (o) => /* @__PURE__ */ m.jsx(Nl, { present: n || i.open, children: /* @__PURE__ */ m.jsx(ry, { asChild: !0, container: r, children: o }) })) });
};
yy.displayName = Gd;
var rl = "DialogOverlay", vy = v.forwardRef(
  (t, e) => {
    const n = by(rl, t.__scopeDialog), { forceMount: s = n.forceMount, ...r } = t, i = An(rl, t.__scopeDialog);
    return i.modal ? /* @__PURE__ */ m.jsx(Nl, { present: s || i.open, children: /* @__PURE__ */ m.jsx(OM, { ...r, ref: e }) }) : null;
  }
);
vy.displayName = rl;
var OM = v.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...s } = t, r = An(rl, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ m.jsx(fy, { as: Ir, allowPinchZoom: !0, shards: [r.contentRef], children: /* @__PURE__ */ m.jsx(
        qe.div,
        {
          "data-state": _d(r.open),
          ...s,
          ref: e,
          style: { pointerEvents: "auto", ...s.style }
        }
      ) })
    );
  }
), rr = "DialogContent", xy = v.forwardRef(
  (t, e) => {
    const n = by(rr, t.__scopeDialog), { forceMount: s = n.forceMount, ...r } = t, i = An(rr, t.__scopeDialog);
    return /* @__PURE__ */ m.jsx(Nl, { present: s || i.open, children: i.modal ? /* @__PURE__ */ m.jsx(LM, { ...r, ref: e }) : /* @__PURE__ */ m.jsx(NM, { ...r, ref: e }) });
  }
);
xy.displayName = rr;
var LM = v.forwardRef(
  (t, e) => {
    const n = An(rr, t.__scopeDialog), s = v.useRef(null), r = Pe(e, n.contentRef, s);
    return v.useEffect(() => {
      const i = s.current;
      if (i) return kM(i);
    }, []), /* @__PURE__ */ m.jsx(
      wy,
      {
        ...t,
        ref: r,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: we(t.onCloseAutoFocus, (i) => {
          var o;
          i.preventDefault(), (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: we(t.onPointerDownOutside, (i) => {
          const o = i.detail.originalEvent, a = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || a) && i.preventDefault();
        }),
        onFocusOutside: we(
          t.onFocusOutside,
          (i) => i.preventDefault()
        )
      }
    );
  }
), NM = v.forwardRef(
  (t, e) => {
    const n = An(rr, t.__scopeDialog), s = v.useRef(!1), r = v.useRef(!1);
    return /* @__PURE__ */ m.jsx(
      wy,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var o, a;
          (o = t.onCloseAutoFocus) == null || o.call(t, i), i.defaultPrevented || (s.current || (a = n.triggerRef.current) == null || a.focus(), i.preventDefault()), s.current = !1, r.current = !1;
        },
        onInteractOutside: (i) => {
          var l, c;
          (l = t.onInteractOutside) == null || l.call(t, i), i.defaultPrevented || (s.current = !0, i.detail.originalEvent.type === "pointerdown" && (r.current = !0));
          const o = i.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && r.current && i.preventDefault();
        }
      }
    );
  }
), wy = v.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, trapFocus: s, onOpenAutoFocus: r, onCloseAutoFocus: i, ...o } = t, a = An(rr, n), l = v.useRef(null), c = Pe(e, l);
    return Hk(), /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        ny,
        {
          asChild: !0,
          loop: !0,
          trapped: s,
          onMountAutoFocus: r,
          onUnmountAutoFocus: i,
          children: /* @__PURE__ */ m.jsx(
            ey,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": _d(a.open),
              ...o,
              ref: c,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
        /* @__PURE__ */ m.jsx(jM, { titleId: a.titleId }),
        /* @__PURE__ */ m.jsx(IM, { contentRef: l, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), Zd = "DialogTitle", Sy = v.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...s } = t, r = An(Zd, n);
    return /* @__PURE__ */ m.jsx(qe.h2, { id: r.titleId, ...s, ref: e });
  }
);
Sy.displayName = Zd;
var Cy = "DialogDescription", Py = v.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...s } = t, r = An(Cy, n);
    return /* @__PURE__ */ m.jsx(qe.p, { id: r.descriptionId, ...s, ref: e });
  }
);
Py.displayName = Cy;
var qy = "DialogClose", Ey = v.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...s } = t, r = An(qy, n);
    return /* @__PURE__ */ m.jsx(
      qe.button,
      {
        type: "button",
        ...s,
        ref: e,
        onClick: we(t.onClick, () => r.onOpenChange(!1))
      }
    );
  }
);
Ey.displayName = qy;
function _d(t) {
  return t ? "open" : "closed";
}
var Ty = "DialogTitleWarning", [J9, Ry] = vk(Ty, {
  contentName: rr,
  titleName: Zd,
  docsSlug: "dialog"
}), jM = ({ titleId: t }) => {
  const e = Ry(Ty), n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
  return v.useEffect(() => {
    t && (document.getElementById(t) || console.error(n));
  }, [n, t]), null;
}, BM = "DialogDescriptionWarning", IM = ({ contentRef: t, descriptionId: e }) => {
  const s = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${Ry(BM).contentName}}.`;
  return v.useEffect(() => {
    var i;
    const r = (i = t.current) == null ? void 0 : i.getAttribute("aria-describedby");
    e && r && (document.getElementById(e) || console.warn(s));
  }, [s, t, e]), null;
}, ky = gy, My = Ay, FM = yy, Jd = vy, $d = xy, ef = Sy, tf = Py, nf = Ey;
function sf(t, e) {
  if (t == null) return {};
  var n = {}, s = Object.keys(t), r, i;
  for (i = 0; i < s.length; i++)
    r = s[i], !(e.indexOf(r) >= 0) && (n[r] = t[r]);
  return n;
}
var VM = ["color"], zM = /* @__PURE__ */ Xr(function(t, e) {
  var n = t.color, s = n === void 0 ? "currentColor" : n, r = sf(t, VM);
  return En("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r, {
    ref: e
  }), En("path", {
    d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
    fill: s,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}), UM = ["color"], WM = /* @__PURE__ */ Xr(function(t, e) {
  var n = t.color, s = n === void 0 ? "currentColor" : n, r = sf(t, UM);
  return En("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r, {
    ref: e
  }), En("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: s,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}), HM = ["color"], QM = /* @__PURE__ */ Xr(function(t, e) {
  var n = t.color, s = n === void 0 ? "currentColor" : n, r = sf(t, HM);
  return En("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r, {
    ref: e
  }), En("path", {
    d: "M1.84998 7.49998C1.84998 4.66458 4.05979 1.84998 7.49998 1.84998C10.2783 1.84998 11.6515 3.9064 12.2367 5H10.5C10.2239 5 10 5.22386 10 5.5C10 5.77614 10.2239 6 10.5 6H13.5C13.7761 6 14 5.77614 14 5.5V2.5C14 2.22386 13.7761 2 13.5 2C13.2239 2 13 2.22386 13 2.5V4.31318C12.2955 3.07126 10.6659 0.849976 7.49998 0.849976C3.43716 0.849976 0.849976 4.18537 0.849976 7.49998C0.849976 10.8146 3.43716 14.15 7.49998 14.15C9.44382 14.15 11.0622 13.3808 12.2145 12.2084C12.8315 11.5806 13.3133 10.839 13.6418 10.0407C13.7469 9.78536 13.6251 9.49315 13.3698 9.38806C13.1144 9.28296 12.8222 9.40478 12.7171 9.66014C12.4363 10.3425 12.0251 10.9745 11.5013 11.5074C10.5295 12.4963 9.16504 13.15 7.49998 13.15C4.05979 13.15 1.84998 10.3354 1.84998 7.49998Z",
    fill: s,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
const Dy = ky, Oy = My, Ly = nf, Ny = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  Jd,
  {
    ref: n,
    className: Be(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      t
    ),
    ...e
  }
));
Ny.displayName = Jd.displayName;
const rf = v.forwardRef(({ className: t, children: e, ...n }, s) => /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
  /* @__PURE__ */ m.jsx(Ny, {}),
  /* @__PURE__ */ m.jsxs(
    $d,
    {
      ref: s,
      className: Be(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        t
      ),
      ...n,
      children: [
        e,
        /* @__PURE__ */ m.jsxs(nf, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ m.jsx(WM, { className: "h-4 w-4" }),
          /* @__PURE__ */ m.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
rf.displayName = $d.displayName;
const of = ({
  className: t,
  ...e
}) => /* @__PURE__ */ m.jsx(
  "div",
  {
    className: Be(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      t
    ),
    ...e
  }
);
of.displayName = "DialogHeader";
const af = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  ef,
  {
    ref: n,
    className: Be(
      "text-lg font-semibold leading-none tracking-tight",
      t
    ),
    ...e
  }
));
af.displayName = ef.displayName;
const YM = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  tf,
  {
    ref: n,
    className: Be("text-sm text-muted-foreground", t),
    ...e
  }
));
YM.displayName = tf.displayName;
function KM(t) {
  if (typeof document > "u") return;
  let e = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", e.appendChild(n), n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(document.createTextNode(t));
}
const jy = z.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: !1,
  isOpen: !1,
  isDragging: !1,
  keyboardIsOpen: {
    current: !1
  },
  snapPointsOffset: null,
  snapPoints: null,
  handleOnly: !1,
  modal: !1,
  shouldFade: !1,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  closeDrawer: () => {
  },
  direction: "bottom",
  shouldScaleBackground: !1,
  setBackgroundColorOnScale: !0,
  noBodyStyles: !1,
  container: null,
  autoFocus: !1
}), si = () => {
  const t = z.useContext(jy);
  if (!t)
    throw new Error("useDrawerContext must be used within a Drawer.Root");
  return t;
};
KM(`[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(
[data-state=closed]
){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,100%,0)}}@keyframes slideFromTop{from{transform:translate3d(0,-100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,-100%,0)}}@keyframes slideFromLeft{from{transform:translate3d(-100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(-100%,0,0)}}@keyframes slideFromRight{from{transform:translate3d(100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(100%,0,0)}}`);
const XM = 24, GM = typeof window < "u" ? od : je;
function yg(...t) {
  return (...e) => {
    for (let n of t)
      typeof n == "function" && n(...e);
  };
}
function ZM() {
  return lf(/^Mac/);
}
function _M() {
  return lf(/^iPhone/);
}
function vg() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function JM() {
  return lf(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  ZM() && navigator.maxTouchPoints > 1;
}
function By() {
  return _M() || JM();
}
function lf(t) {
  return typeof window < "u" && window.navigator != null ? t.test(window.navigator.platform) : void 0;
}
const Lc = typeof document < "u" && window.visualViewport;
function xg(t) {
  let e = window.getComputedStyle(t);
  return /(auto|scroll)/.test(e.overflow + e.overflowX + e.overflowY);
}
function Iy(t) {
  for (xg(t) && (t = t.parentElement); t && !xg(t); )
    t = t.parentElement;
  return t || document.scrollingElement || document.documentElement;
}
const $M = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let Qo = 0, Nc;
function eD(t = {}) {
  let { isDisabled: e } = t;
  GM(() => {
    if (!e)
      return Qo++, Qo === 1 && By() && (Nc = tD()), () => {
        Qo--, Qo === 0 && (Nc == null || Nc());
      };
  }, [
    e
  ]);
}
function tD() {
  let t, e = 0, n = (d) => {
    t = Iy(d.target), !(t === document.documentElement && t === document.body) && (e = d.changedTouches[0].pageY);
  }, s = (d) => {
    if (!t || t === document.documentElement || t === document.body) {
      d.preventDefault();
      return;
    }
    let f = d.changedTouches[0].pageY, h = t.scrollTop, p = t.scrollHeight - t.clientHeight;
    p !== 0 && ((h <= 0 && f > e || h >= p && f < e) && d.preventDefault(), e = f);
  }, r = (d) => {
    let f = d.target;
    ku(f) && f !== document.activeElement && (d.preventDefault(), f.style.transform = "translateY(-2000px)", f.focus(), requestAnimationFrame(() => {
      f.style.transform = "";
    }));
  }, i = (d) => {
    let f = d.target;
    ku(f) && (f.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      f.style.transform = "", Lc && (Lc.height < window.innerHeight ? requestAnimationFrame(() => {
        wg(f);
      }) : Lc.addEventListener("resize", () => wg(f), {
        once: !0
      }));
    }));
  }, o = () => {
    window.scrollTo(0, 0);
  }, a = window.pageXOffset, l = window.pageYOffset, c = yg(nD(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let u = yg(pi(document, "touchstart", n, {
    passive: !1,
    capture: !0
  }), pi(document, "touchmove", s, {
    passive: !1,
    capture: !0
  }), pi(document, "touchend", r, {
    passive: !1,
    capture: !0
  }), pi(document, "focus", i, !0), pi(window, "scroll", o));
  return () => {
    c(), u(), window.scrollTo(a, l);
  };
}
function nD(t, e, n) {
  let s = t.style[e];
  return t.style[e] = n, () => {
    t.style[e] = s;
  };
}
function pi(t, e, n, s) {
  return t.addEventListener(e, n, s), () => {
    t.removeEventListener(e, n, s);
  };
}
function wg(t) {
  let e = document.scrollingElement || document.documentElement;
  for (; t && t !== e; ) {
    let n = Iy(t);
    if (n !== document.documentElement && n !== document.body && n !== t) {
      let s = n.getBoundingClientRect().top, r = t.getBoundingClientRect().top, i = t.getBoundingClientRect().bottom;
      const o = n.getBoundingClientRect().bottom + XM;
      i > o && (n.scrollTop += r - s);
    }
    t = n.parentElement;
  }
}
function ku(t) {
  return t instanceof HTMLInputElement && !$M.has(t.type) || t instanceof HTMLTextAreaElement || t instanceof HTMLElement && t.isContentEditable;
}
function sD(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function rD(...t) {
  return (e) => t.forEach((n) => sD(n, e));
}
function Fy(...t) {
  return v.useCallback(rD(...t), t);
}
const Vy = /* @__PURE__ */ new WeakMap();
function ot(t, e, n = !1) {
  if (!t || !(t instanceof HTMLElement)) return;
  let s = {};
  Object.entries(e).forEach(([r, i]) => {
    if (r.startsWith("--")) {
      t.style.setProperty(r, i);
      return;
    }
    s[r] = t.style[r], t.style[r] = i;
  }), !n && Vy.set(t, s);
}
function iD(t, e) {
  if (!t || !(t instanceof HTMLElement)) return;
  let n = Vy.get(t);
  n && (t.style[e] = n[e]);
}
const at = (t) => {
  switch (t) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return t;
  }
};
function Yo(t, e) {
  if (!t)
    return null;
  const n = window.getComputedStyle(t), s = (
    // @ts-ignore
    n.transform || n.webkitTransform || n.mozTransform
  );
  let r = s.match(/^matrix3d\((.+)\)$/);
  return r ? parseFloat(r[1].split(", ")[at(e) ? 13 : 12]) : (r = s.match(/^matrix\((.+)\)$/), r ? parseFloat(r[1].split(", ")[at(e) ? 5 : 4]) : null);
}
function oD(t) {
  return 8 * (Math.log(t + 1) - 2);
}
function jc(t, e) {
  if (!t) return () => {
  };
  const n = t.style.cssText;
  return Object.assign(t.style, e), () => {
    t.style.cssText = n;
  };
}
function aD(...t) {
  return (...e) => {
    for (const n of t)
      typeof n == "function" && n(...e);
  };
}
const Qe = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
}, zy = 0.4, lD = 0.25, cD = 100, Uy = 8, Bs = 16, Mu = 26, Bc = "vaul-dragging";
function Wy(t) {
  const e = z.useRef(t);
  return z.useEffect(() => {
    e.current = t;
  }), z.useMemo(() => (...n) => e.current == null ? void 0 : e.current.call(e, ...n), []);
}
function uD({ defaultProp: t, onChange: e }) {
  const n = z.useState(t), [s] = n, r = z.useRef(s), i = Wy(e);
  return z.useEffect(() => {
    r.current !== s && (i(s), r.current = s);
  }, [
    s,
    r,
    i
  ]), n;
}
function Hy({ prop: t, defaultProp: e, onChange: n = () => {
} }) {
  const [s, r] = uD({
    defaultProp: e,
    onChange: n
  }), i = t !== void 0, o = i ? t : s, a = Wy(n), l = z.useCallback((c) => {
    if (i) {
      const d = typeof c == "function" ? c(t) : c;
      d !== t && a(d);
    } else
      r(c);
  }, [
    i,
    t,
    r,
    a
  ]);
  return [
    o,
    l
  ];
}
function dD({ activeSnapPointProp: t, setActiveSnapPointProp: e, snapPoints: n, drawerRef: s, overlayRef: r, fadeFromIndex: i, onSnapPointChange: o, direction: a = "bottom", container: l, snapToSequentialPoint: c }) {
  const [u, d] = Hy({
    prop: t,
    defaultProp: n == null ? void 0 : n[0],
    onChange: e
  }), [f, h] = z.useState(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  z.useEffect(() => {
    function C() {
      h({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }
    return window.addEventListener("resize", C), () => window.removeEventListener("resize", C);
  }, []);
  const p = z.useMemo(() => u === (n == null ? void 0 : n[n.length - 1]) || null, [
    n,
    u
  ]), g = z.useMemo(() => n == null ? void 0 : n.findIndex((C) => C === u), [
    n,
    u
  ]), A = n && n.length > 0 && (i || i === 0) && !Number.isNaN(i) && n[i] === u || !n, b = z.useMemo(() => {
    const C = l ? {
      width: l.getBoundingClientRect().width,
      height: l.getBoundingClientRect().height
    } : typeof window < "u" ? {
      width: window.innerWidth,
      height: window.innerHeight
    } : {
      width: 0,
      height: 0
    };
    var E;
    return (E = n == null ? void 0 : n.map((T) => {
      const k = typeof T == "string";
      let R = 0;
      if (k && (R = parseInt(T, 10)), at(a)) {
        const F = k ? R : f ? T * C.height : 0;
        return f ? a === "bottom" ? C.height - F : -C.height + F : F;
      }
      const D = k ? R : f ? T * C.width : 0;
      return f ? a === "right" ? C.width - D : -C.width + D : D;
    })) != null ? E : [];
  }, [
    n,
    f,
    l
  ]), y = z.useMemo(() => g !== null ? b == null ? void 0 : b[g] : null, [
    b,
    g
  ]), w = z.useCallback((C) => {
    var E;
    const T = (E = b == null ? void 0 : b.findIndex((k) => k === C)) != null ? E : null;
    o(T), ot(s.current, {
      transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
      transform: at(a) ? `translate3d(0, ${C}px, 0)` : `translate3d(${C}px, 0, 0)`
    }), b && T !== b.length - 1 && T !== i && T < i ? ot(r.current, {
      transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
      opacity: "0"
    }) : ot(r.current, {
      transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
      opacity: "1"
    }), d(n == null ? void 0 : n[Math.max(T, 0)]);
  }, [
    s.current,
    n,
    b,
    i,
    r,
    d
  ]);
  z.useEffect(() => {
    if (u || t) {
      var C;
      const E = (C = n == null ? void 0 : n.findIndex((T) => T === t || T === u)) != null ? C : -1;
      b && E !== -1 && typeof b[E] == "number" && w(b[E]);
    }
  }, [
    u,
    t,
    n,
    b,
    w
  ]);
  function x({ draggedDistance: C, closeDrawer: E, velocity: T, dismissible: k }) {
    if (i === void 0) return;
    const R = a === "bottom" || a === "right" ? (y ?? 0) - C : (y ?? 0) + C, D = g === i - 1, F = g === 0, j = C > 0;
    if (D && ot(r.current, {
      transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`
    }), !c && T > 2 && !j) {
      k ? E() : w(b[0]);
      return;
    }
    if (!c && T > 2 && j && b && n) {
      w(b[n.length - 1]);
      return;
    }
    const B = b == null ? void 0 : b.reduce((O, N) => typeof O != "number" || typeof N != "number" ? O : Math.abs(N - R) < Math.abs(O - R) ? N : O), L = at(a) ? window.innerHeight : window.innerWidth;
    if (T > zy && Math.abs(C) < L * 0.4) {
      const O = j ? 1 : -1;
      if (O > 0 && p) {
        w(b[n.length - 1]);
        return;
      }
      if (F && O < 0 && k && E(), g === null) return;
      w(b[g + O]);
      return;
    }
    w(B);
  }
  function S({ draggedDistance: C }) {
    if (y === null) return;
    const E = a === "bottom" || a === "right" ? y - C : y + C;
    (a === "bottom" || a === "right") && E < b[b.length - 1] || (a === "top" || a === "left") && E > b[b.length - 1] || ot(s.current, {
      transform: at(a) ? `translate3d(0, ${E}px, 0)` : `translate3d(${E}px, 0, 0)`
    });
  }
  function q(C, E) {
    if (!n || typeof g != "number" || !b || i === void 0) return null;
    const T = g === i - 1;
    if (g >= i && E)
      return 0;
    if (T && !E) return 1;
    if (!A && !T) return null;
    const R = T ? g + 1 : g - 1, D = T ? b[R] - b[R - 1] : b[R + 1] - b[R], F = C / Math.abs(D);
    return T ? 1 - F : F;
  }
  return {
    isLastSnapPoint: p,
    activeSnapPoint: u,
    shouldFade: A,
    getPercentageDragged: q,
    setActiveSnapPoint: d,
    activeSnapPointIndex: g,
    onRelease: x,
    onDrag: S,
    snapPointsOffset: b
  };
}
const fD = () => () => {
};
function hD() {
  const { direction: t, isOpen: e, shouldScaleBackground: n, setBackgroundColorOnScale: s, noBodyStyles: r } = si(), i = z.useRef(null), o = ms(() => document.body.style.backgroundColor, []);
  function a() {
    return (window.innerWidth - Mu) / window.innerWidth;
  }
  z.useEffect(() => {
    if (e && n) {
      i.current && clearTimeout(i.current);
      const l = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!l) return;
      aD(s && !r ? jc(document.body, {
        background: "black"
      }) : fD, jc(l, {
        transformOrigin: at(t) ? "top" : "left",
        transitionProperty: "transform, border-radius",
        transitionDuration: `${Qe.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${Qe.EASE.join(",")})`
      }));
      const c = jc(l, {
        borderRadius: `${Uy}px`,
        overflow: "hidden",
        ...at(t) ? {
          transform: `scale(${a()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${a()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      return () => {
        c(), i.current = window.setTimeout(() => {
          o ? document.body.style.background = o : document.body.style.removeProperty("background");
        }, Qe.DURATION * 1e3);
      };
    }
  }, [
    e,
    n,
    o
  ]);
}
let gi = null;
function pD({ isOpen: t, modal: e, nested: n, hasBeenOpened: s, preventScrollRestoration: r, noBodyStyles: i }) {
  const [o, a] = z.useState(() => typeof window < "u" ? window.location.href : ""), l = z.useRef(0), c = z.useCallback(() => {
    if (vg() && gi === null && t && !i) {
      gi = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX: d, innerHeight: f } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-l.current}px`,
        left: `${-d}px`,
        right: "0px",
        height: "auto"
      }), window.setTimeout(() => window.requestAnimationFrame(() => {
        const h = f - window.innerHeight;
        h && l.current >= f && (document.body.style.top = `${-(l.current + h)}px`);
      }), 300);
    }
  }, [
    t
  ]), u = z.useCallback(() => {
    if (vg() && gi !== null && !i) {
      const d = -parseInt(document.body.style.top, 10), f = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, gi), window.requestAnimationFrame(() => {
        if (r && o !== window.location.href) {
          a(window.location.href);
          return;
        }
        window.scrollTo(f, d);
      }), gi = null;
    }
  }, [
    o
  ]);
  return z.useEffect(() => {
    function d() {
      l.current = window.scrollY;
    }
    return d(), window.addEventListener("scroll", d), () => {
      window.removeEventListener("scroll", d);
    };
  }, []), z.useEffect(() => {
    n || !s || (t ? (!window.matchMedia("(display-mode: standalone)").matches && c(), e || window.setTimeout(() => {
      u();
    }, 500)) : u());
  }, [
    t,
    s,
    o,
    e,
    n,
    c,
    u
  ]), {
    restorePositionSetting: u
  };
}
function Qy({ open: t, onOpenChange: e, children: n, onDrag: s, onRelease: r, snapPoints: i, shouldScaleBackground: o = !1, setBackgroundColorOnScale: a = !0, closeThreshold: l = lD, scrollLockTimeout: c = cD, dismissible: u = !0, handleOnly: d = !1, fadeFromIndex: f = i && i.length - 1, activeSnapPoint: h, setActiveSnapPoint: p, fixed: g, modal: A = !0, onClose: b, nested: y, noBodyStyles: w, direction: x = "bottom", defaultOpen: S = !1, disablePreventScroll: q = !0, snapToSequentialPoint: C = !1, preventScrollRestoration: E = !1, repositionInputs: T = !0, onAnimationEnd: k, container: R, autoFocus: D = !1 }) {
  var F, j;
  const [B = !1, L] = Hy({
    defaultProp: S,
    prop: t,
    onChange: (se) => {
      e == null || e(se), !se && !y && en(), setTimeout(() => {
        k == null || k(se);
      }, Qe.DURATION * 1e3), se && !A && typeof window < "u" && window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      }), se || (document.body.style.pointerEvents = "auto");
    }
  }), [O, N] = z.useState(!1), [H, U] = z.useState(!1), [X, G] = z.useState(!1), pe = z.useRef(null), Me = z.useRef(null), Ee = z.useRef(null), oe = z.useRef(null), He = z.useRef(null), ye = z.useRef(!1), $ = z.useRef(null), Xe = z.useRef(0), Ue = z.useRef(!1), Jt = z.useRef(0), Z = z.useRef(null), Ln = z.useRef(((F = Z.current) == null ? void 0 : F.getBoundingClientRect().height) || 0), Nt = z.useRef(((j = Z.current) == null ? void 0 : j.getBoundingClientRect().width) || 0), Rt = z.useRef(0), ns = z.useCallback((se) => {
    i && se === ge.length - 1 && (Me.current = /* @__PURE__ */ new Date());
  }, []), { activeSnapPoint: ss, activeSnapPointIndex: mt, setActiveSnapPoint: J, onRelease: ee, snapPointsOffset: ge, onDrag: $t, shouldFade: ut, getPercentageDragged: _e } = dD({
    snapPoints: i,
    activeSnapPointProp: h,
    setActiveSnapPointProp: p,
    drawerRef: Z,
    fadeFromIndex: f,
    overlayRef: pe,
    onSnapPointChange: ns,
    direction: x,
    container: R,
    snapToSequentialPoint: C
  });
  eD({
    isDisabled: !B || H || !A || X || !O || !T || !q
  });
  const { restorePositionSetting: en } = pD({
    isOpen: B,
    modal: A,
    nested: y,
    hasBeenOpened: O,
    preventScrollRestoration: E,
    noBodyStyles: w
  });
  function tn() {
    return (window.innerWidth - Mu) / window.innerWidth;
  }
  function Ls(se) {
    var ve, De;
    !u && !i || Z.current && !Z.current.contains(se.target) || (Ln.current = ((ve = Z.current) == null ? void 0 : ve.getBoundingClientRect().height) || 0, Nt.current = ((De = Z.current) == null ? void 0 : De.getBoundingClientRect().width) || 0, U(!0), Ee.current = /* @__PURE__ */ new Date(), By() && window.addEventListener("touchend", () => ye.current = !1, {
      once: !0
    }), se.target.setPointerCapture(se.pointerId), Xe.current = at(x) ? se.pageY : se.pageX);
  }
  function Wt(se, ve) {
    var De, Se;
    let xe = se;
    const vt = (De = window.getSelection()) == null ? void 0 : De.toString(), dt = Z.current ? Yo(Z.current, x) : null, Mt = /* @__PURE__ */ new Date();
    if (xe.hasAttribute("data-vaul-no-drag") || xe.closest("[data-vaul-no-drag]"))
      return !1;
    if (x === "right" || x === "left")
      return !0;
    if (Me.current && Mt.getTime() - Me.current.getTime() < 500)
      return !1;
    if (dt !== null && (x === "bottom" ? dt > 0 : dt < 0))
      return !0;
    if (vt && vt.length > 0)
      return !1;
    if (Mt.getTime() - ((Se = He.current) == null ? void 0 : Se.getTime()) < c && dt === 0 || ve)
      return He.current = Mt, !1;
    for (; xe; ) {
      if (xe.scrollHeight > xe.clientHeight) {
        if (xe.scrollTop !== 0)
          return He.current = /* @__PURE__ */ new Date(), !1;
        if (xe.getAttribute("role") === "dialog")
          return !0;
      }
      xe = xe.parentNode;
    }
    return !0;
  }
  function ai(se) {
    if (Z.current && H) {
      const ve = x === "bottom" || x === "right" ? 1 : -1, De = (Xe.current - (at(x) ? se.pageY : se.pageX)) * ve, Se = De > 0, xe = i && !u && !Se;
      if (xe && mt === 0) return;
      const vt = Math.abs(De), dt = document.querySelector("[data-vaul-drawer-wrapper]"), Mt = x === "bottom" || x === "top" ? Ln.current : Nt.current;
      let jt = vt / Mt;
      const Nn = _e(vt, Se);
      if (Nn !== null && (jt = Nn), xe && jt >= 1 || !ye.current && !Wt(se.target, Se)) return;
      if (Z.current.classList.add(Bc), ye.current = !0, ot(Z.current, {
        transition: "none"
      }), ot(pe.current, {
        transition: "none"
      }), i && $t({
        draggedDistance: De
      }), Se && !i) {
        const Ht = oD(De), dr = Math.min(Ht * -1, 0) * ve;
        ot(Z.current, {
          transform: at(x) ? `translate3d(0, ${dr}px, 0)` : `translate3d(${dr}px, 0, 0)`
        });
        return;
      }
      const ln = 1 - jt;
      if ((ut || f && mt === f - 1) && (s == null || s(se, jt), ot(pe.current, {
        opacity: `${ln}`,
        transition: "none"
      }, !0)), dt && pe.current && o) {
        const Ht = Math.min(tn() + jt * (1 - tn()), 1), dr = 8 - jt * 8, Lo = Math.max(0, 14 - jt * 14);
        ot(dt, {
          borderRadius: `${dr}px`,
          transform: at(x) ? `scale(${Ht}) translate3d(0, ${Lo}px, 0)` : `scale(${Ht}) translate3d(${Lo}px, 0, 0)`,
          transition: "none"
        }, !0);
      }
      if (!i) {
        const Ht = vt * ve;
        ot(Z.current, {
          transform: at(x) ? `translate3d(0, ${Ht}px, 0)` : `translate3d(${Ht}px, 0, 0)`
        });
      }
    }
  }
  z.useEffect(() => {
    var se;
    function ve() {
      if (!Z.current || !T) return;
      const De = document.activeElement;
      if (ku(De) || Ue.current) {
        var Se;
        const xe = ((Se = window.visualViewport) == null ? void 0 : Se.height) || 0, vt = window.innerHeight;
        let dt = vt - xe;
        const Mt = Z.current.getBoundingClientRect().height || 0, jt = Mt > vt * 0.8;
        Rt.current || (Rt.current = Mt);
        const Nn = Z.current.getBoundingClientRect().top;
        if (Math.abs(Jt.current - dt) > 60 && (Ue.current = !Ue.current), i && i.length > 0 && ge && mt) {
          const ln = ge[mt] || 0;
          dt += ln;
        }
        if (Jt.current = dt, Mt > xe || Ue.current) {
          const ln = Z.current.getBoundingClientRect().height;
          let Ht = ln;
          ln > xe && (Ht = xe - (jt ? Nn : Mu)), g ? Z.current.style.height = `${ln - Math.max(dt, 0)}px` : Z.current.style.height = `${Math.max(Ht, xe - Nn)}px`;
        } else
          Z.current.style.height = `${Rt.current}px`;
        i && i.length > 0 && !Ue.current ? Z.current.style.bottom = "0px" : Z.current.style.bottom = `${Math.max(dt, 0)}px`;
      }
    }
    return (se = window.visualViewport) == null || se.addEventListener("resize", ve), () => {
      var De;
      return (De = window.visualViewport) == null ? void 0 : De.removeEventListener("resize", ve);
    };
  }, [
    mt,
    i,
    ge
  ]);
  function kt(se) {
    ec(), b == null || b(), se || L(!1), setTimeout(() => {
      i && J(i[0]);
    }, Qe.DURATION * 1e3);
  }
  function Oo() {
    if (!Z.current) return;
    const se = document.querySelector("[data-vaul-drawer-wrapper]"), ve = Yo(Z.current, x);
    ot(Z.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`
    }), ot(pe.current, {
      transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
      opacity: "1"
    }), o && ve && ve > 0 && B && ot(se, {
      borderRadius: `${Uy}px`,
      overflow: "hidden",
      ...at(x) ? {
        transform: `scale(${tn()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
        transformOrigin: "top"
      } : {
        transform: `scale(${tn()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
        transformOrigin: "left"
      },
      transitionProperty: "transform, border-radius",
      transitionDuration: `${Qe.DURATION}s`,
      transitionTimingFunction: `cubic-bezier(${Qe.EASE.join(",")})`
    }, !0);
  }
  function ec() {
    !H || !Z.current || (Z.current.classList.remove(Bc), ye.current = !1, U(!1), oe.current = /* @__PURE__ */ new Date());
  }
  function tc(se) {
    if (!H || !Z.current) return;
    Z.current.classList.remove(Bc), ye.current = !1, U(!1), oe.current = /* @__PURE__ */ new Date();
    const ve = Yo(Z.current, x);
    if (!Wt(se.target, !1) || !ve || Number.isNaN(ve) || Ee.current === null) return;
    const De = oe.current.getTime() - Ee.current.getTime(), Se = Xe.current - (at(x) ? se.pageY : se.pageX), xe = Math.abs(Se) / De;
    if (xe > 0.05 && (G(!0), setTimeout(() => {
      G(!1);
    }, 200)), i) {
      ee({
        draggedDistance: Se * (x === "bottom" || x === "right" ? 1 : -1),
        closeDrawer: kt,
        velocity: xe,
        dismissible: u
      }), r == null || r(se, !0);
      return;
    }
    if (x === "bottom" || x === "right" ? Se > 0 : Se < 0) {
      Oo(), r == null || r(se, !0);
      return;
    }
    if (xe > zy) {
      kt(), r == null || r(se, !1);
      return;
    }
    var vt;
    const dt = Math.min((vt = Z.current.getBoundingClientRect().height) != null ? vt : 0, window.innerHeight);
    var Mt;
    const jt = Math.min((Mt = Z.current.getBoundingClientRect().width) != null ? Mt : 0, window.innerWidth), Nn = x === "left" || x === "right";
    if (Math.abs(ve) >= (Nn ? jt : dt) * l) {
      kt(), r == null || r(se, !1);
      return;
    }
    r == null || r(se, !0), Oo();
  }
  z.useEffect(() => (B && (ot(document.documentElement, {
    scrollBehavior: "auto"
  }), Me.current = /* @__PURE__ */ new Date()), () => {
    iD(document.documentElement, "scrollBehavior");
  }), [
    B
  ]);
  function nc(se) {
    const ve = se ? (window.innerWidth - Bs) / window.innerWidth : 1, De = se ? -Bs : 0;
    $.current && window.clearTimeout($.current), ot(Z.current, {
      transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
      transform: `scale(${ve}) translate3d(0, ${De}px, 0)`
    }), !se && Z.current && ($.current = setTimeout(() => {
      const Se = Yo(Z.current, x);
      ot(Z.current, {
        transition: "none",
        transform: at(x) ? `translate3d(0, ${Se}px, 0)` : `translate3d(${Se}px, 0, 0)`
      });
    }, 500));
  }
  function sc(se, ve) {
    if (ve < 0) return;
    const De = (window.innerWidth - Bs) / window.innerWidth, Se = De + ve * (1 - De), xe = -Bs + ve * Bs;
    ot(Z.current, {
      transform: at(x) ? `scale(${Se}) translate3d(0, ${xe}px, 0)` : `scale(${Se}) translate3d(${xe}px, 0, 0)`,
      transition: "none"
    });
  }
  function rc(se, ve) {
    const De = at(x) ? window.innerHeight : window.innerWidth, Se = ve ? (De - Bs) / De : 1, xe = ve ? -Bs : 0;
    ve && ot(Z.current, {
      transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
      transform: at(x) ? `scale(${Se}) translate3d(0, ${xe}px, 0)` : `scale(${Se}) translate3d(${xe}px, 0, 0)`
    });
  }
  return /* @__PURE__ */ z.createElement(ky, {
    defaultOpen: S,
    onOpenChange: (se) => {
      !u && !se || (se ? N(!0) : kt(!0), L(se));
    },
    open: B
  }, /* @__PURE__ */ z.createElement(jy.Provider, {
    value: {
      activeSnapPoint: ss,
      snapPoints: i,
      setActiveSnapPoint: J,
      drawerRef: Z,
      overlayRef: pe,
      onOpenChange: e,
      onPress: Ls,
      onRelease: tc,
      onDrag: ai,
      dismissible: u,
      handleOnly: d,
      isOpen: B,
      isDragging: H,
      shouldFade: ut,
      closeDrawer: kt,
      onNestedDrag: sc,
      onNestedOpenChange: nc,
      onNestedRelease: rc,
      keyboardIsOpen: Ue,
      modal: A,
      snapPointsOffset: ge,
      direction: x,
      shouldScaleBackground: o,
      setBackgroundColorOnScale: a,
      noBodyStyles: w,
      container: R,
      autoFocus: D
    }
  }, n));
}
const Yy = /* @__PURE__ */ z.forwardRef(function({ ...t }, e) {
  const { overlayRef: n, snapPoints: s, onRelease: r, shouldFade: i, isOpen: o, modal: a } = si(), l = Fy(e, n), c = s && s.length > 0;
  return a ? /* @__PURE__ */ z.createElement(Jd, {
    onMouseUp: r,
    ref: l,
    "data-vaul-overlay": "",
    "data-vaul-snap-points": o && c ? "true" : "false",
    "data-vaul-snap-points-overlay": o && i ? "true" : "false",
    ...t
  }) : (typeof window < "u" && window.requestAnimationFrame(() => {
    document.body.style.pointerEvents = "auto";
  }), null);
});
Yy.displayName = "Drawer.Overlay";
const Ky = /* @__PURE__ */ z.forwardRef(function({ onPointerDownOutside: t, style: e, onOpenAutoFocus: n, ...s }, r) {
  const { drawerRef: i, onPress: o, onRelease: a, onDrag: l, keyboardIsOpen: c, snapPointsOffset: u, modal: d, isOpen: f, direction: h, snapPoints: p, container: g, handleOnly: A, autoFocus: b } = si(), [y, w] = z.useState(!1), x = Fy(r, i), S = z.useRef(null), q = z.useRef(null), C = z.useRef(!1), E = p && p.length > 0;
  hD();
  const T = (R, D, F = 0) => {
    if (C.current) return !0;
    const j = Math.abs(R.y), B = Math.abs(R.x), L = B > j, O = [
      "bottom",
      "right"
    ].includes(D) ? 1 : -1;
    if (D === "left" || D === "right") {
      if (!(R.x * O < 0) && B >= 0 && B <= F)
        return L;
    } else if (!(R.y * O < 0) && j >= 0 && j <= F)
      return !L;
    return C.current = !0, !0;
  };
  z.useEffect(() => {
    E && window.requestAnimationFrame(() => {
      w(!0);
    });
  }, []);
  function k(R) {
    S.current = null, C.current = !1, a(R);
  }
  return /* @__PURE__ */ z.createElement($d, {
    "data-vaul-drawer-direction": h,
    "data-vaul-drawer": "",
    "data-vaul-delayed-snap-points": y ? "true" : "false",
    "data-vaul-snap-points": f && E ? "true" : "false",
    "data-vaul-custom-container": g ? "true" : "false",
    ...s,
    ref: x,
    style: u && u.length > 0 ? {
      "--snap-point-height": `${u[0]}px`,
      ...e
    } : e,
    onPointerDown: (R) => {
      A || (s.onPointerDown == null || s.onPointerDown.call(s, R), S.current = {
        x: R.pageX,
        y: R.pageY
      }, o(R));
    },
    onOpenAutoFocus: (R) => {
      n == null || n(R), b || R.preventDefault();
    },
    onPointerDownOutside: (R) => {
      if (t == null || t(R), !d || R.defaultPrevented) {
        R.preventDefault();
        return;
      }
      c.current && (c.current = !1);
    },
    onFocusOutside: (R) => {
      if (!d) {
        R.preventDefault();
        return;
      }
    },
    onPointerMove: (R) => {
      if (q.current = R, A || (s.onPointerMove == null || s.onPointerMove.call(s, R), !S.current)) return;
      const D = R.pageY - S.current.y, F = R.pageX - S.current.x, j = R.pointerType === "touch" ? 10 : 2;
      T({
        x: F,
        y: D
      }, h, j) ? l(R) : (Math.abs(F) > j || Math.abs(D) > j) && (S.current = null);
    },
    onPointerUp: (R) => {
      s.onPointerUp == null || s.onPointerUp.call(s, R), S.current = null, C.current = !1, a(R);
    },
    onPointerOut: (R) => {
      s.onPointerOut == null || s.onPointerOut.call(s, R), k(q.current);
    },
    onContextMenu: (R) => {
      s.onContextMenu == null || s.onContextMenu.call(s, R), k(q.current);
    }
  });
});
Ky.displayName = "Drawer.Content";
const gD = 250, mD = 120, Xy = /* @__PURE__ */ z.forwardRef(function({ preventCycle: t = !1, children: e, ...n }, s) {
  const { closeDrawer: r, isDragging: i, snapPoints: o, activeSnapPoint: a, setActiveSnapPoint: l, dismissible: c, handleOnly: u, isOpen: d, onPress: f, onDrag: h } = si(), p = z.useRef(null), g = z.useRef(!1);
  function A() {
    if (g.current) {
      w();
      return;
    }
    window.setTimeout(() => {
      b();
    }, mD);
  }
  function b() {
    if (i || t || g.current) {
      w();
      return;
    }
    if (w(), (!o || o.length === 0) && c) {
      r();
      return;
    }
    if (a === o[o.length - 1] && c) {
      r();
      return;
    }
    const S = o.findIndex((C) => C === a);
    if (S === -1) return;
    const q = o[S + 1];
    l(q);
  }
  function y() {
    p.current = window.setTimeout(() => {
      g.current = !0;
    }, gD);
  }
  function w() {
    window.clearTimeout(p.current), g.current = !1;
  }
  return /* @__PURE__ */ z.createElement("div", {
    onClick: A,
    onPointerCancel: w,
    onPointerDown: (x) => {
      u && f(x), y();
    },
    onPointerMove: (x) => {
      u && h(x);
    },
    // onPointerUp is already handled by the content component
    ref: s,
    "data-vaul-drawer-visible": d ? "true" : "false",
    "data-vaul-handle": "",
    "aria-hidden": "true",
    ...n
  }, /* @__PURE__ */ z.createElement("span", {
    "data-vaul-handle-hitarea": "",
    "aria-hidden": "true"
  }, e));
});
Xy.displayName = "Drawer.Handle";
function AD({ onDrag: t, onOpenChange: e, ...n }) {
  const { onNestedDrag: s, onNestedOpenChange: r, onNestedRelease: i } = si();
  if (!s)
    throw new Error("Drawer.NestedRoot must be placed in another drawer");
  return /* @__PURE__ */ z.createElement(Qy, {
    nested: !0,
    onClose: () => {
      r(!1);
    },
    onDrag: (o, a) => {
      s(o, a), t == null || t(o, a);
    },
    onOpenChange: (o) => {
      o && r(o);
    },
    onRelease: i,
    ...n
  });
}
function bD(t) {
  const e = si(), { container: n = e.container, ...s } = t;
  return /* @__PURE__ */ z.createElement(FM, {
    container: n,
    ...s
  });
}
const Mn = {
  Root: Qy,
  NestedRoot: AD,
  Content: Ky,
  Overlay: Yy,
  Trigger: My,
  Portal: bD,
  Handle: Xy,
  Close: nf,
  Title: ef,
  Description: tf
}, cf = ({
  shouldScaleBackground: t = !0,
  ...e
}) => /* @__PURE__ */ m.jsx(
  Mn.Root,
  {
    shouldScaleBackground: t,
    ...e
  }
);
cf.displayName = "Drawer";
const Gy = Mn.Trigger, Zy = Mn.Close, _y = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  Mn.Overlay,
  {
    ref: n,
    className: Be("fixed inset-0 z-50 bg-black/80", t),
    ...e
  }
));
_y.displayName = Mn.Overlay.displayName;
const uf = v.forwardRef(({ className: t, children: e, ...n }, s) => /* @__PURE__ */ m.jsx(m.Fragment, { children: /* @__PURE__ */ m.jsx(_y, { children: /* @__PURE__ */ m.jsxs(
  Mn.Content,
  {
    ref: s,
    className: Be(
      "fixed inset-x-0 bottom-0 max-h-[90%] z-50 mt-24 flex flex-col rounded-t-[10px] border bg-background",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ m.jsx("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
      e
    ]
  }
) }) }));
uf.displayName = "DrawerContent";
const df = ({
  className: t,
  ...e
}) => /* @__PURE__ */ m.jsx(
  "div",
  {
    className: Be("grid gap-1.5 p-4 text-center sm:text-left", t),
    ...e
  }
);
df.displayName = "DrawerHeader";
const ff = ({
  className: t,
  ...e
}) => /* @__PURE__ */ m.jsx(
  "div",
  {
    className: Be("mt-auto flex flex-col gap-2 p-4", t),
    ...e
  }
);
ff.displayName = "DrawerFooter";
const hf = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  Mn.Title,
  {
    ref: n,
    className: Be(
      "text-lg font-semibold leading-none tracking-tight",
      t
    ),
    ...e
  }
));
hf.displayName = Mn.Title.displayName;
const yD = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  Mn.Description,
  {
    ref: n,
    className: Be("text-sm text-muted-foreground", t),
    ...e
  }
));
yD.displayName = Mn.Description.displayName;
function vD(t, e) {
  return v.useReducer((n, s) => e[n][s] ?? n, t);
}
var Eo = (t) => {
  const { present: e, children: n } = t, s = xD(e), r = typeof n == "function" ? n({ present: s.isPresent }) : v.Children.only(n), i = Pe(s.ref, wD(r));
  return typeof n == "function" || s.isPresent ? v.cloneElement(r, { ref: i }) : null;
};
Eo.displayName = "Presence";
function xD(t) {
  const [e, n] = v.useState(), s = v.useRef({}), r = v.useRef(t), i = v.useRef("none"), o = t ? "mounted" : "unmounted", [a, l] = vD(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return v.useEffect(() => {
    const c = Ko(s.current);
    i.current = a === "mounted" ? c : "none";
  }, [a]), Lt(() => {
    const c = s.current, u = r.current;
    if (u !== t) {
      const f = i.current, h = Ko(c);
      t ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), r.current = t;
    }
  }, [t, l]), Lt(() => {
    if (e) {
      let c;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const g = Ko(s.current).includes(h.animationName);
        if (h.target === e && g && (l("ANIMATION_END"), !r.current)) {
          const A = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = A);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = Ko(s.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(c), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [e, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: v.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function Ko(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function wD(t) {
  var s, r;
  let e = (s = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (r = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
function SD(t, e = []) {
  let n = [];
  function s(i, o) {
    const a = v.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, g = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[l]) || a, A = v.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ m.jsx(g.Provider, { value: A, children: h });
    };
    c.displayName = i + "Provider";
    function u(d, f) {
      var g;
      const h = ((g = f == null ? void 0 : f[t]) == null ? void 0 : g[l]) || a, p = v.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const r = () => {
    const i = n.map((o) => v.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[t]) || i;
      return v.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return r.scopeName = t, [s, CD(r, ...e)];
}
function CD(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const s = t.map((r) => ({
      useScope: r(),
      scopeName: r.scopeName
    }));
    return function(i) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return v.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
var PD = v.createContext(void 0);
function pf(t) {
  const e = v.useContext(PD);
  return t || e || "ltr";
}
function gf(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
function qD(t, e) {
  return v.useReducer((n, s) => e[n][s] ?? n, t);
}
var mf = "ScrollArea", [Jy, $9] = SD(mf), [ED, an] = Jy(mf), $y = v.forwardRef(
  (t, e) => {
    const {
      __scopeScrollArea: n,
      type: s = "hover",
      dir: r,
      scrollHideDelay: i = 600,
      ...o
    } = t, [a, l] = v.useState(null), [c, u] = v.useState(null), [d, f] = v.useState(null), [h, p] = v.useState(null), [g, A] = v.useState(null), [b, y] = v.useState(0), [w, x] = v.useState(0), [S, q] = v.useState(!1), [C, E] = v.useState(!1), T = Pe(e, (R) => l(R)), k = pf(r);
    return /* @__PURE__ */ m.jsx(
      ED,
      {
        scope: n,
        type: s,
        dir: k,
        scrollHideDelay: i,
        scrollArea: a,
        viewport: c,
        onViewportChange: u,
        content: d,
        onContentChange: f,
        scrollbarX: h,
        onScrollbarXChange: p,
        scrollbarXEnabled: S,
        onScrollbarXEnabledChange: q,
        scrollbarY: g,
        onScrollbarYChange: A,
        scrollbarYEnabled: C,
        onScrollbarYEnabledChange: E,
        onCornerWidthChange: y,
        onCornerHeightChange: x,
        children: /* @__PURE__ */ m.jsx(
          qe.div,
          {
            dir: k,
            ...o,
            ref: T,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": b + "px",
              "--radix-scroll-area-corner-height": w + "px",
              ...t.style
            }
          }
        )
      }
    );
  }
);
$y.displayName = mf;
var ev = "ScrollAreaViewport", tv = v.forwardRef(
  (t, e) => {
    const { __scopeScrollArea: n, children: s, asChild: r, nonce: i, ...o } = t, a = an(ev, n), l = v.useRef(null), c = Pe(e, l, a.onViewportChange);
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `
[data-radix-scroll-area-viewport] {
  scrollbar-width: none;
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
}
[data-radix-scroll-area-viewport]::-webkit-scrollbar {
  display: none;
}
:where([data-radix-scroll-area-viewport]) {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
:where([data-radix-scroll-area-content]) {
  flex-grow: 1;
}
`
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ m.jsx(
        qe.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o,
          asChild: r,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
            ...t.style
          },
          children: BD({ asChild: r, children: s }, (u) => /* @__PURE__ */ m.jsx(
            "div",
            {
              "data-radix-scroll-area-content": "",
              ref: a.onContentChange,
              style: { minWidth: a.scrollbarXEnabled ? "fit-content" : void 0 },
              children: u
            }
          ))
        }
      )
    ] });
  }
);
tv.displayName = ev;
var Dn = "ScrollAreaScrollbar", Af = v.forwardRef(
  (t, e) => {
    const { forceMount: n, ...s } = t, r = an(Dn, t.__scopeScrollArea), { onScrollbarXEnabledChange: i, onScrollbarYEnabledChange: o } = r, a = t.orientation === "horizontal";
    return v.useEffect(() => (a ? i(!0) : o(!0), () => {
      a ? i(!1) : o(!1);
    }), [a, i, o]), r.type === "hover" ? /* @__PURE__ */ m.jsx(TD, { ...s, ref: e, forceMount: n }) : r.type === "scroll" ? /* @__PURE__ */ m.jsx(RD, { ...s, ref: e, forceMount: n }) : r.type === "auto" ? /* @__PURE__ */ m.jsx(nv, { ...s, ref: e, forceMount: n }) : r.type === "always" ? /* @__PURE__ */ m.jsx(bf, { ...s, ref: e }) : null;
  }
);
Af.displayName = Dn;
var TD = v.forwardRef((t, e) => {
  const { forceMount: n, ...s } = t, r = an(Dn, t.__scopeScrollArea), [i, o] = v.useState(!1);
  return v.useEffect(() => {
    const a = r.scrollArea;
    let l = 0;
    if (a) {
      const c = () => {
        window.clearTimeout(l), o(!0);
      }, u = () => {
        l = window.setTimeout(() => o(!1), r.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", c), a.addEventListener("pointerleave", u), () => {
        window.clearTimeout(l), a.removeEventListener("pointerenter", c), a.removeEventListener("pointerleave", u);
      };
    }
  }, [r.scrollArea, r.scrollHideDelay]), /* @__PURE__ */ m.jsx(Eo, { present: n || i, children: /* @__PURE__ */ m.jsx(
    nv,
    {
      "data-state": i ? "visible" : "hidden",
      ...s,
      ref: e
    }
  ) });
}), RD = v.forwardRef((t, e) => {
  const { forceMount: n, ...s } = t, r = an(Dn, t.__scopeScrollArea), i = t.orientation === "horizontal", o = Il(() => l("SCROLL_END"), 100), [a, l] = qD("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return v.useEffect(() => {
    if (a === "idle") {
      const c = window.setTimeout(() => l("HIDE"), r.scrollHideDelay);
      return () => window.clearTimeout(c);
    }
  }, [a, r.scrollHideDelay, l]), v.useEffect(() => {
    const c = r.viewport, u = i ? "scrollLeft" : "scrollTop";
    if (c) {
      let d = c[u];
      const f = () => {
        const h = c[u];
        d !== h && (l("SCROLL"), o()), d = h;
      };
      return c.addEventListener("scroll", f), () => c.removeEventListener("scroll", f);
    }
  }, [r.viewport, i, l, o]), /* @__PURE__ */ m.jsx(Eo, { present: n || a !== "hidden", children: /* @__PURE__ */ m.jsx(
    bf,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...s,
      ref: e,
      onPointerEnter: we(t.onPointerEnter, () => l("POINTER_ENTER")),
      onPointerLeave: we(t.onPointerLeave, () => l("POINTER_LEAVE"))
    }
  ) });
}), nv = v.forwardRef((t, e) => {
  const n = an(Dn, t.__scopeScrollArea), { forceMount: s, ...r } = t, [i, o] = v.useState(!1), a = t.orientation === "horizontal", l = Il(() => {
    if (n.viewport) {
      const c = n.viewport.offsetWidth < n.viewport.scrollWidth, u = n.viewport.offsetHeight < n.viewport.scrollHeight;
      o(a ? c : u);
    }
  }, 10);
  return Ur(n.viewport, l), Ur(n.content, l), /* @__PURE__ */ m.jsx(Eo, { present: s || i, children: /* @__PURE__ */ m.jsx(
    bf,
    {
      "data-state": i ? "visible" : "hidden",
      ...r,
      ref: e
    }
  ) });
}), bf = v.forwardRef((t, e) => {
  const { orientation: n = "vertical", ...s } = t, r = an(Dn, t.__scopeScrollArea), i = v.useRef(null), o = v.useRef(0), [a, l] = v.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), c = av(a.viewport, a.content), u = {
    ...s,
    sizes: a,
    onSizesChange: l,
    hasThumb: c > 0 && c < 1,
    onThumbChange: (f) => i.current = f,
    onThumbPointerUp: () => o.current = 0,
    onThumbPointerDown: (f) => o.current = f
  };
  function d(f, h) {
    return ND(f, o.current, a, h);
  }
  return n === "horizontal" ? /* @__PURE__ */ m.jsx(
    kD,
    {
      ...u,
      ref: e,
      onThumbPositionChange: () => {
        if (r.viewport && i.current) {
          const f = r.viewport.scrollLeft, h = Sg(f, a, r.dir);
          i.current.style.transform = `translate3d(${h}px, 0, 0)`;
        }
      },
      onWheelScroll: (f) => {
        r.viewport && (r.viewport.scrollLeft = f);
      },
      onDragScroll: (f) => {
        r.viewport && (r.viewport.scrollLeft = d(f, r.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ m.jsx(
    MD,
    {
      ...u,
      ref: e,
      onThumbPositionChange: () => {
        if (r.viewport && i.current) {
          const f = r.viewport.scrollTop, h = Sg(f, a);
          i.current.style.transform = `translate3d(0, ${h}px, 0)`;
        }
      },
      onWheelScroll: (f) => {
        r.viewport && (r.viewport.scrollTop = f);
      },
      onDragScroll: (f) => {
        r.viewport && (r.viewport.scrollTop = d(f));
      }
    }
  ) : null;
}), kD = v.forwardRef((t, e) => {
  const { sizes: n, onSizesChange: s, ...r } = t, i = an(Dn, t.__scopeScrollArea), [o, a] = v.useState(), l = v.useRef(null), c = Pe(e, l, i.onScrollbarXChange);
  return v.useEffect(() => {
    l.current && a(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ m.jsx(
    rv,
    {
      "data-orientation": "horizontal",
      ...r,
      ref: c,
      sizes: n,
      style: {
        bottom: 0,
        left: i.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: i.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Bl(n) + "px",
        ...t.style
      },
      onThumbPointerDown: (u) => t.onThumbPointerDown(u.x),
      onDragScroll: (u) => t.onDragScroll(u.x),
      onWheelScroll: (u, d) => {
        if (i.viewport) {
          const f = i.viewport.scrollLeft + u.deltaX;
          t.onWheelScroll(f), cv(f, d) && u.preventDefault();
        }
      },
      onResize: () => {
        l.current && i.viewport && o && s({
          content: i.viewport.scrollWidth,
          viewport: i.viewport.offsetWidth,
          scrollbar: {
            size: l.current.clientWidth,
            paddingStart: ol(o.paddingLeft),
            paddingEnd: ol(o.paddingRight)
          }
        });
      }
    }
  );
}), MD = v.forwardRef((t, e) => {
  const { sizes: n, onSizesChange: s, ...r } = t, i = an(Dn, t.__scopeScrollArea), [o, a] = v.useState(), l = v.useRef(null), c = Pe(e, l, i.onScrollbarYChange);
  return v.useEffect(() => {
    l.current && a(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ m.jsx(
    rv,
    {
      "data-orientation": "vertical",
      ...r,
      ref: c,
      sizes: n,
      style: {
        top: 0,
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Bl(n) + "px",
        ...t.style
      },
      onThumbPointerDown: (u) => t.onThumbPointerDown(u.y),
      onDragScroll: (u) => t.onDragScroll(u.y),
      onWheelScroll: (u, d) => {
        if (i.viewport) {
          const f = i.viewport.scrollTop + u.deltaY;
          t.onWheelScroll(f), cv(f, d) && u.preventDefault();
        }
      },
      onResize: () => {
        l.current && i.viewport && o && s({
          content: i.viewport.scrollHeight,
          viewport: i.viewport.offsetHeight,
          scrollbar: {
            size: l.current.clientHeight,
            paddingStart: ol(o.paddingTop),
            paddingEnd: ol(o.paddingBottom)
          }
        });
      }
    }
  );
}), [DD, sv] = Jy(Dn), rv = v.forwardRef((t, e) => {
  const {
    __scopeScrollArea: n,
    sizes: s,
    hasThumb: r,
    onThumbChange: i,
    onThumbPointerUp: o,
    onThumbPointerDown: a,
    onThumbPositionChange: l,
    onDragScroll: c,
    onWheelScroll: u,
    onResize: d,
    ...f
  } = t, h = an(Dn, n), [p, g] = v.useState(null), A = Pe(e, (T) => g(T)), b = v.useRef(null), y = v.useRef(""), w = h.viewport, x = s.content - s.viewport, S = bt(u), q = bt(l), C = Il(d, 10);
  function E(T) {
    if (b.current) {
      const k = T.clientX - b.current.left, R = T.clientY - b.current.top;
      c({ x: k, y: R });
    }
  }
  return v.useEffect(() => {
    const T = (k) => {
      const R = k.target;
      (p == null ? void 0 : p.contains(R)) && S(k, x);
    };
    return document.addEventListener("wheel", T, { passive: !1 }), () => document.removeEventListener("wheel", T, { passive: !1 });
  }, [w, p, x, S]), v.useEffect(q, [s, q]), Ur(p, C), Ur(h.content, C), /* @__PURE__ */ m.jsx(
    DD,
    {
      scope: n,
      scrollbar: p,
      hasThumb: r,
      onThumbChange: bt(i),
      onThumbPointerUp: bt(o),
      onThumbPositionChange: q,
      onThumbPointerDown: bt(a),
      children: /* @__PURE__ */ m.jsx(
        qe.div,
        {
          ...f,
          ref: A,
          style: { position: "absolute", ...f.style },
          onPointerDown: we(t.onPointerDown, (T) => {
            T.button === 0 && (T.target.setPointerCapture(T.pointerId), b.current = p.getBoundingClientRect(), y.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", h.viewport && (h.viewport.style.scrollBehavior = "auto"), E(T));
          }),
          onPointerMove: we(t.onPointerMove, E),
          onPointerUp: we(t.onPointerUp, (T) => {
            const k = T.target;
            k.hasPointerCapture(T.pointerId) && k.releasePointerCapture(T.pointerId), document.body.style.webkitUserSelect = y.current, h.viewport && (h.viewport.style.scrollBehavior = ""), b.current = null;
          })
        }
      )
    }
  );
}), il = "ScrollAreaThumb", iv = v.forwardRef(
  (t, e) => {
    const { forceMount: n, ...s } = t, r = sv(il, t.__scopeScrollArea);
    return /* @__PURE__ */ m.jsx(Eo, { present: n || r.hasThumb, children: /* @__PURE__ */ m.jsx(OD, { ref: e, ...s }) });
  }
), OD = v.forwardRef(
  (t, e) => {
    const { __scopeScrollArea: n, style: s, ...r } = t, i = an(il, n), o = sv(il, n), { onThumbPositionChange: a } = o, l = Pe(
      e,
      (d) => o.onThumbChange(d)
    ), c = v.useRef(), u = Il(() => {
      c.current && (c.current(), c.current = void 0);
    }, 100);
    return v.useEffect(() => {
      const d = i.viewport;
      if (d) {
        const f = () => {
          if (u(), !c.current) {
            const h = jD(d, a);
            c.current = h, a();
          }
        };
        return a(), d.addEventListener("scroll", f), () => d.removeEventListener("scroll", f);
      }
    }, [i.viewport, u, a]), /* @__PURE__ */ m.jsx(
      qe.div,
      {
        "data-state": o.hasThumb ? "visible" : "hidden",
        ...r,
        ref: l,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...s
        },
        onPointerDownCapture: we(t.onPointerDownCapture, (d) => {
          const h = d.target.getBoundingClientRect(), p = d.clientX - h.left, g = d.clientY - h.top;
          o.onThumbPointerDown({ x: p, y: g });
        }),
        onPointerUp: we(t.onPointerUp, o.onThumbPointerUp)
      }
    );
  }
);
iv.displayName = il;
var yf = "ScrollAreaCorner", ov = v.forwardRef(
  (t, e) => {
    const n = an(yf, t.__scopeScrollArea), s = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && s ? /* @__PURE__ */ m.jsx(LD, { ...t, ref: e }) : null;
  }
);
ov.displayName = yf;
var LD = v.forwardRef((t, e) => {
  const { __scopeScrollArea: n, ...s } = t, r = an(yf, n), [i, o] = v.useState(0), [a, l] = v.useState(0), c = !!(i && a);
  return Ur(r.scrollbarX, () => {
    var d;
    const u = ((d = r.scrollbarX) == null ? void 0 : d.offsetHeight) || 0;
    r.onCornerHeightChange(u), l(u);
  }), Ur(r.scrollbarY, () => {
    var d;
    const u = ((d = r.scrollbarY) == null ? void 0 : d.offsetWidth) || 0;
    r.onCornerWidthChange(u), o(u);
  }), c ? /* @__PURE__ */ m.jsx(
    qe.div,
    {
      ...s,
      ref: e,
      style: {
        width: i,
        height: a,
        position: "absolute",
        right: r.dir === "ltr" ? 0 : void 0,
        left: r.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...t.style
      }
    }
  ) : null;
});
function ol(t) {
  return t ? parseInt(t, 10) : 0;
}
function av(t, e) {
  const n = t / e;
  return isNaN(n) ? 0 : n;
}
function Bl(t) {
  const e = av(t.viewport, t.content), n = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = (t.scrollbar.size - n) * e;
  return Math.max(s, 18);
}
function ND(t, e, n, s = "ltr") {
  const r = Bl(n), i = r / 2, o = e || i, a = r - o, l = n.scrollbar.paddingStart + o, c = n.scrollbar.size - n.scrollbar.paddingEnd - a, u = n.content - n.viewport, d = s === "ltr" ? [0, u] : [u * -1, 0];
  return lv([l, c], d)(t);
}
function Sg(t, e, n = "ltr") {
  const s = Bl(e), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, i = e.scrollbar.size - r, o = e.content - e.viewport, a = i - s, l = n === "ltr" ? [0, o] : [o * -1, 0], c = gf(t, l);
  return lv([0, o], [0, a])(c);
}
function lv(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const s = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + s * (n - t[0]);
  };
}
function cv(t, e) {
  return t > 0 && t < e;
}
var jD = (t, e = () => {
}) => {
  let n = { left: t.scrollLeft, top: t.scrollTop }, s = 0;
  return function r() {
    const i = { left: t.scrollLeft, top: t.scrollTop }, o = n.left !== i.left, a = n.top !== i.top;
    (o || a) && e(), n = i, s = window.requestAnimationFrame(r);
  }(), () => window.cancelAnimationFrame(s);
};
function Il(t, e) {
  const n = bt(t), s = v.useRef(0);
  return v.useEffect(() => () => window.clearTimeout(s.current), []), v.useCallback(() => {
    window.clearTimeout(s.current), s.current = window.setTimeout(n, e);
  }, [n, e]);
}
function Ur(t, e) {
  const n = bt(e);
  Lt(() => {
    let s = 0;
    if (t) {
      const r = new ResizeObserver(() => {
        cancelAnimationFrame(s), s = window.requestAnimationFrame(n);
      });
      return r.observe(t), () => {
        window.cancelAnimationFrame(s), r.unobserve(t);
      };
    }
  }, [t, n]);
}
function BD(t, e) {
  const { asChild: n, children: s } = t;
  if (!n) return typeof e == "function" ? e(s) : e;
  const r = v.Children.only(s);
  return v.cloneElement(r, {
    children: typeof e == "function" ? e(r.props.children) : e
  });
}
var uv = $y, ID = tv, FD = ov;
const dv = v.forwardRef(({ className: t, children: e, ...n }, s) => /* @__PURE__ */ m.jsxs(
  uv,
  {
    ref: s,
    className: Be("relative overflow-hidden", t),
    ...n,
    children: [
      /* @__PURE__ */ m.jsx(ID, { className: "h-full w-full rounded-[inherit]", children: e }),
      /* @__PURE__ */ m.jsx(fv, {}),
      /* @__PURE__ */ m.jsx(FD, {})
    ]
  }
));
dv.displayName = uv.displayName;
const fv = v.forwardRef(({ className: t, orientation: e = "vertical", ...n }, s) => /* @__PURE__ */ m.jsx(
  Af,
  {
    ref: s,
    orientation: e,
    className: Be(
      "flex touch-none select-none transition-colors",
      e === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      e === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      t
    ),
    ...n,
    children: /* @__PURE__ */ m.jsx(iv, { className: "relative flex-1 rounded-full bg-border" })
  }
));
fv.displayName = Af.displayName;
function VD() {
  const {
    currentServerSeed: t,
    currentClientSeed: e,
    currentNonce: n,
    newServerSeed: s,
    newClientSeed: r,
    setNewClientSeed: i,
    useNewSeeds: o,
    isProvablyFairDialogOpen: a,
    setIsProvablyFairDialogOpen: l,
    isLoadingCurrentSeed: c,
    fetchCurrentSeed: u
  } = it(), { authToken: d } = vl(), f = Zr();
  je(() => {
    a && d && u(d);
  }, [a, d, u]);
  const h = Fe(() => {
    const q = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    i(q);
  }, []), p = Fe(async () => {
    d && (i(r), await o(d), await u(d));
  }, [d, o, l, i, r]), g = Fe((q) => {
    i(q.target.value);
  }, []), A = "flex items-center space-x-2 bg-primary rounded-md p-1 h-11", b = "bg-primary text-white text-base h-9 border-transparent focus-visible:ring-brand focus-visible:ring-2 focus-visible:ring-offset-0 focus-visible:border-0 transition-all", y = "text-xs text-gray-400", w = /* @__PURE__ */ m.jsxs("div", { className: "space-y-6 px-0", children: [
    /* @__PURE__ */ m.jsx("div", { className: "bg-primary rounded-lg p-4 mb-4", children: /* @__PURE__ */ m.jsx("p", { className: "text-white text-sm", children: "You may use this function to set a new server seed + a new client seed. They can be randomly generated or customized (at least 10 characters), and the number of bets will be reset to zero." }) }),
    /* @__PURE__ */ m.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ m.jsxs("div", { className: "flex items-center justify-center space-x-4", children: [
        /* @__PURE__ */ m.jsx("div", { className: "h-px bg-gray-700 flex-grow" }),
        /* @__PURE__ */ m.jsx("h3", { className: "text-sm font-semibold text-gray-400", children: "Current seeds" }),
        /* @__PURE__ */ m.jsx("div", { className: "h-px bg-gray-700 flex-grow" })
      ] }),
      c ? /* @__PURE__ */ m.jsx("div", { className: "flex justify-center items-center h-24", children: /* @__PURE__ */ m.jsx(OT, { className: "animate-spin h-8 w-8 text-brand" }) }) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
        /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ m.jsx(rt, { htmlFor: "current-server-seed", className: y, children: "Server Seed (hash)" }),
          /* @__PURE__ */ m.jsx("div", { className: A, children: /* @__PURE__ */ m.jsx(
            ft,
            {
              id: "current-server-seed",
              value: t,
              readOnly: !0,
              disabled: !0,
              className: b
            }
          ) })
        ] }),
        /* @__PURE__ */ m.jsxs("div", { className: "flex space-x-4", children: [
          /* @__PURE__ */ m.jsxs("div", { className: "space-y-2 w-[70%]", children: [
            /* @__PURE__ */ m.jsx(rt, { htmlFor: "current-client-seed", className: y, children: "Client Seed" }),
            /* @__PURE__ */ m.jsx("div", { className: A, children: /* @__PURE__ */ m.jsx(
              ft,
              {
                id: "current-client-seed",
                value: e,
                readOnly: !0,
                disabled: !0,
                className: b
              }
            ) })
          ] }),
          /* @__PURE__ */ m.jsxs("div", { className: "space-y-2 w-[30%]", children: [
            /* @__PURE__ */ m.jsx(rt, { htmlFor: "current-nonce", className: y, children: "Nonce" }),
            /* @__PURE__ */ m.jsx("div", { className: A, children: /* @__PURE__ */ m.jsx(
              ft,
              {
                id: "current-nonce",
                value: n,
                readOnly: !0,
                disabled: !0,
                className: b
              }
            ) })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ m.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ m.jsxs("div", { className: "flex items-center justify-center space-x-4", children: [
        /* @__PURE__ */ m.jsx("div", { className: "h-px bg-gray-700 flex-grow" }),
        /* @__PURE__ */ m.jsx("h3", { className: "text-sm font-semibold text-gray-400", children: "New seeds" }),
        /* @__PURE__ */ m.jsx("div", { className: "h-px bg-gray-700 flex-grow" })
      ] }),
      /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ m.jsx(rt, { htmlFor: "new-server-seed", className: y, children: "Server Seed (hash)" }),
        /* @__PURE__ */ m.jsx("div", { className: A, children: /* @__PURE__ */ m.jsx(
          ft,
          {
            id: "new-server-seed",
            value: s,
            readOnly: !0,
            disabled: !0,
            className: b,
            placeholder: "Enter new server seed"
          }
        ) })
      ] }),
      /* @__PURE__ */ m.jsx("div", { className: "flex space-x-4", children: /* @__PURE__ */ m.jsxs("div", { className: "space-y-2 w-full", children: [
        /* @__PURE__ */ m.jsx(
          rt,
          {
            htmlFor: "new-client-seed",
            className: `${y} text-white`,
            children: "Client Seed"
          }
        ),
        /* @__PURE__ */ m.jsxs("div", { className: `${A} relative`, children: [
          /* @__PURE__ */ m.jsx(
            ft,
            {
              id: "new-client-seed",
              value: r,
              onChange: g,
              className: `${b} pr-8`,
              autoComplete: "off",
              placeholder: "Enter new client seed"
            }
          ),
          /* @__PURE__ */ m.jsxs(
            lt,
            {
              type: "button",
              variant: "ghost",
              size: "icon",
              className: "absolute right-0 top-0 h-full hover:bg-transparent focus:ring-0 focus:ring-offset-0 group",
              onClick: h,
              children: [
                /* @__PURE__ */ m.jsx(jT, { className: "h-4 w-4 text-gray-400 transition-colors duration-200 group-hover:text-white" }),
                /* @__PURE__ */ m.jsx("span", { className: "sr-only", children: "Generate random seed" })
              ]
            }
          )
        ] })
      ] }) })
    ] })
  ] }), x = /* @__PURE__ */ m.jsxs(rf, { className: "sm:max-w-[425px] p-3 sm:p-6 bg-secondary border-slate-600", children: [
    /* @__PURE__ */ m.jsx(of, { children: /* @__PURE__ */ m.jsx(af, { className: "text-white text-center", children: "Provably Fair" }) }),
    w,
    /* @__PURE__ */ m.jsxs("div", { className: "mt-4 space-y-2", children: [
      /* @__PURE__ */ m.jsx(
        lt,
        {
          className: "w-full bg-brand hover:bg-brand/80 text-brand-cta-text text-sm font-bold py-3 rounded-md",
          onClick: p,
          children: "Use New Seeds"
        }
      ),
      /* @__PURE__ */ m.jsx(Ly, { asChild: !0, children: /* @__PURE__ */ m.jsx(lt, { variant: "outline", className: "w-full py-3 rounded-md", children: "Close" }) })
    ] })
  ] }), S = /* @__PURE__ */ m.jsxs(uf, { className: "bg-secondary p-2 border-secondary", children: [
    /* @__PURE__ */ m.jsx(df, { className: "text-center text-white ", children: /* @__PURE__ */ m.jsx(hf, { children: "Provably Fair" }) }),
    /* @__PURE__ */ m.jsx(dv, { className: "overflow-y-auto no-scrollbar", children: w }),
    /* @__PURE__ */ m.jsxs(ff, { className: "mt-2 space-y-2", children: [
      /* @__PURE__ */ m.jsx(
        lt,
        {
          className: "w-full bg-brand hover:bg-brand/80 text-sm text-brand-cta-text",
          onClick: p,
          children: "Use New Seeds"
        }
      ),
      /* @__PURE__ */ m.jsx(Zy, { asChild: !0, children: /* @__PURE__ */ m.jsx(lt, { variant: "outline", className: "w-full", children: "Close" }) })
    ] })
  ] });
  return f ? /* @__PURE__ */ m.jsxs(
    cf,
    {
      open: a,
      onOpenChange: l,
      children: [
        /* @__PURE__ */ m.jsx(Gy, { asChild: !0, children: /* @__PURE__ */ m.jsx("button", { className: "text-gray-400 hover:text-white", children: /* @__PURE__ */ m.jsx(IT, { size: 20 }) }) }),
        S
      ]
    }
  ) : /* @__PURE__ */ m.jsxs(
    Dy,
    {
      open: a,
      onOpenChange: l,
      children: [
        /* @__PURE__ */ m.jsx(Oy, { asChild: !0, children: /* @__PURE__ */ m.jsx("button", { className: "text-gray-400 hover:text-white px-1", children: /* @__PURE__ */ m.jsx(LT, { size: 20 }) }) }),
        x
      ]
    }
  );
}
function zD(t, e = []) {
  let n = [];
  function s(i, o) {
    const a = v.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, g = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[l]) || a, A = v.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ m.jsx(g.Provider, { value: A, children: h });
    };
    c.displayName = i + "Provider";
    function u(d, f) {
      var g;
      const h = ((g = f == null ? void 0 : f[t]) == null ? void 0 : g[l]) || a, p = v.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const r = () => {
    const i = n.map((o) => v.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[t]) || i;
      return v.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return r.scopeName = t, [s, UD(r, ...e)];
}
function UD(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const s = t.map((r) => ({
      useScope: r(),
      scopeName: r.scopeName
    }));
    return function(i) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return v.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function vf(t, e = []) {
  let n = [];
  function s(i, o) {
    const a = v.createContext(o), l = n.length;
    n = [...n, o];
    function c(d) {
      const { scope: f, children: h, ...p } = d, g = (f == null ? void 0 : f[t][l]) || a, A = v.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ m.jsx(g.Provider, { value: A, children: h });
    }
    function u(d, f) {
      const h = (f == null ? void 0 : f[t][l]) || a, p = v.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return c.displayName = i + "Provider", [c, u];
  }
  const r = () => {
    const i = n.map((o) => v.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[t]) || i;
      return v.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return r.scopeName = t, [s, WD(r, ...e)];
}
function WD(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const s = t.map((r) => ({
      useScope: r(),
      scopeName: r.scopeName
    }));
    return function(i) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return v.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function hv(t) {
  const e = t + "CollectionProvider", [n, s] = vf(e), [r, i] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (h) => {
    const { scope: p, children: g } = h, A = z.useRef(null), b = z.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ m.jsx(r, { scope: p, itemMap: b, collectionRef: A, children: g });
  };
  o.displayName = e;
  const a = t + "CollectionSlot", l = z.forwardRef(
    (h, p) => {
      const { scope: g, children: A } = h, b = i(a, g), y = Pe(p, b.collectionRef);
      return /* @__PURE__ */ m.jsx(Ir, { ref: y, children: A });
    }
  );
  l.displayName = a;
  const c = t + "CollectionItemSlot", u = "data-radix-collection-item", d = z.forwardRef(
    (h, p) => {
      const { scope: g, children: A, ...b } = h, y = z.useRef(null), w = Pe(p, y), x = i(c, g);
      return z.useEffect(() => (x.itemMap.set(y, { ref: y, ...b }), () => void x.itemMap.delete(y))), /* @__PURE__ */ m.jsx(Ir, { [u]: "", ref: w, children: A });
    }
  );
  d.displayName = c;
  function f(h) {
    const p = i(t + "CollectionConsumer", h);
    return z.useCallback(() => {
      const A = p.collectionRef.current;
      if (!A) return [];
      const b = Array.from(A.querySelectorAll(`[${u}]`));
      return Array.from(p.itemMap.values()).sort(
        (x, S) => b.indexOf(x.ref.current) - b.indexOf(S.ref.current)
      );
    }, [p.collectionRef, p.itemMap]);
  }
  return [
    { Provider: o, Slot: l, ItemSlot: d },
    f,
    s
  ];
}
function HD(t, e = []) {
  let n = [];
  function s(i, o) {
    const a = v.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, g = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[l]) || a, A = v.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ m.jsx(g.Provider, { value: A, children: h });
    };
    c.displayName = i + "Provider";
    function u(d, f) {
      var g;
      const h = ((g = f == null ? void 0 : f[t]) == null ? void 0 : g[l]) || a, p = v.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const r = () => {
    const i = n.map((o) => v.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[t]) || i;
      return v.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return r.scopeName = t, [s, QD(r, ...e)];
}
function QD(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const s = t.map((r) => ({
      useScope: r(),
      scopeName: r.scopeName
    }));
    return function(i) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return v.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function YD(t, e) {
  return v.useReducer((n, s) => e[n][s] ?? n, t);
}
var pv = (t) => {
  const { present: e, children: n } = t, s = KD(e), r = typeof n == "function" ? n({ present: s.isPresent }) : v.Children.only(n), i = Pe(s.ref, XD(r));
  return typeof n == "function" || s.isPresent ? v.cloneElement(r, { ref: i }) : null;
};
pv.displayName = "Presence";
function KD(t) {
  const [e, n] = v.useState(), s = v.useRef({}), r = v.useRef(t), i = v.useRef("none"), o = t ? "mounted" : "unmounted", [a, l] = YD(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return v.useEffect(() => {
    const c = Xo(s.current);
    i.current = a === "mounted" ? c : "none";
  }, [a]), Lt(() => {
    const c = s.current, u = r.current;
    if (u !== t) {
      const f = i.current, h = Xo(c);
      t ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), r.current = t;
    }
  }, [t, l]), Lt(() => {
    if (e) {
      let c;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const g = Xo(s.current).includes(h.animationName);
        if (h.target === e && g && (l("ANIMATION_END"), !r.current)) {
          const A = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = A);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = Xo(s.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(c), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [e, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: v.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function Xo(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function XD(t) {
  var s, r;
  let e = (s = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (r = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var xf = "Collapsible", [GD, gv] = HD(xf), [ZD, wf] = GD(xf), mv = v.forwardRef(
  (t, e) => {
    const {
      __scopeCollapsible: n,
      open: s,
      defaultOpen: r,
      disabled: i,
      onOpenChange: o,
      ...a
    } = t, [l = !1, c] = ni({
      prop: s,
      defaultProp: r,
      onChange: o
    });
    return /* @__PURE__ */ m.jsx(
      ZD,
      {
        scope: n,
        disabled: i,
        contentId: Mr(),
        open: l,
        onOpenToggle: v.useCallback(() => c((u) => !u), [c]),
        children: /* @__PURE__ */ m.jsx(
          qe.div,
          {
            "data-state": Cf(l),
            "data-disabled": i ? "" : void 0,
            ...a,
            ref: e
          }
        )
      }
    );
  }
);
mv.displayName = xf;
var Av = "CollapsibleTrigger", bv = v.forwardRef(
  (t, e) => {
    const { __scopeCollapsible: n, ...s } = t, r = wf(Av, n);
    return /* @__PURE__ */ m.jsx(
      qe.button,
      {
        type: "button",
        "aria-controls": r.contentId,
        "aria-expanded": r.open || !1,
        "data-state": Cf(r.open),
        "data-disabled": r.disabled ? "" : void 0,
        disabled: r.disabled,
        ...s,
        ref: e,
        onClick: we(t.onClick, r.onOpenToggle)
      }
    );
  }
);
bv.displayName = Av;
var Sf = "CollapsibleContent", yv = v.forwardRef(
  (t, e) => {
    const { forceMount: n, ...s } = t, r = wf(Sf, t.__scopeCollapsible);
    return /* @__PURE__ */ m.jsx(pv, { present: n || r.open, children: ({ present: i }) => /* @__PURE__ */ m.jsx(_D, { ...s, ref: e, present: i }) });
  }
);
yv.displayName = Sf;
var _D = v.forwardRef((t, e) => {
  const { __scopeCollapsible: n, present: s, children: r, ...i } = t, o = wf(Sf, n), [a, l] = v.useState(s), c = v.useRef(null), u = Pe(e, c), d = v.useRef(0), f = d.current, h = v.useRef(0), p = h.current, g = o.open || a, A = v.useRef(g), b = v.useRef();
  return v.useEffect(() => {
    const y = requestAnimationFrame(() => A.current = !1);
    return () => cancelAnimationFrame(y);
  }, []), Lt(() => {
    const y = c.current;
    if (y) {
      b.current = b.current || {
        transitionDuration: y.style.transitionDuration,
        animationName: y.style.animationName
      }, y.style.transitionDuration = "0s", y.style.animationName = "none";
      const w = y.getBoundingClientRect();
      d.current = w.height, h.current = w.width, A.current || (y.style.transitionDuration = b.current.transitionDuration, y.style.animationName = b.current.animationName), l(s);
    }
  }, [o.open, s]), /* @__PURE__ */ m.jsx(
    qe.div,
    {
      "data-state": Cf(o.open),
      "data-disabled": o.disabled ? "" : void 0,
      id: o.contentId,
      hidden: !g,
      ...i,
      ref: u,
      style: {
        "--radix-collapsible-content-height": f ? `${f}px` : void 0,
        "--radix-collapsible-content-width": p ? `${p}px` : void 0,
        ...t.style
      },
      children: g && r
    }
  );
});
function Cf(t) {
  return t ? "open" : "closed";
}
var JD = mv, $D = bv, e3 = yv, es = "Accordion", t3 = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [Pf, n3, s3] = hv(es), [Fl, e5] = zD(es, [
  s3,
  gv
]), qf = gv(), vv = z.forwardRef(
  (t, e) => {
    const { type: n, ...s } = t, r = s, i = s;
    return /* @__PURE__ */ m.jsx(Pf.Provider, { scope: t.__scopeAccordion, children: n === "multiple" ? /* @__PURE__ */ m.jsx(a3, { ...i, ref: e }) : /* @__PURE__ */ m.jsx(o3, { ...r, ref: e }) });
  }
);
vv.displayName = es;
var [xv, r3] = Fl(es), [wv, i3] = Fl(
  es,
  { collapsible: !1 }
), o3 = z.forwardRef(
  (t, e) => {
    const {
      value: n,
      defaultValue: s,
      onValueChange: r = () => {
      },
      collapsible: i = !1,
      ...o
    } = t, [a, l] = ni({
      prop: n,
      defaultProp: s,
      onChange: r
    });
    return /* @__PURE__ */ m.jsx(
      xv,
      {
        scope: t.__scopeAccordion,
        value: a ? [a] : [],
        onItemOpen: l,
        onItemClose: z.useCallback(() => i && l(""), [i, l]),
        children: /* @__PURE__ */ m.jsx(wv, { scope: t.__scopeAccordion, collapsible: i, children: /* @__PURE__ */ m.jsx(Sv, { ...o, ref: e }) })
      }
    );
  }
), a3 = z.forwardRef((t, e) => {
  const {
    value: n,
    defaultValue: s,
    onValueChange: r = () => {
    },
    ...i
  } = t, [o = [], a] = ni({
    prop: n,
    defaultProp: s,
    onChange: r
  }), l = z.useCallback(
    (u) => a((d = []) => [...d, u]),
    [a]
  ), c = z.useCallback(
    (u) => a((d = []) => d.filter((f) => f !== u)),
    [a]
  );
  return /* @__PURE__ */ m.jsx(
    xv,
    {
      scope: t.__scopeAccordion,
      value: o,
      onItemOpen: l,
      onItemClose: c,
      children: /* @__PURE__ */ m.jsx(wv, { scope: t.__scopeAccordion, collapsible: !0, children: /* @__PURE__ */ m.jsx(Sv, { ...i, ref: e }) })
    }
  );
}), [l3, Vl] = Fl(es), Sv = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, disabled: s, dir: r, orientation: i = "vertical", ...o } = t, a = z.useRef(null), l = Pe(a, e), c = n3(n), d = pf(r) === "ltr", f = we(t.onKeyDown, (h) => {
      var E;
      if (!t3.includes(h.key)) return;
      const p = h.target, g = c().filter((T) => {
        var k;
        return !((k = T.ref.current) != null && k.disabled);
      }), A = g.findIndex((T) => T.ref.current === p), b = g.length;
      if (A === -1) return;
      h.preventDefault();
      let y = A;
      const w = 0, x = b - 1, S = () => {
        y = A + 1, y > x && (y = w);
      }, q = () => {
        y = A - 1, y < w && (y = x);
      };
      switch (h.key) {
        case "Home":
          y = w;
          break;
        case "End":
          y = x;
          break;
        case "ArrowRight":
          i === "horizontal" && (d ? S() : q());
          break;
        case "ArrowDown":
          i === "vertical" && S();
          break;
        case "ArrowLeft":
          i === "horizontal" && (d ? q() : S());
          break;
        case "ArrowUp":
          i === "vertical" && q();
          break;
      }
      const C = y % b;
      (E = g[C].ref.current) == null || E.focus();
    });
    return /* @__PURE__ */ m.jsx(
      l3,
      {
        scope: n,
        disabled: s,
        direction: r,
        orientation: i,
        children: /* @__PURE__ */ m.jsx(Pf.Slot, { scope: n, children: /* @__PURE__ */ m.jsx(
          qe.div,
          {
            ...o,
            "data-orientation": i,
            ref: l,
            onKeyDown: s ? void 0 : f
          }
        ) })
      }
    );
  }
), al = "AccordionItem", [c3, Ef] = Fl(al), Cv = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, value: s, ...r } = t, i = Vl(al, n), o = r3(al, n), a = qf(n), l = Mr(), c = s && o.value.includes(s) || !1, u = i.disabled || t.disabled;
    return /* @__PURE__ */ m.jsx(
      c3,
      {
        scope: n,
        open: c,
        disabled: u,
        triggerId: l,
        children: /* @__PURE__ */ m.jsx(
          JD,
          {
            "data-orientation": i.orientation,
            "data-state": kv(c),
            ...a,
            ...r,
            ref: e,
            disabled: u,
            open: c,
            onOpenChange: (d) => {
              d ? o.onItemOpen(s) : o.onItemClose(s);
            }
          }
        )
      }
    );
  }
);
Cv.displayName = al;
var Pv = "AccordionHeader", qv = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, ...s } = t, r = Vl(es, n), i = Ef(Pv, n);
    return /* @__PURE__ */ m.jsx(
      qe.h3,
      {
        "data-orientation": r.orientation,
        "data-state": kv(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        ...s,
        ref: e
      }
    );
  }
);
qv.displayName = Pv;
var Du = "AccordionTrigger", Ev = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, ...s } = t, r = Vl(es, n), i = Ef(Du, n), o = i3(Du, n), a = qf(n);
    return /* @__PURE__ */ m.jsx(Pf.ItemSlot, { scope: n, children: /* @__PURE__ */ m.jsx(
      $D,
      {
        "aria-disabled": i.open && !o.collapsible || void 0,
        "data-orientation": r.orientation,
        id: i.triggerId,
        ...a,
        ...s,
        ref: e
      }
    ) });
  }
);
Ev.displayName = Du;
var Tv = "AccordionContent", Rv = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, ...s } = t, r = Vl(es, n), i = Ef(Tv, n), o = qf(n);
    return /* @__PURE__ */ m.jsx(
      e3,
      {
        role: "region",
        "aria-labelledby": i.triggerId,
        "data-orientation": r.orientation,
        ...o,
        ...s,
        ref: e,
        style: {
          "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
          "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
          ...t.style
        }
      }
    );
  }
);
Rv.displayName = Tv;
function kv(t) {
  return t ? "open" : "closed";
}
var u3 = vv, d3 = Cv, f3 = qv, Mv = Ev, Dv = Rv;
const h3 = u3, wa = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsx(
  d3,
  {
    ref: n,
    className: Be("border-b", t),
    ...e
  }
));
wa.displayName = "AccordionItem";
const Sa = v.forwardRef(({ className: t, children: e, ...n }, s) => /* @__PURE__ */ m.jsx(f3, { className: "flex", children: /* @__PURE__ */ m.jsxs(
  Mv,
  {
    ref: s,
    className: Be(
      "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
      t
    ),
    ...n,
    children: [
      e,
      /* @__PURE__ */ m.jsx(zM, { className: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
    ]
  }
) }));
Sa.displayName = Mv.displayName;
const Ca = v.forwardRef(({ className: t, children: e, ...n }, s) => /* @__PURE__ */ m.jsx(
  Dv,
  {
    ref: s,
    className: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
    ...n,
    children: /* @__PURE__ */ m.jsx("div", { className: Be("pb-4 pt-0", t), children: e })
  }
));
Ca.displayName = Dv.displayName;
function p3() {
  const {
    isHelpDialogOpen: t,
    setIsHelpDialogOpen: e,
    selectedCurrency: n
  } = it(), s = Zr(), r = () => /* @__PURE__ */ m.jsxs(h3, { type: "single", collapsible: !0, defaultValue: "how-to-play", className: "w-full", children: [
    /* @__PURE__ */ m.jsxs(wa, { value: "how-to-play", children: [
      /* @__PURE__ */ m.jsx(Sa, { className: "font-bold", children: "How to Play" }),
      /* @__PURE__ */ m.jsxs(Ca, { children: [
        /* @__PURE__ */ m.jsx("p", { children: "Here's how to play the game:" }),
        /* @__PURE__ */ m.jsxs("ul", { className: "list-disc pl-5 mt-2", children: [
          /* @__PURE__ */ m.jsx("li", { children: "Select your bet amount" }),
          /* @__PURE__ */ m.jsx("li", { children: "Click the 'Play' button to start the game" }),
          /* @__PURE__ */ m.jsx("li", { children: "Watch as the multiplier increases" }),
          /* @__PURE__ */ m.jsx("li", { children: "Cash out before the game crashes to win!" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ m.jsxs(wa, { value: "rules", children: [
      /* @__PURE__ */ m.jsx(Sa, { className: "font-bold", children: "Rules" }),
      /* @__PURE__ */ m.jsxs(Ca, { children: [
        /* @__PURE__ */ m.jsx("p", { children: "Game rules and regulations:" }),
        /* @__PURE__ */ m.jsxs("ul", { className: "list-disc pl-5 mt-2", children: [
          /* @__PURE__ */ m.jsxs("li", { children: [
            "Minimum bet: ",
            n.prefixSymbol,
            n.fractionalDigits
          ] }),
          /* @__PURE__ */ m.jsxs("li", { children: [
            "Maximum bet: ",
            n.prefixSymbol,
            "1000"
          ] }),
          /* @__PURE__ */ m.jsx("li", { children: "The game can crash at any moment" }),
          /* @__PURE__ */ m.jsx("li", { children: "Your potential winnings increase as the multiplier grows" }),
          /* @__PURE__ */ m.jsx("li", { children: "If you don't cash out before the crash, you lose your bet" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ m.jsxs(wa, { value: "faq", children: [
      /* @__PURE__ */ m.jsx(Sa, { className: "font-bold", children: "FAQ" }),
      /* @__PURE__ */ m.jsx(Ca, { children: /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ m.jsxs("div", { children: [
          /* @__PURE__ */ m.jsx("h4", { className: "font-semibold", children: "Q: Is the game fair?" }),
          /* @__PURE__ */ m.jsx("p", { children: "A: Yes, the game uses a provably fair algorithm." })
        ] }),
        /* @__PURE__ */ m.jsxs("div", { children: [
          /* @__PURE__ */ m.jsx("h4", { className: "font-semibold", children: "Q: Can I play on mobile?" }),
          /* @__PURE__ */ m.jsx("p", { children: "A: Yes, the game is fully responsive and works on all devices." })
        ] }),
        /* @__PURE__ */ m.jsxs("div", { children: [
          /* @__PURE__ */ m.jsx("h4", { className: "font-semibold", children: "Q: How do I deposit?" }),
          /* @__PURE__ */ m.jsx("p", { children: "A: You can deposit using various cryptocurrencies or traditional payment methods." })
        ] })
      ] }) })
    ] })
  ] });
  return s ? /* @__PURE__ */ m.jsxs(
    cf,
    {
      open: t,
      onOpenChange: e,
      children: [
        /* @__PURE__ */ m.jsx(Gy, { asChild: !0, children: /* @__PURE__ */ m.jsx("button", { className: "text-gray-400 hover:text-white px-2", children: /* @__PURE__ */ m.jsx(eg, { size: 20 }) }) }),
        /* @__PURE__ */ m.jsxs(uf, { className: "bg-secondary text-white p-2", children: [
          /* @__PURE__ */ m.jsx(df, { className: "text-center", children: /* @__PURE__ */ m.jsx(hf, { children: "Game Information" }) }),
          /* @__PURE__ */ m.jsx("div", { className: "px-4 flex-1 overflow-y-auto", children: /* @__PURE__ */ m.jsx(r, {}) }),
          /* @__PURE__ */ m.jsx(ff, { className: "mt-2", children: /* @__PURE__ */ m.jsx(Zy, { asChild: !0, children: /* @__PURE__ */ m.jsx(lt, { variant: "outline", className: "w-full py-3 rounded-md text-black", children: "Close" }) }) })
        ] })
      ]
    }
  ) : /* @__PURE__ */ m.jsxs(
    Dy,
    {
      open: t,
      onOpenChange: e,
      children: [
        /* @__PURE__ */ m.jsx(Oy, { asChild: !0, children: /* @__PURE__ */ m.jsx("button", { className: "text-gray-400 hover:text-white px-2", children: /* @__PURE__ */ m.jsx(eg, { size: 20 }) }) }),
        /* @__PURE__ */ m.jsxs(rf, { className: "sm:max-w-[425px] p-3 sm:p-6 bg-secondary flex flex-col text-white border-brand", children: [
          /* @__PURE__ */ m.jsx(of, { children: /* @__PURE__ */ m.jsx(af, { className: "text-center", children: "Game Information" }) }),
          /* @__PURE__ */ m.jsx("div", { className: "flex-grow overflow-y-auto", children: /* @__PURE__ */ m.jsx(r, {}) }),
          /* @__PURE__ */ m.jsx("div", { className: "mt-4 text-black", children: /* @__PURE__ */ m.jsx(Ly, { asChild: !0, children: /* @__PURE__ */ m.jsx(lt, { variant: "outline", className: "w-full py-3 rounded-md", children: "Close" }) }) })
        ] })
      ]
    }
  );
}
function Ov() {
  const {
    balance: t,
    selectedCurrency: e,
    initializing: n,
    isSoundMuted: s,
    setIsSoundMuted: r,
    setLiveStatsOpen: i,
    isLiveStatsOpen: o
  } = it(), a = t.toFixed(e.fractionalDigits), l = () => {
    r(!s);
  };
  return /* @__PURE__ */ m.jsxs("div", { className: "h-[55px] bg-[#152538] border-t border-gray-700 flex items-center justify-between px-4", children: [
    /* @__PURE__ */ m.jsx("div", { className: "flex items-center space-x-4 text-gray-400", children: n ? /* @__PURE__ */ m.jsxs("div", { className: "h-8 w-[110px] flex items-center w-full space-x-2", children: [
      /* @__PURE__ */ m.jsx(ps, { className: "h-8 w-20 bg-gray-700" }),
      /* @__PURE__ */ m.jsx(ps, { className: "h-8 w-5 bg-gray-700 rounded-full" })
    ] }) : /* @__PURE__ */ m.jsxs("span", { className: "text-xl font-bold text-white w-full justify-between", children: [
      e.prefixSymbol,
      a
    ] }) }),
    /* @__PURE__ */ m.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ m.jsx(
        "button",
        {
          className: `hover:text-white px-2 ${s ? "text-gray-400" : "text-green-400"}`,
          onClick: l,
          children: s ? /* @__PURE__ */ m.jsx(zT, { size: 20 }) : /* @__PURE__ */ m.jsx(VT, { size: 20 })
        }
      ),
      /* @__PURE__ */ m.jsx(
        "button",
        {
          className: "text-gray-400 px-2 hover:text-white",
          onClick: () => i(!o),
          children: /* @__PURE__ */ m.jsx(Tb, { size: 20 })
        }
      ),
      /* @__PURE__ */ m.jsx(p3, {}),
      /* @__PURE__ */ m.jsx(VD, {})
    ] })
  ] });
}
var g3 = "DismissableLayer", Ou = "dismissableLayer.update", m3 = "dismissableLayer.pointerDownOutside", A3 = "dismissableLayer.focusOutside", Cg, Lv = v.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Nv = v.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: s,
      onPointerDownOutside: r,
      onFocusOutside: i,
      onInteractOutside: o,
      onDismiss: a,
      ...l
    } = t, c = v.useContext(Lv), [u, d] = v.useState(null), f = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = v.useState({}), p = Pe(e, (C) => d(C)), g = Array.from(c.layers), [A] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), b = g.indexOf(A), y = u ? g.indexOf(u) : -1, w = c.layersWithOutsidePointerEventsDisabled.size > 0, x = y >= b, S = v3((C) => {
      const E = C.target, T = [...c.branches].some((k) => k.contains(E));
      !x || T || (r == null || r(C), o == null || o(C), C.defaultPrevented || a == null || a());
    }, f), q = x3((C) => {
      const E = C.target;
      [...c.branches].some((k) => k.contains(E)) || (i == null || i(C), o == null || o(C), C.defaultPrevented || a == null || a());
    }, f);
    return Jb((C) => {
      y === c.layers.size - 1 && (s == null || s(C), !C.defaultPrevented && a && (C.preventDefault(), a()));
    }, f), v.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (Cg = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), Pg(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = Cg);
        };
    }, [u, f, n, c]), v.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), Pg());
    }, [u, c]), v.useEffect(() => {
      const C = () => h({});
      return document.addEventListener(Ou, C), () => document.removeEventListener(Ou, C);
    }, []), /* @__PURE__ */ m.jsx(
      qe.div,
      {
        ...l,
        ref: p,
        style: {
          pointerEvents: w ? x ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: we(t.onFocusCapture, q.onFocusCapture),
        onBlurCapture: we(t.onBlurCapture, q.onBlurCapture),
        onPointerDownCapture: we(
          t.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
Nv.displayName = g3;
var b3 = "DismissableLayerBranch", y3 = v.forwardRef((t, e) => {
  const n = v.useContext(Lv), s = v.useRef(null), r = Pe(e, s);
  return v.useEffect(() => {
    const i = s.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ m.jsx(qe.div, { ...t, ref: r });
});
y3.displayName = b3;
function v3(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = bt(t), s = v.useRef(!1), r = v.useRef(() => {
  });
  return v.useEffect(() => {
    const i = (a) => {
      if (a.target && !s.current) {
        let l = function() {
          jv(
            m3,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (e.removeEventListener("click", r.current), r.current = l, e.addEventListener("click", r.current, { once: !0 })) : l();
      } else
        e.removeEventListener("click", r.current);
      s.current = !1;
    }, o = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(o), e.removeEventListener("pointerdown", i), e.removeEventListener("click", r.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => s.current = !0
  };
}
function x3(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = bt(t), s = v.useRef(!1);
  return v.useEffect(() => {
    const r = (i) => {
      i.target && !s.current && jv(A3, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", r), () => e.removeEventListener("focusin", r);
  }, [e, n]), {
    onFocusCapture: () => s.current = !0,
    onBlurCapture: () => s.current = !1
  };
}
function Pg() {
  const t = new CustomEvent(Ou);
  document.dispatchEvent(t);
}
function jv(t, e, n, { discrete: s }) {
  const r = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && r.addEventListener(t, e, { once: !0 }), s ? Ib(r, i) : r.dispatchEvent(i);
}
const w3 = ["top", "right", "bottom", "left"], Cs = Math.min, Kt = Math.max, ll = Math.round, Go = Math.floor, Ps = (t) => ({
  x: t,
  y: t
}), S3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, C3 = {
  start: "end",
  end: "start"
};
function Lu(t, e, n) {
  return Kt(t, Cs(e, n));
}
function Jn(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function $n(t) {
  return t.split("-")[0];
}
function ri(t) {
  return t.split("-")[1];
}
function Tf(t) {
  return t === "x" ? "y" : "x";
}
function Rf(t) {
  return t === "y" ? "height" : "width";
}
function qs(t) {
  return ["top", "bottom"].includes($n(t)) ? "y" : "x";
}
function kf(t) {
  return Tf(qs(t));
}
function P3(t, e, n) {
  n === void 0 && (n = !1);
  const s = ri(t), r = kf(t), i = Rf(r);
  let o = r === "x" ? s === (n ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (o = cl(o)), [o, cl(o)];
}
function q3(t) {
  const e = cl(t);
  return [Nu(t), e, Nu(e)];
}
function Nu(t) {
  return t.replace(/start|end/g, (e) => C3[e]);
}
function E3(t, e, n) {
  const s = ["left", "right"], r = ["right", "left"], i = ["top", "bottom"], o = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? r : s : e ? s : r;
    case "left":
    case "right":
      return e ? i : o;
    default:
      return [];
  }
}
function T3(t, e, n, s) {
  const r = ri(t);
  let i = E3($n(t), n === "start", s);
  return r && (i = i.map((o) => o + "-" + r), e && (i = i.concat(i.map(Nu)))), i;
}
function cl(t) {
  return t.replace(/left|right|bottom|top/g, (e) => S3[e]);
}
function R3(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Bv(t) {
  return typeof t != "number" ? R3(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function ul(t) {
  const {
    x: e,
    y: n,
    width: s,
    height: r
  } = t;
  return {
    width: s,
    height: r,
    top: n,
    left: e,
    right: e + s,
    bottom: n + r,
    x: e,
    y: n
  };
}
function qg(t, e, n) {
  let {
    reference: s,
    floating: r
  } = t;
  const i = qs(e), o = kf(e), a = Rf(o), l = $n(e), c = i === "y", u = s.x + s.width / 2 - r.width / 2, d = s.y + s.height / 2 - r.height / 2, f = s[a] / 2 - r[a] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: u,
        y: s.y - r.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      h = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: s.x - r.width,
        y: d
      };
      break;
    default:
      h = {
        x: s.x,
        y: s.y
      };
  }
  switch (ri(e)) {
    case "start":
      h[o] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      h[o] += f * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const k3 = async (t, e, n) => {
  const {
    placement: s = "bottom",
    strategy: r = "absolute",
    middleware: i = [],
    platform: o
  } = n, a = i.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: t,
    floating: e,
    strategy: r
  }), {
    x: u,
    y: d
  } = qg(c, s, l), f = s, h = {}, p = 0;
  for (let g = 0; g < a.length; g++) {
    const {
      name: A,
      fn: b
    } = a[g], {
      x: y,
      y: w,
      data: x,
      reset: S
    } = await b({
      x: u,
      y: d,
      initialPlacement: s,
      placement: f,
      strategy: r,
      middlewareData: h,
      rects: c,
      platform: o,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = y ?? u, d = w ?? d, h = {
      ...h,
      [A]: {
        ...h[A],
        ...x
      }
    }, S && p <= 50 && (p++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await o.getElementRects({
      reference: t,
      floating: e,
      strategy: r
    }) : S.rects), {
      x: u,
      y: d
    } = qg(c, f, l)), g = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: r,
    middlewareData: h
  };
};
async function lo(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: s,
    y: r,
    platform: i,
    rects: o,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = Jn(e, t), p = Bv(h), A = a[f ? d === "floating" ? "reference" : "floating" : d], b = ul(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(A))) == null || n ? A : A.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), y = d === "floating" ? {
    x: s,
    y: r,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), x = await (i.isElement == null ? void 0 : i.isElement(w)) ? await (i.getScale == null ? void 0 : i.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = ul(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: y,
    offsetParent: w,
    strategy: l
  }) : y);
  return {
    top: (b.top - S.top + p.top) / x.y,
    bottom: (S.bottom - b.bottom + p.bottom) / x.y,
    left: (b.left - S.left + p.left) / x.x,
    right: (S.right - b.right + p.right) / x.x
  };
}
const M3 = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: s,
      placement: r,
      rects: i,
      platform: o,
      elements: a,
      middlewareData: l
    } = e, {
      element: c,
      padding: u = 0
    } = Jn(t, e) || {};
    if (c == null)
      return {};
    const d = Bv(u), f = {
      x: n,
      y: s
    }, h = kf(r), p = Rf(h), g = await o.getDimensions(c), A = h === "y", b = A ? "top" : "left", y = A ? "bottom" : "right", w = A ? "clientHeight" : "clientWidth", x = i.reference[p] + i.reference[h] - f[h] - i.floating[p], S = f[h] - i.reference[h], q = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
    let C = q ? q[w] : 0;
    (!C || !await (o.isElement == null ? void 0 : o.isElement(q))) && (C = a.floating[w] || i.floating[p]);
    const E = x / 2 - S / 2, T = C / 2 - g[p] / 2 - 1, k = Cs(d[b], T), R = Cs(d[y], T), D = k, F = C - g[p] - R, j = C / 2 - g[p] / 2 + E, B = Lu(D, j, F), L = !l.arrow && ri(r) != null && j !== B && i.reference[p] / 2 - (j < D ? k : R) - g[p] / 2 < 0, O = L ? j < D ? j - D : j - F : 0;
    return {
      [h]: f[h] + O,
      data: {
        [h]: B,
        centerOffset: j - B - O,
        ...L && {
          alignmentOffset: O
        }
      },
      reset: L
    };
  }
}), D3 = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, s;
      const {
        placement: r,
        middlewareData: i,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: g = !0,
        ...A
      } = Jn(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const b = $n(r), y = qs(a), w = $n(a) === a, x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), S = f || (w || !g ? [cl(a)] : q3(a)), q = p !== "none";
      !f && q && S.push(...T3(a, g, p, x));
      const C = [a, ...S], E = await lo(e, A), T = [];
      let k = ((s = i.flip) == null ? void 0 : s.overflows) || [];
      if (u && T.push(E[b]), d) {
        const j = P3(r, o, x);
        T.push(E[j[0]], E[j[1]]);
      }
      if (k = [...k, {
        placement: r,
        overflows: T
      }], !T.every((j) => j <= 0)) {
        var R, D;
        const j = (((R = i.flip) == null ? void 0 : R.index) || 0) + 1, B = C[j];
        if (B)
          return {
            data: {
              index: j,
              overflows: k
            },
            reset: {
              placement: B
            }
          };
        let L = (D = k.filter((O) => O.overflows[0] <= 0).sort((O, N) => O.overflows[1] - N.overflows[1])[0]) == null ? void 0 : D.placement;
        if (!L)
          switch (h) {
            case "bestFit": {
              var F;
              const O = (F = k.filter((N) => {
                if (q) {
                  const H = qs(N.placement);
                  return H === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  H === "y";
                }
                return !0;
              }).map((N) => [N.placement, N.overflows.filter((H) => H > 0).reduce((H, U) => H + U, 0)]).sort((N, H) => N[1] - H[1])[0]) == null ? void 0 : F[0];
              O && (L = O);
              break;
            }
            case "initialPlacement":
              L = a;
              break;
          }
        if (r !== L)
          return {
            reset: {
              placement: L
            }
          };
      }
      return {};
    }
  };
};
function Eg(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function Tg(t) {
  return w3.some((e) => t[e] >= 0);
}
const O3 = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: s = "referenceHidden",
        ...r
      } = Jn(t, e);
      switch (s) {
        case "referenceHidden": {
          const i = await lo(e, {
            ...r,
            elementContext: "reference"
          }), o = Eg(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: Tg(o)
            }
          };
        }
        case "escaped": {
          const i = await lo(e, {
            ...r,
            altBoundary: !0
          }), o = Eg(i, n.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: Tg(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function L3(t, e) {
  const {
    placement: n,
    platform: s,
    elements: r
  } = t, i = await (s.isRTL == null ? void 0 : s.isRTL(r.floating)), o = $n(n), a = ri(n), l = qs(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = i && l ? -1 : 1, d = Jn(e, t);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof p == "number" && (h = a === "end" ? p * -1 : p), l ? {
    x: h * u,
    y: f * c
  } : {
    x: f * c,
    y: h * u
  };
}
const N3 = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, s;
      const {
        x: r,
        y: i,
        placement: o,
        middlewareData: a
      } = e, l = await L3(e, t);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: r + l.x,
        y: i + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, j3 = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: s,
        placement: r
      } = e, {
        mainAxis: i = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (A) => {
            let {
              x: b,
              y
            } = A;
            return {
              x: b,
              y
            };
          }
        },
        ...l
      } = Jn(t, e), c = {
        x: n,
        y: s
      }, u = await lo(e, l), d = qs($n(r)), f = Tf(d);
      let h = c[f], p = c[d];
      if (i) {
        const A = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", y = h + u[A], w = h - u[b];
        h = Lu(y, h, w);
      }
      if (o) {
        const A = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", y = p + u[A], w = p - u[b];
        p = Lu(y, p, w);
      }
      const g = a.fn({
        ...e,
        [f]: h,
        [d]: p
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - s,
          enabled: {
            [f]: i,
            [d]: o
          }
        }
      };
    }
  };
}, B3 = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: s,
        placement: r,
        rects: i,
        middlewareData: o
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = Jn(t, e), u = {
        x: n,
        y: s
      }, d = qs(r), f = Tf(d);
      let h = u[f], p = u[d];
      const g = Jn(a, e), A = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (l) {
        const w = f === "y" ? "height" : "width", x = i.reference[f] - i.floating[w] + A.mainAxis, S = i.reference[f] + i.reference[w] - A.mainAxis;
        h < x ? h = x : h > S && (h = S);
      }
      if (c) {
        var b, y;
        const w = f === "y" ? "width" : "height", x = ["top", "left"].includes($n(r)), S = i.reference[d] - i.floating[w] + (x && ((b = o.offset) == null ? void 0 : b[d]) || 0) + (x ? 0 : A.crossAxis), q = i.reference[d] + i.reference[w] + (x ? 0 : ((y = o.offset) == null ? void 0 : y[d]) || 0) - (x ? A.crossAxis : 0);
        p < S ? p = S : p > q && (p = q);
      }
      return {
        [f]: h,
        [d]: p
      };
    }
  };
}, I3 = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, s;
      const {
        placement: r,
        rects: i,
        platform: o,
        elements: a
      } = e, {
        apply: l = () => {
        },
        ...c
      } = Jn(t, e), u = await lo(e, c), d = $n(r), f = ri(r), h = qs(r) === "y", {
        width: p,
        height: g
      } = i.floating;
      let A, b;
      d === "top" || d === "bottom" ? (A = d, b = f === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (b = d, A = f === "end" ? "top" : "bottom");
      const y = g - u.top - u.bottom, w = p - u.left - u.right, x = Cs(g - u[A], y), S = Cs(p - u[b], w), q = !e.middlewareData.shift;
      let C = x, E = S;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (E = w), (s = e.middlewareData.shift) != null && s.enabled.y && (C = y), q && !f) {
        const k = Kt(u.left, 0), R = Kt(u.right, 0), D = Kt(u.top, 0), F = Kt(u.bottom, 0);
        h ? E = p - 2 * (k !== 0 || R !== 0 ? k + R : Kt(u.left, u.right)) : C = g - 2 * (D !== 0 || F !== 0 ? D + F : Kt(u.top, u.bottom));
      }
      await l({
        ...e,
        availableWidth: E,
        availableHeight: C
      });
      const T = await o.getDimensions(a.floating);
      return p !== T.width || g !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function zl() {
  return typeof window < "u";
}
function ii(t) {
  return Iv(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Zt(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function On(t) {
  var e;
  return (e = (Iv(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function Iv(t) {
  return zl() ? t instanceof Node || t instanceof Zt(t).Node : !1;
}
function pn(t) {
  return zl() ? t instanceof Element || t instanceof Zt(t).Element : !1;
}
function kn(t) {
  return zl() ? t instanceof HTMLElement || t instanceof Zt(t).HTMLElement : !1;
}
function Rg(t) {
  return !zl() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Zt(t).ShadowRoot;
}
function To(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: s,
    display: r
  } = gn(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + s + n) && !["inline", "contents"].includes(r);
}
function F3(t) {
  return ["table", "td", "th"].includes(ii(t));
}
function Ul(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function Mf(t) {
  const e = Df(), n = pn(t) ? gn(t) : t;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (n.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (n.contain || "").includes(s));
}
function V3(t) {
  let e = Es(t);
  for (; kn(e) && !Wr(e); ) {
    if (Mf(e))
      return e;
    if (Ul(e))
      return null;
    e = Es(e);
  }
  return null;
}
function Df() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Wr(t) {
  return ["html", "body", "#document"].includes(ii(t));
}
function gn(t) {
  return Zt(t).getComputedStyle(t);
}
function Wl(t) {
  return pn(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Es(t) {
  if (ii(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Rg(t) && t.host || // Fallback.
    On(t)
  );
  return Rg(e) ? e.host : e;
}
function Fv(t) {
  const e = Es(t);
  return Wr(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : kn(e) && To(e) ? e : Fv(e);
}
function co(t, e, n) {
  var s;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const r = Fv(t), i = r === ((s = t.ownerDocument) == null ? void 0 : s.body), o = Zt(r);
  if (i) {
    const a = ju(o);
    return e.concat(o, o.visualViewport || [], To(r) ? r : [], a && n ? co(a) : []);
  }
  return e.concat(r, co(r, [], n));
}
function ju(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function Vv(t) {
  const e = gn(t);
  let n = parseFloat(e.width) || 0, s = parseFloat(e.height) || 0;
  const r = kn(t), i = r ? t.offsetWidth : n, o = r ? t.offsetHeight : s, a = ll(n) !== i || ll(s) !== o;
  return a && (n = i, s = o), {
    width: n,
    height: s,
    $: a
  };
}
function Of(t) {
  return pn(t) ? t : t.contextElement;
}
function Or(t) {
  const e = Of(t);
  if (!kn(e))
    return Ps(1);
  const n = e.getBoundingClientRect(), {
    width: s,
    height: r,
    $: i
  } = Vv(e);
  let o = (i ? ll(n.width) : n.width) / s, a = (i ? ll(n.height) : n.height) / r;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const z3 = /* @__PURE__ */ Ps(0);
function zv(t) {
  const e = Zt(t);
  return !Df() || !e.visualViewport ? z3 : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function U3(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Zt(t) ? !1 : e;
}
function ir(t, e, n, s) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), i = Of(t);
  let o = Ps(1);
  e && (s ? pn(s) && (o = Or(s)) : o = Or(t));
  const a = U3(i, n, s) ? zv(i) : Ps(0);
  let l = (r.left + a.x) / o.x, c = (r.top + a.y) / o.y, u = r.width / o.x, d = r.height / o.y;
  if (i) {
    const f = Zt(i), h = s && pn(s) ? Zt(s) : s;
    let p = f, g = ju(p);
    for (; g && s && h !== p; ) {
      const A = Or(g), b = g.getBoundingClientRect(), y = gn(g), w = b.left + (g.clientLeft + parseFloat(y.paddingLeft)) * A.x, x = b.top + (g.clientTop + parseFloat(y.paddingTop)) * A.y;
      l *= A.x, c *= A.y, u *= A.x, d *= A.y, l += w, c += x, p = Zt(g), g = ju(p);
    }
  }
  return ul({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function W3(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: s,
    strategy: r
  } = t;
  const i = r === "fixed", o = On(s), a = e ? Ul(e.floating) : !1;
  if (s === o || a && i)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = Ps(1);
  const u = Ps(0), d = kn(s);
  if ((d || !d && !i) && ((ii(s) !== "body" || To(o)) && (l = Wl(s)), kn(s))) {
    const f = ir(s);
    c = Or(s), u.x = f.x + s.clientLeft, u.y = f.y + s.clientTop;
  }
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y
  };
}
function H3(t) {
  return Array.from(t.getClientRects());
}
function Bu(t, e) {
  const n = Wl(t).scrollLeft;
  return e ? e.left + n : ir(On(t)).left + n;
}
function Q3(t) {
  const e = On(t), n = Wl(t), s = t.ownerDocument.body, r = Kt(e.scrollWidth, e.clientWidth, s.scrollWidth, s.clientWidth), i = Kt(e.scrollHeight, e.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -n.scrollLeft + Bu(t);
  const a = -n.scrollTop;
  return gn(s).direction === "rtl" && (o += Kt(e.clientWidth, s.clientWidth) - r), {
    width: r,
    height: i,
    x: o,
    y: a
  };
}
function Y3(t, e) {
  const n = Zt(t), s = On(t), r = n.visualViewport;
  let i = s.clientWidth, o = s.clientHeight, a = 0, l = 0;
  if (r) {
    i = r.width, o = r.height;
    const c = Df();
    (!c || c && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: i,
    height: o,
    x: a,
    y: l
  };
}
function K3(t, e) {
  const n = ir(t, !0, e === "fixed"), s = n.top + t.clientTop, r = n.left + t.clientLeft, i = kn(t) ? Or(t) : Ps(1), o = t.clientWidth * i.x, a = t.clientHeight * i.y, l = r * i.x, c = s * i.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function kg(t, e, n) {
  let s;
  if (e === "viewport")
    s = Y3(t, n);
  else if (e === "document")
    s = Q3(On(t));
  else if (pn(e))
    s = K3(e, n);
  else {
    const r = zv(t);
    s = {
      ...e,
      x: e.x - r.x,
      y: e.y - r.y
    };
  }
  return ul(s);
}
function Uv(t, e) {
  const n = Es(t);
  return n === e || !pn(n) || Wr(n) ? !1 : gn(n).position === "fixed" || Uv(n, e);
}
function X3(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let s = co(t, [], !1).filter((a) => pn(a) && ii(a) !== "body"), r = null;
  const i = gn(t).position === "fixed";
  let o = i ? Es(t) : t;
  for (; pn(o) && !Wr(o); ) {
    const a = gn(o), l = Mf(o);
    !l && a.position === "fixed" && (r = null), (i ? !l && !r : !l && a.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || To(o) && !l && Uv(t, o)) ? s = s.filter((u) => u !== o) : r = a, o = Es(o);
  }
  return e.set(t, s), s;
}
function G3(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: s,
    strategy: r
  } = t;
  const o = [...n === "clippingAncestors" ? Ul(e) ? [] : X3(e, this._c) : [].concat(n), s], a = o[0], l = o.reduce((c, u) => {
    const d = kg(e, u, r);
    return c.top = Kt(d.top, c.top), c.right = Cs(d.right, c.right), c.bottom = Cs(d.bottom, c.bottom), c.left = Kt(d.left, c.left), c;
  }, kg(e, a, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function Z3(t) {
  const {
    width: e,
    height: n
  } = Vv(t);
  return {
    width: e,
    height: n
  };
}
function _3(t, e, n) {
  const s = kn(e), r = On(e), i = n === "fixed", o = ir(t, !0, i, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Ps(0);
  if (s || !s && !i)
    if ((ii(e) !== "body" || To(r)) && (a = Wl(e)), s) {
      const h = ir(e, !0, i, e);
      l.x = h.x + e.clientLeft, l.y = h.y + e.clientTop;
    } else r && (l.x = Bu(r));
  let c = 0, u = 0;
  if (r && !s && !i) {
    const h = r.getBoundingClientRect();
    u = h.top + a.scrollTop, c = h.left + a.scrollLeft - // RTL <body> scrollbar.
    Bu(r, h);
  }
  const d = o.left + a.scrollLeft - l.x - c, f = o.top + a.scrollTop - l.y - u;
  return {
    x: d,
    y: f,
    width: o.width,
    height: o.height
  };
}
function Ic(t) {
  return gn(t).position === "static";
}
function Mg(t, e) {
  if (!kn(t) || gn(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return On(t) === n && (n = n.ownerDocument.body), n;
}
function Wv(t, e) {
  const n = Zt(t);
  if (Ul(t))
    return n;
  if (!kn(t)) {
    let r = Es(t);
    for (; r && !Wr(r); ) {
      if (pn(r) && !Ic(r))
        return r;
      r = Es(r);
    }
    return n;
  }
  let s = Mg(t, e);
  for (; s && F3(s) && Ic(s); )
    s = Mg(s, e);
  return s && Wr(s) && Ic(s) && !Mf(s) ? n : s || V3(t) || n;
}
const J3 = async function(t) {
  const e = this.getOffsetParent || Wv, n = this.getDimensions, s = await n(t.floating);
  return {
    reference: _3(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: s.width,
      height: s.height
    }
  };
};
function $3(t) {
  return gn(t).direction === "rtl";
}
const eO = {
  convertOffsetParentRelativeRectToViewportRelativeRect: W3,
  getDocumentElement: On,
  getClippingRect: G3,
  getOffsetParent: Wv,
  getElementRects: J3,
  getClientRects: H3,
  getDimensions: Z3,
  getScale: Or,
  isElement: pn,
  isRTL: $3
};
function tO(t, e) {
  let n = null, s;
  const r = On(t);
  function i() {
    var a;
    clearTimeout(s), (a = n) == null || a.disconnect(), n = null;
  }
  function o(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i();
    const {
      left: c,
      top: u,
      width: d,
      height: f
    } = t.getBoundingClientRect();
    if (a || e(), !d || !f)
      return;
    const h = Go(u), p = Go(r.clientWidth - (c + d)), g = Go(r.clientHeight - (u + f)), A = Go(c), y = {
      rootMargin: -h + "px " + -p + "px " + -g + "px " + -A + "px",
      threshold: Kt(0, Cs(1, l)) || 1
    };
    let w = !0;
    function x(S) {
      const q = S[0].intersectionRatio;
      if (q !== l) {
        if (!w)
          return o();
        q ? o(!1, q) : s = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      w = !1;
    }
    try {
      n = new IntersectionObserver(x, {
        ...y,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x, y);
    }
    n.observe(t);
  }
  return o(!0), i;
}
function nO(t, e, n, s) {
  s === void 0 && (s = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: i = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = s, c = Of(t), u = r || i ? [...c ? co(c) : [], ...co(e)] : [];
  u.forEach((b) => {
    r && b.addEventListener("scroll", n, {
      passive: !0
    }), i && b.addEventListener("resize", n);
  });
  const d = c && a ? tO(c, n) : null;
  let f = -1, h = null;
  o && (h = new ResizeObserver((b) => {
    let [y] = b;
    y && y.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var w;
      (w = h) == null || w.observe(e);
    })), n();
  }), c && !l && h.observe(c), h.observe(e));
  let p, g = l ? ir(t) : null;
  l && A();
  function A() {
    const b = ir(t);
    g && (b.x !== g.x || b.y !== g.y || b.width !== g.width || b.height !== g.height) && n(), g = b, p = requestAnimationFrame(A);
  }
  return n(), () => {
    var b;
    u.forEach((y) => {
      r && y.removeEventListener("scroll", n), i && y.removeEventListener("resize", n);
    }), d == null || d(), (b = h) == null || b.disconnect(), h = null, l && cancelAnimationFrame(p);
  };
}
const sO = N3, rO = j3, iO = D3, oO = I3, aO = O3, Dg = M3, lO = B3, cO = (t, e, n) => {
  const s = /* @__PURE__ */ new Map(), r = {
    platform: eO,
    ...n
  }, i = {
    ...r.platform,
    _c: s
  };
  return k3(t, e, {
    ...r,
    platform: i
  });
};
var Pa = typeof document < "u" ? od : je;
function dl(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, s, r;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (s = n; s-- !== 0; )
        if (!dl(t[s], e[s]))
          return !1;
      return !0;
    }
    if (r = Object.keys(t), n = r.length, n !== Object.keys(e).length)
      return !1;
    for (s = n; s-- !== 0; )
      if (!{}.hasOwnProperty.call(e, r[s]))
        return !1;
    for (s = n; s-- !== 0; ) {
      const i = r[s];
      if (!(i === "_owner" && t.$$typeof) && !dl(t[i], e[i]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function Hv(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Og(t, e) {
  const n = Hv(t);
  return Math.round(e * n) / n;
}
function Fc(t) {
  const e = v.useRef(t);
  return Pa(() => {
    e.current = t;
  }), e;
}
function uO(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: s = [],
    platform: r,
    elements: {
      reference: i,
      floating: o
    } = {},
    transform: a = !0,
    whileElementsMounted: l,
    open: c
  } = t, [u, d] = v.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = v.useState(s);
  dl(f, s) || h(s);
  const [p, g] = v.useState(null), [A, b] = v.useState(null), y = v.useCallback((N) => {
    N !== q.current && (q.current = N, g(N));
  }, []), w = v.useCallback((N) => {
    N !== C.current && (C.current = N, b(N));
  }, []), x = i || p, S = o || A, q = v.useRef(null), C = v.useRef(null), E = v.useRef(u), T = l != null, k = Fc(l), R = Fc(r), D = Fc(c), F = v.useCallback(() => {
    if (!q.current || !C.current)
      return;
    const N = {
      placement: e,
      strategy: n,
      middleware: f
    };
    R.current && (N.platform = R.current), cO(q.current, C.current, N).then((H) => {
      const U = {
        ...H,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: D.current !== !1
      };
      j.current && !dl(E.current, U) && (E.current = U, ad.flushSync(() => {
        d(U);
      }));
    });
  }, [f, e, n, R, D]);
  Pa(() => {
    c === !1 && E.current.isPositioned && (E.current.isPositioned = !1, d((N) => ({
      ...N,
      isPositioned: !1
    })));
  }, [c]);
  const j = v.useRef(!1);
  Pa(() => (j.current = !0, () => {
    j.current = !1;
  }), []), Pa(() => {
    if (x && (q.current = x), S && (C.current = S), x && S) {
      if (k.current)
        return k.current(x, S, F);
      F();
    }
  }, [x, S, F, k, T]);
  const B = v.useMemo(() => ({
    reference: q,
    floating: C,
    setReference: y,
    setFloating: w
  }), [y, w]), L = v.useMemo(() => ({
    reference: x,
    floating: S
  }), [x, S]), O = v.useMemo(() => {
    const N = {
      position: n,
      left: 0,
      top: 0
    };
    if (!L.floating)
      return N;
    const H = Og(L.floating, u.x), U = Og(L.floating, u.y);
    return a ? {
      ...N,
      transform: "translate(" + H + "px, " + U + "px)",
      ...Hv(L.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: H,
      top: U
    };
  }, [n, a, L.floating, u.x, u.y]);
  return v.useMemo(() => ({
    ...u,
    update: F,
    refs: B,
    elements: L,
    floatingStyles: O
  }), [u, F, B, L, O]);
}
const dO = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: s,
        padding: r
      } = typeof t == "function" ? t(n) : t;
      return s && e(s) ? s.current != null ? Dg({
        element: s.current,
        padding: r
      }).fn(n) : {} : s ? Dg({
        element: s,
        padding: r
      }).fn(n) : {};
    }
  };
}, fO = (t, e) => ({
  ...sO(t),
  options: [t, e]
}), hO = (t, e) => ({
  ...rO(t),
  options: [t, e]
}), pO = (t, e) => ({
  ...lO(t),
  options: [t, e]
}), gO = (t, e) => ({
  ...iO(t),
  options: [t, e]
}), mO = (t, e) => ({
  ...oO(t),
  options: [t, e]
}), AO = (t, e) => ({
  ...aO(t),
  options: [t, e]
}), bO = (t, e) => ({
  ...dO(t),
  options: [t, e]
});
var yO = "Arrow", Qv = v.forwardRef((t, e) => {
  const { children: n, width: s = 10, height: r = 5, ...i } = t;
  return /* @__PURE__ */ m.jsx(
    qe.svg,
    {
      ...i,
      ref: e,
      width: s,
      height: r,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ m.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Qv.displayName = yO;
var vO = Qv;
function Yv(t) {
  const [e, n] = v.useState(void 0);
  return Lt(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const s = new ResizeObserver((r) => {
        if (!Array.isArray(r) || !r.length)
          return;
        const i = r[0];
        let o, a;
        if ("borderBoxSize" in i) {
          const l = i.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          o = c.inlineSize, a = c.blockSize;
        } else
          o = t.offsetWidth, a = t.offsetHeight;
        n({ width: o, height: a });
      });
      return s.observe(t, { box: "border-box" }), () => s.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
var Lf = "Popper", [Kv, Xv] = vf(Lf), [xO, Gv] = Kv(Lf), Zv = (t) => {
  const { __scopePopper: e, children: n } = t, [s, r] = v.useState(null);
  return /* @__PURE__ */ m.jsx(xO, { scope: e, anchor: s, onAnchorChange: r, children: n });
};
Zv.displayName = Lf;
var _v = "PopperAnchor", Jv = v.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: s, ...r } = t, i = Gv(_v, n), o = v.useRef(null), a = Pe(e, o);
    return v.useEffect(() => {
      i.onAnchorChange((s == null ? void 0 : s.current) || o.current);
    }), s ? null : /* @__PURE__ */ m.jsx(qe.div, { ...r, ref: a });
  }
);
Jv.displayName = _v;
var Nf = "PopperContent", [wO, SO] = Kv(Nf), $v = v.forwardRef(
  (t, e) => {
    var He, ye, $, Xe, Ue, Jt;
    const {
      __scopePopper: n,
      side: s = "bottom",
      sideOffset: r = 0,
      align: i = "center",
      alignOffset: o = 0,
      arrowPadding: a = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: d = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: p,
      ...g
    } = t, A = Gv(Nf, n), [b, y] = v.useState(null), w = Pe(e, (Z) => y(Z)), [x, S] = v.useState(null), q = Yv(x), C = (q == null ? void 0 : q.width) ?? 0, E = (q == null ? void 0 : q.height) ?? 0, T = s + (i !== "center" ? "-" + i : ""), k = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, R = Array.isArray(c) ? c : [c], D = R.length > 0, F = {
      padding: k,
      boundary: R.filter(PO),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: D
    }, { refs: j, floatingStyles: B, placement: L, isPositioned: O, middlewareData: N } = uO({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: T,
      whileElementsMounted: (...Z) => nO(...Z, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: A.anchor
      },
      middleware: [
        fO({ mainAxis: r + E, alignmentAxis: o }),
        l && hO({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? pO() : void 0,
          ...F
        }),
        l && gO({ ...F }),
        mO({
          ...F,
          apply: ({ elements: Z, rects: Ln, availableWidth: Nt, availableHeight: Rt }) => {
            const { width: ns, height: ss } = Ln.reference, mt = Z.floating.style;
            mt.setProperty("--radix-popper-available-width", `${Nt}px`), mt.setProperty("--radix-popper-available-height", `${Rt}px`), mt.setProperty("--radix-popper-anchor-width", `${ns}px`), mt.setProperty("--radix-popper-anchor-height", `${ss}px`);
          }
        }),
        x && bO({ element: x, padding: a }),
        qO({ arrowWidth: C, arrowHeight: E }),
        f && AO({ strategy: "referenceHidden", ...F })
      ]
    }), [H, U] = nx(L), X = bt(p);
    Lt(() => {
      O && (X == null || X());
    }, [O, X]);
    const G = (He = N.arrow) == null ? void 0 : He.x, pe = (ye = N.arrow) == null ? void 0 : ye.y, Me = (($ = N.arrow) == null ? void 0 : $.centerOffset) !== 0, [Ee, oe] = v.useState();
    return Lt(() => {
      b && oe(window.getComputedStyle(b).zIndex);
    }, [b]), /* @__PURE__ */ m.jsx(
      "div",
      {
        ref: j.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...B,
          transform: O ? B.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Ee,
          "--radix-popper-transform-origin": [
            (Xe = N.transformOrigin) == null ? void 0 : Xe.x,
            (Ue = N.transformOrigin) == null ? void 0 : Ue.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((Jt = N.hide) == null ? void 0 : Jt.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ m.jsx(
          wO,
          {
            scope: n,
            placedSide: H,
            onArrowChange: S,
            arrowX: G,
            arrowY: pe,
            shouldHideArrow: Me,
            children: /* @__PURE__ */ m.jsx(
              qe.div,
              {
                "data-side": H,
                "data-align": U,
                ...g,
                ref: w,
                style: {
                  ...g.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: O ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
$v.displayName = Nf;
var ex = "PopperArrow", CO = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, tx = v.forwardRef(function(e, n) {
  const { __scopePopper: s, ...r } = e, i = SO(ex, s), o = CO[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ m.jsx(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ m.jsx(
          vO,
          {
            ...r,
            ref: n,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
tx.displayName = ex;
function PO(t) {
  return t !== null;
}
var qO = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var A, b, y;
    const { placement: n, rects: s, middlewareData: r } = e, o = ((A = r.arrow) == null ? void 0 : A.centerOffset) !== 0, a = o ? 0 : t.arrowWidth, l = o ? 0 : t.arrowHeight, [c, u] = nx(n), d = { start: "0%", center: "50%", end: "100%" }[u], f = (((b = r.arrow) == null ? void 0 : b.x) ?? 0) + a / 2, h = (((y = r.arrow) == null ? void 0 : y.y) ?? 0) + l / 2;
    let p = "", g = "";
    return c === "bottom" ? (p = o ? d : `${f}px`, g = `${-l}px`) : c === "top" ? (p = o ? d : `${f}px`, g = `${s.floating.height + l}px`) : c === "right" ? (p = `${-l}px`, g = o ? d : `${h}px`) : c === "left" && (p = `${s.floating.width + l}px`, g = o ? d : `${h}px`), { data: { x: p, y: g } };
  }
});
function nx(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var EO = Zv, TO = Jv, RO = $v, kO = tx;
function MO(t, e) {
  return v.useReducer((n, s) => e[n][s] ?? n, t);
}
var sx = (t) => {
  const { present: e, children: n } = t, s = DO(e), r = typeof n == "function" ? n({ present: s.isPresent }) : v.Children.only(n), i = Pe(s.ref, OO(r));
  return typeof n == "function" || s.isPresent ? v.cloneElement(r, { ref: i }) : null;
};
sx.displayName = "Presence";
function DO(t) {
  const [e, n] = v.useState(), s = v.useRef({}), r = v.useRef(t), i = v.useRef("none"), o = t ? "mounted" : "unmounted", [a, l] = MO(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return v.useEffect(() => {
    const c = Zo(s.current);
    i.current = a === "mounted" ? c : "none";
  }, [a]), Lt(() => {
    const c = s.current, u = r.current;
    if (u !== t) {
      const f = i.current, h = Zo(c);
      t ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), r.current = t;
    }
  }, [t, l]), Lt(() => {
    if (e) {
      const c = (d) => {
        const h = Zo(s.current).includes(d.animationName);
        d.target === e && h && ad.flushSync(() => l("ANIMATION_END"));
      }, u = (d) => {
        d.target === e && (i.current = Zo(s.current));
      };
      return e.addEventListener("animationstart", u), e.addEventListener("animationcancel", c), e.addEventListener("animationend", c), () => {
        e.removeEventListener("animationstart", u), e.removeEventListener("animationcancel", c), e.removeEventListener("animationend", c);
      };
    } else
      l("ANIMATION_END");
  }, [e, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: v.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function Zo(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function OO(t) {
  var s, r;
  let e = (s = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (r = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var LO = "VisuallyHidden", rx = v.forwardRef(
  (t, e) => /* @__PURE__ */ m.jsx(
    qe.span,
    {
      ...t,
      ref: e,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...t.style
      }
    }
  )
);
rx.displayName = LO;
var NO = rx, [Hl, t5] = vf("Tooltip", [
  Xv
]), Ql = Xv(), ix = "TooltipProvider", jO = 700, Iu = "tooltip.open", [BO, jf] = Hl(ix), ox = (t) => {
  const {
    __scopeTooltip: e,
    delayDuration: n = jO,
    skipDelayDuration: s = 300,
    disableHoverableContent: r = !1,
    children: i
  } = t, [o, a] = v.useState(!0), l = v.useRef(!1), c = v.useRef(0);
  return v.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ m.jsx(
    BO,
    {
      scope: e,
      isOpenDelayed: o,
      delayDuration: n,
      onOpen: v.useCallback(() => {
        window.clearTimeout(c.current), a(!1);
      }, []),
      onClose: v.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => a(!0),
          s
        );
      }, [s]),
      isPointerInTransitRef: l,
      onPointerInTransitChange: v.useCallback((u) => {
        l.current = u;
      }, []),
      disableHoverableContent: r,
      children: i
    }
  );
};
ox.displayName = ix;
var Yl = "Tooltip", [IO, Kl] = Hl(Yl), ax = (t) => {
  const {
    __scopeTooltip: e,
    children: n,
    open: s,
    defaultOpen: r = !1,
    onOpenChange: i,
    disableHoverableContent: o,
    delayDuration: a
  } = t, l = jf(Yl, t.__scopeTooltip), c = Ql(e), [u, d] = v.useState(null), f = Mr(), h = v.useRef(0), p = o ?? l.disableHoverableContent, g = a ?? l.delayDuration, A = v.useRef(!1), [b = !1, y] = ni({
    prop: s,
    defaultProp: r,
    onChange: (C) => {
      C ? (l.onOpen(), document.dispatchEvent(new CustomEvent(Iu))) : l.onClose(), i == null || i(C);
    }
  }), w = v.useMemo(() => b ? A.current ? "delayed-open" : "instant-open" : "closed", [b]), x = v.useCallback(() => {
    window.clearTimeout(h.current), A.current = !1, y(!0);
  }, [y]), S = v.useCallback(() => {
    window.clearTimeout(h.current), y(!1);
  }, [y]), q = v.useCallback(() => {
    window.clearTimeout(h.current), h.current = window.setTimeout(() => {
      A.current = !0, y(!0);
    }, g);
  }, [g, y]);
  return v.useEffect(() => () => window.clearTimeout(h.current), []), /* @__PURE__ */ m.jsx(EO, { ...c, children: /* @__PURE__ */ m.jsx(
    IO,
    {
      scope: e,
      contentId: f,
      open: b,
      stateAttribute: w,
      trigger: u,
      onTriggerChange: d,
      onTriggerEnter: v.useCallback(() => {
        l.isOpenDelayed ? q() : x();
      }, [l.isOpenDelayed, q, x]),
      onTriggerLeave: v.useCallback(() => {
        p ? S() : window.clearTimeout(h.current);
      }, [S, p]),
      onOpen: x,
      onClose: S,
      disableHoverableContent: p,
      children: n
    }
  ) });
};
ax.displayName = Yl;
var Fu = "TooltipTrigger", lx = v.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...s } = t, r = Kl(Fu, n), i = jf(Fu, n), o = Ql(n), a = v.useRef(null), l = Pe(e, a, r.onTriggerChange), c = v.useRef(!1), u = v.useRef(!1), d = v.useCallback(() => c.current = !1, []);
    return v.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), /* @__PURE__ */ m.jsx(TO, { asChild: !0, ...o, children: /* @__PURE__ */ m.jsx(
      qe.button,
      {
        "aria-describedby": r.open ? r.contentId : void 0,
        "data-state": r.stateAttribute,
        ...s,
        ref: l,
        onPointerMove: we(t.onPointerMove, (f) => {
          f.pointerType !== "touch" && !u.current && !i.isPointerInTransitRef.current && (r.onTriggerEnter(), u.current = !0);
        }),
        onPointerLeave: we(t.onPointerLeave, () => {
          r.onTriggerLeave(), u.current = !1;
        }),
        onPointerDown: we(t.onPointerDown, () => {
          c.current = !0, document.addEventListener("pointerup", d, { once: !0 });
        }),
        onFocus: we(t.onFocus, () => {
          c.current || r.onOpen();
        }),
        onBlur: we(t.onBlur, r.onClose),
        onClick: we(t.onClick, r.onClose)
      }
    ) });
  }
);
lx.displayName = Fu;
var FO = "TooltipPortal", [n5, VO] = Hl(FO, {
  forceMount: void 0
}), Hr = "TooltipContent", cx = v.forwardRef(
  (t, e) => {
    const n = VO(Hr, t.__scopeTooltip), { forceMount: s = n.forceMount, side: r = "top", ...i } = t, o = Kl(Hr, t.__scopeTooltip);
    return /* @__PURE__ */ m.jsx(sx, { present: s || o.open, children: o.disableHoverableContent ? /* @__PURE__ */ m.jsx(ux, { side: r, ...i, ref: e }) : /* @__PURE__ */ m.jsx(zO, { side: r, ...i, ref: e }) });
  }
), zO = v.forwardRef((t, e) => {
  const n = Kl(Hr, t.__scopeTooltip), s = jf(Hr, t.__scopeTooltip), r = v.useRef(null), i = Pe(e, r), [o, a] = v.useState(null), { trigger: l, onClose: c } = n, u = r.current, { onPointerInTransitChange: d } = s, f = v.useCallback(() => {
    a(null), d(!1);
  }, [d]), h = v.useCallback(
    (p, g) => {
      const A = p.currentTarget, b = { x: p.clientX, y: p.clientY }, y = QO(b, A.getBoundingClientRect()), w = YO(b, y), x = KO(g.getBoundingClientRect()), S = GO([...w, ...x]);
      a(S), d(!0);
    },
    [d]
  );
  return v.useEffect(() => () => f(), [f]), v.useEffect(() => {
    if (l && u) {
      const p = (A) => h(A, u), g = (A) => h(A, l);
      return l.addEventListener("pointerleave", p), u.addEventListener("pointerleave", g), () => {
        l.removeEventListener("pointerleave", p), u.removeEventListener("pointerleave", g);
      };
    }
  }, [l, u, h, f]), v.useEffect(() => {
    if (o) {
      const p = (g) => {
        const A = g.target, b = { x: g.clientX, y: g.clientY }, y = (l == null ? void 0 : l.contains(A)) || (u == null ? void 0 : u.contains(A)), w = !XO(b, o);
        y ? f() : w && (f(), c());
      };
      return document.addEventListener("pointermove", p), () => document.removeEventListener("pointermove", p);
    }
  }, [l, u, o, c, f]), /* @__PURE__ */ m.jsx(ux, { ...t, ref: i });
}), [UO, WO] = Hl(Yl, { isInside: !1 }), ux = v.forwardRef(
  (t, e) => {
    const {
      __scopeTooltip: n,
      children: s,
      "aria-label": r,
      onEscapeKeyDown: i,
      onPointerDownOutside: o,
      ...a
    } = t, l = Kl(Hr, n), c = Ql(n), { onClose: u } = l;
    return v.useEffect(() => (document.addEventListener(Iu, u), () => document.removeEventListener(Iu, u)), [u]), v.useEffect(() => {
      if (l.trigger) {
        const d = (f) => {
          const h = f.target;
          h != null && h.contains(l.trigger) && u();
        };
        return window.addEventListener("scroll", d, { capture: !0 }), () => window.removeEventListener("scroll", d, { capture: !0 });
      }
    }, [l.trigger, u]), /* @__PURE__ */ m.jsx(
      Nv,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: o,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: u,
        children: /* @__PURE__ */ m.jsxs(
          RO,
          {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: e,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ m.jsx(jb, { children: s }),
              /* @__PURE__ */ m.jsx(UO, { scope: n, isInside: !0, children: /* @__PURE__ */ m.jsx(NO, { id: l.contentId, role: "tooltip", children: r || s }) })
            ]
          }
        )
      }
    );
  }
);
cx.displayName = Hr;
var dx = "TooltipArrow", HO = v.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...s } = t, r = Ql(n);
    return WO(
      dx,
      n
    ).isInside ? null : /* @__PURE__ */ m.jsx(kO, { ...r, ...s, ref: e });
  }
);
HO.displayName = dx;
function QO(t, e) {
  const n = Math.abs(e.top - t.y), s = Math.abs(e.bottom - t.y), r = Math.abs(e.right - t.x), i = Math.abs(e.left - t.x);
  switch (Math.min(n, s, r, i)) {
    case i:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case s:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function YO(t, e, n = 5) {
  const s = [];
  switch (e) {
    case "top":
      s.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      s.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      s.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      s.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return s;
}
function KO(t) {
  const { top: e, right: n, bottom: s, left: r } = t;
  return [
    { x: r, y: e },
    { x: n, y: e },
    { x: n, y: s },
    { x: r, y: s }
  ];
}
function XO(t, e) {
  const { x: n, y: s } = t;
  let r = !1;
  for (let i = 0, o = e.length - 1; i < e.length; o = i++) {
    const a = e[i].x, l = e[i].y, c = e[o].x, u = e[o].y;
    l > s != u > s && n < (c - a) * (s - l) / (u - l) + a && (r = !r);
  }
  return r;
}
function GO(t) {
  const e = t.slice();
  return e.sort((n, s) => n.x < s.x ? -1 : n.x > s.x ? 1 : n.y < s.y ? -1 : n.y > s.y ? 1 : 0), ZO(e);
}
function ZO(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let s = 0; s < t.length; s++) {
    const r = t[s];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1], o = e[e.length - 2];
      if ((i.x - o.x) * (r.y - o.y) >= (i.y - o.y) * (r.x - o.x)) e.pop();
      else break;
    }
    e.push(r);
  }
  e.pop();
  const n = [];
  for (let s = t.length - 1; s >= 0; s--) {
    const r = t[s];
    for (; n.length >= 2; ) {
      const i = n[n.length - 1], o = n[n.length - 2];
      if ((i.x - o.x) * (r.y - o.y) >= (i.y - o.y) * (r.x - o.x)) n.pop();
      else break;
    }
    n.push(r);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var _O = ox, JO = ax, $O = lx, fx = cx;
const eL = _O, tL = JO, nL = $O, hx = v.forwardRef(({ className: t, sideOffset: e = 4, ...n }, s) => /* @__PURE__ */ m.jsx(
  fx,
  {
    ref: s,
    sideOffset: e,
    className: Be(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      t
    ),
    ...n
  }
));
hx.displayName = fx.displayName;
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function Ro(t) {
  return t + 0.5 | 0;
}
const us = (t, e, n) => Math.max(Math.min(t, n), e);
function Pi(t) {
  return us(Ro(t * 2.55), 0, 255);
}
function gs(t) {
  return us(Ro(t * 255), 0, 255);
}
function zn(t) {
  return us(Ro(t / 2.55) / 100, 0, 1);
}
function Lg(t) {
  return us(Ro(t * 100), 0, 100);
}
const rn = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Vu = [..."0123456789ABCDEF"], sL = (t) => Vu[t & 15], rL = (t) => Vu[(t & 240) >> 4] + Vu[t & 15], _o = (t) => (t & 240) >> 4 === (t & 15), iL = (t) => _o(t.r) && _o(t.g) && _o(t.b) && _o(t.a);
function oL(t) {
  var e = t.length, n;
  return t[0] === "#" && (e === 4 || e === 5 ? n = {
    r: 255 & rn[t[1]] * 17,
    g: 255 & rn[t[2]] * 17,
    b: 255 & rn[t[3]] * 17,
    a: e === 5 ? rn[t[4]] * 17 : 255
  } : (e === 7 || e === 9) && (n = {
    r: rn[t[1]] << 4 | rn[t[2]],
    g: rn[t[3]] << 4 | rn[t[4]],
    b: rn[t[5]] << 4 | rn[t[6]],
    a: e === 9 ? rn[t[7]] << 4 | rn[t[8]] : 255
  })), n;
}
const aL = (t, e) => t < 255 ? e(t) : "";
function lL(t) {
  var e = iL(t) ? sL : rL;
  return t ? "#" + e(t.r) + e(t.g) + e(t.b) + aL(t.a, e) : void 0;
}
const cL = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function px(t, e, n) {
  const s = e * Math.min(n, 1 - n), r = (i, o = (i + t / 30) % 12) => n - s * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [r(0), r(8), r(4)];
}
function uL(t, e, n) {
  const s = (r, i = (r + t / 60) % 6) => n - n * e * Math.max(Math.min(i, 4 - i, 1), 0);
  return [s(5), s(3), s(1)];
}
function dL(t, e, n) {
  const s = px(t, 1, 0.5);
  let r;
  for (e + n > 1 && (r = 1 / (e + n), e *= r, n *= r), r = 0; r < 3; r++)
    s[r] *= 1 - e - n, s[r] += e;
  return s;
}
function fL(t, e, n, s, r) {
  return t === r ? (e - n) / s + (e < n ? 6 : 0) : e === r ? (n - t) / s + 2 : (t - e) / s + 4;
}
function Bf(t) {
  const n = t.r / 255, s = t.g / 255, r = t.b / 255, i = Math.max(n, s, r), o = Math.min(n, s, r), a = (i + o) / 2;
  let l, c, u;
  return i !== o && (u = i - o, c = a > 0.5 ? u / (2 - i - o) : u / (i + o), l = fL(n, s, r, u, i), l = l * 60 + 0.5), [l | 0, c || 0, a];
}
function If(t, e, n, s) {
  return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, s)).map(gs);
}
function Ff(t, e, n) {
  return If(px, t, e, n);
}
function hL(t, e, n) {
  return If(dL, t, e, n);
}
function pL(t, e, n) {
  return If(uL, t, e, n);
}
function gx(t) {
  return (t % 360 + 360) % 360;
}
function gL(t) {
  const e = cL.exec(t);
  let n = 255, s;
  if (!e)
    return;
  e[5] !== s && (n = e[6] ? Pi(+e[5]) : gs(+e[5]));
  const r = gx(+e[2]), i = +e[3] / 100, o = +e[4] / 100;
  return e[1] === "hwb" ? s = hL(r, i, o) : e[1] === "hsv" ? s = pL(r, i, o) : s = Ff(r, i, o), {
    r: s[0],
    g: s[1],
    b: s[2],
    a: n
  };
}
function mL(t, e) {
  var n = Bf(t);
  n[0] = gx(n[0] + e), n = Ff(n), t.r = n[0], t.g = n[1], t.b = n[2];
}
function AL(t) {
  if (!t)
    return;
  const e = Bf(t), n = e[0], s = Lg(e[1]), r = Lg(e[2]);
  return t.a < 255 ? `hsla(${n}, ${s}%, ${r}%, ${zn(t.a)})` : `hsl(${n}, ${s}%, ${r}%)`;
}
const Ng = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, jg = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function bL() {
  const t = {}, e = Object.keys(jg), n = Object.keys(Ng);
  let s, r, i, o, a;
  for (s = 0; s < e.length; s++) {
    for (o = a = e[s], r = 0; r < n.length; r++)
      i = n[r], a = a.replace(i, Ng[i]);
    i = parseInt(jg[o], 16), t[a] = [i >> 16 & 255, i >> 8 & 255, i & 255];
  }
  return t;
}
let Jo;
function yL(t) {
  Jo || (Jo = bL(), Jo.transparent = [0, 0, 0, 0]);
  const e = Jo[t.toLowerCase()];
  return e && {
    r: e[0],
    g: e[1],
    b: e[2],
    a: e.length === 4 ? e[3] : 255
  };
}
const vL = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function xL(t) {
  const e = vL.exec(t);
  let n = 255, s, r, i;
  if (e) {
    if (e[7] !== s) {
      const o = +e[7];
      n = e[8] ? Pi(o) : us(o * 255, 0, 255);
    }
    return s = +e[1], r = +e[3], i = +e[5], s = 255 & (e[2] ? Pi(s) : us(s, 0, 255)), r = 255 & (e[4] ? Pi(r) : us(r, 0, 255)), i = 255 & (e[6] ? Pi(i) : us(i, 0, 255)), {
      r: s,
      g: r,
      b: i,
      a: n
    };
  }
}
function wL(t) {
  return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${zn(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`);
}
const Vc = (t) => t <= 31308e-7 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - 0.055, br = (t) => t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
function SL(t, e, n) {
  const s = br(zn(t.r)), r = br(zn(t.g)), i = br(zn(t.b));
  return {
    r: gs(Vc(s + n * (br(zn(e.r)) - s))),
    g: gs(Vc(r + n * (br(zn(e.g)) - r))),
    b: gs(Vc(i + n * (br(zn(e.b)) - i))),
    a: t.a + n * (e.a - t.a)
  };
}
function $o(t, e, n) {
  if (t) {
    let s = Bf(t);
    s[e] = Math.max(0, Math.min(s[e] + s[e] * n, e === 0 ? 360 : 1)), s = Ff(s), t.r = s[0], t.g = s[1], t.b = s[2];
  }
}
function mx(t, e) {
  return t && Object.assign(e || {}, t);
}
function Bg(t) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = gs(t[3]))) : (e = mx(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = gs(e.a)), e;
}
function CL(t) {
  return t.charAt(0) === "r" ? xL(t) : gL(t);
}
class uo {
  constructor(e) {
    if (e instanceof uo)
      return e;
    const n = typeof e;
    let s;
    n === "object" ? s = Bg(e) : n === "string" && (s = oL(e) || yL(e) || CL(e)), this._rgb = s, this._valid = !!s;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var e = mx(this._rgb);
    return e && (e.a = zn(e.a)), e;
  }
  set rgb(e) {
    this._rgb = Bg(e);
  }
  rgbString() {
    return this._valid ? wL(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? lL(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? AL(this._rgb) : void 0;
  }
  mix(e, n) {
    if (e) {
      const s = this.rgb, r = e.rgb;
      let i;
      const o = n === i ? 0.5 : n, a = 2 * o - 1, l = s.a - r.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
      i = 1 - c, s.r = 255 & c * s.r + i * r.r + 0.5, s.g = 255 & c * s.g + i * r.g + 0.5, s.b = 255 & c * s.b + i * r.b + 0.5, s.a = o * s.a + (1 - o) * r.a, this.rgb = s;
    }
    return this;
  }
  interpolate(e, n) {
    return e && (this._rgb = SL(this._rgb, e._rgb, n)), this;
  }
  clone() {
    return new uo(this.rgb);
  }
  alpha(e) {
    return this._rgb.a = gs(e), this;
  }
  clearer(e) {
    const n = this._rgb;
    return n.a *= 1 - e, this;
  }
  greyscale() {
    const e = this._rgb, n = Ro(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
    return e.r = e.g = e.b = n, this;
  }
  opaquer(e) {
    const n = this._rgb;
    return n.a *= 1 + e, this;
  }
  negate() {
    const e = this._rgb;
    return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
  }
  lighten(e) {
    return $o(this._rgb, 2, e), this;
  }
  darken(e) {
    return $o(this._rgb, 2, -e), this;
  }
  saturate(e) {
    return $o(this._rgb, 1, e), this;
  }
  desaturate(e) {
    return $o(this._rgb, 1, -e), this;
  }
  rotate(e) {
    return mL(this._rgb, e), this;
  }
}
/*!
 * Chart.js v4.4.4
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
function Bn() {
}
const PL = /* @__PURE__ */ (() => {
  let t = 0;
  return () => t++;
})();
function be(t) {
  return t === null || typeof t > "u";
}
function We(t) {
  if (Array.isArray && Array.isArray(t))
    return !0;
  const e = Object.prototype.toString.call(t);
  return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
}
function he(t) {
  return t !== null && Object.prototype.toString.call(t) === "[object Object]";
}
function Ge(t) {
  return (typeof t == "number" || t instanceof Number) && isFinite(+t);
}
function Qt(t, e) {
  return Ge(t) ? t : e;
}
function le(t, e) {
  return typeof t > "u" ? e : t;
}
const qL = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 : +t / e, Ax = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;
function Ne(t, e, n) {
  if (t && typeof t.call == "function")
    return t.apply(n, e);
}
function ke(t, e, n, s) {
  let r, i, o;
  if (We(t))
    for (i = t.length, r = 0; r < i; r++)
      e.call(n, t[r], r);
  else if (he(t))
    for (o = Object.keys(t), i = o.length, r = 0; r < i; r++)
      e.call(n, t[o[r]], o[r]);
}
function fl(t, e) {
  let n, s, r, i;
  if (!t || !e || t.length !== e.length)
    return !1;
  for (n = 0, s = t.length; n < s; ++n)
    if (r = t[n], i = e[n], r.datasetIndex !== i.datasetIndex || r.index !== i.index)
      return !1;
  return !0;
}
function hl(t) {
  if (We(t))
    return t.map(hl);
  if (he(t)) {
    const e = /* @__PURE__ */ Object.create(null), n = Object.keys(t), s = n.length;
    let r = 0;
    for (; r < s; ++r)
      e[n[r]] = hl(t[n[r]]);
    return e;
  }
  return t;
}
function bx(t) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(t) === -1;
}
function EL(t, e, n, s) {
  if (!bx(t))
    return;
  const r = e[t], i = n[t];
  he(r) && he(i) ? fo(r, i, s) : e[t] = hl(i);
}
function fo(t, e, n) {
  const s = We(e) ? e : [
    e
  ], r = s.length;
  if (!he(t))
    return t;
  n = n || {};
  const i = n.merger || EL;
  let o;
  for (let a = 0; a < r; ++a) {
    if (o = s[a], !he(o))
      continue;
    const l = Object.keys(o);
    for (let c = 0, u = l.length; c < u; ++c)
      i(l[c], t, o, n);
  }
  return t;
}
function Ni(t, e) {
  return fo(t, e, {
    merger: TL
  });
}
function TL(t, e, n) {
  if (!bx(t))
    return;
  const s = e[t], r = n[t];
  he(s) && he(r) ? Ni(s, r) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = hl(r));
}
const Ig = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (t) => t,
  // default resolvers
  x: (t) => t.x,
  y: (t) => t.y
};
function RL(t) {
  const e = t.split("."), n = [];
  let s = "";
  for (const r of e)
    s += r, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (n.push(s), s = "");
  return n;
}
function kL(t) {
  const e = RL(t);
  return (n) => {
    for (const s of e) {
      if (s === "")
        break;
      n = n && n[s];
    }
    return n;
  };
}
function Ts(t, e) {
  return (Ig[e] || (Ig[e] = kL(e)))(t);
}
function Vf(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const ho = (t) => typeof t < "u", Rs = (t) => typeof t == "function", Fg = (t, e) => {
  if (t.size !== e.size)
    return !1;
  for (const n of t)
    if (!e.has(n))
      return !1;
  return !0;
};
function ML(t) {
  return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu";
}
const ze = Math.PI, Ve = 2 * ze, DL = Ve + ze, pl = Number.POSITIVE_INFINITY, OL = ze / 180, et = ze / 2, Is = ze / 4, Vg = ze * 2 / 3, ds = Math.log10, qn = Math.sign;
function ji(t, e, n) {
  return Math.abs(t - e) < n;
}
function zg(t) {
  const e = Math.round(t);
  t = ji(t, e, t / 1e3) ? e : t;
  const n = Math.pow(10, Math.floor(ds(t))), s = t / n;
  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * n;
}
function LL(t) {
  const e = [], n = Math.sqrt(t);
  let s;
  for (s = 1; s < n; s++)
    t % s === 0 && (e.push(s), e.push(t / s));
  return n === (n | 0) && e.push(n), e.sort((r, i) => r - i).pop(), e;
}
function Qr(t) {
  return !isNaN(parseFloat(t)) && isFinite(t);
}
function NL(t, e) {
  const n = Math.round(t);
  return n - e <= t && n + e >= t;
}
function yx(t, e, n) {
  let s, r, i;
  for (s = 0, r = t.length; s < r; s++)
    i = t[s][n], isNaN(i) || (e.min = Math.min(e.min, i), e.max = Math.max(e.max, i));
}
function un(t) {
  return t * (ze / 180);
}
function zf(t) {
  return t * (180 / ze);
}
function Ug(t) {
  if (!Ge(t))
    return;
  let e = 1, n = 0;
  for (; Math.round(t * e) / e !== t; )
    e *= 10, n++;
  return n;
}
function vx(t, e) {
  const n = e.x - t.x, s = e.y - t.y, r = Math.sqrt(n * n + s * s);
  let i = Math.atan2(s, n);
  return i < -0.5 * ze && (i += Ve), {
    angle: i,
    distance: r
  };
}
function zu(t, e) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
function jL(t, e) {
  return (t - e + DL) % Ve - ze;
}
function Yt(t) {
  return (t % Ve + Ve) % Ve;
}
function po(t, e, n, s) {
  const r = Yt(t), i = Yt(e), o = Yt(n), a = Yt(i - r), l = Yt(o - r), c = Yt(r - i), u = Yt(r - o);
  return r === i || r === o || s && i === o || a > l && c < u;
}
function pt(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function BL(t) {
  return pt(t, -32768, 32767);
}
function Hn(t, e, n, s = 1e-6) {
  return t >= Math.min(e, n) - s && t <= Math.max(e, n) + s;
}
function Uf(t, e, n) {
  n = n || ((o) => t[o] < e);
  let s = t.length - 1, r = 0, i;
  for (; s - r > 1; )
    i = r + s >> 1, n(i) ? r = i : s = i;
  return {
    lo: r,
    hi: s
  };
}
const Qn = (t, e, n, s) => Uf(t, n, s ? (r) => {
  const i = t[r][e];
  return i < n || i === n && t[r + 1][e] === n;
} : (r) => t[r][e] < n), IL = (t, e, n) => Uf(t, n, (s) => t[s][e] >= n);
function FL(t, e, n) {
  let s = 0, r = t.length;
  for (; s < r && t[s] < e; )
    s++;
  for (; r > s && t[r - 1] > n; )
    r--;
  return s > 0 || r < t.length ? t.slice(s, r) : t;
}
const xx = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function VL(t, e) {
  if (t._chartjs) {
    t._chartjs.listeners.push(e);
    return;
  }
  Object.defineProperty(t, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        e
      ]
    }
  }), xx.forEach((n) => {
    const s = "_onData" + Vf(n), r = t[n];
    Object.defineProperty(t, n, {
      configurable: !0,
      enumerable: !1,
      value(...i) {
        const o = r.apply(this, i);
        return t._chartjs.listeners.forEach((a) => {
          typeof a[s] == "function" && a[s](...i);
        }), o;
      }
    });
  });
}
function Wg(t, e) {
  const n = t._chartjs;
  if (!n)
    return;
  const s = n.listeners, r = s.indexOf(e);
  r !== -1 && s.splice(r, 1), !(s.length > 0) && (xx.forEach((i) => {
    delete t[i];
  }), delete t._chartjs);
}
function wx(t) {
  const e = new Set(t);
  return e.size === t.length ? t : Array.from(e);
}
const Sx = function() {
  return typeof window > "u" ? function(t) {
    return t();
  } : window.requestAnimationFrame;
}();
function Cx(t, e) {
  let n = [], s = !1;
  return function(...r) {
    n = r, s || (s = !0, Sx.call(window, () => {
      s = !1, t.apply(e, n);
    }));
  };
}
function zL(t, e) {
  let n;
  return function(...s) {
    return e ? (clearTimeout(n), n = setTimeout(t, e, s)) : t.apply(this, s), e;
  };
}
const Wf = (t) => t === "start" ? "left" : t === "end" ? "right" : "center", xt = (t, e, n) => t === "start" ? e : t === "end" ? n : (e + n) / 2, UL = (t, e, n, s) => t === (s ? "left" : "right") ? n : t === "center" ? (e + n) / 2 : e;
function Px(t, e, n) {
  const s = e.length;
  let r = 0, i = s;
  if (t._sorted) {
    const { iScale: o, _parsed: a } = t, l = o.axis, { min: c, max: u, minDefined: d, maxDefined: f } = o.getUserBounds();
    d && (r = pt(Math.min(
      // @ts-expect-error Need to type _parsed
      Qn(a, l, c).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? s : Qn(e, l, o.getPixelForValue(c)).lo
    ), 0, s - 1)), f ? i = pt(Math.max(
      // @ts-expect-error Need to type _parsed
      Qn(a, o.axis, u, !0).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? 0 : Qn(e, l, o.getPixelForValue(u), !0).hi + 1
    ), r, s) - r : i = s - r;
  }
  return {
    start: r,
    count: i
  };
}
function qx(t) {
  const { xScale: e, yScale: n, _scaleRanges: s } = t, r = {
    xmin: e.min,
    xmax: e.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!s)
    return t._scaleRanges = r, !0;
  const i = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== n.min || s.ymax !== n.max;
  return Object.assign(s, r), i;
}
const ea = (t) => t === 0 || t === 1, Hg = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * Ve / n)), Qg = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * Ve / n) + 1, Bi = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * et) + 1,
  easeOutSine: (t) => Math.sin(t * et),
  easeInOutSine: (t) => -0.5 * (Math.cos(ze * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => ea(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => ea(t) ? t : Hg(t, 0.075, 0.3),
  easeOutElastic: (t) => ea(t) ? t : Qg(t, 0.075, 0.3),
  easeInOutElastic(t) {
    return ea(t) ? t : t < 0.5 ? 0.5 * Hg(t * 2, 0.1125, 0.45) : 0.5 + 0.5 * Qg(t * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(t) {
    return t * t * ((1.70158 + 1) * t - 1.70158);
  },
  easeOutBack(t) {
    return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1;
  },
  easeInOutBack(t) {
    let e = 1.70158;
    return (t /= 0.5) < 1 ? 0.5 * (t * t * (((e *= 1.525) + 1) * t - e)) : 0.5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2);
  },
  easeInBounce: (t) => 1 - Bi.easeOutBounce(1 - t),
  easeOutBounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? Bi.easeInBounce(t * 2) * 0.5 : Bi.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function Hf(t) {
  if (t && typeof t == "object") {
    const e = t.toString();
    return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
  }
  return !1;
}
function Yg(t) {
  return Hf(t) ? t : new uo(t);
}
function zc(t) {
  return Hf(t) ? t : new uo(t).saturate(0.5).darken(0.1).hexString();
}
const WL = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], HL = [
  "color",
  "borderColor",
  "backgroundColor"
];
function QL(t) {
  t.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), t.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
  }), t.set("animations", {
    colors: {
      type: "color",
      properties: HL
    },
    numbers: {
      type: "number",
      properties: WL
    }
  }), t.describe("animations", {
    _fallback: "animation"
  }), t.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (e) => e | 0
        }
      }
    }
  });
}
function YL(t) {
  t.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const Kg = /* @__PURE__ */ new Map();
function KL(t, e) {
  e = e || {};
  const n = t + JSON.stringify(e);
  let s = Kg.get(n);
  return s || (s = new Intl.NumberFormat(t, e), Kg.set(n, s)), s;
}
function ko(t, e, n) {
  return KL(e, n).format(t);
}
const Ex = {
  values(t) {
    return We(t) ? t : "" + t;
  },
  numeric(t, e, n) {
    if (t === 0)
      return "0";
    const s = this.chart.options.locale;
    let r, i = t;
    if (n.length > 1) {
      const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (c < 1e-4 || c > 1e15) && (r = "scientific"), i = XL(t, n);
    }
    const o = ds(Math.abs(i)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = {
      notation: r,
      minimumFractionDigits: a,
      maximumFractionDigits: a
    };
    return Object.assign(l, this.options.ticks.format), ko(t, s, l);
  },
  logarithmic(t, e, n) {
    if (t === 0)
      return "0";
    const s = n[e].significand || t / Math.pow(10, Math.floor(ds(t)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(s) || e > 0.8 * n.length ? Ex.numeric.call(this, t, e, n) : "";
  }
};
function XL(t, e) {
  let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
  return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n;
}
var Xl = {
  formatters: Ex
};
function GL(t) {
  t.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (e, n) => n.lineWidth,
      tickColor: (e, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Xl.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", {
    _fallback: !1,
    _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
    _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
  }), t.describe("scales", {
    _fallback: "scale"
  }), t.describe("scale.ticks", {
    _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
    _indexable: (e) => e !== "backdropPadding"
  });
}
const or = /* @__PURE__ */ Object.create(null), Uu = /* @__PURE__ */ Object.create(null);
function Ii(t, e) {
  if (!e)
    return t;
  const n = e.split(".");
  for (let s = 0, r = n.length; s < r; ++s) {
    const i = n[s];
    t = t[i] || (t[i] = /* @__PURE__ */ Object.create(null));
  }
  return t;
}
function Uc(t, e, n) {
  return typeof e == "string" ? fo(Ii(t, e), n) : fo(Ii(t, ""), e);
}
class ZL {
  constructor(e, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (s) => s.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (s, r) => zc(r.backgroundColor), this.hoverBorderColor = (s, r) => zc(r.borderColor), this.hoverColor = (s, r) => zc(r.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n);
  }
  set(e, n) {
    return Uc(this, e, n);
  }
  get(e) {
    return Ii(this, e);
  }
  describe(e, n) {
    return Uc(Uu, e, n);
  }
  override(e, n) {
    return Uc(or, e, n);
  }
  route(e, n, s, r) {
    const i = Ii(this, e), o = Ii(this, s), a = "_" + n;
    Object.defineProperties(i, {
      [a]: {
        value: i[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const l = this[a], c = o[r];
          return he(l) ? Object.assign({}, c, l) : le(l, c);
        },
        set(l) {
          this[a] = l;
        }
      }
    });
  }
  apply(e) {
    e.forEach((n) => n(this));
  }
}
var Ze = /* @__PURE__ */ new ZL({
  _scriptable: (t) => !t.startsWith("on"),
  _indexable: (t) => t !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  QL,
  YL,
  GL
]);
function _L(t) {
  return !t || be(t.size) || be(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family;
}
function gl(t, e, n, s, r) {
  let i = e[r];
  return i || (i = e[r] = t.measureText(r).width, n.push(r)), i > s && (s = i), s;
}
function JL(t, e, n, s) {
  s = s || {};
  let r = s.data = s.data || {}, i = s.garbageCollect = s.garbageCollect || [];
  s.font !== e && (r = s.data = {}, i = s.garbageCollect = [], s.font = e), t.save(), t.font = e;
  let o = 0;
  const a = n.length;
  let l, c, u, d, f;
  for (l = 0; l < a; l++)
    if (d = n[l], d != null && !We(d))
      o = gl(t, r, i, o, d);
    else if (We(d))
      for (c = 0, u = d.length; c < u; c++)
        f = d[c], f != null && !We(f) && (o = gl(t, r, i, o, f));
  t.restore();
  const h = i.length / 2;
  if (h > n.length) {
    for (l = 0; l < h; l++)
      delete r[i[l]];
    i.splice(0, h);
  }
  return o;
}
function Fs(t, e, n) {
  const s = t.currentDevicePixelRatio, r = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((e - r) * s) / s + r;
}
function Xg(t, e) {
  !e && !t || (e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore());
}
function Wu(t, e, n, s) {
  Tx(t, e, n, s, null);
}
function Tx(t, e, n, s, r) {
  let i, o, a, l, c, u, d, f;
  const h = e.pointStyle, p = e.rotation, g = e.radius;
  let A = (p || 0) * OL;
  if (h && typeof h == "object" && (i = h.toString(), i === "[object HTMLImageElement]" || i === "[object HTMLCanvasElement]")) {
    t.save(), t.translate(n, s), t.rotate(A), t.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t.restore();
    return;
  }
  if (!(isNaN(g) || g <= 0)) {
    switch (t.beginPath(), h) {
      default:
        r ? t.ellipse(n, s, r / 2, g, 0, 0, Ve) : t.arc(n, s, g, 0, Ve), t.closePath();
        break;
      case "triangle":
        u = r ? r / 2 : g, t.moveTo(n + Math.sin(A) * u, s - Math.cos(A) * g), A += Vg, t.lineTo(n + Math.sin(A) * u, s - Math.cos(A) * g), A += Vg, t.lineTo(n + Math.sin(A) * u, s - Math.cos(A) * g), t.closePath();
        break;
      case "rectRounded":
        c = g * 0.516, l = g - c, o = Math.cos(A + Is) * l, d = Math.cos(A + Is) * (r ? r / 2 - c : l), a = Math.sin(A + Is) * l, f = Math.sin(A + Is) * (r ? r / 2 - c : l), t.arc(n - d, s - a, c, A - ze, A - et), t.arc(n + f, s - o, c, A - et, A), t.arc(n + d, s + a, c, A, A + et), t.arc(n - f, s + o, c, A + et, A + ze), t.closePath();
        break;
      case "rect":
        if (!p) {
          l = Math.SQRT1_2 * g, u = r ? r / 2 : l, t.rect(n - u, s - l, 2 * u, 2 * l);
          break;
        }
        A += Is;
      case "rectRot":
        d = Math.cos(A) * (r ? r / 2 : g), o = Math.cos(A) * g, a = Math.sin(A) * g, f = Math.sin(A) * (r ? r / 2 : g), t.moveTo(n - d, s - a), t.lineTo(n + f, s - o), t.lineTo(n + d, s + a), t.lineTo(n - f, s + o), t.closePath();
        break;
      case "crossRot":
        A += Is;
      case "cross":
        d = Math.cos(A) * (r ? r / 2 : g), o = Math.cos(A) * g, a = Math.sin(A) * g, f = Math.sin(A) * (r ? r / 2 : g), t.moveTo(n - d, s - a), t.lineTo(n + d, s + a), t.moveTo(n + f, s - o), t.lineTo(n - f, s + o);
        break;
      case "star":
        d = Math.cos(A) * (r ? r / 2 : g), o = Math.cos(A) * g, a = Math.sin(A) * g, f = Math.sin(A) * (r ? r / 2 : g), t.moveTo(n - d, s - a), t.lineTo(n + d, s + a), t.moveTo(n + f, s - o), t.lineTo(n - f, s + o), A += Is, d = Math.cos(A) * (r ? r / 2 : g), o = Math.cos(A) * g, a = Math.sin(A) * g, f = Math.sin(A) * (r ? r / 2 : g), t.moveTo(n - d, s - a), t.lineTo(n + d, s + a), t.moveTo(n + f, s - o), t.lineTo(n - f, s + o);
        break;
      case "line":
        o = r ? r / 2 : Math.cos(A) * g, a = Math.sin(A) * g, t.moveTo(n - o, s - a), t.lineTo(n + o, s + a);
        break;
      case "dash":
        t.moveTo(n, s), t.lineTo(n + Math.cos(A) * (r ? r / 2 : g), s + Math.sin(A) * g);
        break;
      case !1:
        t.closePath();
        break;
    }
    t.fill(), e.borderWidth > 0 && t.stroke();
  }
}
function Yn(t, e, n) {
  return n = n || 0.5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n;
}
function Gl(t, e) {
  t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();
}
function Zl(t) {
  t.restore();
}
function $L(t, e, n, s, r) {
  if (!e)
    return t.lineTo(n.x, n.y);
  if (r === "middle") {
    const i = (e.x + n.x) / 2;
    t.lineTo(i, e.y), t.lineTo(i, n.y);
  } else r === "after" != !!s ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y);
  t.lineTo(n.x, n.y);
}
function eN(t, e, n, s) {
  if (!e)
    return t.lineTo(n.x, n.y);
  t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? n.cp2x : n.cp1x, s ? n.cp2y : n.cp1y, n.x, n.y);
}
function tN(t, e) {
  e.translation && t.translate(e.translation[0], e.translation[1]), be(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);
}
function nN(t, e, n, s, r) {
  if (r.strikethrough || r.underline) {
    const i = t.measureText(s), o = e - i.actualBoundingBoxLeft, a = e + i.actualBoundingBoxRight, l = n - i.actualBoundingBoxAscent, c = n + i.actualBoundingBoxDescent, u = r.strikethrough ? (l + c) / 2 : c;
    t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = r.decorationWidth || 2, t.moveTo(o, u), t.lineTo(a, u), t.stroke();
  }
}
function sN(t, e) {
  const n = t.fillStyle;
  t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n;
}
function ar(t, e, n, s, r, i = {}) {
  const o = We(e) ? e : [
    e
  ], a = i.strokeWidth > 0 && i.strokeColor !== "";
  let l, c;
  for (t.save(), t.font = r.string, tN(t, i), l = 0; l < o.length; ++l)
    c = o[l], i.backdrop && sN(t, i.backdrop), a && (i.strokeColor && (t.strokeStyle = i.strokeColor), be(i.strokeWidth) || (t.lineWidth = i.strokeWidth), t.strokeText(c, n, s, i.maxWidth)), t.fillText(c, n, s, i.maxWidth), nN(t, n, s, c, i), s += Number(r.lineHeight);
  t.restore();
}
function go(t, e) {
  const { x: n, y: s, w: r, h: i, radius: o } = e;
  t.arc(n + o.topLeft, s + o.topLeft, o.topLeft, 1.5 * ze, ze, !0), t.lineTo(n, s + i - o.bottomLeft), t.arc(n + o.bottomLeft, s + i - o.bottomLeft, o.bottomLeft, ze, et, !0), t.lineTo(n + r - o.bottomRight, s + i), t.arc(n + r - o.bottomRight, s + i - o.bottomRight, o.bottomRight, et, 0, !0), t.lineTo(n + r, s + o.topRight), t.arc(n + r - o.topRight, s + o.topRight, o.topRight, 0, -et, !0), t.lineTo(n + o.topLeft, s);
}
const rN = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, iN = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function oN(t, e) {
  const n = ("" + t).match(rN);
  if (!n || n[1] === "normal")
    return e * 1.2;
  switch (t = +n[2], n[3]) {
    case "px":
      return t;
    case "%":
      t /= 100;
      break;
  }
  return e * t;
}
const aN = (t) => +t || 0;
function Qf(t, e) {
  const n = {}, s = he(e), r = s ? Object.keys(e) : e, i = he(t) ? s ? (o) => le(t[o], t[e[o]]) : (o) => t[o] : () => t;
  for (const o of r)
    n[o] = aN(i(o));
  return n;
}
function Rx(t) {
  return Qf(t, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Js(t) {
  return Qf(t, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function qt(t) {
  const e = Rx(t);
  return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
}
function ct(t, e) {
  t = t || {}, e = e || Ze.font;
  let n = le(t.size, e.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let s = le(t.style, e.style);
  s && !("" + s).match(iN) && (console.warn('Invalid font style specified: "' + s + '"'), s = void 0);
  const r = {
    family: le(t.family, e.family),
    lineHeight: oN(le(t.lineHeight, e.lineHeight), n),
    size: n,
    style: s,
    weight: le(t.weight, e.weight),
    string: ""
  };
  return r.string = _L(r), r;
}
function qi(t, e, n, s) {
  let r, i, o;
  for (r = 0, i = t.length; r < i; ++r)
    if (o = t[r], o !== void 0 && o !== void 0)
      return o;
}
function lN(t, e, n) {
  const { min: s, max: r } = t, i = Ax(e, (r - s) / 2), o = (a, l) => n && a === 0 ? 0 : a + l;
  return {
    min: o(s, -Math.abs(i)),
    max: o(r, i)
  };
}
function Os(t, e) {
  return Object.assign(Object.create(t), e);
}
function Yf(t, e = [
  ""
], n, s, r = () => t[0]) {
  const i = n || t;
  typeof s > "u" && (s = Ox("_fallback", t));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: t,
    _rootScopes: i,
    _fallback: s,
    _getTarget: r,
    override: (a) => Yf([
      a,
      ...t
    ], e, i, s)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, l) {
      return delete a[l], delete a._keys, delete t[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, l) {
      return Mx(a, l, () => mN(l, e, t, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, l) {
      return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(a, l) {
      return Zg(a).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(a) {
      return Zg(a);
    },
    /**
    * A trap for setting property values.
    */
    set(a, l, c) {
      const u = a._storage || (a._storage = r());
      return a[l] = u[l] = c, delete a._keys, !0;
    }
  });
}
function Yr(t, e, n, s) {
  const r = {
    _cacheable: !1,
    _proxy: t,
    _context: e,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: kx(t, s),
    setContext: (i) => Yr(t, i, n, s),
    override: (i) => Yr(t.override(i), e, n, s)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(i, o) {
      return delete i[o], delete t[o], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(i, o, a) {
      return Mx(i, o, () => uN(i, o, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(i, o) {
      return i._descriptors.allKeys ? Reflect.has(t, o) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(t, o);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t);
    },
    /**
    * A trap for the in operator.
    */
    has(i, o) {
      return Reflect.has(t, o);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(t);
    },
    /**
    * A trap for setting property values.
    */
    set(i, o, a) {
      return t[o] = a, delete i[o], !0;
    }
  });
}
function kx(t, e = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = e.scriptable, _indexable: s = e.indexable, _allKeys: r = e.allKeys } = t;
  return {
    allKeys: r,
    scriptable: n,
    indexable: s,
    isScriptable: Rs(n) ? n : () => n,
    isIndexable: Rs(s) ? s : () => s
  };
}
const cN = (t, e) => t ? t + Vf(e) : e, Kf = (t, e) => he(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function Mx(t, e, n) {
  if (Object.prototype.hasOwnProperty.call(t, e) || e === "constructor")
    return t[e];
  const s = n();
  return t[e] = s, s;
}
function uN(t, e, n) {
  const { _proxy: s, _context: r, _subProxy: i, _descriptors: o } = t;
  let a = s[e];
  return Rs(a) && o.isScriptable(e) && (a = dN(e, a, t, n)), We(a) && a.length && (a = fN(e, a, t, o.isIndexable)), Kf(e, a) && (a = Yr(a, r, i && i[e], o)), a;
}
function dN(t, e, n, s) {
  const { _proxy: r, _context: i, _subProxy: o, _stack: a } = n;
  if (a.has(t))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t);
  a.add(t);
  let l = e(i, o || s);
  return a.delete(t), Kf(t, l) && (l = Xf(r._scopes, r, t, l)), l;
}
function fN(t, e, n, s) {
  const { _proxy: r, _context: i, _subProxy: o, _descriptors: a } = n;
  if (typeof i.index < "u" && s(t))
    return e[i.index % e.length];
  if (he(e[0])) {
    const l = e, c = r._scopes.filter((u) => u !== l);
    e = [];
    for (const u of l) {
      const d = Xf(c, r, t, u);
      e.push(Yr(d, i, o && o[t], a));
    }
  }
  return e;
}
function Dx(t, e, n) {
  return Rs(t) ? t(e, n) : t;
}
const hN = (t, e) => t === !0 ? e : typeof t == "string" ? Ts(e, t) : void 0;
function pN(t, e, n, s, r) {
  for (const i of e) {
    const o = hN(n, i);
    if (o) {
      t.add(o);
      const a = Dx(o._fallback, n, r);
      if (typeof a < "u" && a !== n && a !== s)
        return a;
    } else if (o === !1 && typeof s < "u" && n !== s)
      return null;
  }
  return !1;
}
function Xf(t, e, n, s) {
  const r = e._rootScopes, i = Dx(e._fallback, n, s), o = [
    ...t,
    ...r
  ], a = /* @__PURE__ */ new Set();
  a.add(s);
  let l = Gg(a, o, n, i || n, s);
  return l === null || typeof i < "u" && i !== n && (l = Gg(a, o, i, l, s), l === null) ? !1 : Yf(Array.from(a), [
    ""
  ], r, i, () => gN(e, n, s));
}
function Gg(t, e, n, s, r) {
  for (; n; )
    n = pN(t, e, n, s, r);
  return n;
}
function gN(t, e, n) {
  const s = t._getTarget();
  e in s || (s[e] = {});
  const r = s[e];
  return We(r) && he(n) ? n : r || {};
}
function mN(t, e, n, s) {
  let r;
  for (const i of e)
    if (r = Ox(cN(i, t), n), typeof r < "u")
      return Kf(t, r) ? Xf(n, s, t, r) : r;
}
function Ox(t, e) {
  for (const n of e) {
    if (!n)
      continue;
    const s = n[t];
    if (typeof s < "u")
      return s;
  }
}
function Zg(t) {
  let e = t._keys;
  return e || (e = t._keys = AN(t._scopes)), e;
}
function AN(t) {
  const e = /* @__PURE__ */ new Set();
  for (const n of t)
    for (const s of Object.keys(n).filter((r) => !r.startsWith("_")))
      e.add(s);
  return Array.from(e);
}
function Lx(t, e, n, s) {
  const { iScale: r } = t, { key: i = "r" } = this._parsing, o = new Array(s);
  let a, l, c, u;
  for (a = 0, l = s; a < l; ++a)
    c = a + n, u = e[c], o[a] = {
      r: r.parse(Ts(u, i), c)
    };
  return o;
}
const bN = Number.EPSILON || 1e-14, Kr = (t, e) => e < t.length && !t[e].skip && t[e], Nx = (t) => t === "x" ? "y" : "x";
function yN(t, e, n, s) {
  const r = t.skip ? e : t, i = e, o = n.skip ? e : n, a = zu(i, r), l = zu(o, i);
  let c = a / (a + l), u = l / (a + l);
  c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
  const d = s * c, f = s * u;
  return {
    previous: {
      x: i.x - d * (o.x - r.x),
      y: i.y - d * (o.y - r.y)
    },
    next: {
      x: i.x + f * (o.x - r.x),
      y: i.y + f * (o.y - r.y)
    }
  };
}
function vN(t, e, n) {
  const s = t.length;
  let r, i, o, a, l, c = Kr(t, 0);
  for (let u = 0; u < s - 1; ++u)
    if (l = c, c = Kr(t, u + 1), !(!l || !c)) {
      if (ji(e[u], 0, bN)) {
        n[u] = n[u + 1] = 0;
        continue;
      }
      r = n[u] / e[u], i = n[u + 1] / e[u], a = Math.pow(r, 2) + Math.pow(i, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[u] = r * o * e[u], n[u + 1] = i * o * e[u]);
    }
}
function xN(t, e, n = "x") {
  const s = Nx(n), r = t.length;
  let i, o, a, l = Kr(t, 0);
  for (let c = 0; c < r; ++c) {
    if (o = a, a = l, l = Kr(t, c + 1), !a)
      continue;
    const u = a[n], d = a[s];
    o && (i = (u - o[n]) / 3, a[`cp1${n}`] = u - i, a[`cp1${s}`] = d - i * e[c]), l && (i = (l[n] - u) / 3, a[`cp2${n}`] = u + i, a[`cp2${s}`] = d + i * e[c]);
  }
}
function wN(t, e = "x") {
  const n = Nx(e), s = t.length, r = Array(s).fill(0), i = Array(s);
  let o, a, l, c = Kr(t, 0);
  for (o = 0; o < s; ++o)
    if (a = l, l = c, c = Kr(t, o + 1), !!l) {
      if (c) {
        const u = c[e] - l[e];
        r[o] = u !== 0 ? (c[n] - l[n]) / u : 0;
      }
      i[o] = a ? c ? qn(r[o - 1]) !== qn(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o];
    }
  vN(t, r, i), xN(t, i, e);
}
function ta(t, e, n) {
  return Math.max(Math.min(t, n), e);
}
function SN(t, e) {
  let n, s, r, i, o, a = Yn(t[0], e);
  for (n = 0, s = t.length; n < s; ++n)
    o = i, i = a, a = n < s - 1 && Yn(t[n + 1], e), i && (r = t[n], o && (r.cp1x = ta(r.cp1x, e.left, e.right), r.cp1y = ta(r.cp1y, e.top, e.bottom)), a && (r.cp2x = ta(r.cp2x, e.left, e.right), r.cp2y = ta(r.cp2y, e.top, e.bottom)));
}
function CN(t, e, n, s, r) {
  let i, o, a, l;
  if (e.spanGaps && (t = t.filter((c) => !c.skip)), e.cubicInterpolationMode === "monotone")
    wN(t, r);
  else {
    let c = s ? t[t.length - 1] : t[0];
    for (i = 0, o = t.length; i < o; ++i)
      a = t[i], l = yN(c, a, t[Math.min(i + 1, o - (s ? 0 : 1)) % o], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
  }
  e.capBezierPoints && SN(t, n);
}
function Gf() {
  return typeof window < "u" && typeof document < "u";
}
function Zf(t) {
  let e = t.parentNode;
  return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
}
function ml(t, e, n) {
  let s;
  return typeof t == "string" ? (s = parseInt(t, 10), t.indexOf("%") !== -1 && (s = s / 100 * e.parentNode[n])) : s = t, s;
}
const _l = (t) => t.ownerDocument.defaultView.getComputedStyle(t, null);
function PN(t, e) {
  return _l(t).getPropertyValue(e);
}
const qN = [
  "top",
  "right",
  "bottom",
  "left"
];
function $s(t, e, n) {
  const s = {};
  n = n ? "-" + n : "";
  for (let r = 0; r < 4; r++) {
    const i = qN[r];
    s[i] = parseFloat(t[e + "-" + i + n]) || 0;
  }
  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;
}
const EN = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot);
function TN(t, e) {
  const n = t.touches, s = n && n.length ? n[0] : t, { offsetX: r, offsetY: i } = s;
  let o = !1, a, l;
  if (EN(r, i, t.target))
    a = r, l = i;
  else {
    const c = e.getBoundingClientRect();
    a = s.clientX - c.left, l = s.clientY - c.top, o = !0;
  }
  return {
    x: a,
    y: l,
    box: o
  };
}
function Hs(t, e) {
  if ("native" in t)
    return t;
  const { canvas: n, currentDevicePixelRatio: s } = e, r = _l(n), i = r.boxSizing === "border-box", o = $s(r, "padding"), a = $s(r, "border", "width"), { x: l, y: c, box: u } = TN(t, n), d = o.left + (u && a.left), f = o.top + (u && a.top);
  let { width: h, height: p } = e;
  return i && (h -= o.width + a.width, p -= o.height + a.height), {
    x: Math.round((l - d) / h * n.width / s),
    y: Math.round((c - f) / p * n.height / s)
  };
}
function RN(t, e, n) {
  let s, r;
  if (e === void 0 || n === void 0) {
    const i = t && Zf(t);
    if (!i)
      e = t.clientWidth, n = t.clientHeight;
    else {
      const o = i.getBoundingClientRect(), a = _l(i), l = $s(a, "border", "width"), c = $s(a, "padding");
      e = o.width - c.width - l.width, n = o.height - c.height - l.height, s = ml(a.maxWidth, i, "clientWidth"), r = ml(a.maxHeight, i, "clientHeight");
    }
  }
  return {
    width: e,
    height: n,
    maxWidth: s || pl,
    maxHeight: r || pl
  };
}
const na = (t) => Math.round(t * 10) / 10;
function kN(t, e, n, s) {
  const r = _l(t), i = $s(r, "margin"), o = ml(r.maxWidth, t, "clientWidth") || pl, a = ml(r.maxHeight, t, "clientHeight") || pl, l = RN(t, e, n);
  let { width: c, height: u } = l;
  if (r.boxSizing === "content-box") {
    const f = $s(r, "border", "width"), h = $s(r, "padding");
    c -= h.width + f.width, u -= h.height + f.height;
  }
  return c = Math.max(0, c - i.width), u = Math.max(0, s ? c / s : u - i.height), c = na(Math.min(c, o, l.maxWidth)), u = na(Math.min(u, a, l.maxHeight)), c && !u && (u = na(c / 2)), (e !== void 0 || n !== void 0) && s && l.height && u > l.height && (u = l.height, c = na(Math.floor(u * s))), {
    width: c,
    height: u
  };
}
function _g(t, e, n) {
  const s = e || 1, r = Math.floor(t.height * s), i = Math.floor(t.width * s);
  t.height = Math.floor(t.height), t.width = Math.floor(t.width);
  const o = t.canvas;
  return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), t.currentDevicePixelRatio !== s || o.height !== r || o.width !== i ? (t.currentDevicePixelRatio = s, o.height = r, o.width = i, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;
}
const MN = function() {
  let t = !1;
  try {
    const e = {
      get passive() {
        return t = !0, !1;
      }
    };
    Gf() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e));
  } catch {
  }
  return t;
}();
function Jg(t, e) {
  const n = PN(t, e), s = n && n.match(/^(\d+)(\.\d+)?px$/);
  return s ? +s[1] : void 0;
}
function Qs(t, e, n, s) {
  return {
    x: t.x + n * (e.x - t.x),
    y: t.y + n * (e.y - t.y)
  };
}
function DN(t, e, n, s) {
  return {
    x: t.x + n * (e.x - t.x),
    y: s === "middle" ? n < 0.5 ? t.y : e.y : s === "after" ? n < 1 ? t.y : e.y : n > 0 ? e.y : t.y
  };
}
function ON(t, e, n, s) {
  const r = {
    x: t.cp2x,
    y: t.cp2y
  }, i = {
    x: e.cp1x,
    y: e.cp1y
  }, o = Qs(t, r, n), a = Qs(r, i, n), l = Qs(i, e, n), c = Qs(o, a, n), u = Qs(a, l, n);
  return Qs(c, u, n);
}
const LN = function(t, e) {
  return {
    x(n) {
      return t + t + e - n;
    },
    setWidth(n) {
      e = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, s) {
      return n - s;
    },
    leftForLtr(n, s) {
      return n - s;
    }
  };
}, NN = function() {
  return {
    x(t) {
      return t;
    },
    setWidth(t) {
    },
    textAlign(t) {
      return t;
    },
    xPlus(t, e) {
      return t + e;
    },
    leftForLtr(t, e) {
      return t;
    }
  };
};
function Lr(t, e, n) {
  return t ? LN(e, n) : NN();
}
function jx(t, e) {
  let n, s;
  (e === "ltr" || e === "rtl") && (n = t.canvas.style, s = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", e, "important"), t.prevTextDirection = s);
}
function Bx(t, e) {
  e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]));
}
function Ix(t) {
  return t === "angle" ? {
    between: po,
    compare: jL,
    normalize: Yt
  } : {
    between: Hn,
    compare: (e, n) => e - n,
    normalize: (e) => e
  };
}
function $g({ start: t, end: e, count: n, loop: s, style: r }) {
  return {
    start: t % n,
    end: e % n,
    loop: s && (e - t + 1) % n === 0,
    style: r
  };
}
function jN(t, e, n) {
  const { property: s, start: r, end: i } = n, { between: o, normalize: a } = Ix(s), l = e.length;
  let { start: c, end: u, loop: d } = t, f, h;
  if (d) {
    for (c += l, u += l, f = 0, h = l; f < h && o(a(e[c % l][s]), r, i); ++f)
      c--, u--;
    c %= l, u %= l;
  }
  return u < c && (u += l), {
    start: c,
    end: u,
    loop: d,
    style: t.style
  };
}
function Fx(t, e, n) {
  if (!n)
    return [
      t
    ];
  const { property: s, start: r, end: i } = n, o = e.length, { compare: a, between: l, normalize: c } = Ix(s), { start: u, end: d, loop: f, style: h } = jN(t, e, n), p = [];
  let g = !1, A = null, b, y, w;
  const x = () => l(r, w, b) && a(r, w) !== 0, S = () => a(i, b) === 0 || l(i, w, b), q = () => g || x(), C = () => !g || S();
  for (let E = u, T = u; E <= d; ++E)
    y = e[E % o], !y.skip && (b = c(y[s]), b !== w && (g = l(b, r, i), A === null && q() && (A = a(b, r) === 0 ? E : T), A !== null && C() && (p.push($g({
      start: A,
      end: E,
      loop: f,
      count: o,
      style: h
    })), A = null), T = E, w = b));
  return A !== null && p.push($g({
    start: A,
    end: d,
    loop: f,
    count: o,
    style: h
  })), p;
}
function Vx(t, e) {
  const n = [], s = t.segments;
  for (let r = 0; r < s.length; r++) {
    const i = Fx(s[r], t.points, e);
    i.length && n.push(...i);
  }
  return n;
}
function BN(t, e, n, s) {
  let r = 0, i = e - 1;
  if (n && !s)
    for (; r < e && !t[r].skip; )
      r++;
  for (; r < e && t[r].skip; )
    r++;
  for (r %= e, n && (i += r); i > r && t[i % e].skip; )
    i--;
  return i %= e, {
    start: r,
    end: i
  };
}
function IN(t, e, n, s) {
  const r = t.length, i = [];
  let o = e, a = t[e], l;
  for (l = e + 1; l <= n; ++l) {
    const c = t[l % r];
    c.skip || c.stop ? a.skip || (s = !1, i.push({
      start: e % r,
      end: (l - 1) % r,
      loop: s
    }), e = o = c.stop ? l : null) : (o = l, a.skip && (e = l)), a = c;
  }
  return o !== null && i.push({
    start: e % r,
    end: o % r,
    loop: s
  }), i;
}
function FN(t, e) {
  const n = t.points, s = t.options.spanGaps, r = n.length;
  if (!r)
    return [];
  const i = !!t._loop, { start: o, end: a } = BN(n, r, i, s);
  if (s === !0)
    return em(t, [
      {
        start: o,
        end: a,
        loop: i
      }
    ], n, e);
  const l = a < o ? a + r : a, c = !!t._fullLoop && o === 0 && a === r - 1;
  return em(t, IN(n, o, l, c), n, e);
}
function em(t, e, n, s) {
  return !s || !s.setContext || !n ? e : VN(t, e, n, s);
}
function VN(t, e, n, s) {
  const r = t._chart.getContext(), i = tm(t.options), { _datasetIndex: o, options: { spanGaps: a } } = t, l = n.length, c = [];
  let u = i, d = e[0].start, f = d;
  function h(p, g, A, b) {
    const y = a ? -1 : 1;
    if (p !== g) {
      for (p += l; n[p % l].skip; )
        p -= y;
      for (; n[g % l].skip; )
        g += y;
      p % l !== g % l && (c.push({
        start: p % l,
        end: g % l,
        loop: A,
        style: b
      }), u = b, d = g % l);
    }
  }
  for (const p of e) {
    d = a ? d : p.start;
    let g = n[d % l], A;
    for (f = d + 1; f <= p.end; f++) {
      const b = n[f % l];
      A = tm(s.setContext(Os(r, {
        type: "segment",
        p0: g,
        p1: b,
        p0DataIndex: (f - 1) % l,
        p1DataIndex: f % l,
        datasetIndex: o
      }))), zN(A, u) && h(d, f - 1, p.loop, u), g = b, u = A;
    }
    d < f - 1 && h(d, f - 1, p.loop, u);
  }
  return c;
}
function tm(t) {
  return {
    backgroundColor: t.backgroundColor,
    borderCapStyle: t.borderCapStyle,
    borderDash: t.borderDash,
    borderDashOffset: t.borderDashOffset,
    borderJoinStyle: t.borderJoinStyle,
    borderWidth: t.borderWidth,
    borderColor: t.borderColor
  };
}
function zN(t, e) {
  if (!e)
    return !1;
  const n = [], s = function(r, i) {
    return Hf(i) ? (n.includes(i) || n.push(i), n.indexOf(i)) : i;
  };
  return JSON.stringify(t, s) !== JSON.stringify(e, s);
}
/*!
 * Chart.js v4.4.4
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class UN {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(e, n, s, r) {
    const i = n.listeners[r], o = n.duration;
    i.forEach((a) => a({
      chart: e,
      initial: n.initial,
      numSteps: o,
      currentStep: Math.min(s - n.start, o)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Sx.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(e = Date.now()) {
    let n = 0;
    this._charts.forEach((s, r) => {
      if (!s.running || !s.items.length)
        return;
      const i = s.items;
      let o = i.length - 1, a = !1, l;
      for (; o >= 0; --o)
        l = i[o], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(e), a = !0) : (i[o] = i[i.length - 1], i.pop());
      a && (r.draw(), this._notify(r, s, e, "progress")), i.length || (s.running = !1, this._notify(r, s, e, "complete"), s.initial = !1), n += i.length;
    }), this._lastDate = e, n === 0 && (this._running = !1);
  }
  _getAnims(e) {
    const n = this._charts;
    let s = n.get(e);
    return s || (s = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(e, s)), s;
  }
  listen(e, n, s) {
    this._getAnims(e).listeners[n].push(s);
  }
  add(e, n) {
    !n || !n.length || this._getAnims(e).items.push(...n);
  }
  has(e) {
    return this._getAnims(e).items.length > 0;
  }
  start(e) {
    const n = this._charts.get(e);
    n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((s, r) => Math.max(s, r._duration), 0), this._refresh());
  }
  running(e) {
    if (!this._running)
      return !1;
    const n = this._charts.get(e);
    return !(!n || !n.running || !n.items.length);
  }
  stop(e) {
    const n = this._charts.get(e);
    if (!n || !n.items.length)
      return;
    const s = n.items;
    let r = s.length - 1;
    for (; r >= 0; --r)
      s[r].cancel();
    n.items = [], this._notify(e, n, Date.now(), "complete");
  }
  remove(e) {
    return this._charts.delete(e);
  }
}
var Fn = /* @__PURE__ */ new UN();
const nm = "transparent", WN = {
  boolean(t, e, n) {
    return n > 0.5 ? e : t;
  },
  color(t, e, n) {
    const s = Yg(t || nm), r = s.valid && Yg(e || nm);
    return r && r.valid ? r.mix(s, n).hexString() : e;
  },
  number(t, e, n) {
    return t + (e - t) * n;
  }
};
class HN {
  constructor(e, n, s, r) {
    const i = n[s];
    r = qi([
      e.to,
      r,
      i,
      e.from
    ]);
    const o = qi([
      e.from,
      i,
      r
    ]);
    this._active = !0, this._fn = e.fn || WN[e.type || typeof o], this._easing = Bi[e.easing] || Bi.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = s, this._from = o, this._to = r, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(e, n, s) {
    if (this._active) {
      this._notify(!1);
      const r = this._target[this._prop], i = s - this._start, o = this._duration - i;
      this._start = s, this._duration = Math.floor(Math.max(o, e.duration)), this._total += i, this._loop = !!e.loop, this._to = qi([
        e.to,
        n,
        r,
        e.from
      ]), this._from = qi([
        e.from,
        r,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(e) {
    const n = e - this._start, s = this._duration, r = this._prop, i = this._from, o = this._loop, a = this._to;
    let l;
    if (this._active = i !== a && (o || n < s), !this._active) {
      this._target[r] = a, this._notify(!0);
      return;
    }
    if (n < 0) {
      this._target[r] = i;
      return;
    }
    l = n / s % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(i, a, l);
  }
  wait() {
    const e = this._promises || (this._promises = []);
    return new Promise((n, s) => {
      e.push({
        res: n,
        rej: s
      });
    });
  }
  _notify(e) {
    const n = e ? "res" : "rej", s = this._promises || [];
    for (let r = 0; r < s.length; r++)
      s[r][n]();
  }
}
class zx {
  constructor(e, n) {
    this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(e) {
    if (!he(e))
      return;
    const n = Object.keys(Ze.animation), s = this._properties;
    Object.getOwnPropertyNames(e).forEach((r) => {
      const i = e[r];
      if (!he(i))
        return;
      const o = {};
      for (const a of n)
        o[a] = i[a];
      (We(i.properties) && i.properties || [
        r
      ]).forEach((a) => {
        (a === r || !s.has(a)) && s.set(a, o);
      });
    });
  }
  _animateOptions(e, n) {
    const s = n.options, r = YN(e, s);
    if (!r)
      return [];
    const i = this._createAnimations(r, s);
    return s.$shared && QN(e.options.$animations, s).then(() => {
      e.options = s;
    }, () => {
    }), i;
  }
  _createAnimations(e, n) {
    const s = this._properties, r = [], i = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now();
    let l;
    for (l = o.length - 1; l >= 0; --l) {
      const c = o[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        r.push(...this._animateOptions(e, n));
        continue;
      }
      const u = n[c];
      let d = i[c];
      const f = s.get(c);
      if (d)
        if (f && d.active()) {
          d.update(f, u, a);
          continue;
        } else
          d.cancel();
      if (!f || !f.duration) {
        e[c] = u;
        continue;
      }
      i[c] = d = new HN(f, e, c, u), r.push(d);
    }
    return r;
  }
  update(e, n) {
    if (this._properties.size === 0) {
      Object.assign(e, n);
      return;
    }
    const s = this._createAnimations(e, n);
    if (s.length)
      return Fn.add(this._chart, s), !0;
  }
}
function QN(t, e) {
  const n = [], s = Object.keys(e);
  for (let r = 0; r < s.length; r++) {
    const i = t[s[r]];
    i && i.active() && n.push(i.wait());
  }
  return Promise.all(n);
}
function YN(t, e) {
  if (!e)
    return;
  let n = t.options;
  if (!n) {
    t.options = e;
    return;
  }
  return n.$shared && (t.options = n = Object.assign({}, n, {
    $shared: !1,
    $animations: {}
  })), n;
}
function sm(t, e) {
  const n = t && t.options || {}, s = n.reverse, r = n.min === void 0 ? e : 0, i = n.max === void 0 ? e : 0;
  return {
    start: s ? i : r,
    end: s ? r : i
  };
}
function KN(t, e, n) {
  if (n === !1)
    return !1;
  const s = sm(t, n), r = sm(e, n);
  return {
    top: r.end,
    right: s.end,
    bottom: r.start,
    left: s.start
  };
}
function XN(t) {
  let e, n, s, r;
  return he(t) ? (e = t.top, n = t.right, s = t.bottom, r = t.left) : e = n = s = r = t, {
    top: e,
    right: n,
    bottom: s,
    left: r,
    disabled: t === !1
  };
}
function Ux(t, e) {
  const n = [], s = t._getSortedDatasetMetas(e);
  let r, i;
  for (r = 0, i = s.length; r < i; ++r)
    n.push(s[r].index);
  return n;
}
function rm(t, e, n, s = {}) {
  const r = t.keys, i = s.mode === "single";
  let o, a, l, c;
  if (e !== null) {
    for (o = 0, a = r.length; o < a; ++o) {
      if (l = +r[o], l === n) {
        if (s.all)
          continue;
        break;
      }
      c = t.values[l], Ge(c) && (i || e === 0 || qn(e) === qn(c)) && (e += c);
    }
    return e;
  }
}
function GN(t, e) {
  const { iScale: n, vScale: s } = e, r = n.axis === "x" ? "x" : "y", i = s.axis === "x" ? "x" : "y", o = Object.keys(t), a = new Array(o.length);
  let l, c, u;
  for (l = 0, c = o.length; l < c; ++l)
    u = o[l], a[l] = {
      [r]: u,
      [i]: t[u]
    };
  return a;
}
function im(t, e) {
  const n = t && t.options.stacked;
  return n || n === void 0 && e.stack !== void 0;
}
function ZN(t, e, n) {
  return `${t.id}.${e.id}.${n.stack || n.type}`;
}
function _N(t) {
  const { min: e, max: n, minDefined: s, maxDefined: r } = t.getUserBounds();
  return {
    min: s ? e : Number.NEGATIVE_INFINITY,
    max: r ? n : Number.POSITIVE_INFINITY
  };
}
function JN(t, e, n) {
  const s = t[e] || (t[e] = {});
  return s[n] || (s[n] = {});
}
function om(t, e, n, s) {
  for (const r of e.getMatchingVisibleMetas(s).reverse()) {
    const i = t[r.index];
    if (n && i > 0 || !n && i < 0)
      return r.index;
  }
  return null;
}
function am(t, e) {
  const { chart: n, _cachedMeta: s } = t, r = n._stacks || (n._stacks = {}), { iScale: i, vScale: o, index: a } = s, l = i.axis, c = o.axis, u = ZN(i, o, s), d = e.length;
  let f;
  for (let h = 0; h < d; ++h) {
    const p = e[h], { [l]: g, [c]: A } = p, b = p._stacks || (p._stacks = {});
    f = b[c] = JN(r, u, g), f[a] = A, f._top = om(f, o, !0, s.type), f._bottom = om(f, o, !1, s.type);
    const y = f._visualValues || (f._visualValues = {});
    y[a] = A;
  }
}
function Wc(t, e) {
  const n = t.scales;
  return Object.keys(n).filter((s) => n[s].axis === e).shift();
}
function $N(t, e) {
  return Os(t, {
    active: !1,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: "default",
    type: "dataset"
  });
}
function ej(t, e, n) {
  return Os(t, {
    active: !1,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: e,
    mode: "default",
    type: "data"
  });
}
function mi(t, e) {
  const n = t.controller.index, s = t.vScale && t.vScale.axis;
  if (s) {
    e = e || t._parsed;
    for (const r of e) {
      const i = r._stacks;
      if (!i || i[s] === void 0 || i[s][n] === void 0)
        return;
      delete i[s][n], i[s]._visualValues !== void 0 && i[s]._visualValues[n] !== void 0 && delete i[s]._visualValues[n];
    }
  }
}
const Hc = (t) => t === "reset" || t === "none", lm = (t, e) => e ? t : Object.assign({}, t), tj = (t, e, n) => t && !e.hidden && e._stacked && {
  keys: Ux(n, !0),
  values: null
};
class fn {
  constructor(e, n) {
    this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const e = this._cachedMeta;
    this.configure(), this.linkScales(), e._stacked = im(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(e) {
    this.index !== e && mi(this._cachedMeta), this.index = e;
  }
  linkScales() {
    const e = this.chart, n = this._cachedMeta, s = this.getDataset(), r = (d, f, h, p) => d === "x" ? f : d === "r" ? p : h, i = n.xAxisID = le(s.xAxisID, Wc(e, "x")), o = n.yAxisID = le(s.yAxisID, Wc(e, "y")), a = n.rAxisID = le(s.rAxisID, Wc(e, "r")), l = n.indexAxis, c = n.iAxisID = r(l, i, o, a), u = n.vAxisID = r(l, o, i, a);
    n.xScale = this.getScaleForId(i), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(e) {
    return this.chart.scales[e];
  }
  _getOtherScale(e) {
    const n = this._cachedMeta;
    return e === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const e = this._cachedMeta;
    this._data && Wg(this._data, this), e._stacked && mi(e);
  }
  _dataCheck() {
    const e = this.getDataset(), n = e.data || (e.data = []), s = this._data;
    if (he(n)) {
      const r = this._cachedMeta;
      this._data = GN(n, r);
    } else if (s !== n) {
      if (s) {
        Wg(s, this);
        const r = this._cachedMeta;
        mi(r), r._parsed = [];
      }
      n && Object.isExtensible(n) && VL(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const e = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(e) {
    const n = this._cachedMeta, s = this.getDataset();
    let r = !1;
    this._dataCheck();
    const i = n._stacked;
    n._stacked = im(n.vScale, n), n.stack !== s.stack && (r = !0, mi(n), n.stack = s.stack), this._resyncElements(e), (r || i !== n._stacked) && am(this, n._parsed);
  }
  configure() {
    const e = this.chart.config, n = e.datasetScopeKeys(this._type), s = e.getOptionScopes(this.getDataset(), n, !0);
    this.options = e.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(e, n) {
    const { _cachedMeta: s, _data: r } = this, { iScale: i, _stacked: o } = s, a = i.axis;
    let l = e === 0 && n === r.length ? !0 : s._sorted, c = e > 0 && s._parsed[e - 1], u, d, f;
    if (this._parsing === !1)
      s._parsed = r, s._sorted = !0, f = r;
    else {
      We(r[e]) ? f = this.parseArrayData(s, r, e, n) : he(r[e]) ? f = this.parseObjectData(s, r, e, n) : f = this.parsePrimitiveData(s, r, e, n);
      const h = () => d[a] === null || c && d[a] < c[a];
      for (u = 0; u < n; ++u)
        s._parsed[u + e] = d = f[u], l && (h() && (l = !1), c = d);
      s._sorted = l;
    }
    o && am(this, f);
  }
  parsePrimitiveData(e, n, s, r) {
    const { iScale: i, vScale: o } = e, a = i.axis, l = o.axis, c = i.getLabels(), u = i === o, d = new Array(r);
    let f, h, p;
    for (f = 0, h = r; f < h; ++f)
      p = f + s, d[f] = {
        [a]: u || i.parse(c[p], p),
        [l]: o.parse(n[p], p)
      };
    return d;
  }
  parseArrayData(e, n, s, r) {
    const { xScale: i, yScale: o } = e, a = new Array(r);
    let l, c, u, d;
    for (l = 0, c = r; l < c; ++l)
      u = l + s, d = n[u], a[l] = {
        x: i.parse(d[0], u),
        y: o.parse(d[1], u)
      };
    return a;
  }
  parseObjectData(e, n, s, r) {
    const { xScale: i, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(r);
    let u, d, f, h;
    for (u = 0, d = r; u < d; ++u)
      f = u + s, h = n[f], c[u] = {
        x: i.parse(Ts(h, a), f),
        y: o.parse(Ts(h, l), f)
      };
    return c;
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e];
  }
  getDataElement(e) {
    return this._cachedMeta.data[e];
  }
  applyStack(e, n, s) {
    const r = this.chart, i = this._cachedMeta, o = n[e.axis], a = {
      keys: Ux(r, !0),
      values: n._stacks[e.axis]._visualValues
    };
    return rm(a, o, i.index, {
      mode: s
    });
  }
  updateRangeFromParsed(e, n, s, r) {
    const i = s[n.axis];
    let o = i === null ? NaN : i;
    const a = r && s._stacks[n.axis];
    r && a && (r.values = a, o = rm(r, i, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o);
  }
  getMinMax(e, n) {
    const s = this._cachedMeta, r = s._parsed, i = s._sorted && e === s.iScale, o = r.length, a = this._getOtherScale(e), l = tj(n, s, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: d } = _N(a);
    let f, h;
    function p() {
      h = r[f];
      const g = h[a.axis];
      return !Ge(h[e.axis]) || u > g || d < g;
    }
    for (f = 0; f < o && !(!p() && (this.updateRangeFromParsed(c, e, h, l), i)); ++f)
      ;
    if (i) {
      for (f = o - 1; f >= 0; --f)
        if (!p()) {
          this.updateRangeFromParsed(c, e, h, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(e) {
    const n = this._cachedMeta._parsed, s = [];
    let r, i, o;
    for (r = 0, i = n.length; r < i; ++r)
      o = n[r][e.axis], Ge(o) && s.push(o);
    return s;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, s = n.iScale, r = n.vScale, i = this.getParsed(e);
    return {
      label: s ? "" + s.getLabelForValue(i[s.axis]) : "",
      value: r ? "" + r.getLabelForValue(i[r.axis]) : ""
    };
  }
  _update(e) {
    const n = this._cachedMeta;
    this.update(e || "default"), n._clip = XN(le(this.options.clip, KN(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(e) {
  }
  draw() {
    const e = this._ctx, n = this.chart, s = this._cachedMeta, r = s.data || [], i = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || r.length - a, c = this.options.drawActiveElementsOnTop;
    let u;
    for (s.dataset && s.dataset.draw(e, i, a, l), u = a; u < a + l; ++u) {
      const d = r[u];
      d.hidden || (d.active && c ? o.push(d) : d.draw(e, i));
    }
    for (u = 0; u < o.length; ++u)
      o[u].draw(e, i);
  }
  getStyle(e, n) {
    const s = n ? "active" : "default";
    return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(e || 0, s);
  }
  getContext(e, n, s) {
    const r = this.getDataset();
    let i;
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[e];
      i = o.$context || (o.$context = ej(this.getContext(), e, o)), i.parsed = this.getParsed(e), i.raw = r.data[e], i.index = i.dataIndex = e;
    } else
      i = this.$context || (this.$context = $N(this.chart.getContext(), this.index)), i.dataset = r, i.index = i.datasetIndex = this.index;
    return i.active = !!n, i.mode = s, i;
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e);
  }
  resolveDataElementOptions(e, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, e);
  }
  _resolveElementOptions(e, n = "default", s) {
    const r = n === "active", i = this._cachedDataOpts, o = e + "-" + n, a = i[o], l = this.enableOptionSharing && ho(s);
    if (a)
      return lm(a, l);
    const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, e), d = r ? [
      `${e}Hover`,
      "hover",
      e,
      ""
    ] : [
      e,
      ""
    ], f = c.getOptionScopes(this.getDataset(), u), h = Object.keys(Ze.elements[e]), p = () => this.getContext(s, r, n), g = c.resolveNamedOptions(f, h, p, d);
    return g.$shared && (g.$shared = l, i[o] = Object.freeze(lm(g, l))), g;
  }
  _resolveAnimations(e, n, s) {
    const r = this.chart, i = this._cachedDataOpts, o = `animation-${n}`, a = i[o];
    if (a)
      return a;
    let l;
    if (r.options.animation !== !1) {
      const u = this.chart.config, d = u.datasetAnimationScopeKeys(this._type, n), f = u.getOptionScopes(this.getDataset(), d);
      l = u.createResolver(f, this.getContext(e, s, n));
    }
    const c = new zx(r, l && l.animations);
    return l && l._cacheable && (i[o] = Object.freeze(c)), c;
  }
  getSharedOptions(e) {
    if (e.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
  }
  includeOptions(e, n) {
    return !n || Hc(e) || this.chart._animationsDisabled;
  }
  _getSharedOptions(e, n) {
    const s = this.resolveDataElementOptions(e, n), r = this._sharedOptions, i = this.getSharedOptions(s), o = this.includeOptions(n, i) || i !== r;
    return this.updateSharedOptions(i, n, s), {
      sharedOptions: i,
      includeOptions: o
    };
  }
  updateElement(e, n, s, r) {
    Hc(r) ? Object.assign(e, s) : this._resolveAnimations(n, r).update(e, s);
  }
  updateSharedOptions(e, n, s) {
    e && !Hc(n) && this._resolveAnimations(void 0, n).update(e, s);
  }
  _setStyle(e, n, s, r) {
    e.active = r;
    const i = this.getStyle(n, r);
    this._resolveAnimations(n, s, r).update(e, {
      options: !r && this.getSharedOptions(i) || i
    });
  }
  removeHoverStyle(e, n, s) {
    this._setStyle(e, s, "active", !1);
  }
  setHoverStyle(e, n, s) {
    this._setStyle(e, s, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !0);
  }
  _resyncElements(e) {
    const n = this._data, s = this._cachedMeta.data;
    for (const [a, l, c] of this._syncList)
      this[a](l, c);
    this._syncList = [];
    const r = s.length, i = n.length, o = Math.min(i, r);
    o && this.parse(0, o), i > r ? this._insertElements(r, i - r, e) : i < r && this._removeElements(i, r - i);
  }
  _insertElements(e, n, s = !0) {
    const r = this._cachedMeta, i = r.data, o = e + n;
    let a;
    const l = (c) => {
      for (c.length += n, a = c.length - 1; a >= o; a--)
        c[a] = c[a - n];
    };
    for (l(i), a = e; a < o; ++a)
      i[a] = new this.dataElementType();
    this._parsing && l(r._parsed), this.parse(e, n), s && this.updateElements(i, e, n, "reset");
  }
  updateElements(e, n, s, r) {
  }
  _removeElements(e, n) {
    const s = this._cachedMeta;
    if (this._parsing) {
      const r = s._parsed.splice(e, n);
      s._stacked && mi(s, r);
    }
    s.data.splice(e, n);
  }
  _sync(e) {
    if (this._parsing)
      this._syncList.push(e);
    else {
      const [n, s, r] = e;
      this[n](s, r);
    }
    this.chart._dataChanges.push([
      this.index,
      ...e
    ]);
  }
  _onDataPush() {
    const e = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - e,
      e
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(e, n) {
    n && this._sync([
      "_removeElements",
      e,
      n
    ]);
    const s = arguments.length - 2;
    s && this._sync([
      "_insertElements",
      e,
      s
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
W(fn, "defaults", {}), W(fn, "datasetElementType", null), W(fn, "dataElementType", null);
function nj(t, e) {
  if (!t._cache.$bar) {
    const n = t.getMatchingVisibleMetas(e);
    let s = [];
    for (let r = 0, i = n.length; r < i; r++)
      s = s.concat(n[r].controller.getAllParsedValues(t));
    t._cache.$bar = wx(s.sort((r, i) => r - i));
  }
  return t._cache.$bar;
}
function sj(t) {
  const e = t.iScale, n = nj(e, t.type);
  let s = e._length, r, i, o, a;
  const l = () => {
    o === 32767 || o === -32768 || (ho(a) && (s = Math.min(s, Math.abs(o - a) || s)), a = o);
  };
  for (r = 0, i = n.length; r < i; ++r)
    o = e.getPixelForValue(n[r]), l();
  for (a = void 0, r = 0, i = e.ticks.length; r < i; ++r)
    o = e.getPixelForTick(r), l();
  return s;
}
function rj(t, e, n, s) {
  const r = n.barThickness;
  let i, o;
  return be(r) ? (i = e.min * n.categoryPercentage, o = n.barPercentage) : (i = r * s, o = 1), {
    chunk: i / s,
    ratio: o,
    start: e.pixels[t] - i / 2
  };
}
function ij(t, e, n, s) {
  const r = e.pixels, i = r[t];
  let o = t > 0 ? r[t - 1] : null, a = t < r.length - 1 ? r[t + 1] : null;
  const l = n.categoryPercentage;
  o === null && (o = i - (a === null ? e.end - e.start : a - i)), a === null && (a = i + i - o);
  const c = i - (i - Math.min(o, a)) / 2 * l;
  return {
    chunk: Math.abs(a - o) / 2 * l / s,
    ratio: n.barPercentage,
    start: c
  };
}
function oj(t, e, n, s) {
  const r = n.parse(t[0], s), i = n.parse(t[1], s), o = Math.min(r, i), a = Math.max(r, i);
  let l = o, c = a;
  Math.abs(o) > Math.abs(a) && (l = a, c = o), e[n.axis] = c, e._custom = {
    barStart: l,
    barEnd: c,
    start: r,
    end: i,
    min: o,
    max: a
  };
}
function Wx(t, e, n, s) {
  return We(t) ? oj(t, e, n, s) : e[n.axis] = n.parse(t, s), e;
}
function cm(t, e, n, s) {
  const r = t.iScale, i = t.vScale, o = r.getLabels(), a = r === i, l = [];
  let c, u, d, f;
  for (c = n, u = n + s; c < u; ++c)
    f = e[c], d = {}, d[r.axis] = a || r.parse(o[c], c), l.push(Wx(f, d, i, c));
  return l;
}
function Qc(t) {
  return t && t.barStart !== void 0 && t.barEnd !== void 0;
}
function aj(t, e, n) {
  return t !== 0 ? qn(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1);
}
function lj(t) {
  let e, n, s, r, i;
  return t.horizontal ? (e = t.base > t.x, n = "left", s = "right") : (e = t.base < t.y, n = "bottom", s = "top"), e ? (r = "end", i = "start") : (r = "start", i = "end"), {
    start: n,
    end: s,
    reverse: e,
    top: r,
    bottom: i
  };
}
function cj(t, e, n, s) {
  let r = e.borderSkipped;
  const i = {};
  if (!r) {
    t.borderSkipped = i;
    return;
  }
  if (r === !0) {
    t.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: o, end: a, reverse: l, top: c, bottom: u } = lj(t);
  r === "middle" && n && (t.enableBorderRadius = !0, (n._top || 0) === s ? r = c : (n._bottom || 0) === s ? r = u : (i[um(u, o, a, l)] = !0, r = c)), i[um(r, o, a, l)] = !0, t.borderSkipped = i;
}
function um(t, e, n, s) {
  return s ? (t = uj(t, e, n), t = dm(t, n, e)) : t = dm(t, e, n), t;
}
function uj(t, e, n) {
  return t === e ? n : t === n ? e : t;
}
function dm(t, e, n) {
  return t === "start" ? e : t === "end" ? n : t;
}
function dj(t, { inflateAmount: e }, n) {
  t.inflateAmount = e === "auto" ? n === 1 ? 0.33 : 0 : e;
}
class qa extends fn {
  parsePrimitiveData(e, n, s, r) {
    return cm(e, n, s, r);
  }
  parseArrayData(e, n, s, r) {
    return cm(e, n, s, r);
  }
  parseObjectData(e, n, s, r) {
    const { iScale: i, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = i.axis === "x" ? a : l, u = o.axis === "x" ? a : l, d = [];
    let f, h, p, g;
    for (f = s, h = s + r; f < h; ++f)
      g = n[f], p = {}, p[i.axis] = i.parse(Ts(g, c), f), d.push(Wx(Ts(g, u), p, o, f));
    return d;
  }
  updateRangeFromParsed(e, n, s, r) {
    super.updateRangeFromParsed(e, n, s, r);
    const i = s._custom;
    i && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, i.min), e.max = Math.max(e.max, i.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, { iScale: s, vScale: r } = n, i = this.getParsed(e), o = i._custom, a = Qc(o) ? "[" + o.start + ", " + o.end + "]" : "" + r.getLabelForValue(i[r.axis]);
    return {
      label: "" + s.getLabelForValue(i[s.axis]),
      value: a
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const e = this._cachedMeta;
    e.stack = this.getDataset().stack;
  }
  update(e) {
    const n = this._cachedMeta;
    this.updateElements(n.data, 0, n.data.length, e);
  }
  updateElements(e, n, s, r) {
    const i = r === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), u = this._getRuler(), { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, r);
    for (let h = n; h < n + s; h++) {
      const p = this.getParsed(h), g = i || be(p[a.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(h), A = this._calculateBarIndexPixels(h, u), b = (p._stacks || {})[a.axis], y = {
        horizontal: c,
        base: g.base,
        enableBorderRadius: !b || Qc(p._custom) || o === b._top || o === b._bottom,
        x: c ? g.head : A.center,
        y: c ? A.center : g.head,
        height: c ? A.size : Math.abs(g.size),
        width: c ? Math.abs(g.size) : A.size
      };
      f && (y.options = d || this.resolveDataElementOptions(h, e[h].active ? "active" : r));
      const w = y.options || e[h].options;
      cj(y, w, b, o), dj(y, w, u.ratio), this.updateElement(e[h], h, y, r);
    }
  }
  _getStacks(e, n) {
    const { iScale: s } = this._cachedMeta, r = s.getMatchingVisibleMetas(this._type).filter((u) => u.controller.options.grouped), i = s.options.stacked, o = [], a = this._cachedMeta.controller.getParsed(n), l = a && a[s.axis], c = (u) => {
      const d = u._parsed.find((h) => h[s.axis] === l), f = d && d[u.vScale.axis];
      if (be(f) || isNaN(f))
        return !0;
    };
    for (const u of r)
      if (!(n !== void 0 && c(u)) && ((i === !1 || o.indexOf(u.stack) === -1 || i === void 0 && u.stack === void 0) && o.push(u.stack), u.index === e))
        break;
    return o.length || o.push(void 0), o;
  }
  _getStackCount(e) {
    return this._getStacks(void 0, e).length;
  }
  _getStackIndex(e, n, s) {
    const r = this._getStacks(e, s), i = n !== void 0 ? r.indexOf(n) : -1;
    return i === -1 ? r.length - 1 : i;
  }
  _getRuler() {
    const e = this.options, n = this._cachedMeta, s = n.iScale, r = [];
    let i, o;
    for (i = 0, o = n.data.length; i < o; ++i)
      r.push(s.getPixelForValue(this.getParsed(i)[s.axis], i));
    const a = e.barThickness;
    return {
      min: a || sj(n),
      pixels: r,
      start: s._startPixel,
      end: s._endPixel,
      stackCount: this._getStackCount(),
      scale: s,
      grouped: e.grouped,
      ratio: a ? 1 : e.categoryPercentage * e.barPercentage
    };
  }
  _calculateBarValuePixels(e) {
    const { _cachedMeta: { vScale: n, _stacked: s, index: r }, options: { base: i, minBarLength: o } } = this, a = i || 0, l = this.getParsed(e), c = l._custom, u = Qc(c);
    let d = l[n.axis], f = 0, h = s ? this.applyStack(n, l, s) : d, p, g;
    h !== d && (f = h - d, h = d), u && (d = c.barStart, h = c.barEnd - c.barStart, d !== 0 && qn(d) !== qn(c.barEnd) && (f = 0), f += d);
    const A = !be(i) && !u ? i : f;
    let b = n.getPixelForValue(A);
    if (this.chart.getDataVisibility(e) ? p = n.getPixelForValue(f + h) : p = b, g = p - b, Math.abs(g) < o) {
      g = aj(g, n, a) * o, d === a && (b -= g / 2);
      const y = n.getPixelForDecimal(0), w = n.getPixelForDecimal(1), x = Math.min(y, w), S = Math.max(y, w);
      b = Math.max(Math.min(b, S), x), p = b + g, s && !u && (l._stacks[n.axis]._visualValues[r] = n.getValueForPixel(p) - n.getValueForPixel(b));
    }
    if (b === n.getPixelForValue(a)) {
      const y = qn(g) * n.getLineWidthForValue(a) / 2;
      b += y, g -= y;
    }
    return {
      size: g,
      base: b,
      head: p,
      center: p + g / 2
    };
  }
  _calculateBarIndexPixels(e, n) {
    const s = n.scale, r = this.options, i = r.skipNull, o = le(r.maxBarThickness, 1 / 0);
    let a, l;
    if (n.grouped) {
      const c = i ? this._getStackCount(e) : n.stackCount, u = r.barThickness === "flex" ? ij(e, n, r, c) : rj(e, n, r, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, i ? e : void 0);
      a = u.start + u.chunk * d + u.chunk / 2, l = Math.min(o, u.chunk * u.ratio);
    } else
      a = s.getPixelForValue(this.getParsed(e)[s.axis], e), l = Math.min(o, n.min * n.ratio);
    return {
      base: a - l / 2,
      head: a + l / 2,
      center: a,
      size: l
    };
  }
  draw() {
    const e = this._cachedMeta, n = e.vScale, s = e.data, r = s.length;
    let i = 0;
    for (; i < r; ++i)
      this.getParsed(i)[n.axis] !== null && !s[i].hidden && s[i].draw(this._ctx);
  }
}
W(qa, "id", "bar"), W(qa, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), W(qa, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class Ea extends fn {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(e, n, s, r) {
    const i = super.parsePrimitiveData(e, n, s, r);
    for (let o = 0; o < i.length; o++)
      i[o]._custom = this.resolveDataElementOptions(o + s).radius;
    return i;
  }
  parseArrayData(e, n, s, r) {
    const i = super.parseArrayData(e, n, s, r);
    for (let o = 0; o < i.length; o++) {
      const a = n[s + o];
      i[o]._custom = le(a[2], this.resolveDataElementOptions(o + s).radius);
    }
    return i;
  }
  parseObjectData(e, n, s, r) {
    const i = super.parseObjectData(e, n, s, r);
    for (let o = 0; o < i.length; o++) {
      const a = n[s + o];
      i[o]._custom = le(a && a.r && +a.r, this.resolveDataElementOptions(o + s).radius);
    }
    return i;
  }
  getMaxOverflow() {
    const e = this._cachedMeta.data;
    let n = 0;
    for (let s = e.length - 1; s >= 0; --s)
      n = Math.max(n, e[s].size(this.resolveDataElementOptions(s)) / 2);
    return n > 0 && n;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, s = this.chart.data.labels || [], { xScale: r, yScale: i } = n, o = this.getParsed(e), a = r.getLabelForValue(o.x), l = i.getLabelForValue(o.y), c = o._custom;
    return {
      label: s[e] || "",
      value: "(" + a + ", " + l + (c ? ", " + c : "") + ")"
    };
  }
  update(e) {
    const n = this._cachedMeta.data;
    this.updateElements(n, 0, n.length, e);
  }
  updateElements(e, n, s, r) {
    const i = r === "reset", { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(n, r), u = o.axis, d = a.axis;
    for (let f = n; f < n + s; f++) {
      const h = e[f], p = !i && this.getParsed(f), g = {}, A = g[u] = i ? o.getPixelForDecimal(0.5) : o.getPixelForValue(p[u]), b = g[d] = i ? a.getBasePixel() : a.getPixelForValue(p[d]);
      g.skip = isNaN(A) || isNaN(b), c && (g.options = l || this.resolveDataElementOptions(f, h.active ? "active" : r), i && (g.options.radius = 0)), this.updateElement(h, f, g, r);
    }
  }
  resolveDataElementOptions(e, n) {
    const s = this.getParsed(e);
    let r = super.resolveDataElementOptions(e, n);
    r.$shared && (r = Object.assign({}, r, {
      $shared: !1
    }));
    const i = r.radius;
    return n !== "active" && (r.radius = 0), r.radius += le(s && s._custom, i), r;
  }
}
W(Ea, "id", "bubble"), W(Ea, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), W(Ea, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function fj(t, e, n) {
  let s = 1, r = 1, i = 0, o = 0;
  if (e < Ve) {
    const a = t, l = a + e, c = Math.cos(a), u = Math.sin(a), d = Math.cos(l), f = Math.sin(l), h = (w, x, S) => po(w, a, l, !0) ? 1 : Math.max(x, x * n, S, S * n), p = (w, x, S) => po(w, a, l, !0) ? -1 : Math.min(x, x * n, S, S * n), g = h(0, c, d), A = h(et, u, f), b = p(ze, c, d), y = p(ze + et, u, f);
    s = (g - b) / 2, r = (A - y) / 2, i = -(g + b) / 2, o = -(A + y) / 2;
  }
  return {
    ratioX: s,
    ratioY: r,
    offsetX: i,
    offsetY: o
  };
}
class Xs extends fn {
  constructor(e, n) {
    super(e, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(e, n) {
    const s = this.getDataset().data, r = this._cachedMeta;
    if (this._parsing === !1)
      r._parsed = s;
    else {
      let i = (l) => +s[l];
      if (he(s[e])) {
        const { key: l = "value" } = this._parsing;
        i = (c) => +Ts(s[c], l);
      }
      let o, a;
      for (o = e, a = e + n; o < a; ++o)
        r._parsed[o] = i(o);
    }
  }
  _getRotation() {
    return un(this.options.rotation - 90);
  }
  _getCircumference() {
    return un(this.options.circumference);
  }
  _getRotationExtents() {
    let e = Ve, n = -Ve;
    for (let s = 0; s < this.chart.data.datasets.length; ++s)
      if (this.chart.isDatasetVisible(s) && this.chart.getDatasetMeta(s).type === this._type) {
        const r = this.chart.getDatasetMeta(s).controller, i = r._getRotation(), o = r._getCircumference();
        e = Math.min(e, i), n = Math.max(n, i + o);
      }
    return {
      rotation: e,
      circumference: n - e
    };
  }
  update(e) {
    const n = this.chart, { chartArea: s } = n, r = this._cachedMeta, i = r.data, o = this.getMaxBorderWidth() + this.getMaxOffset(i) + this.options.spacing, a = Math.max((Math.min(s.width, s.height) - o) / 2, 0), l = Math.min(qL(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: f, ratioY: h, offsetX: p, offsetY: g } = fj(d, u, l), A = (s.width - o) / f, b = (s.height - o) / h, y = Math.max(Math.min(A, b) / 2, 0), w = Ax(this.options.radius, y), x = Math.max(w * l, 0), S = (w - x) / this._getVisibleDatasetWeightTotal();
    this.offsetX = p * w, this.offsetY = g * w, r.total = this.calculateTotal(), this.outerRadius = w - S * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - S * c, 0), this.updateElements(i, 0, i.length, e);
  }
  _circumference(e, n) {
    const s = this.options, r = this._cachedMeta, i = this._getCircumference();
    return n && s.animation.animateRotate || !this.chart.getDataVisibility(e) || r._parsed[e] === null || r.data[e].hidden ? 0 : this.calculateCircumference(r._parsed[e] * i / Ve);
  }
  updateElements(e, n, s, r) {
    const i = r === "reset", o = this.chart, a = o.chartArea, c = o.options.animation, u = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, f = i && c.animateScale, h = f ? 0 : this.innerRadius, p = f ? 0 : this.outerRadius, { sharedOptions: g, includeOptions: A } = this._getSharedOptions(n, r);
    let b = this._getRotation(), y;
    for (y = 0; y < n; ++y)
      b += this._circumference(y, i);
    for (y = n; y < n + s; ++y) {
      const w = this._circumference(y, i), x = e[y], S = {
        x: u + this.offsetX,
        y: d + this.offsetY,
        startAngle: b,
        endAngle: b + w,
        circumference: w,
        outerRadius: p,
        innerRadius: h
      };
      A && (S.options = g || this.resolveDataElementOptions(y, x.active ? "active" : r)), b += w, this.updateElement(x, y, S, r);
    }
  }
  calculateTotal() {
    const e = this._cachedMeta, n = e.data;
    let s = 0, r;
    for (r = 0; r < n.length; r++) {
      const i = e._parsed[r];
      i !== null && !isNaN(i) && this.chart.getDataVisibility(r) && !n[r].hidden && (s += Math.abs(i));
    }
    return s;
  }
  calculateCircumference(e) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(e) ? Ve * (Math.abs(e) / n) : 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, s = this.chart, r = s.data.labels || [], i = ko(n._parsed[e], s.options.locale);
    return {
      label: r[e] || "",
      value: i
    };
  }
  getMaxBorderWidth(e) {
    let n = 0;
    const s = this.chart;
    let r, i, o, a, l;
    if (!e) {
      for (r = 0, i = s.data.datasets.length; r < i; ++r)
        if (s.isDatasetVisible(r)) {
          o = s.getDatasetMeta(r), e = o.data, a = o.controller;
          break;
        }
    }
    if (!e)
      return 0;
    for (r = 0, i = e.length; r < i; ++r)
      l = a.resolveDataElementOptions(r), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(e) {
    let n = 0;
    for (let s = 0, r = e.length; s < r; ++s) {
      const i = this.resolveDataElementOptions(s);
      n = Math.max(n, i.offset || 0, i.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(e) {
    let n = 0;
    for (let s = 0; s < e; ++s)
      this.chart.isDatasetVisible(s) && (n += this._getRingWeight(s));
    return n;
  }
  _getRingWeight(e) {
    return Math.max(le(this.chart.data.datasets[e].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
W(Xs, "id", "doughnut"), W(Xs, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), W(Xs, "descriptors", {
  _scriptable: (e) => e !== "spacing",
  _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
}), W(Xs, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const n = e.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: s, color: r } } = e.legend.options;
            return n.labels.map((i, o) => {
              const l = e.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: i,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: r,
                lineWidth: l.borderWidth,
                pointStyle: s,
                hidden: !e.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(e, n, s) {
        s.chart.toggleDataVisibility(n.index), s.chart.update();
      }
    }
  }
});
class Ta extends fn {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(e) {
    const n = this._cachedMeta, { dataset: s, data: r = [], _dataset: i } = n, o = this.chart._animationsDisabled;
    let { start: a, count: l } = Px(n, r, o);
    this._drawStart = a, this._drawCount = l, qx(n) && (a = 0, l = r.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!i._decimated, s.points = r;
    const c = this.resolveDatasetElementOptions(e);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {
      animated: !o,
      options: c
    }, e), this.updateElements(r, a, l, e);
  }
  updateElements(e, n, s, r) {
    const i = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, r), f = o.axis, h = a.axis, { spanGaps: p, segment: g } = this.options, A = Qr(p) ? p : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || i || r === "none", y = n + s, w = e.length;
    let x = n > 0 && this.getParsed(n - 1);
    for (let S = 0; S < w; ++S) {
      const q = e[S], C = b ? q : {};
      if (S < n || S >= y) {
        C.skip = !0;
        continue;
      }
      const E = this.getParsed(S), T = be(E[h]), k = C[f] = o.getPixelForValue(E[f], S), R = C[h] = i || T ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, E, l) : E[h], S);
      C.skip = isNaN(k) || isNaN(R) || T, C.stop = S > 0 && Math.abs(E[f] - x[f]) > A, g && (C.parsed = E, C.raw = c.data[S]), d && (C.options = u || this.resolveDataElementOptions(S, q.active ? "active" : r)), b || this.updateElement(q, S, C, r), x = E;
    }
  }
  getMaxOverflow() {
    const e = this._cachedMeta, n = e.dataset, s = n.options && n.options.borderWidth || 0, r = e.data || [];
    if (!r.length)
      return s;
    const i = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
    return Math.max(s, i, o) / 2;
  }
  draw() {
    const e = this._cachedMeta;
    e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
  }
}
W(Ta, "id", "line"), W(Ta, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), W(Ta, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class Fi extends fn {
  constructor(e, n) {
    super(e, n), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, s = this.chart, r = s.data.labels || [], i = ko(n._parsed[e].r, s.options.locale);
    return {
      label: r[e] || "",
      value: i
    };
  }
  parseObjectData(e, n, s, r) {
    return Lx.bind(this)(e, n, s, r);
  }
  update(e) {
    const n = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(n, 0, n.length, e);
  }
  getMinMax() {
    const e = this._cachedMeta, n = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return e.data.forEach((s, r) => {
      const i = this.getParsed(r).r;
      !isNaN(i) && this.chart.getDataVisibility(r) && (i < n.min && (n.min = i), i > n.max && (n.max = i));
    }), n;
  }
  _updateRadius() {
    const e = this.chart, n = e.chartArea, s = e.options, r = Math.min(n.right - n.left, n.bottom - n.top), i = Math.max(r / 2, 0), o = Math.max(s.cutoutPercentage ? i / 100 * s.cutoutPercentage : 1, 0), a = (i - o) / e.getVisibleDatasetCount();
    this.outerRadius = i - a * this.index, this.innerRadius = this.outerRadius - a;
  }
  updateElements(e, n, s, r) {
    const i = r === "reset", o = this.chart, l = o.options.animation, c = this._cachedMeta.rScale, u = c.xCenter, d = c.yCenter, f = c.getIndexAngle(0) - 0.5 * ze;
    let h = f, p;
    const g = 360 / this.countVisibleElements();
    for (p = 0; p < n; ++p)
      h += this._computeAngle(p, r, g);
    for (p = n; p < n + s; p++) {
      const A = e[p];
      let b = h, y = h + this._computeAngle(p, r, g), w = o.getDataVisibility(p) ? c.getDistanceFromCenterForValue(this.getParsed(p).r) : 0;
      h = y, i && (l.animateScale && (w = 0), l.animateRotate && (b = y = f));
      const x = {
        x: u,
        y: d,
        innerRadius: 0,
        outerRadius: w,
        startAngle: b,
        endAngle: y,
        options: this.resolveDataElementOptions(p, A.active ? "active" : r)
      };
      this.updateElement(A, p, x, r);
    }
  }
  countVisibleElements() {
    const e = this._cachedMeta;
    let n = 0;
    return e.data.forEach((s, r) => {
      !isNaN(this.getParsed(r).r) && this.chart.getDataVisibility(r) && n++;
    }), n;
  }
  _computeAngle(e, n, s) {
    return this.chart.getDataVisibility(e) ? un(this.resolveDataElementOptions(e, n).angle || s) : 0;
  }
}
W(Fi, "id", "polarArea"), W(Fi, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), W(Fi, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const n = e.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: s, color: r } } = e.legend.options;
            return n.labels.map((i, o) => {
              const l = e.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: i,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: r,
                lineWidth: l.borderWidth,
                pointStyle: s,
                hidden: !e.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(e, n, s) {
        s.chart.toggleDataVisibility(n.index), s.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class Hu extends Xs {
}
W(Hu, "id", "pie"), W(Hu, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class Ra extends fn {
  getLabelAndValue(e) {
    const n = this._cachedMeta.vScale, s = this.getParsed(e);
    return {
      label: n.getLabels()[e],
      value: "" + n.getLabelForValue(s[n.axis])
    };
  }
  parseObjectData(e, n, s, r) {
    return Lx.bind(this)(e, n, s, r);
  }
  update(e) {
    const n = this._cachedMeta, s = n.dataset, r = n.data || [], i = n.iScale.getLabels();
    if (s.points = r, e !== "resize") {
      const o = this.resolveDatasetElementOptions(e);
      this.options.showLine || (o.borderWidth = 0);
      const a = {
        _loop: !0,
        _fullLoop: i.length === r.length,
        options: o
      };
      this.updateElement(s, void 0, a, e);
    }
    this.updateElements(r, 0, r.length, e);
  }
  updateElements(e, n, s, r) {
    const i = this._cachedMeta.rScale, o = r === "reset";
    for (let a = n; a < n + s; a++) {
      const l = e[a], c = this.resolveDataElementOptions(a, l.active ? "active" : r), u = i.getPointPositionForValue(a, this.getParsed(a).r), d = o ? i.xCenter : u.x, f = o ? i.yCenter : u.y, h = {
        x: d,
        y: f,
        angle: u.angle,
        skip: isNaN(d) || isNaN(f),
        options: c
      };
      this.updateElement(l, a, h, r);
    }
  }
}
W(Ra, "id", "radar"), W(Ra, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), W(Ra, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class ka extends fn {
  getLabelAndValue(e) {
    const n = this._cachedMeta, s = this.chart.data.labels || [], { xScale: r, yScale: i } = n, o = this.getParsed(e), a = r.getLabelForValue(o.x), l = i.getLabelForValue(o.y);
    return {
      label: s[e] || "",
      value: "(" + a + ", " + l + ")"
    };
  }
  update(e) {
    const n = this._cachedMeta, { data: s = [] } = n, r = this.chart._animationsDisabled;
    let { start: i, count: o } = Px(n, s, r);
    if (this._drawStart = i, this._drawCount = o, qx(n) && (i = 0, o = s.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: a, _dataset: l } = n;
      a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;
      const c = this.resolveDatasetElementOptions(e);
      c.segment = this.options.segment, this.updateElement(a, void 0, {
        animated: !r,
        options: c
      }, e);
    } else this.datasetElementType && (delete n.dataset, this.datasetElementType = !1);
    this.updateElements(s, i, o, e);
  }
  addElements() {
    const { showLine: e } = this.options;
    !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(e, n, s, r) {
    const i = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, u = this.resolveDataElementOptions(n, r), d = this.getSharedOptions(u), f = this.includeOptions(r, d), h = o.axis, p = a.axis, { spanGaps: g, segment: A } = this.options, b = Qr(g) ? g : Number.POSITIVE_INFINITY, y = this.chart._animationsDisabled || i || r === "none";
    let w = n > 0 && this.getParsed(n - 1);
    for (let x = n; x < n + s; ++x) {
      const S = e[x], q = this.getParsed(x), C = y ? S : {}, E = be(q[p]), T = C[h] = o.getPixelForValue(q[h], x), k = C[p] = i || E ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, q, l) : q[p], x);
      C.skip = isNaN(T) || isNaN(k) || E, C.stop = x > 0 && Math.abs(q[h] - w[h]) > b, A && (C.parsed = q, C.raw = c.data[x]), f && (C.options = d || this.resolveDataElementOptions(x, S.active ? "active" : r)), y || this.updateElement(S, x, C, r), w = q;
    }
    this.updateSharedOptions(d, r, u);
  }
  getMaxOverflow() {
    const e = this._cachedMeta, n = e.data || [];
    if (!this.options.showLine) {
      let a = 0;
      for (let l = n.length - 1; l >= 0; --l)
        a = Math.max(a, n[l].size(this.resolveDataElementOptions(l)) / 2);
      return a > 0 && a;
    }
    const s = e.dataset, r = s.options && s.options.borderWidth || 0;
    if (!n.length)
      return r;
    const i = n[0].size(this.resolveDataElementOptions(0)), o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));
    return Math.max(r, i, o) / 2;
  }
}
W(ka, "id", "scatter"), W(ka, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), W(ka, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var hj = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: qa,
  BubbleController: Ea,
  DoughnutController: Xs,
  LineController: Ta,
  PieController: Hu,
  PolarAreaController: Fi,
  RadarController: Ra,
  ScatterController: ka
});
function Vs() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class _f {
  constructor(e) {
    W(this, "options");
    this.options = e || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(e) {
    Object.assign(_f.prototype, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return Vs();
  }
  parse() {
    return Vs();
  }
  format() {
    return Vs();
  }
  add() {
    return Vs();
  }
  diff() {
    return Vs();
  }
  startOf() {
    return Vs();
  }
  endOf() {
    return Vs();
  }
}
var pj = {
  _date: _f
};
function gj(t, e, n, s) {
  const { controller: r, data: i, _sorted: o } = t, a = r._cachedMeta.iScale;
  if (a && e === a.axis && e !== "r" && o && i.length) {
    const l = a._reversePixels ? IL : Qn;
    if (s) {
      if (r._sharedOptions) {
        const c = i[0], u = typeof c.getRange == "function" && c.getRange(e);
        if (u) {
          const d = l(i, e, n - u), f = l(i, e, n + u);
          return {
            lo: d.lo,
            hi: f.hi
          };
        }
      }
    } else return l(i, e, n);
  }
  return {
    lo: 0,
    hi: i.length - 1
  };
}
function Mo(t, e, n, s, r) {
  const i = t.getSortedVisibleDatasetMetas(), o = n[e];
  for (let a = 0, l = i.length; a < l; ++a) {
    const { index: c, data: u } = i[a], { lo: d, hi: f } = gj(i[a], e, o, r);
    for (let h = d; h <= f; ++h) {
      const p = u[h];
      p.skip || s(p, c, h);
    }
  }
}
function mj(t) {
  const e = t.indexOf("x") !== -1, n = t.indexOf("y") !== -1;
  return function(s, r) {
    const i = e ? Math.abs(s.x - r.x) : 0, o = n ? Math.abs(s.y - r.y) : 0;
    return Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2));
  };
}
function Yc(t, e, n, s, r) {
  const i = [];
  return !r && !t.isPointInArea(e) || Mo(t, n, e, function(a, l, c) {
    !r && !Yn(a, t.chartArea, 0) || a.inRange(e.x, e.y, s) && i.push({
      element: a,
      datasetIndex: l,
      index: c
    });
  }, !0), i;
}
function Aj(t, e, n, s) {
  let r = [];
  function i(o, a, l) {
    const { startAngle: c, endAngle: u } = o.getProps([
      "startAngle",
      "endAngle"
    ], s), { angle: d } = vx(o, {
      x: e.x,
      y: e.y
    });
    po(d, c, u) && r.push({
      element: o,
      datasetIndex: a,
      index: l
    });
  }
  return Mo(t, n, e, i), r;
}
function bj(t, e, n, s, r, i) {
  let o = [];
  const a = mj(n);
  let l = Number.POSITIVE_INFINITY;
  function c(u, d, f) {
    const h = u.inRange(e.x, e.y, r);
    if (s && !h)
      return;
    const p = u.getCenterPoint(r);
    if (!(!!i || t.isPointInArea(p)) && !h)
      return;
    const A = a(e, p);
    A < l ? (o = [
      {
        element: u,
        datasetIndex: d,
        index: f
      }
    ], l = A) : A === l && o.push({
      element: u,
      datasetIndex: d,
      index: f
    });
  }
  return Mo(t, n, e, c), o;
}
function Kc(t, e, n, s, r, i) {
  return !i && !t.isPointInArea(e) ? [] : n === "r" && !s ? Aj(t, e, n, r) : bj(t, e, n, s, r, i);
}
function fm(t, e, n, s, r) {
  const i = [], o = n === "x" ? "inXRange" : "inYRange";
  let a = !1;
  return Mo(t, n, e, (l, c, u) => {
    l[o] && l[o](e[n], r) && (i.push({
      element: l,
      datasetIndex: c,
      index: u
    }), a = a || l.inRange(e.x, e.y, r));
  }), s && !a ? [] : i;
}
var yj = {
  evaluateInteractionItems: Mo,
  modes: {
    index(t, e, n, s) {
      const r = Hs(e, t), i = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? Yc(t, r, i, s, o) : Kc(t, r, i, !1, s, o), l = [];
      return a.length ? (t.getSortedVisibleDatasetMetas().forEach((c) => {
        const u = a[0].index, d = c.data[u];
        d && !d.skip && l.push({
          element: d,
          datasetIndex: c.index,
          index: u
        });
      }), l) : [];
    },
    dataset(t, e, n, s) {
      const r = Hs(e, t), i = n.axis || "xy", o = n.includeInvisible || !1;
      let a = n.intersect ? Yc(t, r, i, s, o) : Kc(t, r, i, !1, s, o);
      if (a.length > 0) {
        const l = a[0].datasetIndex, c = t.getDatasetMeta(l).data;
        a = [];
        for (let u = 0; u < c.length; ++u)
          a.push({
            element: c[u],
            datasetIndex: l,
            index: u
          });
      }
      return a;
    },
    point(t, e, n, s) {
      const r = Hs(e, t), i = n.axis || "xy", o = n.includeInvisible || !1;
      return Yc(t, r, i, s, o);
    },
    nearest(t, e, n, s) {
      const r = Hs(e, t), i = n.axis || "xy", o = n.includeInvisible || !1;
      return Kc(t, r, i, n.intersect, s, o);
    },
    x(t, e, n, s) {
      const r = Hs(e, t);
      return fm(t, r, "x", n.intersect, s);
    },
    y(t, e, n, s) {
      const r = Hs(e, t);
      return fm(t, r, "y", n.intersect, s);
    }
  }
};
const Hx = [
  "left",
  "top",
  "right",
  "bottom"
];
function Ai(t, e) {
  return t.filter((n) => n.pos === e);
}
function hm(t, e) {
  return t.filter((n) => Hx.indexOf(n.pos) === -1 && n.box.axis === e);
}
function bi(t, e) {
  return t.sort((n, s) => {
    const r = e ? s : n, i = e ? n : s;
    return r.weight === i.weight ? r.index - i.index : r.weight - i.weight;
  });
}
function vj(t) {
  const e = [];
  let n, s, r, i, o, a;
  for (n = 0, s = (t || []).length; n < s; ++n)
    r = t[n], { position: i, options: { stack: o, stackWeight: a = 1 } } = r, e.push({
      index: n,
      box: r,
      pos: i,
      horizontal: r.isHorizontal(),
      weight: r.weight,
      stack: o && i + o,
      stackWeight: a
    });
  return e;
}
function xj(t) {
  const e = {};
  for (const n of t) {
    const { stack: s, pos: r, stackWeight: i } = n;
    if (!s || !Hx.includes(r))
      continue;
    const o = e[s] || (e[s] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    o.count++, o.weight += i;
  }
  return e;
}
function wj(t, e) {
  const n = xj(t), { vBoxMaxWidth: s, hBoxMaxHeight: r } = e;
  let i, o, a;
  for (i = 0, o = t.length; i < o; ++i) {
    a = t[i];
    const { fullSize: l } = a.box, c = n[a.stack], u = c && a.stackWeight / c.weight;
    a.horizontal ? (a.width = u ? u * s : l && e.availableWidth, a.height = r) : (a.width = s, a.height = u ? u * r : l && e.availableHeight);
  }
  return n;
}
function Sj(t) {
  const e = vj(t), n = bi(e.filter((c) => c.box.fullSize), !0), s = bi(Ai(e, "left"), !0), r = bi(Ai(e, "right")), i = bi(Ai(e, "top"), !0), o = bi(Ai(e, "bottom")), a = hm(e, "x"), l = hm(e, "y");
  return {
    fullSize: n,
    leftAndTop: s.concat(i),
    rightAndBottom: r.concat(l).concat(o).concat(a),
    chartArea: Ai(e, "chartArea"),
    vertical: s.concat(r).concat(l),
    horizontal: i.concat(o).concat(a)
  };
}
function pm(t, e, n, s) {
  return Math.max(t[n], e[n]) + Math.max(t[s], e[s]);
}
function Qx(t, e) {
  t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);
}
function Cj(t, e, n, s) {
  const { pos: r, box: i } = n, o = t.maxPadding;
  if (!he(r)) {
    n.size && (t[r] -= n.size);
    const d = s[n.stack] || {
      size: 0,
      count: 1
    };
    d.size = Math.max(d.size, n.horizontal ? i.height : i.width), n.size = d.size / d.count, t[r] += n.size;
  }
  i.getPadding && Qx(o, i.getPadding());
  const a = Math.max(0, e.outerWidth - pm(o, t, "left", "right")), l = Math.max(0, e.outerHeight - pm(o, t, "top", "bottom")), c = a !== t.w, u = l !== t.h;
  return t.w = a, t.h = l, n.horizontal ? {
    same: c,
    other: u
  } : {
    same: u,
    other: c
  };
}
function Pj(t) {
  const e = t.maxPadding;
  function n(s) {
    const r = Math.max(e[s] - t[s], 0);
    return t[s] += r, r;
  }
  t.y += n("top"), t.x += n("left"), n("right"), n("bottom");
}
function qj(t, e) {
  const n = e.maxPadding;
  function s(r) {
    const i = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return r.forEach((o) => {
      i[o] = Math.max(e[o], n[o]);
    }), i;
  }
  return s(t ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Ei(t, e, n, s) {
  const r = [];
  let i, o, a, l, c, u;
  for (i = 0, o = t.length, c = 0; i < o; ++i) {
    a = t[i], l = a.box, l.update(a.width || e.w, a.height || e.h, qj(a.horizontal, e));
    const { same: d, other: f } = Cj(e, n, a, s);
    c |= d && r.length, u = u || f, l.fullSize || r.push(a);
  }
  return c && Ei(r, e, n, s) || u;
}
function sa(t, e, n, s, r) {
  t.top = n, t.left = e, t.right = e + s, t.bottom = n + r, t.width = s, t.height = r;
}
function gm(t, e, n, s) {
  const r = n.padding;
  let { x: i, y: o } = e;
  for (const a of t) {
    const l = a.box, c = s[a.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    }, u = a.stackWeight / c.weight || 1;
    if (a.horizontal) {
      const d = e.w * u, f = c.size || l.height;
      ho(c.start) && (o = c.start), l.fullSize ? sa(l, r.left, o, n.outerWidth - r.right - r.left, f) : sa(l, e.left + c.placed, o, d, f), c.start = o, c.placed += d, o = l.bottom;
    } else {
      const d = e.h * u, f = c.size || l.width;
      ho(c.start) && (i = c.start), l.fullSize ? sa(l, i, r.top, f, n.outerHeight - r.bottom - r.top) : sa(l, i, e.top + c.placed, f, d), c.start = i, c.placed += d, i = l.right;
    }
  }
  e.x = i, e.y = o;
}
var Ct = {
  addBox(t, e) {
    t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            e.draw(n);
          }
        }
      ];
    }, t.boxes.push(e);
  },
  removeBox(t, e) {
    const n = t.boxes ? t.boxes.indexOf(e) : -1;
    n !== -1 && t.boxes.splice(n, 1);
  },
  configure(t, e, n) {
    e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight;
  },
  update(t, e, n, s) {
    if (!t)
      return;
    const r = qt(t.options.layout.padding), i = Math.max(e - r.width, 0), o = Math.max(n - r.height, 0), a = Sj(t.boxes), l = a.vertical, c = a.horizontal;
    ke(t.boxes, (g) => {
      typeof g.beforeLayout == "function" && g.beforeLayout();
    });
    const u = l.reduce((g, A) => A.box.options && A.box.options.display === !1 ? g : g + 1, 0) || 1, d = Object.freeze({
      outerWidth: e,
      outerHeight: n,
      padding: r,
      availableWidth: i,
      availableHeight: o,
      vBoxMaxWidth: i / 2 / u,
      hBoxMaxHeight: o / 2
    }), f = Object.assign({}, r);
    Qx(f, qt(s));
    const h = Object.assign({
      maxPadding: f,
      w: i,
      h: o,
      x: r.left,
      y: r.top
    }, r), p = wj(l.concat(c), d);
    Ei(a.fullSize, h, d, p), Ei(l, h, d, p), Ei(c, h, d, p) && Ei(l, h, d, p), Pj(h), gm(a.leftAndTop, h, d, p), h.x += h.w, h.y += h.h, gm(a.rightAndBottom, h, d, p), t.chartArea = {
      left: h.left,
      top: h.top,
      right: h.left + h.w,
      bottom: h.top + h.h,
      height: h.h,
      width: h.w
    }, ke(a.chartArea, (g) => {
      const A = g.box;
      Object.assign(A, t.chartArea), A.update(h.w, h.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class Yx {
  acquireContext(e, n) {
  }
  releaseContext(e) {
    return !1;
  }
  addEventListener(e, n, s) {
  }
  removeEventListener(e, n, s) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(e, n, s, r) {
    return n = Math.max(0, n || e.width), s = s || e.height, {
      width: n,
      height: Math.max(0, r ? Math.floor(n / r) : s)
    };
  }
  isAttached(e) {
    return !0;
  }
  updateConfig(e) {
  }
}
class Ej extends Yx {
  acquireContext(e) {
    return e && e.getContext && e.getContext("2d") || null;
  }
  updateConfig(e) {
    e.options.animation = !1;
  }
}
const Ma = "$chartjs", Tj = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, mm = (t) => t === null || t === "";
function Rj(t, e) {
  const n = t.style, s = t.getAttribute("height"), r = t.getAttribute("width");
  if (t[Ma] = {
    initial: {
      height: s,
      width: r,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", mm(r)) {
    const i = Jg(t, "width");
    i !== void 0 && (t.width = i);
  }
  if (mm(s))
    if (t.style.height === "")
      t.height = t.width / (e || 2);
    else {
      const i = Jg(t, "height");
      i !== void 0 && (t.height = i);
    }
  return t;
}
const Kx = MN ? {
  passive: !0
} : !1;
function kj(t, e, n) {
  t && t.addEventListener(e, n, Kx);
}
function Mj(t, e, n) {
  t && t.canvas && t.canvas.removeEventListener(e, n, Kx);
}
function Dj(t, e) {
  const n = Tj[t.type] || t.type, { x: s, y: r } = Hs(t, e);
  return {
    type: n,
    chart: e,
    native: t,
    x: s !== void 0 ? s : null,
    y: r !== void 0 ? r : null
  };
}
function Al(t, e) {
  for (const n of t)
    if (n === e || n.contains(e))
      return !0;
}
function Oj(t, e, n) {
  const s = t.canvas, r = new MutationObserver((i) => {
    let o = !1;
    for (const a of i)
      o = o || Al(a.addedNodes, s), o = o && !Al(a.removedNodes, s);
    o && n();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
function Lj(t, e, n) {
  const s = t.canvas, r = new MutationObserver((i) => {
    let o = !1;
    for (const a of i)
      o = o || Al(a.removedNodes, s), o = o && !Al(a.addedNodes, s);
    o && n();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
const mo = /* @__PURE__ */ new Map();
let Am = 0;
function Xx() {
  const t = window.devicePixelRatio;
  t !== Am && (Am = t, mo.forEach((e, n) => {
    n.currentDevicePixelRatio !== t && e();
  }));
}
function Nj(t, e) {
  mo.size || window.addEventListener("resize", Xx), mo.set(t, e);
}
function jj(t) {
  mo.delete(t), mo.size || window.removeEventListener("resize", Xx);
}
function Bj(t, e, n) {
  const s = t.canvas, r = s && Zf(s);
  if (!r)
    return;
  const i = Cx((a, l) => {
    const c = r.clientWidth;
    n(a, l), c < r.clientWidth && n();
  }, window), o = new ResizeObserver((a) => {
    const l = a[0], c = l.contentRect.width, u = l.contentRect.height;
    c === 0 && u === 0 || i(c, u);
  });
  return o.observe(r), Nj(t, i), o;
}
function Xc(t, e, n) {
  n && n.disconnect(), e === "resize" && jj(t);
}
function Ij(t, e, n) {
  const s = t.canvas, r = Cx((i) => {
    t.ctx !== null && n(Dj(i, t));
  }, t);
  return kj(s, e, r), r;
}
class Fj extends Yx {
  acquireContext(e, n) {
    const s = e && e.getContext && e.getContext("2d");
    return s && s.canvas === e ? (Rj(e, n), s) : null;
  }
  releaseContext(e) {
    const n = e.canvas;
    if (!n[Ma])
      return !1;
    const s = n[Ma].initial;
    [
      "height",
      "width"
    ].forEach((i) => {
      const o = s[i];
      be(o) ? n.removeAttribute(i) : n.setAttribute(i, o);
    });
    const r = s.style || {};
    return Object.keys(r).forEach((i) => {
      n.style[i] = r[i];
    }), n.width = n.width, delete n[Ma], !0;
  }
  addEventListener(e, n, s) {
    this.removeEventListener(e, n);
    const r = e.$proxies || (e.$proxies = {}), o = {
      attach: Oj,
      detach: Lj,
      resize: Bj
    }[n] || Ij;
    r[n] = o(e, n, s);
  }
  removeEventListener(e, n) {
    const s = e.$proxies || (e.$proxies = {}), r = s[n];
    if (!r)
      return;
    ({
      attach: Xc,
      detach: Xc,
      resize: Xc
    }[n] || Mj)(e, n, r), s[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(e, n, s, r) {
    return kN(e, n, s, r);
  }
  isAttached(e) {
    const n = e && Zf(e);
    return !!(n && n.isConnected);
  }
}
function Vj(t) {
  return !Gf() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? Ej : Fj;
}
var fa;
let ts = (fa = class {
  constructor() {
    W(this, "x");
    W(this, "y");
    W(this, "active", !1);
    W(this, "options");
    W(this, "$animations");
  }
  tooltipPosition(e) {
    const { x: n, y: s } = this.getProps([
      "x",
      "y"
    ], e);
    return {
      x: n,
      y: s
    };
  }
  hasValue() {
    return Qr(this.x) && Qr(this.y);
  }
  getProps(e, n) {
    const s = this.$animations;
    if (!n || !s)
      return this;
    const r = {};
    return e.forEach((i) => {
      r[i] = s[i] && s[i].active() ? s[i]._to : this[i];
    }), r;
  }
}, W(fa, "defaults", {}), W(fa, "defaultRoutes"), fa);
function zj(t, e) {
  const n = t.options.ticks, s = Uj(t), r = Math.min(n.maxTicksLimit || s, s), i = n.major.enabled ? Hj(e) : [], o = i.length, a = i[0], l = i[o - 1], c = [];
  if (o > r)
    return Qj(e, c, i, o / r), c;
  const u = Wj(i, e, r);
  if (o > 0) {
    let d, f;
    const h = o > 1 ? Math.round((l - a) / (o - 1)) : null;
    for (ra(e, c, u, be(h) ? 0 : a - h, a), d = 0, f = o - 1; d < f; d++)
      ra(e, c, u, i[d], i[d + 1]);
    return ra(e, c, u, l, be(h) ? e.length : l + h), c;
  }
  return ra(e, c, u), c;
}
function Uj(t) {
  const e = t.options.offset, n = t._tickSize(), s = t._length / n + (e ? 0 : 1), r = t._maxLength / n;
  return Math.floor(Math.min(s, r));
}
function Wj(t, e, n) {
  const s = Yj(t), r = e.length / n;
  if (!s)
    return Math.max(r, 1);
  const i = LL(s);
  for (let o = 0, a = i.length - 1; o < a; o++) {
    const l = i[o];
    if (l > r)
      return l;
  }
  return Math.max(r, 1);
}
function Hj(t) {
  const e = [];
  let n, s;
  for (n = 0, s = t.length; n < s; n++)
    t[n].major && e.push(n);
  return e;
}
function Qj(t, e, n, s) {
  let r = 0, i = n[0], o;
  for (s = Math.ceil(s), o = 0; o < t.length; o++)
    o === i && (e.push(t[o]), r++, i = n[r * s]);
}
function ra(t, e, n, s, r) {
  const i = le(s, 0), o = Math.min(le(r, t.length), t.length);
  let a = 0, l, c, u;
  for (n = Math.ceil(n), r && (l = r - s, n = l / Math.floor(l / n)), u = i; u < 0; )
    a++, u = Math.round(i + a * n);
  for (c = Math.max(i, 0); c < o; c++)
    c === u && (e.push(t[c]), a++, u = Math.round(i + a * n));
}
function Yj(t) {
  const e = t.length;
  let n, s;
  if (e < 2)
    return !1;
  for (s = t[0], n = 1; n < e; ++n)
    if (t[n] - t[n - 1] !== s)
      return !1;
  return s;
}
const Kj = (t) => t === "left" ? "right" : t === "right" ? "left" : t, bm = (t, e, n) => e === "top" || e === "left" ? t[e] + n : t[e] - n, ym = (t, e) => Math.min(e || t, t);
function vm(t, e) {
  const n = [], s = t.length / e, r = t.length;
  let i = 0;
  for (; i < r; i += s)
    n.push(t[Math.floor(i)]);
  return n;
}
function Xj(t, e, n) {
  const s = t.ticks.length, r = Math.min(e, s - 1), i = t._startPixel, o = t._endPixel, a = 1e-6;
  let l = t.getPixelForTick(r), c;
  if (!(n && (s === 1 ? c = Math.max(l - i, o - l) : e === 0 ? c = (t.getPixelForTick(1) - l) / 2 : c = (l - t.getPixelForTick(r - 1)) / 2, l += r < e ? c : -c, l < i - a || l > o + a)))
    return l;
}
function Gj(t, e) {
  ke(t, (n) => {
    const s = n.gc, r = s.length / 2;
    let i;
    if (r > e) {
      for (i = 0; i < r; ++i)
        delete n.data[s[i]];
      s.splice(0, r);
    }
  });
}
function yi(t) {
  return t.drawTicks ? t.tickLength : 0;
}
function xm(t, e) {
  if (!t.display)
    return 0;
  const n = ct(t.font, e), s = qt(t.padding);
  return (We(t.text) ? t.text.length : 1) * n.lineHeight + s.height;
}
function Zj(t, e) {
  return Os(t, {
    scale: e,
    type: "scale"
  });
}
function _j(t, e, n) {
  return Os(t, {
    tick: n,
    index: e,
    type: "tick"
  });
}
function Jj(t, e, n) {
  let s = Wf(t);
  return (n && e !== "right" || !n && e === "right") && (s = Kj(s)), s;
}
function $j(t, e, n, s) {
  const { top: r, left: i, bottom: o, right: a, chart: l } = t, { chartArea: c, scales: u } = l;
  let d = 0, f, h, p;
  const g = o - r, A = a - i;
  if (t.isHorizontal()) {
    if (h = xt(s, i, a), he(n)) {
      const b = Object.keys(n)[0], y = n[b];
      p = u[b].getPixelForValue(y) + g - e;
    } else n === "center" ? p = (c.bottom + c.top) / 2 + g - e : p = bm(t, n, e);
    f = a - i;
  } else {
    if (he(n)) {
      const b = Object.keys(n)[0], y = n[b];
      h = u[b].getPixelForValue(y) - A + e;
    } else n === "center" ? h = (c.left + c.right) / 2 - A + e : h = bm(t, n, e);
    p = xt(s, o, r), d = n === "left" ? -et : et;
  }
  return {
    titleX: h,
    titleY: p,
    maxWidth: f,
    rotation: d
  };
}
class ur extends ts {
  constructor(e) {
    super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(e) {
    this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
  }
  parse(e, n) {
    return e;
  }
  getUserBounds() {
    let { _userMin: e, _userMax: n, _suggestedMin: s, _suggestedMax: r } = this;
    return e = Qt(e, Number.POSITIVE_INFINITY), n = Qt(n, Number.NEGATIVE_INFINITY), s = Qt(s, Number.POSITIVE_INFINITY), r = Qt(r, Number.NEGATIVE_INFINITY), {
      min: Qt(e, s),
      max: Qt(n, r),
      minDefined: Ge(e),
      maxDefined: Ge(n)
    };
  }
  getMinMax(e) {
    let { min: n, max: s, minDefined: r, maxDefined: i } = this.getUserBounds(), o;
    if (r && i)
      return {
        min: n,
        max: s
      };
    const a = this.getMatchingVisibleMetas();
    for (let l = 0, c = a.length; l < c; ++l)
      o = a[l].controller.getMinMax(this, e), r || (n = Math.min(n, o.min)), i || (s = Math.max(s, o.max));
    return n = i && n > s ? s : n, s = r && n > s ? n : s, {
      min: Qt(n, Qt(s, n)),
      max: Qt(s, Qt(n, s))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const e = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    Ne(this.options.beforeUpdate, [
      this
    ]);
  }
  update(e, n, s) {
    const { beginAtZero: r, grace: i, ticks: o } = this.options, a = o.sampleSize;
    this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = s = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = lN(this, i, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = a < this.ticks.length;
    this._convertTicksToLabels(l ? vm(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = zj(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let e = this.options.reverse, n, s;
    this.isHorizontal() ? (n = this.left, s = this.right) : (n = this.top, s = this.bottom, e = !e), this._startPixel = n, this._endPixel = s, this._reversePixels = e, this._length = s - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    Ne(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    Ne(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    Ne(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(e) {
    this.chart.notifyPlugins(e, this.getContext()), Ne(this.options[e], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    Ne(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(e) {
    const n = this.options.ticks;
    let s, r, i;
    for (s = 0, r = e.length; s < r; s++)
      i = e[s], i.label = Ne(n.callback, [
        i.value,
        s,
        e
      ], this);
  }
  afterTickToLabelConversion() {
    Ne(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    Ne(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const e = this.options, n = e.ticks, s = ym(this.ticks.length, e.ticks.maxTicksLimit), r = n.minRotation || 0, i = n.maxRotation;
    let o = r, a, l, c;
    if (!this._isVisible() || !n.display || r >= i || s <= 1 || !this.isHorizontal()) {
      this.labelRotation = r;
      return;
    }
    const u = this._getLabelSizes(), d = u.widest.width, f = u.highest.height, h = pt(this.chart.width - d, 0, this.maxWidth);
    a = e.offset ? this.maxWidth / s : h / (s - 1), d + 6 > a && (a = h / (s - (e.offset ? 0.5 : 1)), l = this.maxHeight - yi(e.grid) - n.padding - xm(e.title, this.chart.options.font), c = Math.sqrt(d * d + f * f), o = zf(Math.min(Math.asin(pt((u.highest.height + 6) / a, -1, 1)), Math.asin(pt(l / c, -1, 1)) - Math.asin(pt(f / c, -1, 1)))), o = Math.max(r, Math.min(i, o))), this.labelRotation = o;
  }
  afterCalculateLabelRotation() {
    Ne(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    Ne(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const e = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: s, title: r, grid: i } } = this, o = this._isVisible(), a = this.isHorizontal();
    if (o) {
      const l = xm(r, n.options.font);
      if (a ? (e.width = this.maxWidth, e.height = yi(i) + l) : (e.height = this.maxHeight, e.width = yi(i) + l), s.display && this.ticks.length) {
        const { first: c, last: u, widest: d, highest: f } = this._getLabelSizes(), h = s.padding * 2, p = un(this.labelRotation), g = Math.cos(p), A = Math.sin(p);
        if (a) {
          const b = s.mirror ? 0 : A * d.width + g * f.height;
          e.height = Math.min(this.maxHeight, e.height + b + h);
        } else {
          const b = s.mirror ? 0 : g * d.width + A * f.height;
          e.width = Math.min(this.maxWidth, e.width + b + h);
        }
        this._calculatePadding(c, u, A, g);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(e, n, s, r) {
    const { ticks: { align: i, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let f = 0, h = 0;
      l ? c ? (f = r * e.width, h = s * n.height) : (f = s * e.height, h = r * n.width) : i === "start" ? h = n.width : i === "end" ? f = e.width : i !== "inner" && (f = e.width / 2, h = n.width / 2), this.paddingLeft = Math.max((f - u + o) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h - d + o) * this.width / (this.width - d), 0);
    } else {
      let u = n.height / 2, d = e.height / 2;
      i === "start" ? (u = 0, d = e.height) : i === "end" && (u = n.height, d = 0), this.paddingTop = u + o, this.paddingBottom = d + o;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    Ne(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: e, position: n } = this.options;
    return n === "top" || n === "bottom" || e === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(e) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(e);
    let n, s;
    for (n = 0, s = e.length; n < s; n++)
      be(e[n].label) && (e.splice(n, 1), s--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let e = this._labelSizes;
    if (!e) {
      const n = this.options.ticks.sampleSize;
      let s = this.ticks;
      n < s.length && (s = vm(s, n)), this._labelSizes = e = this._computeLabelSizes(s, s.length, this.options.ticks.maxTicksLimit);
    }
    return e;
  }
  _computeLabelSizes(e, n, s) {
    const { ctx: r, _longestTextCache: i } = this, o = [], a = [], l = Math.floor(n / ym(n, s));
    let c = 0, u = 0, d, f, h, p, g, A, b, y, w, x, S;
    for (d = 0; d < n; d += l) {
      if (p = e[d].label, g = this._resolveTickFontOptions(d), r.font = A = g.string, b = i[A] = i[A] || {
        data: {},
        gc: []
      }, y = g.lineHeight, w = x = 0, !be(p) && !We(p))
        w = gl(r, b.data, b.gc, w, p), x = y;
      else if (We(p))
        for (f = 0, h = p.length; f < h; ++f)
          S = p[f], !be(S) && !We(S) && (w = gl(r, b.data, b.gc, w, S), x += y);
      o.push(w), a.push(x), c = Math.max(w, c), u = Math.max(x, u);
    }
    Gj(i, n);
    const q = o.indexOf(c), C = a.indexOf(u), E = (T) => ({
      width: o[T] || 0,
      height: a[T] || 0
    });
    return {
      first: E(0),
      last: E(n - 1),
      widest: E(q),
      highest: E(C),
      widths: o,
      heights: a
    };
  }
  getLabelForValue(e) {
    return e;
  }
  getPixelForValue(e, n) {
    return NaN;
  }
  getValueForPixel(e) {
  }
  getPixelForTick(e) {
    const n = this.ticks;
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value);
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e);
    const n = this._startPixel + e * this._length;
    return BL(this._alignToPixels ? Fs(this.chart, n, 0) : n);
  }
  getDecimalForPixel(e) {
    const n = (e - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: e, max: n } = this;
    return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0;
  }
  getContext(e) {
    const n = this.ticks || [];
    if (e >= 0 && e < n.length) {
      const s = n[e];
      return s.$context || (s.$context = _j(this.getContext(), e, s));
    }
    return this.$context || (this.$context = Zj(this.chart.getContext(), this));
  }
  _tickSize() {
    const e = this.options.ticks, n = un(this.labelRotation), s = Math.abs(Math.cos(n)), r = Math.abs(Math.sin(n)), i = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = i ? i.widest.width + o : 0, l = i ? i.highest.height + o : 0;
    return this.isHorizontal() ? l * s > a * r ? a / s : l / r : l * r < a * s ? l / s : a / r;
  }
  _isVisible() {
    const e = this.options.display;
    return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(e) {
    const n = this.axis, s = this.chart, r = this.options, { grid: i, position: o, border: a } = r, l = i.offset, c = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), f = yi(i), h = [], p = a.setContext(this.getContext()), g = p.display ? p.width : 0, A = g / 2, b = function(L) {
      return Fs(s, L, g);
    };
    let y, w, x, S, q, C, E, T, k, R, D, F;
    if (o === "top")
      y = b(this.bottom), C = this.bottom - f, T = y - A, R = b(e.top) + A, F = e.bottom;
    else if (o === "bottom")
      y = b(this.top), R = e.top, F = b(e.bottom) - A, C = y + A, T = this.top + f;
    else if (o === "left")
      y = b(this.right), q = this.right - f, E = y - A, k = b(e.left) + A, D = e.right;
    else if (o === "right")
      y = b(this.left), k = e.left, D = b(e.right) - A, q = y + A, E = this.left + f;
    else if (n === "x") {
      if (o === "center")
        y = b((e.top + e.bottom) / 2 + 0.5);
      else if (he(o)) {
        const L = Object.keys(o)[0], O = o[L];
        y = b(this.chart.scales[L].getPixelForValue(O));
      }
      R = e.top, F = e.bottom, C = y + A, T = C + f;
    } else if (n === "y") {
      if (o === "center")
        y = b((e.left + e.right) / 2);
      else if (he(o)) {
        const L = Object.keys(o)[0], O = o[L];
        y = b(this.chart.scales[L].getPixelForValue(O));
      }
      q = y - A, E = q - f, k = e.left, D = e.right;
    }
    const j = le(r.ticks.maxTicksLimit, d), B = Math.max(1, Math.ceil(d / j));
    for (w = 0; w < d; w += B) {
      const L = this.getContext(w), O = i.setContext(L), N = a.setContext(L), H = O.lineWidth, U = O.color, X = N.dash || [], G = N.dashOffset, pe = O.tickWidth, Me = O.tickColor, Ee = O.tickBorderDash || [], oe = O.tickBorderDashOffset;
      x = Xj(this, w, l), x !== void 0 && (S = Fs(s, x, H), c ? q = E = k = D = S : C = T = R = F = S, h.push({
        tx1: q,
        ty1: C,
        tx2: E,
        ty2: T,
        x1: k,
        y1: R,
        x2: D,
        y2: F,
        width: H,
        color: U,
        borderDash: X,
        borderDashOffset: G,
        tickWidth: pe,
        tickColor: Me,
        tickBorderDash: Ee,
        tickBorderDashOffset: oe
      }));
    }
    return this._ticksLength = d, this._borderValue = y, h;
  }
  _computeLabelItems(e) {
    const n = this.axis, s = this.options, { position: r, ticks: i } = s, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: d } = i, f = yi(s.grid), h = f + u, p = d ? -u : h, g = -un(this.labelRotation), A = [];
    let b, y, w, x, S, q, C, E, T, k, R, D, F = "middle";
    if (r === "top")
      q = this.bottom - p, C = this._getXAxisLabelAlignment();
    else if (r === "bottom")
      q = this.top + p, C = this._getXAxisLabelAlignment();
    else if (r === "left") {
      const B = this._getYAxisLabelAlignment(f);
      C = B.textAlign, S = B.x;
    } else if (r === "right") {
      const B = this._getYAxisLabelAlignment(f);
      C = B.textAlign, S = B.x;
    } else if (n === "x") {
      if (r === "center")
        q = (e.top + e.bottom) / 2 + h;
      else if (he(r)) {
        const B = Object.keys(r)[0], L = r[B];
        q = this.chart.scales[B].getPixelForValue(L) + h;
      }
      C = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (r === "center")
        S = (e.left + e.right) / 2 - h;
      else if (he(r)) {
        const B = Object.keys(r)[0], L = r[B];
        S = this.chart.scales[B].getPixelForValue(L);
      }
      C = this._getYAxisLabelAlignment(f).textAlign;
    }
    n === "y" && (l === "start" ? F = "top" : l === "end" && (F = "bottom"));
    const j = this._getLabelSizes();
    for (b = 0, y = a.length; b < y; ++b) {
      w = a[b], x = w.label;
      const B = i.setContext(this.getContext(b));
      E = this.getPixelForTick(b) + i.labelOffset, T = this._resolveTickFontOptions(b), k = T.lineHeight, R = We(x) ? x.length : 1;
      const L = R / 2, O = B.color, N = B.textStrokeColor, H = B.textStrokeWidth;
      let U = C;
      o ? (S = E, C === "inner" && (b === y - 1 ? U = this.options.reverse ? "left" : "right" : b === 0 ? U = this.options.reverse ? "right" : "left" : U = "center"), r === "top" ? c === "near" || g !== 0 ? D = -R * k + k / 2 : c === "center" ? D = -j.highest.height / 2 - L * k + k : D = -j.highest.height + k / 2 : c === "near" || g !== 0 ? D = k / 2 : c === "center" ? D = j.highest.height / 2 - L * k : D = j.highest.height - R * k, d && (D *= -1), g !== 0 && !B.showLabelBackdrop && (S += k / 2 * Math.sin(g))) : (q = E, D = (1 - R) * k / 2);
      let X;
      if (B.showLabelBackdrop) {
        const G = qt(B.backdropPadding), pe = j.heights[b], Me = j.widths[b];
        let Ee = D - G.top, oe = 0 - G.left;
        switch (F) {
          case "middle":
            Ee -= pe / 2;
            break;
          case "bottom":
            Ee -= pe;
            break;
        }
        switch (C) {
          case "center":
            oe -= Me / 2;
            break;
          case "right":
            oe -= Me;
            break;
          case "inner":
            b === y - 1 ? oe -= Me : b > 0 && (oe -= Me / 2);
            break;
        }
        X = {
          left: oe,
          top: Ee,
          width: Me + G.width,
          height: pe + G.height,
          color: B.backdropColor
        };
      }
      A.push({
        label: x,
        font: T,
        textOffset: D,
        options: {
          rotation: g,
          color: O,
          strokeColor: N,
          strokeWidth: H,
          textAlign: U,
          textBaseline: F,
          translation: [
            S,
            q
          ],
          backdrop: X
        }
      });
    }
    return A;
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: n } = this.options;
    if (-un(this.labelRotation))
      return e === "top" ? "left" : "right";
    let r = "center";
    return n.align === "start" ? r = "left" : n.align === "end" ? r = "right" : n.align === "inner" && (r = "inner"), r;
  }
  _getYAxisLabelAlignment(e) {
    const { position: n, ticks: { crossAlign: s, mirror: r, padding: i } } = this.options, o = this._getLabelSizes(), a = e + i, l = o.widest.width;
    let c, u;
    return n === "left" ? r ? (u = this.right + i, s === "near" ? c = "left" : s === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, s === "near" ? c = "right" : s === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : n === "right" ? r ? (u = this.left + i, s === "near" ? c = "right" : s === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, s === "near" ? c = "left" : s === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
      textAlign: c,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const e = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      };
  }
  drawBackground() {
    const { ctx: e, options: { backgroundColor: n }, left: s, top: r, width: i, height: o } = this;
    n && (e.save(), e.fillStyle = n, e.fillRect(s, r, i, o), e.restore());
  }
  getLineWidthForValue(e) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const r = this.ticks.findIndex((i) => i.value === e);
    return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0;
  }
  drawGrid(e) {
    const n = this.options.grid, s = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
    let i, o;
    const a = (l, c, u) => {
      !u.width || !u.color || (s.save(), s.lineWidth = u.width, s.strokeStyle = u.color, s.setLineDash(u.borderDash || []), s.lineDashOffset = u.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());
    };
    if (n.display)
      for (i = 0, o = r.length; i < o; ++i) {
        const l = r[i];
        n.drawOnChartArea && a({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), n.drawTicks && a({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: e, ctx: n, options: { border: s, grid: r } } = this, i = s.setContext(this.getContext()), o = s.display ? i.width : 0;
    if (!o)
      return;
    const a = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, u, d, f;
    this.isHorizontal() ? (c = Fs(e, this.left, o) - o / 2, u = Fs(e, this.right, a) + a / 2, d = f = l) : (d = Fs(e, this.top, o) - o / 2, f = Fs(e, this.bottom, a) + a / 2, c = u = l), n.save(), n.lineWidth = i.width, n.strokeStyle = i.color, n.beginPath(), n.moveTo(c, d), n.lineTo(u, f), n.stroke(), n.restore();
  }
  drawLabels(e) {
    if (!this.options.ticks.display)
      return;
    const s = this.ctx, r = this._computeLabelArea();
    r && Gl(s, r);
    const i = this.getLabelItems(e);
    for (const o of i) {
      const a = o.options, l = o.font, c = o.label, u = o.textOffset;
      ar(s, c, 0, u, l, a);
    }
    r && Zl(s);
  }
  drawTitle() {
    const { ctx: e, options: { position: n, title: s, reverse: r } } = this;
    if (!s.display)
      return;
    const i = ct(s.font), o = qt(s.padding), a = s.align;
    let l = i.lineHeight / 2;
    n === "bottom" || n === "center" || he(n) ? (l += o.bottom, We(s.text) && (l += i.lineHeight * (s.text.length - 1))) : l += o.top;
    const { titleX: c, titleY: u, maxWidth: d, rotation: f } = $j(this, l, n, a);
    ar(e, s.text, 0, 0, i, {
      color: s.color,
      maxWidth: d,
      rotation: f,
      textAlign: Jj(a, n, r),
      textBaseline: "middle",
      translation: [
        c,
        u
      ]
    });
  }
  draw(e) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
  }
  _layers() {
    const e = this.options, n = e.ticks && e.ticks.z || 0, s = le(e.grid && e.grid.z, -1), r = le(e.border && e.border.z, 0);
    return !this._isVisible() || this.draw !== ur.prototype.draw ? [
      {
        z: n,
        draw: (i) => {
          this.draw(i);
        }
      }
    ] : [
      {
        z: s,
        draw: (i) => {
          this.drawBackground(), this.drawGrid(i), this.drawTitle();
        }
      },
      {
        z: r,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (i) => {
          this.drawLabels(i);
        }
      }
    ];
  }
  getMatchingVisibleMetas(e) {
    const n = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + "AxisID", r = [];
    let i, o;
    for (i = 0, o = n.length; i < o; ++i) {
      const a = n[i];
      a[s] === this.id && (!e || a.type === e) && r.push(a);
    }
    return r;
  }
  _resolveTickFontOptions(e) {
    const n = this.options.ticks.setContext(this.getContext(e));
    return ct(n.font);
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / e;
  }
}
class ia {
  constructor(e, n, s) {
    this.type = e, this.scope = n, this.override = s, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
  }
  register(e) {
    const n = Object.getPrototypeOf(e);
    let s;
    nB(n) && (s = this.register(n));
    const r = this.items, i = e.id, o = this.scope + "." + i;
    if (!i)
      throw new Error("class does not have id: " + e);
    return i in r || (r[i] = e, eB(e, o, s), this.override && Ze.override(e.id, e.overrides)), o;
  }
  get(e) {
    return this.items[e];
  }
  unregister(e) {
    const n = this.items, s = e.id, r = this.scope;
    s in n && delete n[s], r && s in Ze[r] && (delete Ze[r][s], this.override && delete or[s]);
  }
}
function eB(t, e, n) {
  const s = fo(/* @__PURE__ */ Object.create(null), [
    n ? Ze.get(n) : {},
    Ze.get(e),
    t.defaults
  ]);
  Ze.set(e, s), t.defaultRoutes && tB(e, t.defaultRoutes), t.descriptors && Ze.describe(e, t.descriptors);
}
function tB(t, e) {
  Object.keys(e).forEach((n) => {
    const s = n.split("."), r = s.pop(), i = [
      t
    ].concat(s).join("."), o = e[n].split("."), a = o.pop(), l = o.join(".");
    Ze.route(i, r, l, a);
  });
}
function nB(t) {
  return "id" in t && "defaults" in t;
}
class sB {
  constructor() {
    this.controllers = new ia(fn, "datasets", !0), this.elements = new ia(ts, "elements"), this.plugins = new ia(Object, "plugins"), this.scales = new ia(ur, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...e) {
    this._each("register", e);
  }
  remove(...e) {
    this._each("unregister", e);
  }
  addControllers(...e) {
    this._each("register", e, this.controllers);
  }
  addElements(...e) {
    this._each("register", e, this.elements);
  }
  addPlugins(...e) {
    this._each("register", e, this.plugins);
  }
  addScales(...e) {
    this._each("register", e, this.scales);
  }
  getController(e) {
    return this._get(e, this.controllers, "controller");
  }
  getElement(e) {
    return this._get(e, this.elements, "element");
  }
  getPlugin(e) {
    return this._get(e, this.plugins, "plugin");
  }
  getScale(e) {
    return this._get(e, this.scales, "scale");
  }
  removeControllers(...e) {
    this._each("unregister", e, this.controllers);
  }
  removeElements(...e) {
    this._each("unregister", e, this.elements);
  }
  removePlugins(...e) {
    this._each("unregister", e, this.plugins);
  }
  removeScales(...e) {
    this._each("unregister", e, this.scales);
  }
  _each(e, n, s) {
    [
      ...n
    ].forEach((r) => {
      const i = s || this._getRegistryForType(r);
      s || i.isForType(r) || i === this.plugins && r.id ? this._exec(e, i, r) : ke(r, (o) => {
        const a = s || this._getRegistryForType(o);
        this._exec(e, a, o);
      });
    });
  }
  _exec(e, n, s) {
    const r = Vf(e);
    Ne(s["before" + r], [], s), n[e](s), Ne(s["after" + r], [], s);
  }
  _getRegistryForType(e) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const s = this._typedRegistries[n];
      if (s.isForType(e))
        return s;
    }
    return this.plugins;
  }
  _get(e, n, s) {
    const r = n.get(e);
    if (r === void 0)
      throw new Error('"' + e + '" is not a registered ' + s + ".");
    return r;
  }
}
var yn = /* @__PURE__ */ new sB();
class rB {
  constructor() {
    this._init = [];
  }
  notify(e, n, s, r) {
    n === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install"));
    const i = r ? this._descriptors(e).filter(r) : this._descriptors(e), o = this._notify(i, e, n, s);
    return n === "afterDestroy" && (this._notify(i, e, "stop"), this._notify(this._init, e, "uninstall")), o;
  }
  _notify(e, n, s, r) {
    r = r || {};
    for (const i of e) {
      const o = i.plugin, a = o[s], l = [
        n,
        r,
        i.options
      ];
      if (Ne(a, l, o) === !1 && r.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    be(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(e) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(e);
    return this._notifyStateChanges(e), n;
  }
  _createDescriptors(e, n) {
    const s = e && e.config, r = le(s.options && s.options.plugins, {}), i = iB(s);
    return r === !1 && !n ? [] : aB(e, i, r, n);
  }
  _notifyStateChanges(e) {
    const n = this._oldCache || [], s = this._cache, r = (i, o) => i.filter((a) => !o.some((l) => a.plugin.id === l.plugin.id));
    this._notify(r(n, s), e, "stop"), this._notify(r(s, n), e, "start");
  }
}
function iB(t) {
  const e = {}, n = [], s = Object.keys(yn.plugins.items);
  for (let i = 0; i < s.length; i++)
    n.push(yn.getPlugin(s[i]));
  const r = t.plugins || [];
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    n.indexOf(o) === -1 && (n.push(o), e[o.id] = !0);
  }
  return {
    plugins: n,
    localIds: e
  };
}
function oB(t, e) {
  return !e && t === !1 ? null : t === !0 ? {} : t;
}
function aB(t, { plugins: e, localIds: n }, s, r) {
  const i = [], o = t.getContext();
  for (const a of e) {
    const l = a.id, c = oB(s[l], r);
    c !== null && i.push({
      plugin: a,
      options: lB(t.config, {
        plugin: a,
        local: n[l]
      }, c, o)
    });
  }
  return i;
}
function lB(t, { plugin: e, local: n }, s, r) {
  const i = t.pluginScopeKeys(e), o = t.getOptionScopes(s, i);
  return n && e.defaults && o.push(e.defaults), t.createResolver(o, r, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Qu(t, e) {
  const n = Ze.datasets[t] || {};
  return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x";
}
function cB(t, e) {
  let n = t;
  return t === "_index_" ? n = e : t === "_value_" && (n = e === "x" ? "y" : "x"), n;
}
function uB(t, e) {
  return t === e ? "_index_" : "_value_";
}
function wm(t) {
  if (t === "x" || t === "y" || t === "r")
    return t;
}
function dB(t) {
  if (t === "top" || t === "bottom")
    return "x";
  if (t === "left" || t === "right")
    return "y";
}
function Yu(t, ...e) {
  if (wm(t))
    return t;
  for (const n of e) {
    const s = n.axis || dB(n.position) || t.length > 1 && wm(t[0].toLowerCase());
    if (s)
      return s;
  }
  throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);
}
function Sm(t, e, n) {
  if (n[e + "AxisID"] === t)
    return {
      axis: e
    };
}
function fB(t, e) {
  if (e.data && e.data.datasets) {
    const n = e.data.datasets.filter((s) => s.xAxisID === t || s.yAxisID === t);
    if (n.length)
      return Sm(t, "x", n[0]) || Sm(t, "y", n[0]);
  }
  return {};
}
function hB(t, e) {
  const n = or[t.type] || {
    scales: {}
  }, s = e.scales || {}, r = Qu(t.type, e), i = /* @__PURE__ */ Object.create(null);
  return Object.keys(s).forEach((o) => {
    const a = s[o];
    if (!he(a))
      return console.error(`Invalid scale configuration for scale: ${o}`);
    if (a._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
    const l = Yu(o, a, fB(o, t), Ze.scales[a.type]), c = uB(l, r), u = n.scales || {};
    i[o] = Ni(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      a,
      u[l],
      u[c]
    ]);
  }), t.data.datasets.forEach((o) => {
    const a = o.type || t.type, l = o.indexAxis || Qu(a, e), u = (or[a] || {}).scales || {};
    Object.keys(u).forEach((d) => {
      const f = cB(d, l), h = o[f + "AxisID"] || f;
      i[h] = i[h] || /* @__PURE__ */ Object.create(null), Ni(i[h], [
        {
          axis: f
        },
        s[h],
        u[d]
      ]);
    });
  }), Object.keys(i).forEach((o) => {
    const a = i[o];
    Ni(a, [
      Ze.scales[a.type],
      Ze.scale
    ]);
  }), i;
}
function Gx(t) {
  const e = t.options || (t.options = {});
  e.plugins = le(e.plugins, {}), e.scales = hB(t, e);
}
function Zx(t) {
  return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t;
}
function pB(t) {
  return t = t || {}, t.data = Zx(t.data), Gx(t), t;
}
const Cm = /* @__PURE__ */ new Map(), _x = /* @__PURE__ */ new Set();
function oa(t, e) {
  let n = Cm.get(t);
  return n || (n = e(), Cm.set(t, n), _x.add(n)), n;
}
const vi = (t, e, n) => {
  const s = Ts(e, n);
  s !== void 0 && t.add(s);
};
class gB {
  constructor(e) {
    this._config = pB(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(e) {
    this._config.type = e;
  }
  get data() {
    return this._config.data;
  }
  set data(e) {
    this._config.data = Zx(e);
  }
  get options() {
    return this._config.options;
  }
  set options(e) {
    this._config.options = e;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const e = this._config;
    this.clearCache(), Gx(e);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(e) {
    return oa(e, () => [
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(e, n) {
    return oa(`${e}.transition.${n}`, () => [
      [
        `datasets.${e}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(e, n) {
    return oa(`${e}-${n}`, () => [
      [
        `datasets.${e}.elements.${n}`,
        `datasets.${e}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(e) {
    const n = e.id, s = this.type;
    return oa(`${s}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...e.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(e, n) {
    const s = this._scopeCache;
    let r = s.get(e);
    return (!r || n) && (r = /* @__PURE__ */ new Map(), s.set(e, r)), r;
  }
  getOptionScopes(e, n, s) {
    const { options: r, type: i } = this, o = this._cachedScopes(e, s), a = o.get(n);
    if (a)
      return a;
    const l = /* @__PURE__ */ new Set();
    n.forEach((u) => {
      e && (l.add(e), u.forEach((d) => vi(l, e, d))), u.forEach((d) => vi(l, r, d)), u.forEach((d) => vi(l, or[i] || {}, d)), u.forEach((d) => vi(l, Ze, d)), u.forEach((d) => vi(l, Uu, d));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), _x.has(n) && o.set(n, c), c;
  }
  chartOptionScopes() {
    const { options: e, type: n } = this;
    return [
      e,
      or[n] || {},
      Ze.datasets[n] || {},
      {
        type: n
      },
      Ze,
      Uu
    ];
  }
  resolveNamedOptions(e, n, s, r = [
    ""
  ]) {
    const i = {
      $shared: !0
    }, { resolver: o, subPrefixes: a } = Pm(this._resolverCache, e, r);
    let l = o;
    if (AB(o, n)) {
      i.$shared = !1, s = Rs(s) ? s() : s;
      const c = this.createResolver(e, s, a);
      l = Yr(o, s, c);
    }
    for (const c of n)
      i[c] = l[c];
    return i;
  }
  createResolver(e, n, s = [
    ""
  ], r) {
    const { resolver: i } = Pm(this._resolverCache, e, s);
    return he(n) ? Yr(i, n, void 0, r) : i;
  }
}
function Pm(t, e, n) {
  let s = t.get(e);
  s || (s = /* @__PURE__ */ new Map(), t.set(e, s));
  const r = n.join();
  let i = s.get(r);
  return i || (i = {
    resolver: Yf(e, n),
    subPrefixes: n.filter((a) => !a.toLowerCase().includes("hover"))
  }, s.set(r, i)), i;
}
const mB = (t) => he(t) && Object.getOwnPropertyNames(t).some((e) => Rs(t[e]));
function AB(t, e) {
  const { isScriptable: n, isIndexable: s } = kx(t);
  for (const r of e) {
    const i = n(r), o = s(r), a = (o || i) && t[r];
    if (i && (Rs(a) || mB(a)) || o && We(a))
      return !0;
  }
  return !1;
}
var bB = "4.4.4";
const yB = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function qm(t, e) {
  return t === "top" || t === "bottom" || yB.indexOf(t) === -1 && e === "x";
}
function Em(t, e) {
  return function(n, s) {
    return n[t] === s[t] ? n[e] - s[e] : n[t] - s[t];
  };
}
function Tm(t) {
  const e = t.chart, n = e.options.animation;
  e.notifyPlugins("afterRender"), Ne(n && n.onComplete, [
    t
  ], e);
}
function vB(t) {
  const e = t.chart, n = e.options.animation;
  Ne(n && n.onProgress, [
    t
  ], e);
}
function Jx(t) {
  return Gf() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;
}
const Da = {}, Rm = (t) => {
  const e = Jx(t);
  return Object.values(Da).filter((n) => n.canvas === e).pop();
};
function xB(t, e, n) {
  const s = Object.keys(t);
  for (const r of s) {
    const i = +r;
    if (i >= e) {
      const o = t[r];
      delete t[r], (n > 0 || i > e) && (t[i + n] = o);
    }
  }
}
function wB(t, e, n, s) {
  return !n || t.type === "mouseout" ? null : s ? e : t;
}
function aa(t, e, n) {
  return t.options.clip ? t[n] : e[n];
}
function SB(t, e) {
  const { xScale: n, yScale: s } = t;
  return n && s ? {
    left: aa(n, e, "left"),
    right: aa(n, e, "right"),
    top: aa(s, e, "top"),
    bottom: aa(s, e, "bottom")
  } : e;
}
class Un {
  static register(...e) {
    yn.add(...e), km();
  }
  static unregister(...e) {
    yn.remove(...e), km();
  }
  constructor(e, n) {
    const s = this.config = new gB(n), r = Jx(e), i = Rm(r);
    if (i)
      throw new Error("Canvas is already in use. Chart with ID '" + i.id + "' must be destroyed before the canvas with ID '" + i.canvas.id + "' can be reused.");
    const o = s.createResolver(s.chartOptionScopes(), this.getContext());
    this.platform = new (s.platform || Vj(r))(), this.platform.updateConfig(s);
    const a = this.platform.acquireContext(r, o.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width;
    if (this.id = PL(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new rB(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = zL((d) => this.update(d), o.resizeDelay || 0), this._dataChanges = [], Da[this.id] = this, !a || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Fn.listen(this, "complete", Tm), Fn.listen(this, "progress", vB), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: e, maintainAspectRatio: n }, width: s, height: r, _aspectRatio: i } = this;
    return be(e) ? n && i ? i : r ? s / r : null : e;
  }
  get data() {
    return this.config.data;
  }
  set data(e) {
    this.config.data = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this.config.options = e;
  }
  get registry() {
    return yn;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : _g(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return Xg(this.canvas, this.ctx), this;
  }
  stop() {
    return Fn.stop(this), this;
  }
  resize(e, n) {
    Fn.running(this) ? this._resizeBeforeDraw = {
      width: e,
      height: n
    } : this._resize(e, n);
  }
  _resize(e, n) {
    const s = this.options, r = this.canvas, i = s.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, e, n, i), a = s.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, _g(this, a, !0) && (this.notifyPlugins("resize", {
      size: o
    }), Ne(s.onResize, [
      this,
      o
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    ke(n, (s, r) => {
      s.id = r;
    });
  }
  buildOrUpdateScales() {
    const e = this.options, n = e.scales, s = this.scales, r = Object.keys(s).reduce((o, a) => (o[a] = !1, o), {});
    let i = [];
    n && (i = i.concat(Object.keys(n).map((o) => {
      const a = n[o], l = Yu(o, a), c = l === "r", u = l === "x";
      return {
        options: a,
        dposition: c ? "chartArea" : u ? "bottom" : "left",
        dtype: c ? "radialLinear" : u ? "category" : "linear"
      };
    }))), ke(i, (o) => {
      const a = o.options, l = a.id, c = Yu(l, a), u = le(a.type, o.dtype);
      (a.position === void 0 || qm(a.position, c) !== qm(o.dposition)) && (a.position = o.dposition), r[l] = !0;
      let d = null;
      if (l in s && s[l].type === u)
        d = s[l];
      else {
        const f = yn.getScale(u);
        d = new f({
          id: l,
          type: u,
          ctx: this.ctx,
          chart: this
        }), s[d.id] = d;
      }
      d.init(a, e);
    }), ke(r, (o, a) => {
      o || delete s[a];
    }), ke(s, (o) => {
      Ct.configure(this, o, o.options), Ct.addBox(this, o);
    });
  }
  _updateMetasets() {
    const e = this._metasets, n = this.data.datasets.length, s = e.length;
    if (e.sort((r, i) => r.index - i.index), s > n) {
      for (let r = n; r < s; ++r)
        this._destroyDatasetMeta(r);
      e.splice(n, s - n);
    }
    this._sortedMetasets = e.slice(0).sort(Em("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: e, data: { datasets: n } } = this;
    e.length > n.length && delete this._stacks, e.forEach((s, r) => {
      n.filter((i) => i === s._dataset).length === 0 && this._destroyDatasetMeta(r);
    });
  }
  buildOrUpdateControllers() {
    const e = [], n = this.data.datasets;
    let s, r;
    for (this._removeUnreferencedMetasets(), s = 0, r = n.length; s < r; s++) {
      const i = n[s];
      let o = this.getDatasetMeta(s);
      const a = i.type || this.config.type;
      if (o.type && o.type !== a && (this._destroyDatasetMeta(s), o = this.getDatasetMeta(s)), o.type = a, o.indexAxis = i.indexAxis || Qu(a, this.options), o.order = i.order || 0, o.index = s, o.label = "" + i.label, o.visible = this.isDatasetVisible(s), o.controller)
        o.controller.updateIndex(s), o.controller.linkScales();
      else {
        const l = yn.getController(a), { datasetElementType: c, dataElementType: u } = Ze.datasets[a];
        Object.assign(l, {
          dataElementType: yn.getElement(u),
          datasetElementType: c && yn.getElement(c)
        }), o.controller = new l(this, s), e.push(o.controller);
      }
    }
    return this._updateMetasets(), e;
  }
  _resetElements() {
    ke(this.data.datasets, (e, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(e) {
    const n = this.config;
    n.update();
    const s = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !s.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: e,
      cancelable: !0
    }) === !1)
      return;
    const i = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let o = 0;
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: d } = this.getDatasetMeta(c), f = !r && i.indexOf(d) === -1;
      d.buildOrUpdateElements(f), o = Math.max(+d.getMaxOverflow(), o);
    }
    o = this._minPadding = s.layout.autoPadding ? o : 0, this._updateLayout(o), r || ke(i, (c) => {
      c.reset();
    }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
      mode: e
    }), this._layers.sort(Em("z", "_idx"));
    const { _active: a, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();
  }
  _updateScales() {
    ke(this.scales, (e) => {
      Ct.removeBox(this, e);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const e = this.options, n = new Set(Object.keys(this._listeners)), s = new Set(e.events);
    (!Fg(n, s) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || [];
    for (const { method: s, start: r, count: i } of n) {
      const o = s === "_removeElements" ? -i : i;
      xB(e, r, o);
    }
  }
  _getUniformDataChanges() {
    const e = this._dataChanges;
    if (!e || !e.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, s = (i) => new Set(e.filter((o) => o[0] === i).map((o, a) => a + "," + o.splice(1).join(","))), r = s(0);
    for (let i = 1; i < n; i++)
      if (!Fg(r, s(i)))
        return;
    return Array.from(r).map((i) => i.split(",")).map((i) => ({
      method: i[1],
      start: +i[2],
      count: +i[3]
    }));
  }
  _updateLayout(e) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Ct.update(this, this.width, this.height, e);
    const n = this.chartArea, s = n.width <= 0 || n.height <= 0;
    this._layers = [], ke(this.boxes, (r) => {
      s && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers()));
    }, this), this._layers.forEach((r, i) => {
      r._idx = i;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(e) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: e,
      cancelable: !0
    }) !== !1) {
      for (let n = 0, s = this.data.datasets.length; n < s; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, s = this.data.datasets.length; n < s; ++n)
        this._updateDataset(n, Rs(e) ? e({
          datasetIndex: n
        }) : e);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: e
      });
    }
  }
  _updateDataset(e, n) {
    const s = this.getDatasetMeta(e), r = {
      meta: s,
      index: e,
      mode: n,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (s.controller._update(n), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Fn.has(this) ? this.attached && !Fn.running(this) && Fn.start(this) : (this.draw(), Tm({
      chart: this
    })));
  }
  draw() {
    let e;
    if (this._resizeBeforeDraw) {
      const { width: s, height: r } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(s, r);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const n = this._layers;
    for (e = 0; e < n.length && n[e].z <= 0; ++e)
      n[e].draw(this.chartArea);
    for (this._drawDatasets(); e < n.length; ++e)
      n[e].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(e) {
    const n = this._sortedMetasets, s = [];
    let r, i;
    for (r = 0, i = n.length; r < i; ++r) {
      const o = n[r];
      (!e || o.visible) && s.push(o);
    }
    return s;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const e = this.getSortedVisibleDatasetMetas();
    for (let n = e.length - 1; n >= 0; --n)
      this._drawDataset(e[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(e) {
    const n = this.ctx, s = e._clip, r = !s.disabled, i = SB(e, this.chartArea), o = {
      meta: e,
      index: e.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (r && Gl(n, {
      left: s.left === !1 ? 0 : i.left - s.left,
      right: s.right === !1 ? this.width : i.right + s.right,
      top: s.top === !1 ? 0 : i.top - s.top,
      bottom: s.bottom === !1 ? this.height : i.bottom + s.bottom
    }), e.controller.draw(), r && Zl(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o));
  }
  isPointInArea(e) {
    return Yn(e, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, n, s, r) {
    const i = yj.modes[n];
    return typeof i == "function" ? i(this, e, s, r) : [];
  }
  getDatasetMeta(e) {
    const n = this.data.datasets[e], s = this._metasets;
    let r = s.filter((i) => i && i._dataset === n).pop();
    return r || (r = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: e,
      _dataset: n,
      _parsed: [],
      _sorted: !1
    }, s.push(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = Os(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(e) {
    const n = this.data.datasets[e];
    if (!n)
      return !1;
    const s = this.getDatasetMeta(e);
    return typeof s.hidden == "boolean" ? !s.hidden : !n.hidden;
  }
  setDatasetVisibility(e, n) {
    const s = this.getDatasetMeta(e);
    s.hidden = !n;
  }
  toggleDataVisibility(e) {
    this._hiddenIndices[e] = !this._hiddenIndices[e];
  }
  getDataVisibility(e) {
    return !this._hiddenIndices[e];
  }
  _updateVisibility(e, n, s) {
    const r = s ? "show" : "hide", i = this.getDatasetMeta(e), o = i.controller._resolveAnimations(void 0, r);
    ho(n) ? (i.data[n].hidden = !s, this.update()) : (this.setDatasetVisibility(e, s), o.update(i, {
      visible: s
    }), this.update((a) => a.datasetIndex === e ? r : void 0));
  }
  hide(e, n) {
    this._updateVisibility(e, n, !1);
  }
  show(e, n) {
    this._updateVisibility(e, n, !0);
  }
  _destroyDatasetMeta(e) {
    const n = this._metasets[e];
    n && n.controller && n.controller._destroy(), delete this._metasets[e];
  }
  _stop() {
    let e, n;
    for (this.stop(), Fn.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)
      this._destroyDatasetMeta(e);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: e, ctx: n } = this;
    this._stop(), this.config.clearCache(), e && (this.unbindEvents(), Xg(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Da[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...e) {
    return this.canvas.toDataURL(...e);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const e = this._listeners, n = this.platform, s = (i, o) => {
      n.addEventListener(this, i, o), e[i] = o;
    }, r = (i, o, a) => {
      i.offsetX = o, i.offsetY = a, this._eventHandler(i);
    };
    ke(this.options.events, (i) => s(i, r));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const e = this._responsiveListeners, n = this.platform, s = (l, c) => {
      n.addEventListener(this, l, c), e[l] = c;
    }, r = (l, c) => {
      e[l] && (n.removeEventListener(this, l, c), delete e[l]);
    }, i = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let o;
    const a = () => {
      r("attach", a), this.attached = !0, this.resize(), s("resize", i), s("detach", o);
    };
    o = () => {
      this.attached = !1, r("resize", i), this._stop(), this._resize(0, 0), s("attach", a);
    }, n.isAttached(this.canvas) ? a() : o();
  }
  unbindEvents() {
    ke(this._listeners, (e, n) => {
      this.platform.removeEventListener(this, n, e);
    }), this._listeners = {}, ke(this._responsiveListeners, (e, n) => {
      this.platform.removeEventListener(this, n, e);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(e, n, s) {
    const r = s ? "set" : "remove";
    let i, o, a, l;
    for (n === "dataset" && (i = this.getDatasetMeta(e[0].datasetIndex), i.controller["_" + r + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) {
      o = e[a];
      const c = o && this.getDatasetMeta(o.datasetIndex).controller;
      c && c[r + "HoverStyle"](o.element, o.datasetIndex, o.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e) {
    const n = this._active || [], s = e.map(({ datasetIndex: i, index: o }) => {
      const a = this.getDatasetMeta(i);
      if (!a)
        throw new Error("No dataset found at index " + i);
      return {
        datasetIndex: i,
        element: a.data[o],
        index: o
      };
    });
    !fl(s, n) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, n));
  }
  notifyPlugins(e, n, s) {
    return this._plugins.notify(this, e, n, s);
  }
  isPluginEnabled(e) {
    return this._plugins._cache.filter((n) => n.plugin.id === e).length === 1;
  }
  _updateHoverStyles(e, n, s) {
    const r = this.options.hover, i = (l, c) => l.filter((u) => !c.some((d) => u.datasetIndex === d.datasetIndex && u.index === d.index)), o = i(n, e), a = s ? e : i(e, n);
    o.length && this.updateHoverStyle(o, r.mode, !1), a.length && r.mode && this.updateHoverStyle(a, r.mode, !0);
  }
  _eventHandler(e, n) {
    const s = {
      event: e,
      replay: n,
      cancelable: !0,
      inChartArea: this.isPointInArea(e)
    }, r = (o) => (o.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", s, r) === !1)
      return;
    const i = this._handleEvent(e, n, s.inChartArea);
    return s.cancelable = !1, this.notifyPlugins("afterEvent", s, r), (i || s.changed) && this.render(), this;
  }
  _handleEvent(e, n, s) {
    const { _active: r = [], options: i } = this, o = n, a = this._getActiveElements(e, r, s, o), l = ML(e), c = wB(e, this._lastEvent, s, l);
    s && (this._lastEvent = null, Ne(i.onHover, [
      e,
      a,
      this
    ], this), l && Ne(i.onClick, [
      e,
      a,
      this
    ], this));
    const u = !fl(a, r);
    return (u || n) && (this._active = a, this._updateHoverStyles(a, r, n)), this._lastEvent = c, u;
  }
  _getActiveElements(e, n, s, r) {
    if (e.type === "mouseout")
      return [];
    if (!s)
      return n;
    const i = this.options.hover;
    return this.getElementsAtEventForMode(e, i.mode, i, r);
  }
}
W(Un, "defaults", Ze), W(Un, "instances", Da), W(Un, "overrides", or), W(Un, "registry", yn), W(Un, "version", bB), W(Un, "getChart", Rm);
function km() {
  return ke(Un.instances, (t) => t._plugins.invalidate());
}
function CB(t, e, n) {
  const { startAngle: s, pixelMargin: r, x: i, y: o, outerRadius: a, innerRadius: l } = e;
  let c = r / a;
  t.beginPath(), t.arc(i, o, a, s - c, n + c), l > r ? (c = r / l, t.arc(i, o, l, n + c, s - c, !0)) : t.arc(i, o, r, n + et, s - et), t.closePath(), t.clip();
}
function PB(t) {
  return Qf(t, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function qB(t, e, n, s) {
  const r = PB(t.options.borderRadius), i = (n - e) / 2, o = Math.min(i, s * e / 2), a = (l) => {
    const c = (n - Math.min(i, l)) * s / 2;
    return pt(l, 0, Math.min(i, c));
  };
  return {
    outerStart: a(r.outerStart),
    outerEnd: a(r.outerEnd),
    innerStart: pt(r.innerStart, 0, o),
    innerEnd: pt(r.innerEnd, 0, o)
  };
}
function yr(t, e, n, s) {
  return {
    x: n + t * Math.cos(e),
    y: s + t * Math.sin(e)
  };
}
function bl(t, e, n, s, r, i) {
  const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: u } = e, d = Math.max(e.outerRadius + s + n - c, 0), f = u > 0 ? u + s + n + c : 0;
  let h = 0;
  const p = r - l;
  if (s) {
    const B = u > 0 ? u - s : 0, L = d > 0 ? d - s : 0, O = (B + L) / 2, N = O !== 0 ? p * O / (O + s) : p;
    h = (p - N) / 2;
  }
  const g = Math.max(1e-3, p * d - n / ze) / d, A = (p - g) / 2, b = l + A + h, y = r - A - h, { outerStart: w, outerEnd: x, innerStart: S, innerEnd: q } = qB(e, f, d, y - b), C = d - w, E = d - x, T = b + w / C, k = y - x / E, R = f + S, D = f + q, F = b + S / R, j = y - q / D;
  if (t.beginPath(), i) {
    const B = (T + k) / 2;
    if (t.arc(o, a, d, T, B), t.arc(o, a, d, B, k), x > 0) {
      const H = yr(E, k, o, a);
      t.arc(H.x, H.y, x, k, y + et);
    }
    const L = yr(D, y, o, a);
    if (t.lineTo(L.x, L.y), q > 0) {
      const H = yr(D, j, o, a);
      t.arc(H.x, H.y, q, y + et, j + Math.PI);
    }
    const O = (y - q / f + (b + S / f)) / 2;
    if (t.arc(o, a, f, y - q / f, O, !0), t.arc(o, a, f, O, b + S / f, !0), S > 0) {
      const H = yr(R, F, o, a);
      t.arc(H.x, H.y, S, F + Math.PI, b - et);
    }
    const N = yr(C, b, o, a);
    if (t.lineTo(N.x, N.y), w > 0) {
      const H = yr(C, T, o, a);
      t.arc(H.x, H.y, w, b - et, T);
    }
  } else {
    t.moveTo(o, a);
    const B = Math.cos(T) * d + o, L = Math.sin(T) * d + a;
    t.lineTo(B, L);
    const O = Math.cos(k) * d + o, N = Math.sin(k) * d + a;
    t.lineTo(O, N);
  }
  t.closePath();
}
function EB(t, e, n, s, r) {
  const { fullCircles: i, startAngle: o, circumference: a } = e;
  let l = e.endAngle;
  if (i) {
    bl(t, e, n, s, l, r);
    for (let c = 0; c < i; ++c)
      t.fill();
    isNaN(a) || (l = o + (a % Ve || Ve));
  }
  return bl(t, e, n, s, l, r), t.fill(), l;
}
function TB(t, e, n, s, r) {
  const { fullCircles: i, startAngle: o, circumference: a, options: l } = e, { borderWidth: c, borderJoinStyle: u, borderDash: d, borderDashOffset: f } = l, h = l.borderAlign === "inner";
  if (!c)
    return;
  t.setLineDash(d || []), t.lineDashOffset = f, h ? (t.lineWidth = c * 2, t.lineJoin = u || "round") : (t.lineWidth = c, t.lineJoin = u || "bevel");
  let p = e.endAngle;
  if (i) {
    bl(t, e, n, s, p, r);
    for (let g = 0; g < i; ++g)
      t.stroke();
    isNaN(a) || (p = o + (a % Ve || Ve));
  }
  h && CB(t, e, p), i || (bl(t, e, n, s, p, r), t.stroke());
}
class Ti extends ts {
  constructor(n) {
    super();
    W(this, "circumference");
    W(this, "endAngle");
    W(this, "fullCircles");
    W(this, "innerRadius");
    W(this, "outerRadius");
    W(this, "pixelMargin");
    W(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, n && Object.assign(this, n);
  }
  inRange(n, s, r) {
    const i = this.getProps([
      "x",
      "y"
    ], r), { angle: o, distance: a } = vx(i, {
      x: n,
      y: s
    }), { startAngle: l, endAngle: c, innerRadius: u, outerRadius: d, circumference: f } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], r), h = (this.options.spacing + this.options.borderWidth) / 2, p = le(f, c - l), g = po(o, l, c) && l !== c, A = p >= Ve || g, b = Hn(a, u + h, d + h);
    return A && b;
  }
  getCenterPoint(n) {
    const { x: s, y: r, startAngle: i, endAngle: o, innerRadius: a, outerRadius: l } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], n), { offset: c, spacing: u } = this.options, d = (i + o) / 2, f = (a + l + u + c) / 2;
    return {
      x: s + Math.cos(d) * f,
      y: r + Math.sin(d) * f
    };
  }
  tooltipPosition(n) {
    return this.getCenterPoint(n);
  }
  draw(n) {
    const { options: s, circumference: r } = this, i = (s.offset || 0) / 4, o = (s.spacing || 0) / 2, a = s.circular;
    if (this.pixelMargin = s.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = r > Ve ? Math.floor(r / Ve) : 0, r === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    n.save();
    const l = (this.startAngle + this.endAngle) / 2;
    n.translate(Math.cos(l) * i, Math.sin(l) * i);
    const c = 1 - Math.sin(Math.min(ze, r || 0)), u = i * c;
    n.fillStyle = s.backgroundColor, n.strokeStyle = s.borderColor, EB(n, this, u, o, a), TB(n, this, u, o, a), n.restore();
  }
}
W(Ti, "id", "arc"), W(Ti, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), W(Ti, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), W(Ti, "descriptors", {
  _scriptable: !0,
  _indexable: (n) => n !== "borderDash"
});
function $x(t, e, n = e) {
  t.lineCap = le(n.borderCapStyle, e.borderCapStyle), t.setLineDash(le(n.borderDash, e.borderDash)), t.lineDashOffset = le(n.borderDashOffset, e.borderDashOffset), t.lineJoin = le(n.borderJoinStyle, e.borderJoinStyle), t.lineWidth = le(n.borderWidth, e.borderWidth), t.strokeStyle = le(n.borderColor, e.borderColor);
}
function RB(t, e, n) {
  t.lineTo(n.x, n.y);
}
function kB(t) {
  return t.stepped ? $L : t.tension || t.cubicInterpolationMode === "monotone" ? eN : RB;
}
function ew(t, e, n = {}) {
  const s = t.length, { start: r = 0, end: i = s - 1 } = n, { start: o, end: a } = e, l = Math.max(r, o), c = Math.min(i, a), u = r < o && i < o || r > a && i > a;
  return {
    count: s,
    start: l,
    loop: e.loop,
    ilen: c < l && !u ? s + c - l : c - l
  };
}
function MB(t, e, n, s) {
  const { points: r, options: i } = e, { count: o, start: a, loop: l, ilen: c } = ew(r, n, s), u = kB(i);
  let { move: d = !0, reverse: f } = s || {}, h, p, g;
  for (h = 0; h <= c; ++h)
    p = r[(a + (f ? c - h : h)) % o], !p.skip && (d ? (t.moveTo(p.x, p.y), d = !1) : u(t, g, p, f, i.stepped), g = p);
  return l && (p = r[(a + (f ? c : 0)) % o], u(t, g, p, f, i.stepped)), !!l;
}
function DB(t, e, n, s) {
  const r = e.points, { count: i, start: o, ilen: a } = ew(r, n, s), { move: l = !0, reverse: c } = s || {};
  let u = 0, d = 0, f, h, p, g, A, b;
  const y = (x) => (o + (c ? a - x : x)) % i, w = () => {
    g !== A && (t.lineTo(u, A), t.lineTo(u, g), t.lineTo(u, b));
  };
  for (l && (h = r[y(0)], t.moveTo(h.x, h.y)), f = 0; f <= a; ++f) {
    if (h = r[y(f)], h.skip)
      continue;
    const x = h.x, S = h.y, q = x | 0;
    q === p ? (S < g ? g = S : S > A && (A = S), u = (d * u + x) / ++d) : (w(), t.lineTo(x, S), p = q, d = 0, g = A = S), b = S;
  }
  w();
}
function Ku(t) {
  const e = t.options, n = e.borderDash && e.borderDash.length;
  return !t._decimated && !t._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !n ? DB : MB;
}
function OB(t) {
  return t.stepped ? DN : t.tension || t.cubicInterpolationMode === "monotone" ? ON : Qs;
}
function LB(t, e, n, s) {
  let r = e._path;
  r || (r = e._path = new Path2D(), e.path(r, n, s) && r.closePath()), $x(t, e.options), t.stroke(r);
}
function NB(t, e, n, s) {
  const { segments: r, options: i } = e, o = Ku(e);
  for (const a of r)
    $x(t, i, a.style), t.beginPath(), o(t, e, a, {
      start: n,
      end: n + s - 1
    }) && t.closePath(), t.stroke();
}
const jB = typeof Path2D == "function";
function BB(t, e, n, s) {
  jB && !e.options.segment ? LB(t, e, n, s) : NB(t, e, n, s);
}
class fs extends ts {
  constructor(e) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e);
  }
  updateControlPoints(e, n) {
    const s = this.options;
    if ((s.tension || s.cubicInterpolationMode === "monotone") && !s.stepped && !this._pointsUpdated) {
      const r = s.spanGaps ? this._loop : this._fullLoop;
      CN(this._points, s, e, r, n), this._pointsUpdated = !0;
    }
  }
  set points(e) {
    this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = FN(this, this.options.segment));
  }
  first() {
    const e = this.segments, n = this.points;
    return e.length && n[e[0].start];
  }
  last() {
    const e = this.segments, n = this.points, s = e.length;
    return s && n[e[s - 1].end];
  }
  interpolate(e, n) {
    const s = this.options, r = e[n], i = this.points, o = Vx(this, {
      property: n,
      start: r,
      end: r
    });
    if (!o.length)
      return;
    const a = [], l = OB(s);
    let c, u;
    for (c = 0, u = o.length; c < u; ++c) {
      const { start: d, end: f } = o[c], h = i[d], p = i[f];
      if (h === p) {
        a.push(h);
        continue;
      }
      const g = Math.abs((r - h[n]) / (p[n] - h[n])), A = l(h, p, g, s.stepped);
      A[n] = e[n], a.push(A);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(e, n, s) {
    return Ku(this)(e, this, n, s);
  }
  path(e, n, s) {
    const r = this.segments, i = Ku(this);
    let o = this._loop;
    n = n || 0, s = s || this.points.length - n;
    for (const a of r)
      o &= i(e, this, a, {
        start: n,
        end: n + s - 1
      });
    return !!o;
  }
  draw(e, n, s, r) {
    const i = this.options || {};
    (this.points || []).length && i.borderWidth && (e.save(), BB(e, this, s, r), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
W(fs, "id", "line"), W(fs, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), W(fs, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), W(fs, "descriptors", {
  _scriptable: !0,
  _indexable: (e) => e !== "borderDash" && e !== "fill"
});
function Mm(t, e, n, s) {
  const r = t.options, { [n]: i } = t.getProps([
    n
  ], s);
  return Math.abs(e - i) < r.radius + r.hitRadius;
}
class Oa extends ts {
  constructor(n) {
    super();
    W(this, "parsed");
    W(this, "skip");
    W(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, n && Object.assign(this, n);
  }
  inRange(n, s, r) {
    const i = this.options, { x: o, y: a } = this.getProps([
      "x",
      "y"
    ], r);
    return Math.pow(n - o, 2) + Math.pow(s - a, 2) < Math.pow(i.hitRadius + i.radius, 2);
  }
  inXRange(n, s) {
    return Mm(this, n, "x", s);
  }
  inYRange(n, s) {
    return Mm(this, n, "y", s);
  }
  getCenterPoint(n) {
    const { x: s, y: r } = this.getProps([
      "x",
      "y"
    ], n);
    return {
      x: s,
      y: r
    };
  }
  size(n) {
    n = n || this.options || {};
    let s = n.radius || 0;
    s = Math.max(s, s && n.hoverRadius || 0);
    const r = s && n.borderWidth || 0;
    return (s + r) * 2;
  }
  draw(n, s) {
    const r = this.options;
    this.skip || r.radius < 0.1 || !Yn(this, s, this.size(r) / 2) || (n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.fillStyle = r.backgroundColor, Wu(n, r, this.x, this.y));
  }
  getRange() {
    const n = this.options || {};
    return n.radius + n.hitRadius;
  }
}
W(Oa, "id", "point"), /**
* @type {any}
*/
W(Oa, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
W(Oa, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function tw(t, e) {
  const { x: n, y: s, base: r, width: i, height: o } = t.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], e);
  let a, l, c, u, d;
  return t.horizontal ? (d = o / 2, a = Math.min(n, r), l = Math.max(n, r), c = s - d, u = s + d) : (d = i / 2, a = n - d, l = n + d, c = Math.min(s, r), u = Math.max(s, r)), {
    left: a,
    top: c,
    right: l,
    bottom: u
  };
}
function hs(t, e, n, s) {
  return t ? 0 : pt(e, n, s);
}
function IB(t, e, n) {
  const s = t.options.borderWidth, r = t.borderSkipped, i = Rx(s);
  return {
    t: hs(r.top, i.top, 0, n),
    r: hs(r.right, i.right, 0, e),
    b: hs(r.bottom, i.bottom, 0, n),
    l: hs(r.left, i.left, 0, e)
  };
}
function FB(t, e, n) {
  const { enableBorderRadius: s } = t.getProps([
    "enableBorderRadius"
  ]), r = t.options.borderRadius, i = Js(r), o = Math.min(e, n), a = t.borderSkipped, l = s || he(r);
  return {
    topLeft: hs(!l || a.top || a.left, i.topLeft, 0, o),
    topRight: hs(!l || a.top || a.right, i.topRight, 0, o),
    bottomLeft: hs(!l || a.bottom || a.left, i.bottomLeft, 0, o),
    bottomRight: hs(!l || a.bottom || a.right, i.bottomRight, 0, o)
  };
}
function VB(t) {
  const e = tw(t), n = e.right - e.left, s = e.bottom - e.top, r = IB(t, n / 2, s / 2), i = FB(t, n / 2, s / 2);
  return {
    outer: {
      x: e.left,
      y: e.top,
      w: n,
      h: s,
      radius: i
    },
    inner: {
      x: e.left + r.l,
      y: e.top + r.t,
      w: n - r.l - r.r,
      h: s - r.t - r.b,
      radius: {
        topLeft: Math.max(0, i.topLeft - Math.max(r.t, r.l)),
        topRight: Math.max(0, i.topRight - Math.max(r.t, r.r)),
        bottomLeft: Math.max(0, i.bottomLeft - Math.max(r.b, r.l)),
        bottomRight: Math.max(0, i.bottomRight - Math.max(r.b, r.r))
      }
    }
  };
}
function Gc(t, e, n, s) {
  const r = e === null, i = n === null, a = t && !(r && i) && tw(t, s);
  return a && (r || Hn(e, a.left, a.right)) && (i || Hn(n, a.top, a.bottom));
}
function zB(t) {
  return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight;
}
function UB(t, e) {
  t.rect(e.x, e.y, e.w, e.h);
}
function Zc(t, e, n = {}) {
  const s = t.x !== n.x ? -e : 0, r = t.y !== n.y ? -e : 0, i = (t.x + t.w !== n.x + n.w ? e : 0) - s, o = (t.y + t.h !== n.y + n.h ? e : 0) - r;
  return {
    x: t.x + s,
    y: t.y + r,
    w: t.w + i,
    h: t.h + o,
    radius: t.radius
  };
}
class La extends ts {
  constructor(e) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
  }
  draw(e) {
    const { inflateAmount: n, options: { borderColor: s, backgroundColor: r } } = this, { inner: i, outer: o } = VB(this), a = zB(o.radius) ? go : UB;
    e.save(), (o.w !== i.w || o.h !== i.h) && (e.beginPath(), a(e, Zc(o, n, i)), e.clip(), a(e, Zc(i, -n, o)), e.fillStyle = s, e.fill("evenodd")), e.beginPath(), a(e, Zc(i, n)), e.fillStyle = r, e.fill(), e.restore();
  }
  inRange(e, n, s) {
    return Gc(this, e, n, s);
  }
  inXRange(e, n) {
    return Gc(this, e, null, n);
  }
  inYRange(e, n) {
    return Gc(this, null, e, n);
  }
  getCenterPoint(e) {
    const { x: n, y: s, base: r, horizontal: i } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], e);
    return {
      x: i ? (n + r) / 2 : n,
      y: i ? s : (s + r) / 2
    };
  }
  getRange(e) {
    return e === "x" ? this.width / 2 : this.height / 2;
  }
}
W(La, "id", "bar"), W(La, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), W(La, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var WB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: Ti,
  BarElement: La,
  LineElement: fs,
  PointElement: Oa
});
const Xu = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], Dm = /* @__PURE__ */ Xu.map((t) => t.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function nw(t) {
  return Xu[t % Xu.length];
}
function sw(t) {
  return Dm[t % Dm.length];
}
function HB(t, e) {
  return t.borderColor = nw(e), t.backgroundColor = sw(e), ++e;
}
function QB(t, e) {
  return t.backgroundColor = t.data.map(() => nw(e++)), e;
}
function YB(t, e) {
  return t.backgroundColor = t.data.map(() => sw(e++)), e;
}
function KB(t) {
  let e = 0;
  return (n, s) => {
    const r = t.getDatasetMeta(s).controller;
    r instanceof Xs ? e = QB(n, e) : r instanceof Fi ? e = YB(n, e) : r && (e = HB(n, e));
  };
}
function Om(t) {
  let e;
  for (e in t)
    if (t[e].borderColor || t[e].backgroundColor)
      return !0;
  return !1;
}
function XB(t) {
  return t && (t.borderColor || t.backgroundColor);
}
var GB = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(t, e, n) {
    if (!n.enabled)
      return;
    const { data: { datasets: s }, options: r } = t.config, { elements: i } = r;
    if (!n.forceOverride && (Om(s) || XB(r) || i && Om(i)))
      return;
    const o = KB(t);
    s.forEach(o);
  }
};
function ZB(t, e, n, s, r) {
  const i = r.samples || s;
  if (i >= n)
    return t.slice(e, e + n);
  const o = [], a = (n - 2) / (i - 2);
  let l = 0;
  const c = e + n - 1;
  let u = e, d, f, h, p, g;
  for (o[l++] = t[u], d = 0; d < i - 2; d++) {
    let A = 0, b = 0, y;
    const w = Math.floor((d + 1) * a) + 1 + e, x = Math.min(Math.floor((d + 2) * a) + 1, n) + e, S = x - w;
    for (y = w; y < x; y++)
      A += t[y].x, b += t[y].y;
    A /= S, b /= S;
    const q = Math.floor(d * a) + 1 + e, C = Math.min(Math.floor((d + 1) * a) + 1, n) + e, { x: E, y: T } = t[u];
    for (h = p = -1, y = q; y < C; y++)
      p = 0.5 * Math.abs((E - A) * (t[y].y - T) - (E - t[y].x) * (b - T)), p > h && (h = p, f = t[y], g = y);
    o[l++] = f, u = g;
  }
  return o[l++] = t[c], o;
}
function _B(t, e, n, s) {
  let r = 0, i = 0, o, a, l, c, u, d, f, h, p, g;
  const A = [], b = e + n - 1, y = t[e].x, x = t[b].x - y;
  for (o = e; o < e + n; ++o) {
    a = t[o], l = (a.x - y) / x * s, c = a.y;
    const S = l | 0;
    if (S === u)
      c < p ? (p = c, d = o) : c > g && (g = c, f = o), r = (i * r + a.x) / ++i;
    else {
      const q = o - 1;
      if (!be(d) && !be(f)) {
        const C = Math.min(d, f), E = Math.max(d, f);
        C !== h && C !== q && A.push({
          ...t[C],
          x: r
        }), E !== h && E !== q && A.push({
          ...t[E],
          x: r
        });
      }
      o > 0 && q !== h && A.push(t[q]), A.push(a), u = S, i = 0, p = g = c, d = f = h = o;
    }
  }
  return A;
}
function rw(t) {
  if (t._decimated) {
    const e = t._data;
    delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: e
    });
  }
}
function Lm(t) {
  t.data.datasets.forEach((e) => {
    rw(e);
  });
}
function JB(t, e) {
  const n = e.length;
  let s = 0, r;
  const { iScale: i } = t, { min: o, max: a, minDefined: l, maxDefined: c } = i.getUserBounds();
  return l && (s = pt(Qn(e, i.axis, o).lo, 0, n - 1)), c ? r = pt(Qn(e, i.axis, a).hi + 1, s, n) - s : r = n - s, {
    start: s,
    count: r
  };
}
var $B = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (t, e, n) => {
    if (!n.enabled) {
      Lm(t);
      return;
    }
    const s = t.width;
    t.data.datasets.forEach((r, i) => {
      const { _data: o, indexAxis: a } = r, l = t.getDatasetMeta(i), c = o || r.data;
      if (qi([
        a,
        t.options.indexAxis
      ]) === "y" || !l.controller.supportsDecimation)
        return;
      const u = t.scales[l.xAxisID];
      if (u.type !== "linear" && u.type !== "time" || t.options.parsing)
        return;
      let { start: d, count: f } = JB(l, c);
      const h = n.threshold || 4 * s;
      if (f <= h) {
        rw(r);
        return;
      }
      be(o) && (r._data = c, delete r.data, Object.defineProperty(r, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(g) {
          this._data = g;
        }
      }));
      let p;
      switch (n.algorithm) {
        case "lttb":
          p = ZB(c, d, f, s, n);
          break;
        case "min-max":
          p = _B(c, d, f, s);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`);
      }
      r._decimated = p;
    });
  },
  destroy(t) {
    Lm(t);
  }
};
function eI(t, e, n) {
  const s = t.segments, r = t.points, i = e.points, o = [];
  for (const a of s) {
    let { start: l, end: c } = a;
    c = Jf(l, c, r);
    const u = Gu(n, r[l], r[c], a.loop);
    if (!e.segments) {
      o.push({
        source: a,
        target: u,
        start: r[l],
        end: r[c]
      });
      continue;
    }
    const d = Vx(e, u);
    for (const f of d) {
      const h = Gu(n, i[f.start], i[f.end], f.loop), p = Fx(a, r, h);
      for (const g of p)
        o.push({
          source: g,
          target: f,
          start: {
            [n]: Nm(u, h, "start", Math.max)
          },
          end: {
            [n]: Nm(u, h, "end", Math.min)
          }
        });
    }
  }
  return o;
}
function Gu(t, e, n, s) {
  if (s)
    return;
  let r = e[t], i = n[t];
  return t === "angle" && (r = Yt(r), i = Yt(i)), {
    property: t,
    start: r,
    end: i
  };
}
function tI(t, e) {
  const { x: n = null, y: s = null } = t || {}, r = e.points, i = [];
  return e.segments.forEach(({ start: o, end: a }) => {
    a = Jf(o, a, r);
    const l = r[o], c = r[a];
    s !== null ? (i.push({
      x: l.x,
      y: s
    }), i.push({
      x: c.x,
      y: s
    })) : n !== null && (i.push({
      x: n,
      y: l.y
    }), i.push({
      x: n,
      y: c.y
    }));
  }), i;
}
function Jf(t, e, n) {
  for (; e > t; e--) {
    const s = n[e];
    if (!isNaN(s.x) && !isNaN(s.y))
      break;
  }
  return e;
}
function Nm(t, e, n, s) {
  return t && e ? s(t[n], e[n]) : t ? t[n] : e ? e[n] : 0;
}
function iw(t, e) {
  let n = [], s = !1;
  return We(t) ? (s = !0, n = t) : n = tI(t, e), n.length ? new fs({
    points: n,
    options: {
      tension: 0
    },
    _loop: s,
    _fullLoop: s
  }) : null;
}
function jm(t) {
  return t && t.fill !== !1;
}
function nI(t, e, n) {
  let r = t[e].fill;
  const i = [
    e
  ];
  let o;
  if (!n)
    return r;
  for (; r !== !1 && i.indexOf(r) === -1; ) {
    if (!Ge(r))
      return r;
    if (o = t[r], !o)
      return !1;
    if (o.visible)
      return r;
    i.push(r), r = o.fill;
  }
  return !1;
}
function sI(t, e, n) {
  const s = aI(t);
  if (he(s))
    return isNaN(s.value) ? !1 : s;
  let r = parseFloat(s);
  return Ge(r) && Math.floor(r) === r ? rI(s[0], e, r, n) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(s) >= 0 && s;
}
function rI(t, e, n, s) {
  return (t === "-" || t === "+") && (n = e + n), n === e || n < 0 || n >= s ? !1 : n;
}
function iI(t, e) {
  let n = null;
  return t === "start" ? n = e.bottom : t === "end" ? n = e.top : he(t) ? n = e.getPixelForValue(t.value) : e.getBasePixel && (n = e.getBasePixel()), n;
}
function oI(t, e, n) {
  let s;
  return t === "start" ? s = n : t === "end" ? s = e.options.reverse ? e.min : e.max : he(t) ? s = t.value : s = e.getBaseValue(), s;
}
function aI(t) {
  const e = t.options, n = e.fill;
  let s = le(n && n.target, n);
  return s === void 0 && (s = !!e.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? "origin" : s;
}
function lI(t) {
  const { scale: e, index: n, line: s } = t, r = [], i = s.segments, o = s.points, a = cI(e, n);
  a.push(iw({
    x: null,
    y: e.bottom
  }, s));
  for (let l = 0; l < i.length; l++) {
    const c = i[l];
    for (let u = c.start; u <= c.end; u++)
      uI(r, o[u], a);
  }
  return new fs({
    points: r,
    options: {}
  });
}
function cI(t, e) {
  const n = [], s = t.getMatchingVisibleMetas("line");
  for (let r = 0; r < s.length; r++) {
    const i = s[r];
    if (i.index === e)
      break;
    i.hidden || n.unshift(i.dataset);
  }
  return n;
}
function uI(t, e, n) {
  const s = [];
  for (let r = 0; r < n.length; r++) {
    const i = n[r], { first: o, last: a, point: l } = dI(i, e, "x");
    if (!(!l || o && a)) {
      if (o)
        s.unshift(l);
      else if (t.push(l), !a)
        break;
    }
  }
  t.push(...s);
}
function dI(t, e, n) {
  const s = t.interpolate(e, n);
  if (!s)
    return {};
  const r = s[n], i = t.segments, o = t.points;
  let a = !1, l = !1;
  for (let c = 0; c < i.length; c++) {
    const u = i[c], d = o[u.start][n], f = o[u.end][n];
    if (Hn(r, d, f)) {
      a = r === d, l = r === f;
      break;
    }
  }
  return {
    first: a,
    last: l,
    point: s
  };
}
class ow {
  constructor(e) {
    this.x = e.x, this.y = e.y, this.radius = e.radius;
  }
  pathSegment(e, n, s) {
    const { x: r, y: i, radius: o } = this;
    return n = n || {
      start: 0,
      end: Ve
    }, e.arc(r, i, o, n.end, n.start, !0), !s.bounds;
  }
  interpolate(e) {
    const { x: n, y: s, radius: r } = this, i = e.angle;
    return {
      x: n + Math.cos(i) * r,
      y: s + Math.sin(i) * r,
      angle: i
    };
  }
}
function fI(t) {
  const { chart: e, fill: n, line: s } = t;
  if (Ge(n))
    return hI(e, n);
  if (n === "stack")
    return lI(t);
  if (n === "shape")
    return !0;
  const r = pI(t);
  return r instanceof ow ? r : iw(r, s);
}
function hI(t, e) {
  const n = t.getDatasetMeta(e);
  return n && t.isDatasetVisible(e) ? n.dataset : null;
}
function pI(t) {
  return (t.scale || {}).getPointPositionForValue ? mI(t) : gI(t);
}
function gI(t) {
  const { scale: e = {}, fill: n } = t, s = iI(n, e);
  if (Ge(s)) {
    const r = e.isHorizontal();
    return {
      x: r ? s : null,
      y: r ? null : s
    };
  }
  return null;
}
function mI(t) {
  const { scale: e, fill: n } = t, s = e.options, r = e.getLabels().length, i = s.reverse ? e.max : e.min, o = oI(n, e, i), a = [];
  if (s.grid.circular) {
    const l = e.getPointPositionForValue(0, i);
    return new ow({
      x: l.x,
      y: l.y,
      radius: e.getDistanceFromCenterForValue(o)
    });
  }
  for (let l = 0; l < r; ++l)
    a.push(e.getPointPositionForValue(l, o));
  return a;
}
function _c(t, e, n) {
  const s = fI(e), { line: r, scale: i, axis: o } = e, a = r.options, l = a.fill, c = a.backgroundColor, { above: u = c, below: d = c } = l || {};
  s && r.points.length && (Gl(t, n), AI(t, {
    line: r,
    target: s,
    above: u,
    below: d,
    area: n,
    scale: i,
    axis: o
  }), Zl(t));
}
function AI(t, e) {
  const { line: n, target: s, above: r, below: i, area: o, scale: a } = e, l = n._loop ? "angle" : e.axis;
  t.save(), l === "x" && i !== r && (Bm(t, s, o.top), Im(t, {
    line: n,
    target: s,
    color: r,
    scale: a,
    property: l
  }), t.restore(), t.save(), Bm(t, s, o.bottom)), Im(t, {
    line: n,
    target: s,
    color: i,
    scale: a,
    property: l
  }), t.restore();
}
function Bm(t, e, n) {
  const { segments: s, points: r } = e;
  let i = !0, o = !1;
  t.beginPath();
  for (const a of s) {
    const { start: l, end: c } = a, u = r[l], d = r[Jf(l, c, r)];
    i ? (t.moveTo(u.x, u.y), i = !1) : (t.lineTo(u.x, n), t.lineTo(u.x, u.y)), o = !!e.pathSegment(t, a, {
      move: o
    }), o ? t.closePath() : t.lineTo(d.x, n);
  }
  t.lineTo(e.first().x, n), t.closePath(), t.clip();
}
function Im(t, e) {
  const { line: n, target: s, property: r, color: i, scale: o } = e, a = eI(n, s, r);
  for (const { source: l, target: c, start: u, end: d } of a) {
    const { style: { backgroundColor: f = i } = {} } = l, h = s !== !0;
    t.save(), t.fillStyle = f, bI(t, o, h && Gu(r, u, d)), t.beginPath();
    const p = !!n.pathSegment(t, l);
    let g;
    if (h) {
      p ? t.closePath() : Fm(t, s, d, r);
      const A = !!s.pathSegment(t, c, {
        move: p,
        reverse: !0
      });
      g = p && A, g || Fm(t, s, u, r);
    }
    t.closePath(), t.fill(g ? "evenodd" : "nonzero"), t.restore();
  }
}
function bI(t, e, n) {
  const { top: s, bottom: r } = e.chart.chartArea, { property: i, start: o, end: a } = n || {};
  i === "x" && (t.beginPath(), t.rect(o, s, a - o, r - s), t.clip());
}
function Fm(t, e, n, s) {
  const r = e.interpolate(n, s);
  r && t.lineTo(r.x, r.y);
}
var yI = {
  id: "filler",
  afterDatasetsUpdate(t, e, n) {
    const s = (t.data.datasets || []).length, r = [];
    let i, o, a, l;
    for (o = 0; o < s; ++o)
      i = t.getDatasetMeta(o), a = i.dataset, l = null, a && a.options && a instanceof fs && (l = {
        visible: t.isDatasetVisible(o),
        index: o,
        fill: sI(a, o, s),
        chart: t,
        axis: i.controller.options.indexAxis,
        scale: i.vScale,
        line: a
      }), i.$filler = l, r.push(l);
    for (o = 0; o < s; ++o)
      l = r[o], !(!l || l.fill === !1) && (l.fill = nI(r, o, n.propagate));
  },
  beforeDraw(t, e, n) {
    const s = n.drawTime === "beforeDraw", r = t.getSortedVisibleDatasetMetas(), i = t.chartArea;
    for (let o = r.length - 1; o >= 0; --o) {
      const a = r[o].$filler;
      a && (a.line.updateControlPoints(i, a.axis), s && a.fill && _c(t.ctx, a, i));
    }
  },
  beforeDatasetsDraw(t, e, n) {
    if (n.drawTime !== "beforeDatasetsDraw")
      return;
    const s = t.getSortedVisibleDatasetMetas();
    for (let r = s.length - 1; r >= 0; --r) {
      const i = s[r].$filler;
      jm(i) && _c(t.ctx, i, t.chartArea);
    }
  },
  beforeDatasetDraw(t, e, n) {
    const s = e.meta.$filler;
    !jm(s) || n.drawTime !== "beforeDatasetDraw" || _c(t.ctx, s, t.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const Vm = (t, e) => {
  let { boxHeight: n = e, boxWidth: s = e } = t;
  return t.usePointStyle && (n = Math.min(n, e), s = t.pointStyleWidth || Math.min(s, e)), {
    boxWidth: s,
    boxHeight: n,
    itemHeight: Math.max(e, n)
  };
}, vI = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index;
class zm extends ts {
  constructor(e) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, n, s) {
    this.maxWidth = e, this.maxHeight = n, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const e = this.options.labels || {};
    let n = Ne(e.generateLabels, [
      this.chart
    ], this) || [];
    e.filter && (n = n.filter((s) => e.filter(s, this.chart.data))), e.sort && (n = n.sort((s, r) => e.sort(s, r, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n;
  }
  fit() {
    const { options: e, ctx: n } = this;
    if (!e.display) {
      this.width = this.height = 0;
      return;
    }
    const s = e.labels, r = ct(s.font), i = r.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = Vm(s, i);
    let c, u;
    n.font = r.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(o, i, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(o, r, a, l) + 10), this.width = Math.min(c, e.maxWidth || this.maxWidth), this.height = Math.min(u, e.maxHeight || this.maxHeight);
  }
  _fitRows(e, n, s, r) {
    const { ctx: i, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
      0
    ], u = r + a;
    let d = e;
    i.textAlign = "left", i.textBaseline = "middle";
    let f = -1, h = -u;
    return this.legendItems.forEach((p, g) => {
      const A = s + n / 2 + i.measureText(p.text).width;
      (g === 0 || c[c.length - 1] + A + 2 * a > o) && (d += u, c[c.length - (g > 0 ? 0 : 1)] = 0, h += u, f++), l[g] = {
        left: 0,
        top: h,
        row: f,
        width: A,
        height: r
      }, c[c.length - 1] += A + a;
    }), d;
  }
  _fitCols(e, n, s, r) {
    const { ctx: i, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = o - e;
    let d = a, f = 0, h = 0, p = 0, g = 0;
    return this.legendItems.forEach((A, b) => {
      const { itemWidth: y, itemHeight: w } = xI(s, n, i, A, r);
      b > 0 && h + w + 2 * a > u && (d += f + a, c.push({
        width: f,
        height: h
      }), p += f + a, g++, f = h = 0), l[b] = {
        left: p,
        top: h,
        col: g,
        width: y,
        height: w
      }, f = Math.max(f, y), h += w + a;
    }), d += f, c.push({
      width: f,
      height: h
    }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: s, labels: { padding: r }, rtl: i } } = this, o = Lr(i, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, l = xt(s, this.left + r, this.right - this.lineWidths[a]);
      for (const c of n)
        a !== c.row && (a = c.row, l = xt(s, this.left + r, this.right - this.lineWidths[a])), c.top += this.top + e + r, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + r;
    } else {
      let a = 0, l = xt(s, this.top + e + r, this.bottom - this.columnSizes[a].height);
      for (const c of n)
        c.col !== a && (a = c.col, l = xt(s, this.top + e + r, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + r, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + r;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx;
      Gl(e, this), this._draw(), Zl(e);
    }
  }
  _draw() {
    const { options: e, columnSizes: n, lineWidths: s, ctx: r } = this, { align: i, labels: o } = e, a = Ze.color, l = Lr(e.rtl, this.left, this.width), c = ct(o.font), { padding: u } = o, d = c.size, f = d / 2;
    let h;
    this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = 0.5, r.font = c.string;
    const { boxWidth: p, boxHeight: g, itemHeight: A } = Vm(o, d), b = function(q, C, E) {
      if (isNaN(p) || p <= 0 || isNaN(g) || g < 0)
        return;
      r.save();
      const T = le(E.lineWidth, 1);
      if (r.fillStyle = le(E.fillStyle, a), r.lineCap = le(E.lineCap, "butt"), r.lineDashOffset = le(E.lineDashOffset, 0), r.lineJoin = le(E.lineJoin, "miter"), r.lineWidth = T, r.strokeStyle = le(E.strokeStyle, a), r.setLineDash(le(E.lineDash, [])), o.usePointStyle) {
        const k = {
          radius: g * Math.SQRT2 / 2,
          pointStyle: E.pointStyle,
          rotation: E.rotation,
          borderWidth: T
        }, R = l.xPlus(q, p / 2), D = C + f;
        Tx(r, k, R, D, o.pointStyleWidth && p);
      } else {
        const k = C + Math.max((d - g) / 2, 0), R = l.leftForLtr(q, p), D = Js(E.borderRadius);
        r.beginPath(), Object.values(D).some((F) => F !== 0) ? go(r, {
          x: R,
          y: k,
          w: p,
          h: g,
          radius: D
        }) : r.rect(R, k, p, g), r.fill(), T !== 0 && r.stroke();
      }
      r.restore();
    }, y = function(q, C, E) {
      ar(r, E.text, q, C + A / 2, c, {
        strikethrough: E.hidden,
        textAlign: l.textAlign(E.textAlign)
      });
    }, w = this.isHorizontal(), x = this._computeTitleHeight();
    w ? h = {
      x: xt(i, this.left + u, this.right - s[0]),
      y: this.top + u + x,
      line: 0
    } : h = {
      x: this.left + u,
      y: xt(i, this.top + x + u, this.bottom - n[0].height),
      line: 0
    }, jx(this.ctx, e.textDirection);
    const S = A + u;
    this.legendItems.forEach((q, C) => {
      r.strokeStyle = q.fontColor, r.fillStyle = q.fontColor;
      const E = r.measureText(q.text).width, T = l.textAlign(q.textAlign || (q.textAlign = o.textAlign)), k = p + f + E;
      let R = h.x, D = h.y;
      l.setWidth(this.width), w ? C > 0 && R + k + u > this.right && (D = h.y += S, h.line++, R = h.x = xt(i, this.left + u, this.right - s[h.line])) : C > 0 && D + S > this.bottom && (R = h.x = R + n[h.line].width + u, h.line++, D = h.y = xt(i, this.top + x + u, this.bottom - n[h.line].height));
      const F = l.x(R);
      if (b(F, D, q), R = UL(T, R + p + f, w ? R + k : this.right, e.rtl), y(l.x(R), D, q), w)
        h.x += k + u;
      else if (typeof q.text != "string") {
        const j = c.lineHeight;
        h.y += aw(q, j) + u;
      } else
        h.y += S;
    }), Bx(this.ctx, e.textDirection);
  }
  drawTitle() {
    const e = this.options, n = e.title, s = ct(n.font), r = qt(n.padding);
    if (!n.display)
      return;
    const i = Lr(e.rtl, this.left, this.width), o = this.ctx, a = n.position, l = s.size / 2, c = r.top + l;
    let u, d = this.left, f = this.width;
    if (this.isHorizontal())
      f = Math.max(...this.lineWidths), u = this.top + c, d = xt(e.align, d, this.right - f);
    else {
      const p = this.columnSizes.reduce((g, A) => Math.max(g, A.height), 0);
      u = c + xt(e.align, this.top, this.bottom - p - e.labels.padding - this._computeTitleHeight());
    }
    const h = xt(a, d, d + f);
    o.textAlign = i.textAlign(Wf(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = s.string, ar(o, n.text, h, u, s);
  }
  _computeTitleHeight() {
    const e = this.options.title, n = ct(e.font), s = qt(e.padding);
    return e.display ? n.lineHeight + s.height : 0;
  }
  _getLegendItemAt(e, n) {
    let s, r, i;
    if (Hn(e, this.left, this.right) && Hn(n, this.top, this.bottom)) {
      for (i = this.legendHitBoxes, s = 0; s < i.length; ++s)
        if (r = i[s], Hn(e, r.left, r.left + r.width) && Hn(n, r.top, r.top + r.height))
          return this.legendItems[s];
    }
    return null;
  }
  handleEvent(e) {
    const n = this.options;
    if (!CI(e.type, n))
      return;
    const s = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const r = this._hoveredItem, i = vI(r, s);
      r && !i && Ne(n.onLeave, [
        e,
        r,
        this
      ], this), this._hoveredItem = s, s && !i && Ne(n.onHover, [
        e,
        s,
        this
      ], this);
    } else s && Ne(n.onClick, [
      e,
      s,
      this
    ], this);
  }
}
function xI(t, e, n, s, r) {
  const i = wI(s, t, e, n), o = SI(r, s, e.lineHeight);
  return {
    itemWidth: i,
    itemHeight: o
  };
}
function wI(t, e, n, s) {
  let r = t.text;
  return r && typeof r != "string" && (r = r.reduce((i, o) => i.length > o.length ? i : o)), e + n.size / 2 + s.measureText(r).width;
}
function SI(t, e, n) {
  let s = t;
  return typeof e.text != "string" && (s = aw(e, n)), s;
}
function aw(t, e) {
  const n = t.text ? t.text.length : 0;
  return e * n;
}
function CI(t, e) {
  return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup"));
}
var PI = {
  id: "legend",
  _element: zm,
  start(t, e, n) {
    const s = t.legend = new zm({
      ctx: t.ctx,
      options: n,
      chart: t
    });
    Ct.configure(t, s, n), Ct.addBox(t, s);
  },
  stop(t) {
    Ct.removeBox(t, t.legend), delete t.legend;
  },
  beforeUpdate(t, e, n) {
    const s = t.legend;
    Ct.configure(t, s, n), s.options = n;
  },
  afterUpdate(t) {
    const e = t.legend;
    e.buildLabels(), e.adjustHitBoxes();
  },
  afterEvent(t, e) {
    e.replay || t.legend.handleEvent(e.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(t, e, n) {
      const s = e.datasetIndex, r = n.chart;
      r.isDatasetVisible(s) ? (r.hide(s), e.hidden = !0) : (r.show(s), e.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (t) => t.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(t) {
        const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: s, textAlign: r, color: i, useBorderRadius: o, borderRadius: a } } = t.legend.options;
        return t._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(n ? 0 : void 0), u = qt(c.borderWidth);
          return {
            text: e[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: i,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: s || c.pointStyle,
            rotation: c.rotation,
            textAlign: r || c.textAlign,
            borderRadius: o && (a || c.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (t) => t.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (t) => !t.startsWith("on"),
    labels: {
      _scriptable: (t) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(t)
    }
  }
};
class $f extends ts {
  constructor(e) {
    super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, n) {
    const s = this.options;
    if (this.left = 0, this.top = 0, !s.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = e, this.height = this.bottom = n;
    const r = We(s.text) ? s.text.length : 1;
    this._padding = qt(s.padding);
    const i = r * ct(s.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = i : this.width = i;
  }
  isHorizontal() {
    const e = this.options.position;
    return e === "top" || e === "bottom";
  }
  _drawArgs(e) {
    const { top: n, left: s, bottom: r, right: i, options: o } = this, a = o.align;
    let l = 0, c, u, d;
    return this.isHorizontal() ? (u = xt(a, s, i), d = n + e, c = i - s) : (o.position === "left" ? (u = s + e, d = xt(a, r, n), l = ze * -0.5) : (u = i - e, d = xt(a, n, r), l = ze * 0.5), c = r - n), {
      titleX: u,
      titleY: d,
      maxWidth: c,
      rotation: l
    };
  }
  draw() {
    const e = this.ctx, n = this.options;
    if (!n.display)
      return;
    const s = ct(n.font), i = s.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(i);
    ar(e, n.text, 0, 0, s, {
      color: n.color,
      maxWidth: l,
      rotation: c,
      textAlign: Wf(n.align),
      textBaseline: "middle",
      translation: [
        o,
        a
      ]
    });
  }
}
function qI(t, e) {
  const n = new $f({
    ctx: t.ctx,
    options: e,
    chart: t
  });
  Ct.configure(t, n, e), Ct.addBox(t, n), t.titleBlock = n;
}
var EI = {
  id: "title",
  _element: $f,
  start(t, e, n) {
    qI(t, n);
  },
  stop(t) {
    const e = t.titleBlock;
    Ct.removeBox(t, e), delete t.titleBlock;
  },
  beforeUpdate(t, e, n) {
    const s = t.titleBlock;
    Ct.configure(t, s, n), s.options = n;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const la = /* @__PURE__ */ new WeakMap();
var TI = {
  id: "subtitle",
  start(t, e, n) {
    const s = new $f({
      ctx: t.ctx,
      options: n,
      chart: t
    });
    Ct.configure(t, s, n), Ct.addBox(t, s), la.set(t, s);
  },
  stop(t) {
    Ct.removeBox(t, la.get(t)), la.delete(t);
  },
  beforeUpdate(t, e, n) {
    const s = la.get(t);
    Ct.configure(t, s, n), s.options = n;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Ri = {
  average(t) {
    if (!t.length)
      return !1;
    let e, n, s = /* @__PURE__ */ new Set(), r = 0, i = 0;
    for (e = 0, n = t.length; e < n; ++e) {
      const a = t[e].element;
      if (a && a.hasValue()) {
        const l = a.tooltipPosition();
        s.add(l.x), r += l.y, ++i;
      }
    }
    return i === 0 || s.size === 0 ? !1 : {
      x: [
        ...s
      ].reduce((a, l) => a + l) / s.size,
      y: r / i
    };
  },
  nearest(t, e) {
    if (!t.length)
      return !1;
    let n = e.x, s = e.y, r = Number.POSITIVE_INFINITY, i, o, a;
    for (i = 0, o = t.length; i < o; ++i) {
      const l = t[i].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), u = zu(e, c);
        u < r && (r = u, a = l);
      }
    }
    if (a) {
      const l = a.tooltipPosition();
      n = l.x, s = l.y;
    }
    return {
      x: n,
      y: s
    };
  }
};
function bn(t, e) {
  return e && (We(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
}
function Vn(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t;
}
function RI(t, e) {
  const { element: n, datasetIndex: s, index: r } = e, i = t.getDatasetMeta(s).controller, { label: o, value: a } = i.getLabelAndValue(r);
  return {
    chart: t,
    label: o,
    parsed: i.getParsed(r),
    raw: t.data.datasets[s].data[r],
    formattedValue: a,
    dataset: i.getDataset(),
    dataIndex: r,
    datasetIndex: s,
    element: n
  };
}
function Um(t, e) {
  const n = t.chart.ctx, { body: s, footer: r, title: i } = t, { boxWidth: o, boxHeight: a } = e, l = ct(e.bodyFont), c = ct(e.titleFont), u = ct(e.footerFont), d = i.length, f = r.length, h = s.length, p = qt(e.padding);
  let g = p.height, A = 0, b = s.reduce((x, S) => x + S.before.length + S.lines.length + S.after.length, 0);
  if (b += t.beforeBody.length + t.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), b) {
    const x = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
    g += h * x + (b - h) * l.lineHeight + (b - 1) * e.bodySpacing;
  }
  f && (g += e.footerMarginTop + f * u.lineHeight + (f - 1) * e.footerSpacing);
  let y = 0;
  const w = function(x) {
    A = Math.max(A, n.measureText(x).width + y);
  };
  return n.save(), n.font = c.string, ke(t.title, w), n.font = l.string, ke(t.beforeBody.concat(t.afterBody), w), y = e.displayColors ? o + 2 + e.boxPadding : 0, ke(s, (x) => {
    ke(x.before, w), ke(x.lines, w), ke(x.after, w);
  }), y = 0, n.font = u.string, ke(t.footer, w), n.restore(), A += p.width, {
    width: A,
    height: g
  };
}
function kI(t, e) {
  const { y: n, height: s } = e;
  return n < s / 2 ? "top" : n > t.height - s / 2 ? "bottom" : "center";
}
function MI(t, e, n, s) {
  const { x: r, width: i } = s, o = n.caretSize + n.caretPadding;
  if (t === "left" && r + i + o > e.width || t === "right" && r - i - o < 0)
    return !0;
}
function DI(t, e, n, s) {
  const { x: r, width: i } = n, { width: o, chartArea: { left: a, right: l } } = t;
  let c = "center";
  return s === "center" ? c = r <= (a + l) / 2 ? "left" : "right" : r <= i / 2 ? c = "left" : r >= o - i / 2 && (c = "right"), MI(c, t, e, n) && (c = "center"), c;
}
function Wm(t, e, n) {
  const s = n.yAlign || e.yAlign || kI(t, n);
  return {
    xAlign: n.xAlign || e.xAlign || DI(t, e, n, s),
    yAlign: s
  };
}
function OI(t, e) {
  let { x: n, width: s } = t;
  return e === "right" ? n -= s : e === "center" && (n -= s / 2), n;
}
function LI(t, e, n) {
  let { y: s, height: r } = t;
  return e === "top" ? s += n : e === "bottom" ? s -= r + n : s -= r / 2, s;
}
function Hm(t, e, n, s) {
  const { caretSize: r, caretPadding: i, cornerRadius: o } = t, { xAlign: a, yAlign: l } = n, c = r + i, { topLeft: u, topRight: d, bottomLeft: f, bottomRight: h } = Js(o);
  let p = OI(e, a);
  const g = LI(e, l, c);
  return l === "center" ? a === "left" ? p += c : a === "right" && (p -= c) : a === "left" ? p -= Math.max(u, f) + r : a === "right" && (p += Math.max(d, h) + r), {
    x: pt(p, 0, s.width - e.width),
    y: pt(g, 0, s.height - e.height)
  };
}
function ca(t, e, n) {
  const s = qt(n.padding);
  return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - s.right : t.x + s.left;
}
function Qm(t) {
  return bn([], Vn(t));
}
function NI(t, e, n) {
  return Os(t, {
    tooltip: e,
    tooltipItems: n,
    type: "tooltip"
  });
}
function Ym(t, e) {
  const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
  return n ? t.override(n) : t;
}
const lw = {
  beforeTitle: Bn,
  title(t) {
    if (t.length > 0) {
      const e = t[0], n = e.chart.data.labels, s = n ? n.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return e.dataset.label || "";
      if (e.label)
        return e.label;
      if (s > 0 && e.dataIndex < s)
        return n[e.dataIndex];
    }
    return "";
  },
  afterTitle: Bn,
  beforeBody: Bn,
  beforeLabel: Bn,
  label(t) {
    if (this && this.options && this.options.mode === "dataset")
      return t.label + ": " + t.formattedValue || t.formattedValue;
    let e = t.dataset.label || "";
    e && (e += ": ");
    const n = t.formattedValue;
    return be(n) || (e += n), e;
  },
  labelColor(t) {
    const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(t) {
    const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      pointStyle: n.pointStyle,
      rotation: n.rotation
    };
  },
  afterLabel: Bn,
  afterBody: Bn,
  beforeFooter: Bn,
  footer: Bn,
  afterFooter: Bn
};
function It(t, e, n, s) {
  const r = t[e].call(n, s);
  return typeof r > "u" ? lw[e].call(n, s) : r;
}
class Zu extends ts {
  constructor(e) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(e) {
    this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const e = this._cachedAnimations;
    if (e)
      return e;
    const n = this.chart, s = this.options.setContext(this.getContext()), r = s.enabled && n.options.animation && s.animations, i = new zx(this.chart, r);
    return r._cacheable && (this._cachedAnimations = Object.freeze(i)), i;
  }
  getContext() {
    return this.$context || (this.$context = NI(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(e, n) {
    const { callbacks: s } = n, r = It(s, "beforeTitle", this, e), i = It(s, "title", this, e), o = It(s, "afterTitle", this, e);
    let a = [];
    return a = bn(a, Vn(r)), a = bn(a, Vn(i)), a = bn(a, Vn(o)), a;
  }
  getBeforeBody(e, n) {
    return Qm(It(n.callbacks, "beforeBody", this, e));
  }
  getBody(e, n) {
    const { callbacks: s } = n, r = [];
    return ke(e, (i) => {
      const o = {
        before: [],
        lines: [],
        after: []
      }, a = Ym(s, i);
      bn(o.before, Vn(It(a, "beforeLabel", this, i))), bn(o.lines, It(a, "label", this, i)), bn(o.after, Vn(It(a, "afterLabel", this, i))), r.push(o);
    }), r;
  }
  getAfterBody(e, n) {
    return Qm(It(n.callbacks, "afterBody", this, e));
  }
  getFooter(e, n) {
    const { callbacks: s } = n, r = It(s, "beforeFooter", this, e), i = It(s, "footer", this, e), o = It(s, "afterFooter", this, e);
    let a = [];
    return a = bn(a, Vn(r)), a = bn(a, Vn(i)), a = bn(a, Vn(o)), a;
  }
  _createItems(e) {
    const n = this._active, s = this.chart.data, r = [], i = [], o = [];
    let a = [], l, c;
    for (l = 0, c = n.length; l < c; ++l)
      a.push(RI(this.chart, n[l]));
    return e.filter && (a = a.filter((u, d, f) => e.filter(u, d, f, s))), e.itemSort && (a = a.sort((u, d) => e.itemSort(u, d, s))), ke(a, (u) => {
      const d = Ym(e.callbacks, u);
      r.push(It(d, "labelColor", this, u)), i.push(It(d, "labelPointStyle", this, u)), o.push(It(d, "labelTextColor", this, u));
    }), this.labelColors = r, this.labelPointStyles = i, this.labelTextColors = o, this.dataPoints = a, a;
  }
  update(e, n) {
    const s = this.options.setContext(this.getContext()), r = this._active;
    let i, o = [];
    if (!r.length)
      this.opacity !== 0 && (i = {
        opacity: 0
      });
    else {
      const a = Ri[s.position].call(this, r, this._eventPosition);
      o = this._createItems(s), this.title = this.getTitle(o, s), this.beforeBody = this.getBeforeBody(o, s), this.body = this.getBody(o, s), this.afterBody = this.getAfterBody(o, s), this.footer = this.getFooter(o, s);
      const l = this._size = Um(this, s), c = Object.assign({}, a, l), u = Wm(this.chart, s, c), d = Hm(s, c, u, this.chart);
      this.xAlign = u.xAlign, this.yAlign = u.yAlign, i = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = o, this.$context = void 0, i && this._resolveAnimations().update(this, i), e && s.external && s.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: n
    });
  }
  drawCaret(e, n, s, r) {
    const i = this.getCaretPosition(e, s, r);
    n.lineTo(i.x1, i.y1), n.lineTo(i.x2, i.y2), n.lineTo(i.x3, i.y3);
  }
  getCaretPosition(e, n, s) {
    const { xAlign: r, yAlign: i } = this, { caretSize: o, cornerRadius: a } = s, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: d } = Js(a), { x: f, y: h } = e, { width: p, height: g } = n;
    let A, b, y, w, x, S;
    return i === "center" ? (x = h + g / 2, r === "left" ? (A = f, b = A - o, w = x + o, S = x - o) : (A = f + p, b = A + o, w = x - o, S = x + o), y = A) : (r === "left" ? b = f + Math.max(l, u) + o : r === "right" ? b = f + p - Math.max(c, d) - o : b = this.caretX, i === "top" ? (w = h, x = w - o, A = b - o, y = b + o) : (w = h + g, x = w + o, A = b + o, y = b - o), S = w), {
      x1: A,
      x2: b,
      x3: y,
      y1: w,
      y2: x,
      y3: S
    };
  }
  drawTitle(e, n, s) {
    const r = this.title, i = r.length;
    let o, a, l;
    if (i) {
      const c = Lr(s.rtl, this.x, this.width);
      for (e.x = ca(this, s.titleAlign, s), n.textAlign = c.textAlign(s.titleAlign), n.textBaseline = "middle", o = ct(s.titleFont), a = s.titleSpacing, n.fillStyle = s.titleColor, n.font = o.string, l = 0; l < i; ++l)
        n.fillText(r[l], c.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === i && (e.y += s.titleMarginBottom - a);
    }
  }
  _drawColorBox(e, n, s, r, i) {
    const o = this.labelColors[s], a = this.labelPointStyles[s], { boxHeight: l, boxWidth: c } = i, u = ct(i.bodyFont), d = ca(this, "left", i), f = r.x(d), h = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, p = n.y + h;
    if (i.usePointStyle) {
      const g = {
        radius: Math.min(c, l) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, A = r.leftForLtr(f, c) + c / 2, b = p + l / 2;
      e.strokeStyle = i.multiKeyBackground, e.fillStyle = i.multiKeyBackground, Wu(e, g, A, b), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, Wu(e, g, A, b);
    } else {
      e.lineWidth = he(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0;
      const g = r.leftForLtr(f, c), A = r.leftForLtr(r.xPlus(f, 1), c - 2), b = Js(o.borderRadius);
      Object.values(b).some((y) => y !== 0) ? (e.beginPath(), e.fillStyle = i.multiKeyBackground, go(e, {
        x: g,
        y: p,
        w: c,
        h: l,
        radius: b
      }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), go(e, {
        x: A,
        y: p + 1,
        w: c - 2,
        h: l - 2,
        radius: b
      }), e.fill()) : (e.fillStyle = i.multiKeyBackground, e.fillRect(g, p, c, l), e.strokeRect(g, p, c, l), e.fillStyle = o.backgroundColor, e.fillRect(A, p + 1, c - 2, l - 2));
    }
    e.fillStyle = this.labelTextColors[s];
  }
  drawBody(e, n, s) {
    const { body: r } = this, { bodySpacing: i, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u } = s, d = ct(s.bodyFont);
    let f = d.lineHeight, h = 0;
    const p = Lr(s.rtl, this.x, this.width), g = function(E) {
      n.fillText(E, p.x(e.x + h), e.y + f / 2), e.y += f + i;
    }, A = p.textAlign(o);
    let b, y, w, x, S, q, C;
    for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, e.x = ca(this, A, s), n.fillStyle = s.bodyColor, ke(this.beforeBody, g), h = a && A !== "right" ? o === "center" ? c / 2 + u : c + 2 + u : 0, x = 0, q = r.length; x < q; ++x) {
      for (b = r[x], y = this.labelTextColors[x], n.fillStyle = y, ke(b.before, g), w = b.lines, a && w.length && (this._drawColorBox(n, e, x, p, s), f = Math.max(d.lineHeight, l)), S = 0, C = w.length; S < C; ++S)
        g(w[S]), f = d.lineHeight;
      ke(b.after, g);
    }
    h = 0, f = d.lineHeight, ke(this.afterBody, g), e.y -= i;
  }
  drawFooter(e, n, s) {
    const r = this.footer, i = r.length;
    let o, a;
    if (i) {
      const l = Lr(s.rtl, this.x, this.width);
      for (e.x = ca(this, s.footerAlign, s), e.y += s.footerMarginTop, n.textAlign = l.textAlign(s.footerAlign), n.textBaseline = "middle", o = ct(s.footerFont), n.fillStyle = s.footerColor, n.font = o.string, a = 0; a < i; ++a)
        n.fillText(r[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + s.footerSpacing;
    }
  }
  drawBackground(e, n, s, r) {
    const { xAlign: i, yAlign: o } = this, { x: a, y: l } = e, { width: c, height: u } = s, { topLeft: d, topRight: f, bottomLeft: h, bottomRight: p } = Js(r.cornerRadius);
    n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.beginPath(), n.moveTo(a + d, l), o === "top" && this.drawCaret(e, n, s, r), n.lineTo(a + c - f, l), n.quadraticCurveTo(a + c, l, a + c, l + f), o === "center" && i === "right" && this.drawCaret(e, n, s, r), n.lineTo(a + c, l + u - p), n.quadraticCurveTo(a + c, l + u, a + c - p, l + u), o === "bottom" && this.drawCaret(e, n, s, r), n.lineTo(a + h, l + u), n.quadraticCurveTo(a, l + u, a, l + u - h), o === "center" && i === "left" && this.drawCaret(e, n, s, r), n.lineTo(a, l + d), n.quadraticCurveTo(a, l, a + d, l), n.closePath(), n.fill(), r.borderWidth > 0 && n.stroke();
  }
  _updateAnimationTarget(e) {
    const n = this.chart, s = this.$animations, r = s && s.x, i = s && s.y;
    if (r || i) {
      const o = Ri[e.position].call(this, this._active, this._eventPosition);
      if (!o)
        return;
      const a = this._size = Um(this, e), l = Object.assign({}, o, this._size), c = Wm(n, e, l), u = Hm(e, l, c, n);
      (r._to !== u.x || i._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, u));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(e) {
    const n = this.options.setContext(this.getContext());
    let s = this.opacity;
    if (!s)
      return;
    this._updateAnimationTarget(n);
    const r = {
      width: this.width,
      height: this.height
    }, i = {
      x: this.x,
      y: this.y
    };
    s = Math.abs(s) < 1e-3 ? 0 : s;
    const o = qt(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && a && (e.save(), e.globalAlpha = s, this.drawBackground(i, e, r, n), jx(e, n.textDirection), i.y += o.top, this.drawTitle(i, e, n), this.drawBody(i, e, n), this.drawFooter(i, e, n), Bx(e, n.textDirection), e.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e, n) {
    const s = this._active, r = e.map(({ datasetIndex: a, index: l }) => {
      const c = this.chart.getDatasetMeta(a);
      if (!c)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: c.data[l],
        index: l
      };
    }), i = !fl(s, r), o = this._positionChanged(r, n);
    (i || o) && (this._active = r, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(e, n, s = !0) {
    if (n && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const r = this.options, i = this._active || [], o = this._getActiveElements(e, i, n, s), a = this._positionChanged(o, e), l = n || !fl(o, i) || a;
    return l && (this._active = o, (r.enabled || r.external) && (this._eventPosition = {
      x: e.x,
      y: e.y
    }, this.update(!0, n))), l;
  }
  _getActiveElements(e, n, s, r) {
    const i = this.options;
    if (e.type === "mouseout")
      return [];
    if (!r)
      return n.filter((a) => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
    const o = this.chart.getElementsAtEventForMode(e, i.mode, i, s);
    return i.reverse && o.reverse(), o;
  }
  _positionChanged(e, n) {
    const { caretX: s, caretY: r, options: i } = this, o = Ri[i.position].call(this, e, n);
    return o !== !1 && (s !== o.x || r !== o.y);
  }
}
W(Zu, "positioners", Ri);
var jI = {
  id: "tooltip",
  _element: Zu,
  positioners: Ri,
  afterInit(t, e, n) {
    n && (t.tooltip = new Zu({
      chart: t,
      options: n
    }));
  },
  beforeUpdate(t, e, n) {
    t.tooltip && t.tooltip.initialize(n);
  },
  reset(t, e, n) {
    t.tooltip && t.tooltip.initialize(n);
  },
  afterDraw(t) {
    const e = t.tooltip;
    if (e && e._willRender()) {
      const n = {
        tooltip: e
      };
      if (t.notifyPlugins("beforeTooltipDraw", {
        ...n,
        cancelable: !0
      }) === !1)
        return;
      e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n);
    }
  },
  afterEvent(t, e) {
    if (t.tooltip) {
      const n = e.replay;
      t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (t, e) => e.bodyFont.size,
    boxWidth: (t, e) => e.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: lw
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (t) => t !== "filter" && t !== "itemSort" && t !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, BI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: GB,
  Decimation: $B,
  Filler: yI,
  Legend: PI,
  SubTitle: TI,
  Title: EI,
  Tooltip: jI
});
const II = (t, e, n, s) => (typeof e == "string" ? (n = t.push(e) - 1, s.unshift({
  index: n,
  label: e
})) : isNaN(e) && (n = null), n);
function FI(t, e, n, s) {
  const r = t.indexOf(e);
  if (r === -1)
    return II(t, e, n, s);
  const i = t.lastIndexOf(e);
  return r !== i ? n : r;
}
const VI = (t, e) => t === null ? null : pt(Math.round(t), 0, e);
function Km(t) {
  const e = this.getLabels();
  return t >= 0 && t < e.length ? e[t] : t;
}
class _u extends ur {
  constructor(e) {
    super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(e) {
    const n = this._addedLabels;
    if (n.length) {
      const s = this.getLabels();
      for (const { index: r, label: i } of n)
        s[r] === i && s.splice(r, 1);
      this._addedLabels = [];
    }
    super.init(e);
  }
  parse(e, n) {
    if (be(e))
      return null;
    const s = this.getLabels();
    return n = isFinite(n) && s[n] === e ? n : FI(s, e, le(n, e), this._addedLabels), VI(n, s.length - 1);
  }
  determineDataLimits() {
    const { minDefined: e, maxDefined: n } = this.getUserBounds();
    let { min: s, max: r } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (e || (s = 0), n || (r = this.getLabels().length - 1)), this.min = s, this.max = r;
  }
  buildTicks() {
    const e = this.min, n = this.max, s = this.options.offset, r = [];
    let i = this.getLabels();
    i = e === 0 && n === i.length - 1 ? i : i.slice(e, n + 1), this._valueRange = Math.max(i.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);
    for (let o = e; o <= n; o++)
      r.push({
        value: o
      });
    return r;
  }
  getLabelForValue(e) {
    return Km.call(this, e);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(e) {
    return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getPixelForTick(e) {
    const n = this.ticks;
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value);
  }
  getValueForPixel(e) {
    return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
W(_u, "id", "category"), W(_u, "defaults", {
  ticks: {
    callback: Km
  }
});
function zI(t, e) {
  const n = [], { bounds: r, step: i, min: o, max: a, precision: l, count: c, maxTicks: u, maxDigits: d, includeBounds: f } = t, h = i || 1, p = u - 1, { min: g, max: A } = e, b = !be(o), y = !be(a), w = !be(c), x = (A - g) / (d + 1);
  let S = zg((A - g) / p / h) * h, q, C, E, T;
  if (S < 1e-14 && !b && !y)
    return [
      {
        value: g
      },
      {
        value: A
      }
    ];
  T = Math.ceil(A / S) - Math.floor(g / S), T > p && (S = zg(T * S / p / h) * h), be(l) || (q = Math.pow(10, l), S = Math.ceil(S * q) / q), r === "ticks" ? (C = Math.floor(g / S) * S, E = Math.ceil(A / S) * S) : (C = g, E = A), b && y && i && NL((a - o) / i, S / 1e3) ? (T = Math.round(Math.min((a - o) / S, u)), S = (a - o) / T, C = o, E = a) : w ? (C = b ? o : C, E = y ? a : E, T = c - 1, S = (E - C) / T) : (T = (E - C) / S, ji(T, Math.round(T), S / 1e3) ? T = Math.round(T) : T = Math.ceil(T));
  const k = Math.max(Ug(S), Ug(C));
  q = Math.pow(10, be(l) ? k : l), C = Math.round(C * q) / q, E = Math.round(E * q) / q;
  let R = 0;
  for (b && (f && C !== o ? (n.push({
    value: o
  }), C < o && R++, ji(Math.round((C + R * S) * q) / q, o, Xm(o, x, t)) && R++) : C < o && R++); R < T; ++R) {
    const D = Math.round((C + R * S) * q) / q;
    if (y && D > a)
      break;
    n.push({
      value: D
    });
  }
  return y && f && E !== a ? n.length && ji(n[n.length - 1].value, a, Xm(a, x, t)) ? n[n.length - 1].value = a : n.push({
    value: a
  }) : (!y || E === a) && n.push({
    value: E
  }), n;
}
function Xm(t, e, { horizontal: n, minRotation: s }) {
  const r = un(s), i = (n ? Math.sin(r) : Math.cos(r)) || 1e-3, o = 0.75 * e * ("" + t).length;
  return Math.min(e / i, o);
}
class yl extends ur {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(e, n) {
    return be(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
  }
  handleTickRangeOptions() {
    const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: s } = this.getUserBounds();
    let { min: r, max: i } = this;
    const o = (l) => r = n ? r : l, a = (l) => i = s ? i : l;
    if (e) {
      const l = qn(r), c = qn(i);
      l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0);
    }
    if (r === i) {
      let l = i === 0 ? 1 : Math.abs(i * 0.05);
      a(i + l), e || o(r - l);
    }
    this.min = r, this.max = i;
  }
  getTickLimit() {
    const e = this.options.ticks;
    let { maxTicksLimit: n, stepSize: s } = e, r;
    return s ? (r = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), n = n || 11), n && (r = Math.min(n, r)), r;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const e = this.options, n = e.ticks;
    let s = this.getTickLimit();
    s = Math.max(2, s);
    const r = {
      maxTicks: s,
      bounds: e.bounds,
      min: e.min,
      max: e.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== !1
    }, i = this._range || this, o = zI(r, i);
    return e.bounds === "ticks" && yx(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
  }
  configure() {
    const e = this.ticks;
    let n = this.min, s = this.max;
    if (super.configure(), this.options.offset && e.length) {
      const r = (s - n) / Math.max(e.length - 1, 1) / 2;
      n -= r, s += r;
    }
    this._startValue = n, this._endValue = s, this._valueRange = s - n;
  }
  getLabelForValue(e) {
    return ko(e, this.chart.options.locale, this.options.ticks.format);
  }
}
class Ju extends yl {
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!0);
    this.min = Ge(e) ? e : 0, this.max = Ge(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const e = this.isHorizontal(), n = e ? this.width : this.height, s = un(this.options.ticks.minRotation), r = (e ? Math.sin(s) : Math.cos(s)) || 1e-3, i = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, i.lineHeight / r));
  }
  getPixelForValue(e) {
    return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
  }
}
W(Ju, "id", "linear"), W(Ju, "defaults", {
  ticks: {
    callback: Xl.formatters.numeric
  }
});
const Ao = (t) => Math.floor(ds(t)), zs = (t, e) => Math.pow(10, Ao(t) + e);
function Gm(t) {
  return t / Math.pow(10, Ao(t)) === 1;
}
function Zm(t, e, n) {
  const s = Math.pow(10, n), r = Math.floor(t / s);
  return Math.ceil(e / s) - r;
}
function UI(t, e) {
  const n = e - t;
  let s = Ao(n);
  for (; Zm(t, e, s) > 10; )
    s++;
  for (; Zm(t, e, s) < 10; )
    s--;
  return Math.min(s, Ao(t));
}
function WI(t, { min: e, max: n }) {
  e = Qt(t.min, e);
  const s = [], r = Ao(e);
  let i = UI(e, n), o = i < 0 ? Math.pow(10, Math.abs(i)) : 1;
  const a = Math.pow(10, i), l = r > i ? Math.pow(10, r) : 0, c = Math.round((e - l) * o) / o, u = Math.floor((e - l) / a / 10) * a * 10;
  let d = Math.floor((c - u) / Math.pow(10, i)), f = Qt(t.min, Math.round((l + u + d * Math.pow(10, i)) * o) / o);
  for (; f < n; )
    s.push({
      value: f,
      major: Gm(f),
      significand: d
    }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (i++, d = 2, o = i >= 0 ? 1 : o), f = Math.round((l + u + d * Math.pow(10, i)) * o) / o;
  const h = Qt(t.max, f);
  return s.push({
    value: h,
    major: Gm(h),
    significand: d
  }), s;
}
class $u extends ur {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(e, n) {
    const s = yl.prototype.parse.apply(this, [
      e,
      n
    ]);
    if (s === 0) {
      this._zero = !0;
      return;
    }
    return Ge(s) && s > 0 ? s : null;
  }
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!0);
    this.min = Ge(e) ? Math.max(0, e) : null, this.max = Ge(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Ge(this._userMin) && (this.min = e === zs(this.min, 0) ? zs(this.min, -1) : zs(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: e, maxDefined: n } = this.getUserBounds();
    let s = this.min, r = this.max;
    const i = (a) => s = e ? s : a, o = (a) => r = n ? r : a;
    s === r && (s <= 0 ? (i(1), o(10)) : (i(zs(s, -1)), o(zs(r, 1)))), s <= 0 && i(zs(r, -1)), r <= 0 && o(zs(s, 1)), this.min = s, this.max = r;
  }
  buildTicks() {
    const e = this.options, n = {
      min: this._userMin,
      max: this._userMax
    }, s = WI(n, this);
    return e.bounds === "ticks" && yx(s, this, "value"), e.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
  }
  getLabelForValue(e) {
    return e === void 0 ? "0" : ko(e, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const e = this.min;
    super.configure(), this._startValue = ds(e), this._valueRange = ds(this.max) - ds(e);
  }
  getPixelForValue(e) {
    return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (ds(e) - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    const n = this.getDecimalForPixel(e);
    return Math.pow(10, this._startValue + n * this._valueRange);
  }
}
W($u, "id", "logarithmic"), W($u, "defaults", {
  ticks: {
    callback: Xl.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function ed(t) {
  const e = t.ticks;
  if (e.display && t.display) {
    const n = qt(e.backdropPadding);
    return le(e.font && e.font.size, Ze.font.size) + n.height;
  }
  return 0;
}
function HI(t, e, n) {
  return n = We(n) ? n : [
    n
  ], {
    w: JL(t, e.string, n),
    h: n.length * e.lineHeight
  };
}
function _m(t, e, n, s, r) {
  return t === s || t === r ? {
    start: e - n / 2,
    end: e + n / 2
  } : t < s || t > r ? {
    start: e - n,
    end: e
  } : {
    start: e,
    end: e + n
  };
}
function QI(t) {
  const e = {
    l: t.left + t._padding.left,
    r: t.right - t._padding.right,
    t: t.top + t._padding.top,
    b: t.bottom - t._padding.bottom
  }, n = Object.assign({}, e), s = [], r = [], i = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? ze / i : 0;
  for (let l = 0; l < i; l++) {
    const c = o.setContext(t.getPointLabelContext(l));
    r[l] = c.padding;
    const u = t.getPointPosition(l, t.drawingArea + r[l], a), d = ct(c.font), f = HI(t.ctx, d, t._pointLabels[l]);
    s[l] = f;
    const h = Yt(t.getIndexAngle(l) + a), p = Math.round(zf(h)), g = _m(p, u.x, f.w, 0, 180), A = _m(p, u.y, f.h, 90, 270);
    YI(n, e, h, g, A);
  }
  t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = GI(t, s, r);
}
function YI(t, e, n, s, r) {
  const i = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n));
  let a = 0, l = 0;
  s.start < e.l ? (a = (e.l - s.start) / i, t.l = Math.min(t.l, e.l - a)) : s.end > e.r && (a = (s.end - e.r) / i, t.r = Math.max(t.r, e.r + a)), r.start < e.t ? (l = (e.t - r.start) / o, t.t = Math.min(t.t, e.t - l)) : r.end > e.b && (l = (r.end - e.b) / o, t.b = Math.max(t.b, e.b + l));
}
function KI(t, e, n) {
  const s = t.drawingArea, { extra: r, additionalAngle: i, padding: o, size: a } = n, l = t.getPointPosition(e, s + r + o, i), c = Math.round(zf(Yt(l.angle + et))), u = JI(l.y, a.h, c), d = ZI(c), f = _I(l.x, a.w, d);
  return {
    visible: !0,
    x: l.x,
    y: u,
    textAlign: d,
    left: f,
    top: u,
    right: f + a.w,
    bottom: u + a.h
  };
}
function XI(t, e) {
  if (!e)
    return !0;
  const { left: n, top: s, right: r, bottom: i } = t;
  return !(Yn({
    x: n,
    y: s
  }, e) || Yn({
    x: n,
    y: i
  }, e) || Yn({
    x: r,
    y: s
  }, e) || Yn({
    x: r,
    y: i
  }, e));
}
function GI(t, e, n) {
  const s = [], r = t._pointLabels.length, i = t.options, { centerPointLabels: o, display: a } = i.pointLabels, l = {
    extra: ed(i) / 2,
    additionalAngle: o ? ze / r : 0
  };
  let c;
  for (let u = 0; u < r; u++) {
    l.padding = n[u], l.size = e[u];
    const d = KI(t, u, l);
    s.push(d), a === "auto" && (d.visible = XI(d, c), d.visible && (c = d));
  }
  return s;
}
function ZI(t) {
  return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right";
}
function _I(t, e, n) {
  return n === "right" ? t -= e : n === "center" && (t -= e / 2), t;
}
function JI(t, e, n) {
  return n === 90 || n === 270 ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t;
}
function $I(t, e, n) {
  const { left: s, top: r, right: i, bottom: o } = n, { backdropColor: a } = e;
  if (!be(a)) {
    const l = Js(e.borderRadius), c = qt(e.backdropPadding);
    t.fillStyle = a;
    const u = s - c.left, d = r - c.top, f = i - s + c.width, h = o - r + c.height;
    Object.values(l).some((p) => p !== 0) ? (t.beginPath(), go(t, {
      x: u,
      y: d,
      w: f,
      h,
      radius: l
    }), t.fill()) : t.fillRect(u, d, f, h);
  }
}
function e9(t, e) {
  const { ctx: n, options: { pointLabels: s } } = t;
  for (let r = e - 1; r >= 0; r--) {
    const i = t._pointLabelItems[r];
    if (!i.visible)
      continue;
    const o = s.setContext(t.getPointLabelContext(r));
    $I(n, o, i);
    const a = ct(o.font), { x: l, y: c, textAlign: u } = i;
    ar(n, t._pointLabels[r], l, c + a.lineHeight / 2, a, {
      color: o.color,
      textAlign: u,
      textBaseline: "middle"
    });
  }
}
function cw(t, e, n, s) {
  const { ctx: r } = t;
  if (n)
    r.arc(t.xCenter, t.yCenter, e, 0, Ve);
  else {
    let i = t.getPointPosition(0, e);
    r.moveTo(i.x, i.y);
    for (let o = 1; o < s; o++)
      i = t.getPointPosition(o, e), r.lineTo(i.x, i.y);
  }
}
function t9(t, e, n, s, r) {
  const i = t.ctx, o = e.circular, { color: a, lineWidth: l } = e;
  !o && !s || !a || !l || n < 0 || (i.save(), i.strokeStyle = a, i.lineWidth = l, i.setLineDash(r.dash), i.lineDashOffset = r.dashOffset, i.beginPath(), cw(t, n, o, s), i.closePath(), i.stroke(), i.restore());
}
function n9(t, e, n) {
  return Os(t, {
    label: n,
    index: e,
    type: "pointLabel"
  });
}
class ki extends yl {
  constructor(e) {
    super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const e = this._padding = qt(ed(this.options) / 2), n = this.width = this.maxWidth - e.width, s = this.height = this.maxHeight - e.height;
    this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + s / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, s) / 2);
  }
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!1);
    this.min = Ge(e) && !isNaN(e) ? e : 0, this.max = Ge(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / ed(this.options));
  }
  generateTickLabels(e) {
    yl.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, s) => {
      const r = Ne(this.options.pointLabels.callback, [
        n,
        s
      ], this);
      return r || r === 0 ? r : "";
    }).filter((n, s) => this.chart.getDataVisibility(s));
  }
  fit() {
    const e = this.options;
    e.display && e.pointLabels.display ? QI(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(e, n, s, r) {
    this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((s - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, s, r));
  }
  getIndexAngle(e) {
    const n = Ve / (this._pointLabels.length || 1), s = this.options.startAngle || 0;
    return Yt(e * n + un(s));
  }
  getDistanceFromCenterForValue(e) {
    if (be(e))
      return NaN;
    const n = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - e) * n : (e - this.min) * n;
  }
  getValueForDistanceFromCenter(e) {
    if (be(e))
      return NaN;
    const n = e / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - n : this.min + n;
  }
  getPointLabelContext(e) {
    const n = this._pointLabels || [];
    if (e >= 0 && e < n.length) {
      const s = n[e];
      return n9(this.getContext(), e, s);
    }
  }
  getPointPosition(e, n, s = 0) {
    const r = this.getIndexAngle(e) - et + s;
    return {
      x: Math.cos(r) * n + this.xCenter,
      y: Math.sin(r) * n + this.yCenter,
      angle: r
    };
  }
  getPointPositionForValue(e, n) {
    return this.getPointPosition(e, this.getDistanceFromCenterForValue(n));
  }
  getBasePosition(e) {
    return this.getPointPositionForValue(e || 0, this.getBaseValue());
  }
  getPointLabelPosition(e) {
    const { left: n, top: s, right: r, bottom: i } = this._pointLabelItems[e];
    return {
      left: n,
      top: s,
      right: r,
      bottom: i
    };
  }
  drawBackground() {
    const { backgroundColor: e, grid: { circular: n } } = this.options;
    if (e) {
      const s = this.ctx;
      s.save(), s.beginPath(), cw(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), s.closePath(), s.fillStyle = e, s.fill(), s.restore();
    }
  }
  drawGrid() {
    const e = this.ctx, n = this.options, { angleLines: s, grid: r, border: i } = n, o = this._pointLabels.length;
    let a, l, c;
    if (n.pointLabels.display && e9(this, o), r.display && this.ticks.forEach((u, d) => {
      if (d !== 0 || d === 0 && this.min < 0) {
        l = this.getDistanceFromCenterForValue(u.value);
        const f = this.getContext(d), h = r.setContext(f), p = i.setContext(f);
        t9(this, h, l, o, p);
      }
    }), s.display) {
      for (e.save(), a = o - 1; a >= 0; a--) {
        const u = s.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: f } = u;
        !f || !d || (e.lineWidth = f, e.strokeStyle = d, e.setLineDash(u.borderDash), e.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(n.reverse ? this.min : this.max), c = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(c.x, c.y), e.stroke());
      }
      e.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const e = this.ctx, n = this.options, s = n.ticks;
    if (!s.display)
      return;
    const r = this.getIndexAngle(0);
    let i, o;
    e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => {
      if (l === 0 && this.min >= 0 && !n.reverse)
        return;
      const c = s.setContext(this.getContext(l)), u = ct(c.font);
      if (i = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
        e.font = u.string, o = e.measureText(a.label).width, e.fillStyle = c.backdropColor;
        const d = qt(c.backdropPadding);
        e.fillRect(-o / 2 - d.left, -i - u.size / 2 - d.top, o + d.width, u.size + d.height);
      }
      ar(e, a.label, 0, -i, u, {
        color: c.color,
        strokeColor: c.textStrokeColor,
        strokeWidth: c.textStrokeWidth
      });
    }), e.restore();
  }
  drawTitle() {
  }
}
W(ki, "id", "radialLinear"), W(ki, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: Xl.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(e) {
      return e;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), W(ki, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), W(ki, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const Jl = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Vt = /* @__PURE__ */ Object.keys(Jl);
function Jm(t, e) {
  return t - e;
}
function $m(t, e) {
  if (be(e))
    return null;
  const n = t._adapter, { parser: s, round: r, isoWeekday: i } = t._parseOpts;
  let o = e;
  return typeof s == "function" && (o = s(o)), Ge(o) || (o = typeof s == "string" ? n.parse(o, s) : n.parse(o)), o === null ? null : (r && (o = r === "week" && (Qr(i) || i === !0) ? n.startOf(o, "isoWeek", i) : n.startOf(o, r)), +o);
}
function eA(t, e, n, s) {
  const r = Vt.length;
  for (let i = Vt.indexOf(t); i < r - 1; ++i) {
    const o = Jl[Vt[i]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
    if (o.common && Math.ceil((n - e) / (a * o.size)) <= s)
      return Vt[i];
  }
  return Vt[r - 1];
}
function s9(t, e, n, s, r) {
  for (let i = Vt.length - 1; i >= Vt.indexOf(n); i--) {
    const o = Vt[i];
    if (Jl[o].common && t._adapter.diff(r, s, o) >= e - 1)
      return o;
  }
  return Vt[n ? Vt.indexOf(n) : 0];
}
function r9(t) {
  for (let e = Vt.indexOf(t) + 1, n = Vt.length; e < n; ++e)
    if (Jl[Vt[e]].common)
      return Vt[e];
}
function tA(t, e, n) {
  if (!n)
    t[e] = !0;
  else if (n.length) {
    const { lo: s, hi: r } = Uf(n, e), i = n[s] >= e ? n[s] : n[r];
    t[i] = !0;
  }
}
function i9(t, e, n, s) {
  const r = t._adapter, i = +r.startOf(e[0].value, s), o = e[e.length - 1].value;
  let a, l;
  for (a = i; a <= o; a = +r.add(a, 1, s))
    l = n[a], l >= 0 && (e[l].major = !0);
  return e;
}
function nA(t, e, n) {
  const s = [], r = {}, i = e.length;
  let o, a;
  for (o = 0; o < i; ++o)
    a = e[o], r[a] = o, s.push({
      value: a,
      major: !1
    });
  return i === 0 || !n ? s : i9(t, s, r, n);
}
class bo extends ur {
  constructor(e) {
    super(e), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(e, n = {}) {
    const s = e.time || (e.time = {}), r = this._adapter = new pj._date(e.adapters.date);
    r.init(n), Ni(s.displayFormats, r.formats()), this._parseOpts = {
      parser: s.parser,
      round: s.round,
      isoWeekday: s.isoWeekday
    }, super.init(e), this._normalized = n.normalized;
  }
  parse(e, n) {
    return e === void 0 ? null : $m(this, e);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const e = this.options, n = this._adapter, s = e.time.unit || "day";
    let { min: r, max: i, minDefined: o, maxDefined: a } = this.getUserBounds();
    function l(c) {
      !o && !isNaN(c.min) && (r = Math.min(r, c.min)), !a && !isNaN(c.max) && (i = Math.max(i, c.max));
    }
    (!o || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(!1))), r = Ge(r) && !isNaN(r) ? r : +n.startOf(Date.now(), s), i = Ge(i) && !isNaN(i) ? i : +n.endOf(Date.now(), s) + 1, this.min = Math.min(r, i - 1), this.max = Math.max(r + 1, i);
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    return e.length && (n = e[0], s = e[e.length - 1]), {
      min: n,
      max: s
    };
  }
  buildTicks() {
    const e = this.options, n = e.time, s = e.ticks, r = s.source === "labels" ? this.getLabelTimestamps() : this._generate();
    e.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
    const i = this.min, o = this.max, a = FL(r, i, o);
    return this._unit = n.unit || (s.autoSkip ? eA(n.minUnit, this.min, this.max, this._getLabelCapacity(i)) : s9(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === "year" ? void 0 : r9(this._unit), this.initOffsets(r), e.reverse && a.reverse(), nA(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
  }
  initOffsets(e = []) {
    let n = 0, s = 0, r, i;
    this.options.offset && e.length && (r = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - r : n = (this.getDecimalForValue(e[1]) - r) / 2, i = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? s = i : s = (i - this.getDecimalForValue(e[e.length - 2])) / 2);
    const o = e.length < 3 ? 0.5 : 0.25;
    n = pt(n, 0, o), s = pt(s, 0, o), this._offsets = {
      start: n,
      end: s,
      factor: 1 / (n + 1 + s)
    };
  }
  _generate() {
    const e = this._adapter, n = this.min, s = this.max, r = this.options, i = r.time, o = i.unit || eA(i.minUnit, n, s, this._getLabelCapacity(n)), a = le(r.ticks.stepSize, 1), l = o === "week" ? i.isoWeekday : !1, c = Qr(l) || l === !0, u = {};
    let d = n, f, h;
    if (c && (d = +e.startOf(d, "isoWeek", l)), d = +e.startOf(d, c ? "day" : o), e.diff(s, n, o) > 1e5 * a)
      throw new Error(n + " and " + s + " are too far apart with stepSize of " + a + " " + o);
    const p = r.ticks.source === "data" && this.getDataTimestamps();
    for (f = d, h = 0; f < s; f = +e.add(f, a, o), h++)
      tA(u, f, p);
    return (f === s || r.bounds === "ticks" || h === 1) && tA(u, f, p), Object.keys(u).sort(Jm).map((g) => +g);
  }
  getLabelForValue(e) {
    const n = this._adapter, s = this.options.time;
    return s.tooltipFormat ? n.format(e, s.tooltipFormat) : n.format(e, s.displayFormats.datetime);
  }
  format(e, n) {
    const r = this.options.time.displayFormats, i = this._unit, o = n || r[i];
    return this._adapter.format(e, o);
  }
  _tickFormatFunction(e, n, s, r) {
    const i = this.options, o = i.ticks.callback;
    if (o)
      return Ne(o, [
        e,
        n,
        s
      ], this);
    const a = i.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && a[l], d = c && a[c], f = s[n], h = c && d && f && f.major;
    return this._adapter.format(e, r || (h ? d : u));
  }
  generateTickLabels(e) {
    let n, s, r;
    for (n = 0, s = e.length; n < s; ++n)
      r = e[n], r.label = this._tickFormatFunction(r.value, n, e);
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min);
  }
  getPixelForValue(e) {
    const n = this._offsets, s = this.getDecimalForValue(e);
    return this.getPixelForDecimal((n.start + s) * n.factor);
  }
  getValueForPixel(e) {
    const n = this._offsets, s = this.getDecimalForPixel(e) / n.factor - n.end;
    return this.min + s * (this.max - this.min);
  }
  _getLabelSize(e) {
    const n = this.options.ticks, s = this.ctx.measureText(e).width, r = un(this.isHorizontal() ? n.maxRotation : n.minRotation), i = Math.cos(r), o = Math.sin(r), a = this._resolveTickFontOptions(0).size;
    return {
      w: s * i + a * o,
      h: s * o + a * i
    };
  }
  _getLabelCapacity(e) {
    const n = this.options.time, s = n.displayFormats, r = s[n.unit] || s.millisecond, i = this._tickFormatFunction(e, 0, nA(this, [
      e
    ], this._majorUnit), r), o = this._getLabelSize(i), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let e = this._cache.data || [], n, s;
    if (e.length)
      return e;
    const r = this.getMatchingVisibleMetas();
    if (this._normalized && r.length)
      return this._cache.data = r[0].controller.getAllParsedValues(this);
    for (n = 0, s = r.length; n < s; ++n)
      e = e.concat(r[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(e);
  }
  getLabelTimestamps() {
    const e = this._cache.labels || [];
    let n, s;
    if (e.length)
      return e;
    const r = this.getLabels();
    for (n = 0, s = r.length; n < s; ++n)
      e.push($m(this, r[n]));
    return this._cache.labels = this._normalized ? e : this.normalize(e);
  }
  normalize(e) {
    return wx(e.sort(Jm));
  }
}
W(bo, "id", "time"), W(bo, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function ua(t, e, n) {
  let s = 0, r = t.length - 1, i, o, a, l;
  n ? (e >= t[s].pos && e <= t[r].pos && ({ lo: s, hi: r } = Qn(t, "pos", e)), { pos: i, time: a } = t[s], { pos: o, time: l } = t[r]) : (e >= t[s].time && e <= t[r].time && ({ lo: s, hi: r } = Qn(t, "time", e)), { time: i, pos: a } = t[s], { time: o, pos: l } = t[r]);
  const c = o - i;
  return c ? a + (l - a) * (e - i) / c : a;
}
class td extends bo {
  constructor(e) {
    super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e);
    this._minPos = ua(n, this.min), this._tableRange = ua(n, this.max) - this._minPos, super.initOffsets(e);
  }
  buildLookupTable(e) {
    const { min: n, max: s } = this, r = [], i = [];
    let o, a, l, c, u;
    for (o = 0, a = e.length; o < a; ++o)
      c = e[o], c >= n && c <= s && r.push(c);
    if (r.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: s,
          pos: 1
        }
      ];
    for (o = 0, a = r.length; o < a; ++o)
      u = r[o + 1], l = r[o - 1], c = r[o], Math.round((u + l) / 2) !== c && i.push({
        time: c,
        pos: o / (a - 1)
      });
    return i;
  }
  _generate() {
    const e = this.min, n = this.max;
    let s = super.getDataTimestamps();
    return (!s.includes(e) || !s.length) && s.splice(0, 0, e), (!s.includes(n) || s.length === 1) && s.push(n), s.sort((r, i) => r - i);
  }
  _getTimestampsForTable() {
    let e = this._cache.all || [];
    if (e.length)
      return e;
    const n = this.getDataTimestamps(), s = this.getLabelTimestamps();
    return n.length && s.length ? e = this.normalize(n.concat(s)) : e = n.length ? n : s, e = this._cache.all = e, e;
  }
  getDecimalForValue(e) {
    return (ua(this._table, e) - this._minPos) / this._tableRange;
  }
  getValueForPixel(e) {
    const n = this._offsets, s = this.getDecimalForPixel(e) / n.factor - n.end;
    return ua(this._table, s * this._tableRange + this._minPos, !0);
  }
}
W(td, "id", "timeseries"), W(td, "defaults", bo.defaults);
var o9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: _u,
  LinearScale: Ju,
  LogarithmicScale: $u,
  RadialLinearScale: ki,
  TimeScale: bo,
  TimeSeriesScale: td
});
const a9 = [
  hj,
  WB,
  BI,
  o9
];
Un.register(...a9);
const sA = {
  profit: [0],
  wins: 0,
  losses: 0,
  history: []
}, Do = Gr((t) => ({
  ...sA,
  updateProfitData: (e, n) => t((s) => {
    const i = s.profit[s.profit.length - 1] + e;
    return {
      profit: [...s.profit, i],
      wins: n ? s.wins + 1 : s.wins,
      losses: n ? s.losses : s.losses + 1,
      history: [...s.history, e]
    };
  }),
  resetProfitData: () => t(sA)
})), uw = () => {
  const { selectedCurrency: t } = it();
  return Fe((n) => {
    const s = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: t.currencyCode,
      minimumFractionDigits: t.fractionalDigits,
      maximumFractionDigits: t.fractionalDigits
    }).format(n);
    return t.currencyCode === "BTC" ? s.replace(/BTC/, "₿") : s;
  }, [t]);
}, rA = "rgb(74, 222, 128)", iA = "rgb(248, 113, 113)";
function l9() {
  const { profit: t, wins: e, losses: n } = Do(), s = uw(), r = t.length > 0 ? t[t.length - 1] : 0;
  return /* @__PURE__ */ m.jsxs("div", { className: "flex rounded-md bg-primary p-4 text-sm", children: [
    /* @__PURE__ */ m.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ m.jsx("p", { className: "font-medium text-slate-400", children: "Profit" }),
      /* @__PURE__ */ m.jsx(
        "p",
        {
          className: `font-semibold tabular-nums ${r >= 0 ? "text-green-400" : "text-red-400"}`,
          children: s(r)
        }
      )
    ] }),
    /* @__PURE__ */ m.jsx("div", { className: "mx-4 w-0.5 bg-slate-600", "aria-hidden": !0 }),
    /* @__PURE__ */ m.jsxs("div", { className: "flex-1 space-y-2", children: [
      /* @__PURE__ */ m.jsxs("div", { children: [
        /* @__PURE__ */ m.jsx("p", { className: "font-medium text-slate-400", children: "Wins" }),
        /* @__PURE__ */ m.jsx("p", { className: "font-semibold tabular-nums text-green-400", children: e })
      ] }),
      /* @__PURE__ */ m.jsxs("div", { children: [
        /* @__PURE__ */ m.jsx("p", { className: "font-medium text-slate-400", children: "Losses" }),
        /* @__PURE__ */ m.jsx("p", { className: "font-semibold tabular-nums text-red-400", children: n })
      ] })
    ] })
  ] });
}
function c9() {
  const t = gt(null), e = gt(null), [n, s] = tt(null), { profit: r } = Do(), i = uw();
  return je(() => {
    if (t.current) {
      const o = t.current.getContext("2d");
      o && (e.current && e.current.destroy(), e.current = new Un(o, {
        type: "line",
        data: {
          labels: r,
          datasets: [
            {
              label: "Profit",
              data: r,
              fill: {
                target: "origin",
                above: "rgba(74, 222, 128, 0.3)",
                below: "rgba(248, 113, 113, 0.3)"
              },
              segment: {
                borderColor: (a) => {
                  const l = a.p0.parsed.y, c = a.p1.parsed.y;
                  return c === 0 ? l < 0 ? iA : rA : c < 0 ? iA : rA;
                }
              },
              tension: 0.1,
              pointRadius: 0,
              pointHoverRadius: 6,
              pointHoverBackgroundColor: "white",
              pointHoverBorderColor: "white",
              pointHoverBorderWidth: 3
            }
          ]
        },
        options: {
          responsive: !0,
          bezierCurve: !0,
          maintainAspectRatio: !1,
          animations: {
            y: {
              duration: 0
            }
          },
          plugins: {
            legend: { display: !1 },
            tooltip: { enabled: !1 }
          },
          scales: {
            x: {
              border: { display: !1 },
              grid: { display: !1 },
              ticks: { display: !1 }
            },
            y: {
              border: { display: !1 },
              grid: { display: !1 },
              ticks: { display: !1 },
              grace: "1%"
            }
          },
          onHover: (a, l) => {
            if (l.length) {
              const c = l[0].index;
              s(r[c]);
            }
          },
          interaction: {
            intersect: !1,
            mode: "index"
          }
        }
      }));
    }
    return () => {
      e.current && e.current.destroy();
    };
  }, [r]), /* @__PURE__ */ m.jsxs("div", { className: "relative mt-4 rounded-md bg-primary p-4 text-sm", children: [
    /* @__PURE__ */ m.jsx("p", { className: "font-medium text-slate-400", children: "Profit History" }),
    n !== null && /* @__PURE__ */ m.jsx(
      "p",
      {
        className: `absolute top-4 right-4 font-semibold tabular-nums ${n >= 0 ? "text-green-400" : "text-red-400"}`,
        children: i(n)
      }
    ),
    /* @__PURE__ */ m.jsx("div", { className: "mt-6 h-44 w-64", children: /* @__PURE__ */ m.jsx("canvas", { ref: t }) }),
    /* @__PURE__ */ m.jsx("div", { id: "chartjs-tooltip", className: "hidden" })
  ] });
}
function dw() {
  const { resetProfitData: t } = Do(), { isLiveStatsOpen: e, setLiveStatsOpen: n } = it();
  return /* @__PURE__ */ m.jsx(m.Fragment, { children: e && /* @__PURE__ */ m.jsxs("div", { className: "absolute z-20 bottom-16 right-2 w-80 rounded-lg bg-secondary border border-gray-700 shadow-lg", children: [
    /* @__PURE__ */ m.jsxs("div", { className: "flex items-center justify-between p-4 text-white", children: [
      /* @__PURE__ */ m.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ m.jsx(Tb, { className: "mr-2 h-5 w-5" }),
        /* @__PURE__ */ m.jsx("h2", { className: "text-sm font-medium", children: "Live Stats" })
      ] }),
      /* @__PURE__ */ m.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ m.jsx(eL, { children: /* @__PURE__ */ m.jsxs(tL, { children: [
          /* @__PURE__ */ m.jsx(nL, { asChild: !0, children: /* @__PURE__ */ m.jsx(
            lt,
            {
              variant: "ghost",
              size: "icon",
              onClick: t,
              className: "mr-2 text-gray-400 hover:bg-gray-700 hover:text-white",
              children: /* @__PURE__ */ m.jsx(NT, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ m.jsx(hx, { children: /* @__PURE__ */ m.jsx("p", { children: "Reset Live Stats" }) })
        ] }) }),
        /* @__PURE__ */ m.jsx(
          lt,
          {
            variant: "ghost",
            size: "icon",
            onClick: () => n(!e),
            className: "text-gray-400 hover:bg-gray-700 hover:text-white",
            children: /* @__PURE__ */ m.jsx(Rb, { className: "h-4 w-4" })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ m.jsxs("div", { className: "p-4", children: [
      /* @__PURE__ */ m.jsx(l9, {}),
      /* @__PURE__ */ m.jsx(c9, {})
    ] })
  ] }) });
}
const u9 = () => {
  const t = Math.floor(Math.random() * 4), e = Math.random() * window.innerWidth;
  switch (t) {
    case 0:
      return { x: e, y: 0, angle: 45 };
    case 1:
      return { x: window.innerWidth, y: e, angle: 135 };
    case 2:
      return { x: e, y: window.innerHeight, angle: 225 };
    case 3:
      return { x: 0, y: e, angle: 315 };
    default:
      return { x: 0, y: 0, angle: 45 };
  }
}, fw = ({
  minSpeed: t = 10,
  maxSpeed: e = 30,
  minDelay: n = 1200,
  maxDelay: s = 4200,
  starColor: r = "#9E00FF",
  trailColor: i = "#2EB9DF",
  starWidth: o = 10,
  starHeight: a = 1,
  className: l
}) => {
  const [c, u] = tt(null), d = gt(null);
  return je(() => {
    const f = () => {
      const { x: h, y: p, angle: g } = u9(), A = {
        id: Date.now(),
        x: h,
        y: p,
        angle: g,
        scale: 1,
        speed: Math.random() * (e - t) + t,
        distance: 0
      };
      u(A);
      const b = Math.random() * (s - n) + n;
      setTimeout(f, b);
    };
    return f(), () => {
    };
  }, [t, e, n, s]), je(() => {
    const h = requestAnimationFrame(() => {
      c && u((p) => {
        if (!p) return null;
        const g = p.x + p.speed * Math.cos(p.angle * Math.PI / 180), A = p.y + p.speed * Math.sin(p.angle * Math.PI / 180), b = p.distance + p.speed, y = 1 + b / 100;
        return g < -20 || g > window.innerWidth + 20 || A < -20 || A > window.innerHeight + 20 ? null : {
          ...p,
          x: g,
          y: A,
          distance: b,
          scale: y
        };
      });
    });
    return () => cancelAnimationFrame(h);
  }, [c]), /* @__PURE__ */ m.jsxs(
    "svg",
    {
      ref: d,
      className: Be("w-full h-full absolute inset-0", l),
      children: [
        c && /* @__PURE__ */ m.jsx(
          "rect",
          {
            x: c.x,
            y: c.y,
            width: o * c.scale,
            height: a,
            fill: "url(#gradient)",
            transform: `rotate(${c.angle}, ${c.x + o * c.scale / 2}, ${c.y + a / 2})`
          },
          c.id
        ),
        /* @__PURE__ */ m.jsx("defs", { children: /* @__PURE__ */ m.jsxs("linearGradient", { id: "gradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
          /* @__PURE__ */ m.jsx("stop", { offset: "0%", style: { stopColor: i, stopOpacity: 0 } }),
          /* @__PURE__ */ m.jsx(
            "stop",
            {
              offset: "100%",
              style: { stopColor: r, stopOpacity: 1 }
            }
          )
        ] }) })
      ]
    }
  );
}, hw = ({
  starDensity: t = 15e-5,
  allStarsTwinkle: e = !0,
  twinkleProbability: n = 0.7,
  minTwinkleSpeed: s = 0.5,
  maxTwinkleSpeed: r = 1,
  className: i
}) => {
  const [o, a] = tt([]), l = gt(null), c = Fe(
    (u, d) => {
      const f = u * d, h = Math.floor(f * t);
      return Array.from({ length: h }, () => {
        const p = e || Math.random() < n;
        return {
          x: Math.random() * u,
          y: Math.random() * d,
          radius: Math.random() * 0.05 + 0.5,
          opacity: Math.random() * 0.5 + 0.5,
          twinkleSpeed: p ? s + Math.random() * (r - s) : null
        };
      });
    },
    [
      t,
      e,
      n,
      s,
      r
    ]
  );
  return je(() => {
    const u = () => {
      if (l.current) {
        const f = l.current;
        if (!f.getContext("2d")) return;
        const { width: p, height: g } = f.getBoundingClientRect();
        f.width = p, f.height = g, a(c(p, g));
      }
    };
    u();
    const d = new ResizeObserver(u);
    return l.current && d.observe(l.current), () => {
      l.current && d.unobserve(l.current);
    };
  }, [
    t,
    e,
    n,
    s,
    r,
    c
  ]), je(() => {
    const u = l.current;
    if (!u) return;
    const d = u.getContext("2d");
    if (!d) return;
    let f;
    const h = () => {
      d.clearRect(0, 0, u.width, u.height), o.forEach((p) => {
        d.beginPath(), d.arc(p.x, p.y, p.radius, 0, Math.PI * 2), d.fillStyle = `rgba(255, 255, 255, ${p.opacity})`, d.fill(), p.twinkleSpeed !== null && (p.opacity = 0.5 + Math.abs(Math.sin(Date.now() * 1e-3 / p.twinkleSpeed) * 0.5));
      }), f = requestAnimationFrame(h);
    };
    return h(), () => {
      cancelAnimationFrame(f);
    };
  }, [o]), /* @__PURE__ */ m.jsx(
    "canvas",
    {
      ref: l,
      className: Be("h-full w-full absolute inset-0", i)
    }
  );
}, d9 = ({ currency: t, lang: e, theme: n }) => {
  const { authToken: s } = vl(), r = Zr(), { betAmount: i, coinSide: o, validateSettings: a, updateSettings: l, mode: c } = ya(), {
    isGameActive: u,
    setIsGameActive: d,
    selectedCurrency: f,
    setCurrency: h,
    setInitializing: p,
    setBalance: g,
    setTheme: A,
    setIsAutoPlaying: b,
    setCurrentAutoBet: y,
    setBetRanges: w,
    setIsFinishingBet: x,
    finishAutoPlay: S,
    isSoundMuted: q
  } = it(), { setResult: C, setMultiplier: E, setTotalProfit: T, resetGame: k } = yA(), { updateProfitData: R } = Do(), [D, F] = tt(!1);
  je(() => {
    q || zb(), A(n), (async () => {
      if (s)
        await j(), d(!1);
      else
        throw p(!1), new Error("No authToken found.");
    })();
  }, [n, A]);
  const j = async () => {
    if (s)
      try {
        p(!0);
        const U = await Db(s, "cointoss");
        h(U.currencyDefinition), w({
          minBet: U.allowedBets[0],
          maxBet: U.allowedBets[1]
        }), l({ betAmount: Number(U.allowedBets[0]) }), g(U.balance);
      } catch (U) {
        console.error("Error fetching game data:", U);
      } finally {
        p(!1), F(!0);
      }
  }, B = Fe(
    async (U) => {
      if (s)
        try {
          p(!0);
          const X = await Mb(s, U);
          h(X.currencyDefinition), w({
            minBet: X.allowedBets[0],
            maxBet: X.allowedBets[1]
          }), l({ betAmount: Number(X.allowedBets[0]) }), g(X.balance);
        } catch (X) {
          console.error("Error changing currency:", X);
        } finally {
          p(!1);
        }
    },
    [s, h, g, p, w]
  );
  je(() => {
    D && f.currencyCode !== t && B(t);
  }, [D, f, t, B]);
  const L = Fe(async () => {
    if (!(u || !s)) {
      k();
      try {
        const U = {
          amount: i.toString(),
          currency: f.currencyCode,
          custom: {
            face: o
          }
        }, X = await Ga(s, "cointoss", U);
        C(X.custom.face), E(X.multiplier ?? 0), T(X.winAmount), g(X.balance), d(!1), R(X.winAmount, X.win), Ft(X.win ? "win" : "lose");
      } catch (U) {
        console.error("Error placing bet:", U), U instanceof Error && console.error("Error message:", U.message);
      }
    }
  }, [
    i,
    o,
    s,
    d,
    u,
    C,
    g,
    f,
    R,
    E,
    T,
    k
  ]), O = Fe(
    (U) => {
      C(U.custom.face), g(U.balance), d(!1), E(U.multiplier ?? 0), T(U.winAmount), R(U.win ? U.winAmount - i : U.winAmount, U.win), Ft(U.win ? "win" : "lose");
    },
    [
      g,
      R,
      d,
      C,
      E,
      T,
      i
    ]
  ), N = Fe(async () => {
    if (!s) return;
    const U = (Ee) => new Promise((oe) => setTimeout(oe, Ee));
    b(!0), x(!1), y(1);
    let X = 0, G = 0;
    const pe = i;
    console.log("Original betAmount:", pe);
    const Me = async () => {
      const Ee = it.getState(), oe = ya.getState();
      if (!Ee.isAutoPlaying && !Ee.isFinishingBet) {
        S();
        return;
      }
      if (!a()) {
        console.error("Invalid settings, stopping auto-play"), S();
        return;
      }
      if (oe.numberOfBets !== "∞" && Ee.currentAutoBet > Number(oe.numberOfBets)) {
        console.log("Reached maximum number of bets, stopping auto-play"), S();
        return;
      }
      try {
        k(), await U(50);
        const He = ya.getState().betAmount;
        console.log("Current bet amount:", He);
        const ye = {
          amount: He.toString(),
          currency: f.currencyCode,
          custom: {
            face: o
          }
        }, $ = await Ga(
          s,
          "cointoss",
          ye
        );
        O($), await U(50);
        const Xe = $.winAmount ?? 0;
        if (console.log("Net win:", Xe), oe.stopOnWin > 0 && (X += Xe > 0 ? Xe : 0), oe.stopOnLoss > 0 && (G += Xe < 0 ? -Xe : 0), console.log("Local accumulated win:", X), console.log("Local accumulated loss:", G), oe.stopOnWin > 0 && X >= oe.stopOnWin) {
          console.log("Reached stop win condition, stopping auto-play"), S();
          return;
        }
        if (oe.stopOnLoss > 0 && G >= oe.stopOnLoss) {
          console.log("Reached stop loss condition, stopping auto-play"), S();
          return;
        }
        let Ue = He;
        if ($.win) {
          if (oe.onWinMode === "reset")
            Ue = pe;
          else if (oe.onWinMode === "increase") {
            const Z = 1 + oe.onWinValue / 100;
            Ue = He * Z;
          }
        } else if (oe.onLossMode === "reset")
          Ue = pe;
        else if (oe.onLossMode === "increase") {
          const Z = 1 + oe.onLossValue / 100;
          Ue = He * Z;
        }
        console.log("Updating betAmount to:", Ue), Ue > 0 && l({ betAmount: Ue }), y((Z) => Z + 1), it.getState().isAutoPlaying ? Me() : (S(), l({ betAmount: pe }));
      } catch (He) {
        console.error("Error in auto-play:", He), S();
      }
    };
    Me();
  }, [
    s,
    i,
    f,
    y,
    O,
    S,
    b,
    x,
    a,
    l,
    o,
    k
  ]), H = Fe(() => {
    u || !s || (c === "auto" ? N() : L());
  }, [
    u,
    s,
    c,
    N,
    L
  ]);
  return /* @__PURE__ */ m.jsxs(hA, { children: [
    /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col lg:flex-row h-auto lg:h-[600px]", children: [
      /* @__PURE__ */ m.jsx(yk, { handleStartGame: H }),
      /* @__PURE__ */ m.jsxs("div", { className: "relative flex-grow lg:p-6 flex items-center justify-center order-1 lg:order-2", children: [
        /* @__PURE__ */ m.jsx("div", { className: "relative z-10 bg-black p-3 lg:p-2 rounded-md w-full lg:max-w-[480px] aspect-square", children: /* @__PURE__ */ m.jsx(tR, {}) }),
        !r && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(
            fw,
            {
              starHeight: 5,
              starWidth: 20,
              minSpeed: 5,
              maxSpeed: 20,
              trailColor: n === "betpanda" ? "#0c2d30" : "#dc146e",
              starColor: n === "betpanda" ? "#1fe88a" : "#dc146e"
            }
          ),
          /* @__PURE__ */ m.jsx(hw, { starDensity: 2e-3 })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ m.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ m.jsx(dw, {}),
      /* @__PURE__ */ m.jsx(Ov, {})
    ] })
  ] });
}, f9 = Yd(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function h9({ className: t, variant: e, ...n }) {
  return /* @__PURE__ */ m.jsx("div", { className: Be(f9({ variant: e }), t), ...n });
}
const da = {
  board: Array(25).fill("hidden"),
  gameRoundId: null,
  isEnded: !1,
  multiplier: 0,
  preSelectMultiplier: 0,
  revealedCells: [],
  selectedCells: [],
  totalProfit: 0,
  fetchingCells: []
  // Initialize fetchingCells
}, yo = Gr((t) => ({
  ...da,
  selectedCells: [],
  setGameRoundId: (e) => t((n) => ({
    ...da,
    gameRoundId: e,
    selectedCells: n.selectedCells
  })),
  revealCell: (e, n) => t((s) => ({
    board: s.board.map((r, i) => i === e ? n : r),
    fetchingCells: s.fetchingCells.filter((r) => r !== e)
    // Remove from fetchingCells when revealed
  })),
  setMultiplier: (e) => t({ multiplier: e }),
  setPreselectMultiplier: (e) => t({ preSelectMultiplier: e }),
  updateBoard: (e) => t({ board: e }),
  resetBoard: () => t({ board: da.board }),
  setRevealedCells: (e) => t({ revealedCells: e }),
  toggleSelectedCell: (e) => t((n) => ({
    selectedCells: n.selectedCells.includes(e) ? n.selectedCells.filter((s) => s !== e) : [...n.selectedCells, e]
  })),
  clearSelectedCells: () => t({ selectedCells: [] }),
  endGame: (e) => t(() => ({
    isEnded: !0,
    totalProfit: e,
    fetchingCells: []
    // Clear fetchingCells when the game ends
  })),
  resetGame: () => t((e) => ({
    ...da,
    preSelectMultiplier: e.preSelectMultiplier,
    selectedCells: e.selectedCells
  })),
  addFetchingCell: (e) => t((n) => ({
    fetchingCells: [...n.fetchingCells, e]
  })),
  removeFetchingCell: (e) => t((n) => ({
    fetchingCells: n.fetchingCells.filter((s) => s !== e)
  }))
})), oA = {
  mode: "manual",
  betAmount: 0,
  minesCount: 5,
  stopOnWin: 0,
  stopOnLoss: 0,
  numberOfBets: "∞",
  onWinMode: "reset",
  onLossMode: "reset",
  onWinValue: 0,
  onLossValue: 0
}, Vi = Gr((t, e) => ({
  ...oA,
  errors: {},
  updateSettings: (n) => t((s) => {
    const r = { ...s, ...n }, { clearSelectedCells: i } = yo.getState();
    return n.minesCount && i(), n.onWinMode === "reset" && s.onWinMode !== "reset" && (r.onWinValue = 0), n.onLossMode === "reset" && s.onLossMode !== "reset" && (r.onLossValue = 0), r;
  }),
  resetSettings: () => t(oA),
  validateSettings: () => {
    const { betRanges: n, selectedCurrency: s, balance: r } = it.getState();
    yo.getState();
    const i = e(), o = Re.object({
      mode: Re.enum(["manual", "auto"]),
      betAmount: Re.number().min(parseFloat(n.minBet), `Your bet must be at least ${s.prefixSymbol} ${n.minBet}`).max(parseFloat(n.maxBet), `Your bet can max be ${s.prefixSymbol} ${n.maxBet}`).max(r, "You don't have enough balance."),
      minesCount: Re.number().int().min(1).max(24, "Mines count must be between 1 and 24"),
      stopOnWin: Re.number().nonnegative("Stop on win must be non-negative").max(r, "You don't have enough balance."),
      stopOnLoss: Re.number().nonnegative("Stop on loss must be non-negative"),
      numberOfBets: Re.union([
        Re.literal("∞"),
        Re.string().refine(
          (a) => !isNaN(Number(a)) && Number(a) > 0 && Number(a) <= 1e3,
          {
            message: "Number of bets must be a positive number up to 1000 or '∞'"
          }
        ),
        Re.number().int().positive().max(1e3, "Maximum 1000")
      ]).transform((a) => a === "∞" ? a : Number(a)),
      onWinMode: Re.enum(["reset", "increase"]),
      onLossMode: Re.enum(["reset", "increase"]),
      onWinValue: Re.number().nonnegative("Cannot be less than 0"),
      onLossValue: Re.number().nonnegative("Cannot be less than 0")
    });
    try {
      return o.parse(i), t({ errors: {} }), !0;
    } catch (a) {
      if (a instanceof Re.ZodError) {
        const l = {};
        a.issues.forEach((c) => {
          c.path[0] && (l[c.path[0]] = c.message, console.log("newErrors", c.message));
        }), t({ errors: l });
      }
      return !1;
    }
  },
  setErrors: (n) => t({ errors: n })
})), p9 = "data:image/jpeg;base64,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", g9 = "data:image/png;base64,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", m9 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2076.61%2070'%3e%3cdefs%3e%3cstyle%3e.cls-1{fill:%23051d27;}.cls-2{fill:%2306e403;}.cls-3{fill:%2305a902;}.cls-4{fill:%2301e501;}.cls-5{fill:%2300d503;}.cls-6{fill:%2309fd02;}.cls-7{fill:%23019902;}.cls-8{fill:%2301e300;}.cls-9{fill:%2357fd7f;}.cls-10{fill:%2303be02;}%3c/style%3e%3c/defs%3e%3ctitle%3e3Artboard%20710%3c/title%3e%3cg%20id='Layer_1'%20data-name='Layer%201'%3e%3cpath%20class='cls-1'%20d='M38,70h0a2.75,2.75,0,0,1-2-.92L.7,29.62a2.76,2.76,0,0,1-.31-3.25L11,8.55a2.76,2.76,0,0,1,1.27-1.12L23.12,2.71a2.77,2.77,0,0,1,.62-.19L37.74,0a3.09,3.09,0,0,1,1,0L52.62,2.52a3.38,3.38,0,0,1,.62.18L64.42,7.58l.13,0h0a2.69,2.69,0,0,1,.65.45h0a3,3,0,0,1,.4.47h0l.09.14L76.23,26.6a2.73,2.73,0,0,1-.34,3.25L40.06,69.1A2.76,2.76,0,0,1,38,70Z'/%3e%3cpath%20class='cls-2'%20d='M22.13,18.75c-2.64,7-1.74,13.65,2.09,20,6.74-3.1,11.83-8.4,14.44-17C33,18.93,27.49,17.74,22.13,18.75Z'/%3e%3cpath%20class='cls-3'%20d='M73.86,28,63.33,10.1c-6.26,1.19-8.79,4.41-9,8.91C58.67,25.3,65.39,28,73.86,28Z'/%3e%3cpath%20class='cls-4'%20d='M38.49,21.94c.15,7.77,4.2,13.31,12.19,16.57l.07,0c4.5-5.59,5.9-12,3.62-19.47C48.26,16.08,42.9,16.72,38.49,21.94Z'/%3e%3cpath%20class='cls-5'%20d='M24.22,38.76q13.19,6.43,26.46-.25L38.49,21.94Z'/%3e%3cpath%20class='cls-6'%20d='M24.22,38.76c1,9.17,6.29,18.72,13.81,28.49,7.4-9,12.5-18.4,12.72-28.77Z'/%3e%3cpath%20class='cls-7'%20d='M50.75,38.48,38,67.25,73.86,28C64.47,28.32,56.19,30.75,50.75,38.48Z'/%3e%3cpath%20class='cls-8'%20d='M2.75,27.79,38,67.25,24.22,38.76C20.11,31,11.89,28.8,2.75,27.79Z'/%3e%3cpath%20class='cls-9'%20d='M13.39,10,2.75,27.79c9.33,1.22,16.19-1.21,19.54-8.88C24.57,13.79,21.22,11,13.39,10Z'/%3e%3cpolygon%20class='cls-6'%20points='2.75%2027.79%2024.22%2038.76%2022.29%2018.91%202.75%2027.79'/%3e%3cpolygon%20class='cls-6'%20points='52.14%205.23%2038.22%202.75%2024.22%205.23%2013.39%209.96%2022.29%2018.91%2038.49%2021.94%2054.37%2019.01%2063.33%2010.1%2052.14%205.23'/%3e%3cpolygon%20class='cls-10'%20points='50.74%2038.48%2073.86%2027.99%2054.37%2019.01%2050.74%2038.48'/%3e%3cpolygon%20class='cls-9'%20points='13.89%2010.83%2024.37%205.43%2038.22%202.75%2024.22%205.23%2013.39%209.96%2013.89%2010.83'/%3e%3cpolygon%20class='cls-9'%20points='22.29%2018.91%2024.22%2038.76%2021.1%2019.05%2022.29%2018.91'/%3e%3cpolygon%20class='cls-9'%20points='22.29%2018.91%2038.49%2021.94%2038.03%2022.48%2022.29%2018.91'/%3e%3cpolygon%20class='cls-9'%20points='63.33%2010.1%2053%2019.28%2054.37%2019.01%2063.33%2010.1'/%3e%3c/g%3e%3c/svg%3e", pw = "data:image/svg+xml,%3csvg%20id='Layer_1'%20data-name='Layer%201'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2070%2070'%3e%3ctitle%3ebomb%3c/title%3e%3cpath%20d='M35,70a35.47,35.47,0,0,1-8.45-1A35,35,0,1,1,49.83,3.3c3.53-2.25,8.75-.54,12.39,4.16.15.19.3.39.44.59a11.89,11.89,0,0,1,3.61,2.31,10.6,10.6,0,0,1,3.27,7.91A9,9,0,0,1,68,23.44a32.32,32.32,0,0,1,1.14,4h0A35,35,0,0,1,35,70ZM35,6.47A28.57,28.57,0,1,0,62.85,28.84h0A27.53,27.53,0,0,0,61.34,24a3.17,3.17,0,0,1-.16-2,3.2,3.2,0,0,1-1.49-1.33c-.29-.5-.6-1-.92-1.48a3.23,3.23,0,0,1-.11-3.39.92.92,0,0,0,.06-.29,3.33,3.33,0,0,1,.77-1.79,3.16,3.16,0,0,1-1.73-1.4,11.43,11.43,0,0,0-.65-.95c-1.59-2-3.35-2.68-3.87-2.62A1.81,1.81,0,0,1,53,9l-1.37.79a3.22,3.22,0,0,1-3.14.06A28.47,28.47,0,0,0,35,6.47Z'%20style='fill:%23051d27'/%3e%3cpath%20d='M66.76,35A31.62,31.62,0,0,0,66,28.14c-2.45-.61-13.43-3.53-16.07-3.53-17.55,0-28.75,14.48-28.75,32,0,2.35,5.65,7,6.14,9.19A31.8,31.8,0,0,0,66.76,35Z'%20style='fill:%23d8003e'/%3e%3cpath%20d='M58.34,27.2a31.72,31.72,0,0,1,7.67.94A31.76,31.76,0,1,0,27.33,65.83a31.77,31.77,0,0,1,31-38.63Z'%20style='fill:%23fd013e'/%3e%3cpath%20d='M51.33,6.19,45.71,9.44c-2.24,1.74-1.7,6.17,1.19,9.9S54,24.69,56.19,23l4.55-4.64Z'%20style='fill:%23d8003e'/%3e%3cellipse%20cx='56.03'%20cy='12.26'%20rx='4.6'%20ry='7.67'%20transform='translate(4.24%2036.9)%20rotate(-37.78)'%20style='fill:%23fd013e'/%3e%3cpath%20d='M41.45,38.53a1.55,1.55,0,0,1-.37,0,1.84,1.84,0,0,1-1.44-2.17c2-9.64,10.07-12,16-13.71,4.86-1.41,7-2.24,7-4.34a3.76,3.76,0,0,0-1.11-2.89c-1.91-1.81-5.63-1.67-5.67-1.66a1.84,1.84,0,1,1-.2-3.68c.22,0,5.33-.25,8.41,2.67a7.43,7.43,0,0,1,2.26,5.56c0,5.08-4.9,6.5-9.65,7.88-5.85,1.69-11.9,3.45-13.41,10.9A1.85,1.85,0,0,1,41.45,38.53Z'%20style='fill:%232a2f3c'/%3e%3cpolygon%20points='32.81%2053.29%2033.53%2054.59%2030.13%2056.91%2030.49%2053.72%2032.81%2053.29'%20style='fill:%23fff'/%3e%3cpolygon%20points='20.47%2056.89%2020.73%2057.24%2019.67%2057.76%2019.72%2056.95%2020.47%2056.89'%20style='fill:%23fff'/%3e%3cpolygon%20points='32.15%2047.91%2032.26%2048.82%2033.05%2048.66%2032.87%2047.59%2032.15%2047.91'%20style='fill:%23fff'/%3e%3cpolygon%20points='35.28%2046.02%2034.89%2047.73%2036.14%2047.94%2036.82%2046.87%2036.39%2045.91%2035.28%2046.02'%20style='fill:%23fff'/%3e%3cpolygon%20points='38.02%2048.47%2037.97%2049.28%2039.03%2048.76%2038.77%2048.41%2038.02%2048.47'%20style='fill:%23fff'/%3e%3cpolygon%20points='41.13%2049.33%2042.21%2048.85%2042.71%2050.93%2041.48%2051.1%2041.13%2049.33'%20style='fill:%23fff'/%3e%3cpolygon%20points='32.64%2039.9%2033.07%2040.85%2032.39%2041.92%2031.14%2041.71%2031.54%2040%2032.64%2039.9'%20style='fill:%23fff'/%3e%3cpolygon%20points='44.43%2045.41%2044.62%2046.48%2043.83%2046.65%2043.71%2045.74%2044.43%2045.41'%20style='fill:%23fff'/%3e%3cpolygon%20points='47.56%2043.79%2046.62%2045.17%2049.51%2046.55%2049.95%2045.02%2047.56%2043.79'%20style='fill:%23fff'/%3e%3cpolygon%20points='52.47%2047.67%2052.42%2048.48%2053.48%2047.96%2053.22%2047.61%2052.47%2047.67'%20style='fill:%23fff'/%3e%3cpolygon%20points='51.74%2051.27%2051.31%2052.23%2052.6%2053.19%2054.63%2051.91%2051.74%2051.27'%20style='fill:%23fff'/%3e%3cpolygon%20points='51.63%2058.46%2050.91%2058.78%2051.02%2059.69%2051.82%2059.53%2051.63%2058.46'%20style='fill:%23fff'/%3e%3cpolygon%20points='46.62%2039.13%2046.86%2036.72%2048.76%2036.45%2049.38%2037.45%2046.62%2039.13'%20style='fill:%23fff'/%3e%3cpolygon%20points='61.89%2033.9%2061.84%2034.71%2062.9%2034.19%2062.64%2033.84%2061.89%2033.9'%20style='fill:%23fff'/%3e%3cpolygon%20points='47.15%2033.15%2047.73%2033.71%2047.01%2034.52%2046.57%2033.86%2047.15%2033.15'%20style='fill:%23fff'/%3e%3cpolygon%20points='36.75%2033.83%2035.69%2034.34%2035.73%2033.53%2036.48%2033.47%2036.75%2033.83'%20style='fill:%23fff'/%3e%3cpolygon%20points='35.78%2037.44%2035.05%2037.77%2035.17%2038.67%2035.96%2038.51%2035.78%2037.44'%20style='fill:%23fff'/%3e%3cpolygon%20points='33.78%2034.62%2033%2035.77%2031.73%2035.41%2031.25%2033.9%2032.46%2032.87%2033.78%2034.62'%20style='fill:%23fff'/%3e%3cpolygon%20points='28.58%2024.4%2028.76%2025.46%2027.97%2025.63%2027.85%2024.72%2028.58%2024.4'%20style='fill:%23fff'/%3e%3cpolygon%20points='47%2026.82%2043.8%2040.43%2034.23%2026.82%2041.68%2041.48%2031.04%2038.34%2037.42%2042.53%2019.33%2047.76%2039.55%2044.62%2036.36%2055.09%2042.74%2047.76%2047%2051.95%2047%2046.72%2061.89%2049.86%2048.06%2043.57%2055.51%2038.34%2047%2041.48%2047%2026.82'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='56.57%2043.61%2063.67%2041.84%2063.67%2043.61%2056.57%2043.61'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='32.63%2033.01%2026.43%2022.4%2025.54%2025.05%2032.63%2033.01'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='34.41%2052.44%2028.2%2063.04%2027.31%2060.39%2034.41%2052.44'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='46.93%2044.58%2052.19%2051.23%2044.6%2047%2042.26%2052.44%2041.09%2048.21%2033.1%2050.41%2038.17%2044.58%2032.92%2042.16%2038.17%2040.35%2036.42%2037.94%2041.09%2038.54%2039.92%2029.47%2043.43%2038.54%2044.6%2037.94%2044.6%2039.75%2049.85%2037.33%2046.93%2042.16%2053.36%2042.77%2046.93%2044.58'%20style='fill:%23fff'/%3e%3c/svg%3e";
function A9({
  handleRevealCell: t,
  handleAutoSelection: e
}) {
  const {
    board: n,
    isEnded: s,
    multiplier: r,
    revealedCells: i,
    totalProfit: o,
    selectedCells: a,
    setPreselectMultiplier: l,
    fetchingCells: c
  } = yo(), { mode: u, minesCount: d } = Vi(), { isGameActive: f, theme: h, isAutoPlaying: p } = it(), g = Zr(), A = i.slice(-1).join(), [b, y] = tt(!1), w = (T) => T === "betpanda" ? p9 : g9, x = (T) => {
    if (u === "auto" && !f && !p) {
      if (!a.includes(T) && d + a.length >= 25) return;
      Ft("tick"), e(T);
    } else u === "manual" && f && !c.includes(T) && t(T);
  }, S = (T) => {
    y(!0), x(T);
  }, q = (T) => {
    b && x(T);
  }, C = () => {
    y(!1);
  };
  je(() => {
    a.length === 0 && l(0), l(Q1(d, a.length));
  }, [a, l, d]), je(() => (document.addEventListener("mouseup", C), () => {
    document.removeEventListener("mouseup", C);
  }), []);
  const E = (T, k) => {
    const R = u === "auto" && a.includes(T), D = {
      backgroundImage: k === "hidden" && h !== "betplay-alt" ? `url(${w(h)})` : "none",
      backgroundSize: "cover",
      transition: "all 0.3s ease",
      borderWidth: R ? "3px" : h === "betplay-alt" ? "0px" : "2px",
      borderStyle: "solid",
      borderColor: R ? "#9932CC" : h === "betplay-alt" ? "" : h === "betpanda" ? "rgba(31, 232, 138, 0.7)" : "rgba(220, 1, 108, 0.7)"
    };
    return k === "diamond" ? {
      ...D,
      borderColor: "#1fe88a",
      backgroundColor: "#1fe88a"
      // Green for gems
    } : k === "mine" ? {
      ...D,
      borderColor: "rgb(248, 113, 113)",
      backgroundColor: "rgb(248, 113, 113)"
      // Red for bombs
    } : D;
  };
  return /* @__PURE__ */ m.jsxs("div", { className: "grid grid-cols-5 gap-2 h-full w-full", children: [
    n.map((T, k) => /* @__PURE__ */ m.jsxs(
      Tr.div,
      {
        initial: { rotateY: 0 },
        animate: { rotateY: T !== "hidden" ? 180 : 0 },
        transition: { duration: 0.3 },
        className: `w-full h-full aspect-square rounded-sm flex items-center justify-center will-change-auto
          ${s && !i.includes(k) ? "opacity-20" : ""}
          ${c.includes(k) ? "animate-custom-pulse" : ""}
        `,
        children: [
          /* @__PURE__ */ m.jsxs(
            lt,
            {
              onMouseDown: () => S(k),
              onMouseEnter: () => q(k),
              style: E(k, T),
              className: `w-full h-full disabled:opacity-100 text-4xl rounded-sm p-3 select-none 
              ${T === "diamond" ? "bg-green-500 border-opacity-0" : T === "mine" ? "bg-red-400 text-white border-opacity-0" : "bg-secondary cursor-pointer border-secondary"}
            `,
              disabled: p || u === "manual" && (!f || T !== "hidden"),
              children: [
                c.includes(k) && h === "betplay-alt" && /* @__PURE__ */ m.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ m.jsx("div", { className: "w-9 h-9 border-4 border-border border-t-brand rounded-full animate-spin" }) }),
                (T !== "hidden" || s) && /* @__PURE__ */ m.jsx(
                  "img",
                  {
                    src: T === "mine" ? pw : m9,
                    width: "0",
                    height: "0",
                    alt: "",
                    style: { width: "100%", height: "auto" }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ m.jsx(wu, { children: T === "diamond" && parseInt(A) === k && f && u === "manual" && /* @__PURE__ */ m.jsx(
            Tr.div,
            {
              initial: { opacity: 0, scale: 0.8 },
              animate: { opacity: 1, scale: 1, rotateY: 180 },
              exit: { opacity: 0, scale: 0.8 },
              transition: { duration: 0.3 },
              className: "absolute top-0 left-50",
              style: { top: "-15px" },
              children: /* @__PURE__ */ m.jsxs(
                h9,
                {
                  variant: "secondary",
                  className: "relative z-50 text-xs bg-violet-700 text-white font-black px-1.5 pointer-events-none",
                  children: [
                    r.toFixed(2),
                    "x"
                  ]
                }
              )
            }
          ) })
        ]
      },
      `${k}-${h}`
    )),
    /* @__PURE__ */ m.jsx(wu, { children: u === "auto" && a.length === 0 && /* @__PURE__ */ m.jsxs(
      Tr.div,
      {
        className: "absolute left-3 right-3 top-full mt-4 bg-white text-black p-4 rounded-lg shadow-lg",
        initial: { opacity: 0, y: -30 },
        animate: { opacity: 1, y: -5 },
        exit: { opacity: 0, y: -30 },
        transition: { duration: 0.3 },
        children: [
          /* @__PURE__ */ m.jsx("div", { className: "absolute -top-2 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-b-8 border-transparent border-b-white" }),
          /* @__PURE__ */ m.jsx("h2", { className: "text-sm font-bold mb-2", children: "Welcome to Auto Mode!" }),
          /* @__PURE__ */ m.jsx("p", { className: "text-sm", children: "Select the cells you want to reveal automatically. The game will play these selections for you when you start." })
        ]
      }
    ) }),
    s && r !== 0 && /* @__PURE__ */ m.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ m.jsx(Lb, { multiplier: r, amount: o }) }),
    !g && !f && !p && a.length === 0 && /* @__PURE__ */ m.jsx(
      qA,
      {
        size: 700,
        duration: 10,
        colorFrom: h === "betpanda" ? "#1fe88a" : "#dc146e",
        colorTo: "#08080800",
        borderWidth: 1.5
      }
    )
  ] });
}
function b9(t, e = []) {
  let n = [];
  function s(i, o) {
    const a = v.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, g = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[l]) || a, A = v.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ m.jsx(g.Provider, { value: A, children: h });
    };
    c.displayName = i + "Provider";
    function u(d, f) {
      var g;
      const h = ((g = f == null ? void 0 : f[t]) == null ? void 0 : g[l]) || a, p = v.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const r = () => {
    const i = n.map((o) => v.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[t]) || i;
      return v.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return r.scopeName = t, [s, y9(r, ...e)];
}
function y9(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const s = t.map((r) => ({
      useScope: r(),
      scopeName: r.scopeName
    }));
    return function(i) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return v.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function v9(t) {
  const e = v.useRef({ value: t, previous: t });
  return v.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t]);
}
var gw = ["PageUp", "PageDown"], mw = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Aw = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, oi = "Slider", [nd, x9, w9] = hv(oi), [bw, r5] = b9(oi, [
  w9
]), [S9, $l] = bw(oi), yw = v.forwardRef(
  (t, e) => {
    const {
      name: n,
      min: s = 0,
      max: r = 100,
      step: i = 1,
      orientation: o = "horizontal",
      disabled: a = !1,
      minStepsBetweenThumbs: l = 0,
      defaultValue: c = [s],
      value: u,
      onValueChange: d = () => {
      },
      onValueCommit: f = () => {
      },
      inverted: h = !1,
      form: p,
      ...g
    } = t, A = v.useRef(/* @__PURE__ */ new Set()), b = v.useRef(0), w = o === "horizontal" ? C9 : P9, [x = [], S] = ni({
      prop: u,
      defaultProp: c,
      onChange: (R) => {
        var F;
        (F = [...A.current][b.current]) == null || F.focus(), d(R);
      }
    }), q = v.useRef(x);
    function C(R) {
      const D = k9(x, R);
      k(R, D);
    }
    function E(R) {
      k(R, b.current);
    }
    function T() {
      const R = q.current[b.current];
      x[b.current] !== R && f(x);
    }
    function k(R, D, { commit: F } = { commit: !1 }) {
      const j = L9(i), B = N9(Math.round((R - s) / i) * i + s, j), L = gf(B, [s, r]);
      S((O = []) => {
        const N = T9(O, L, D);
        if (O9(N, l * i)) {
          b.current = N.indexOf(L);
          const H = String(N) !== String(O);
          return H && F && f(N), H ? N : O;
        } else
          return O;
      });
    }
    return /* @__PURE__ */ m.jsx(
      S9,
      {
        scope: t.__scopeSlider,
        name: n,
        disabled: a,
        min: s,
        max: r,
        valueIndexToChangeRef: b,
        thumbs: A.current,
        values: x,
        orientation: o,
        form: p,
        children: /* @__PURE__ */ m.jsx(nd.Provider, { scope: t.__scopeSlider, children: /* @__PURE__ */ m.jsx(nd.Slot, { scope: t.__scopeSlider, children: /* @__PURE__ */ m.jsx(
          w,
          {
            "aria-disabled": a,
            "data-disabled": a ? "" : void 0,
            ...g,
            ref: e,
            onPointerDown: we(g.onPointerDown, () => {
              a || (q.current = x);
            }),
            min: s,
            max: r,
            inverted: h,
            onSlideStart: a ? void 0 : C,
            onSlideMove: a ? void 0 : E,
            onSlideEnd: a ? void 0 : T,
            onHomeKeyDown: () => !a && k(s, 0, { commit: !0 }),
            onEndKeyDown: () => !a && k(r, x.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: R, direction: D }) => {
              if (!a) {
                const B = gw.includes(R.key) || R.shiftKey && mw.includes(R.key) ? 10 : 1, L = b.current, O = x[L], N = i * B * D;
                k(O + N, L, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
yw.displayName = oi;
var [vw, xw] = bw(oi, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), C9 = v.forwardRef(
  (t, e) => {
    const {
      min: n,
      max: s,
      dir: r,
      inverted: i,
      onSlideStart: o,
      onSlideMove: a,
      onSlideEnd: l,
      onStepKeyDown: c,
      ...u
    } = t, [d, f] = v.useState(null), h = Pe(e, (w) => f(w)), p = v.useRef(), g = pf(r), A = g === "ltr", b = A && !i || !A && i;
    function y(w) {
      const x = p.current || d.getBoundingClientRect(), S = [0, x.width], C = eh(S, b ? [n, s] : [s, n]);
      return p.current = x, C(w - x.left);
    }
    return /* @__PURE__ */ m.jsx(
      vw,
      {
        scope: t.__scopeSlider,
        startEdge: b ? "left" : "right",
        endEdge: b ? "right" : "left",
        direction: b ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ m.jsx(
          ww,
          {
            dir: g,
            "data-orientation": "horizontal",
            ...u,
            ref: h,
            style: {
              ...u.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (w) => {
              const x = y(w.clientX);
              o == null || o(x);
            },
            onSlideMove: (w) => {
              const x = y(w.clientX);
              a == null || a(x);
            },
            onSlideEnd: () => {
              p.current = void 0, l == null || l();
            },
            onStepKeyDown: (w) => {
              const S = Aw[b ? "from-left" : "from-right"].includes(w.key);
              c == null || c({ event: w, direction: S ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), P9 = v.forwardRef(
  (t, e) => {
    const {
      min: n,
      max: s,
      inverted: r,
      onSlideStart: i,
      onSlideMove: o,
      onSlideEnd: a,
      onStepKeyDown: l,
      ...c
    } = t, u = v.useRef(null), d = Pe(e, u), f = v.useRef(), h = !r;
    function p(g) {
      const A = f.current || u.current.getBoundingClientRect(), b = [0, A.height], w = eh(b, h ? [s, n] : [n, s]);
      return f.current = A, w(g - A.top);
    }
    return /* @__PURE__ */ m.jsx(
      vw,
      {
        scope: t.__scopeSlider,
        startEdge: h ? "bottom" : "top",
        endEdge: h ? "top" : "bottom",
        size: "height",
        direction: h ? 1 : -1,
        children: /* @__PURE__ */ m.jsx(
          ww,
          {
            "data-orientation": "vertical",
            ...c,
            ref: d,
            style: {
              ...c.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (g) => {
              const A = p(g.clientY);
              i == null || i(A);
            },
            onSlideMove: (g) => {
              const A = p(g.clientY);
              o == null || o(A);
            },
            onSlideEnd: () => {
              f.current = void 0, a == null || a();
            },
            onStepKeyDown: (g) => {
              const b = Aw[h ? "from-bottom" : "from-top"].includes(g.key);
              l == null || l({ event: g, direction: b ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), ww = v.forwardRef(
  (t, e) => {
    const {
      __scopeSlider: n,
      onSlideStart: s,
      onSlideMove: r,
      onSlideEnd: i,
      onHomeKeyDown: o,
      onEndKeyDown: a,
      onStepKeyDown: l,
      ...c
    } = t, u = $l(oi, n);
    return /* @__PURE__ */ m.jsx(
      qe.span,
      {
        ...c,
        ref: e,
        onKeyDown: we(t.onKeyDown, (d) => {
          d.key === "Home" ? (o(d), d.preventDefault()) : d.key === "End" ? (a(d), d.preventDefault()) : gw.concat(mw).includes(d.key) && (l(d), d.preventDefault());
        }),
        onPointerDown: we(t.onPointerDown, (d) => {
          const f = d.target;
          f.setPointerCapture(d.pointerId), d.preventDefault(), u.thumbs.has(f) ? f.focus() : s(d);
        }),
        onPointerMove: we(t.onPointerMove, (d) => {
          d.target.hasPointerCapture(d.pointerId) && r(d);
        }),
        onPointerUp: we(t.onPointerUp, (d) => {
          const f = d.target;
          f.hasPointerCapture(d.pointerId) && (f.releasePointerCapture(d.pointerId), i(d));
        })
      }
    );
  }
), Sw = "SliderTrack", Cw = v.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, ...s } = t, r = $l(Sw, n);
    return /* @__PURE__ */ m.jsx(
      qe.span,
      {
        "data-disabled": r.disabled ? "" : void 0,
        "data-orientation": r.orientation,
        ...s,
        ref: e
      }
    );
  }
);
Cw.displayName = Sw;
var sd = "SliderRange", Pw = v.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, ...s } = t, r = $l(sd, n), i = xw(sd, n), o = v.useRef(null), a = Pe(e, o), l = r.values.length, c = r.values.map(
      (f) => Ew(f, r.min, r.max)
    ), u = l > 1 ? Math.min(...c) : 0, d = 100 - Math.max(...c);
    return /* @__PURE__ */ m.jsx(
      qe.span,
      {
        "data-orientation": r.orientation,
        "data-disabled": r.disabled ? "" : void 0,
        ...s,
        ref: a,
        style: {
          ...t.style,
          [i.startEdge]: u + "%",
          [i.endEdge]: d + "%"
        }
      }
    );
  }
);
Pw.displayName = sd;
var rd = "SliderThumb", qw = v.forwardRef(
  (t, e) => {
    const n = x9(t.__scopeSlider), [s, r] = v.useState(null), i = Pe(e, (a) => r(a)), o = v.useMemo(
      () => s ? n().findIndex((a) => a.ref.current === s) : -1,
      [n, s]
    );
    return /* @__PURE__ */ m.jsx(q9, { ...t, ref: i, index: o });
  }
), q9 = v.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, index: s, name: r, ...i } = t, o = $l(rd, n), a = xw(rd, n), [l, c] = v.useState(null), u = Pe(e, (y) => c(y)), d = l ? o.form || !!l.closest("form") : !0, f = Yv(l), h = o.values[s], p = h === void 0 ? 0 : Ew(h, o.min, o.max), g = R9(s, o.values.length), A = f == null ? void 0 : f[a.size], b = A ? M9(A, p, a.direction) : 0;
    return v.useEffect(() => {
      if (l)
        return o.thumbs.add(l), () => {
          o.thumbs.delete(l);
        };
    }, [l, o.thumbs]), /* @__PURE__ */ m.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [a.startEdge]: `calc(${p}% + ${b}px)`
        },
        children: [
          /* @__PURE__ */ m.jsx(nd.ItemSlot, { scope: t.__scopeSlider, children: /* @__PURE__ */ m.jsx(
            qe.span,
            {
              role: "slider",
              "aria-label": t["aria-label"] || g,
              "aria-valuemin": o.min,
              "aria-valuenow": h,
              "aria-valuemax": o.max,
              "aria-orientation": o.orientation,
              "data-orientation": o.orientation,
              "data-disabled": o.disabled ? "" : void 0,
              tabIndex: o.disabled ? void 0 : 0,
              ...i,
              ref: u,
              style: h === void 0 ? { display: "none" } : t.style,
              onFocus: we(t.onFocus, () => {
                o.valueIndexToChangeRef.current = s;
              })
            }
          ) }),
          d && /* @__PURE__ */ m.jsx(
            E9,
            {
              name: r ?? (o.name ? o.name + (o.values.length > 1 ? "[]" : "") : void 0),
              form: o.form,
              value: h
            },
            s
          )
        ]
      }
    );
  }
);
qw.displayName = rd;
var E9 = (t) => {
  const { value: e, ...n } = t, s = v.useRef(null), r = v9(e);
  return v.useEffect(() => {
    const i = s.current, o = window.HTMLInputElement.prototype, l = Object.getOwnPropertyDescriptor(o, "value").set;
    if (r !== e && l) {
      const c = new Event("input", { bubbles: !0 });
      l.call(i, e), i.dispatchEvent(c);
    }
  }, [r, e]), /* @__PURE__ */ m.jsx("input", { style: { display: "none" }, ...n, ref: s, defaultValue: e });
};
function T9(t = [], e, n) {
  const s = [...t];
  return s[n] = e, s.sort((r, i) => r - i);
}
function Ew(t, e, n) {
  const i = 100 / (n - e) * (t - e);
  return gf(i, [0, 100]);
}
function R9(t, e) {
  return e > 2 ? `Value ${t + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][t] : void 0;
}
function k9(t, e) {
  if (t.length === 1) return 0;
  const n = t.map((r) => Math.abs(r - e)), s = Math.min(...n);
  return n.indexOf(s);
}
function M9(t, e, n) {
  const s = t / 2, i = eh([0, 50], [0, s]);
  return (s - i(e) * n) * n;
}
function D9(t) {
  return t.slice(0, -1).map((e, n) => t[n + 1] - e);
}
function O9(t, e) {
  if (e > 0) {
    const n = D9(t);
    return Math.min(...n) >= e;
  }
  return !0;
}
function eh(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const s = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + s * (n - t[0]);
  };
}
function L9(t) {
  return (String(t).split(".")[1] || "").length;
}
function N9(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
var Tw = yw, j9 = Cw, B9 = Pw, I9 = qw;
const Rw = v.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ m.jsxs(
  Tw,
  {
    ref: n,
    className: Be(
      "relative flex w-full touch-none select-none items-center",
      t
    ),
    ...e,
    children: [
      /* @__PURE__ */ m.jsx(j9, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-gray-300", children: /* @__PURE__ */ m.jsx(B9, { className: "absolute h-full bg-brand" }) }),
      /* @__PURE__ */ m.jsx(I9, { className: `block h-4 w-4 rounded-full bg-white ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disable
d:pointer-events-none disabled:opacity-50 cursor-pointer` })
    ]
  }
));
Rw.displayName = Tw.displayName;
const F9 = ({
  handleStartGame: t,
  handleCashout: e
}) => {
  const {
    isGameActive: n,
    selectedCurrency: s,
    initializing: r,
    isAutoPlaying: i,
    currentAutoBet: o,
    isFinishingBet: a,
    setIsAutoPlaying: l,
    setIsFinishingBet: c,
    betRanges: u
  } = it(), { multiplier: d, selectedCells: f, preSelectMultiplier: h } = yo(), {
    updateSettings: p,
    mode: g,
    betAmount: A,
    stopOnWin: b,
    stopOnLoss: y,
    numberOfBets: w,
    onWinMode: x,
    onLossMode: S,
    onWinValue: q,
    onLossValue: C,
    minesCount: E,
    errors: T,
    validateSettings: k
  } = Vi(), { addToast: R } = Qd(), D = ($) => $.toFixed(s.fractionalDigits), [F, j] = tt(
    D(A)
  ), [B, L] = tt(null);
  je(() => {
    if (A > Number(u.minBet))
      j(D(A));
    else if (u.minBet) {
      const $ = D(Number(u.minBet));
      j($);
    }
  }, [s, A, j]);
  const O = ($, Xe, Ue = !1) => {
    Ue && Ft("tick"), p({ [$]: Xe });
  }, N = ($) => {
    j($.target.value);
  }, H = () => {
    const $ = parseFloat(F);
    isNaN($) ? j(D(A)) : (O("betAmount", $), j(D($))), L(null);
  }, U = () => {
    i ? (l(!1), c(!0), R({
      variant: "notice",
      message: "Stopping Autoplay...",
      duration: 2e3
    })) : n ? e() : k() && t();
  }, X = () => a ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(QM, { className: "mr-2 h-4 w-4 animate-spin" }),
    "Finishing bet..."
  ] }) : i ? w === "∞" ? "Stop autobet" : `Stop autobet (${o} / ${w})` : n ? `Cash out ${d.toFixed(2)}x` : g === "auto" ? f.length > 0 ? "Start Autobet" : "Select cells to start" : "Place bet", G = ($) => `
    flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200
    ${B === $ ? "ring-1 ring-brand" : ""}`, pe = "flex-grow bg-transparent border-none text-white text-base h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0", Me = "h-9 w-16 px-2 text-sm bg-pills text-white hover:bg-opacity-80 font-bold", Ee = "flex items-center space-x-1 bg-primary rounded-md p-1 h-11 w-1/2", oe = "flex-1 px-1 py-2 rounded text-xs font-bold whitespace-nowrap overflow-hidden", He = "[&>.sliderTrack]:bg-red-500 [&>.sliderTrack]:h-1 [&>.sliderThumb]:h-4 [&>.sliderThumb]:w-2", ye = n || i;
  return /* @__PURE__ */ m.jsxs("div", { className: "bg-secondary flex flex-col no-scrollbar w-full lg:w-1/3 p-4 space-y-4 order-2 lg:order-1 overflow-y-auto", children: [
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: `bg-primary order-last lg:order-first p-2 rounded-md flex mt-4 lg:mb-4 lg:mt-0 ${ye ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ m.jsx(
            "button",
            {
              onClick: () => O("mode", "manual", !0),
              disabled: n && g !== "manual",
              className: `flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all ${g === "manual" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: "Manual"
            }
          ),
          /* @__PURE__ */ m.jsx(
            "button",
            {
              onClick: () => O("mode", "auto", !0),
              disabled: n && g !== "auto",
              className: `flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all ${g === "auto" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: "Auto"
            }
          )
        ]
      }
    ),
    g === "auto" && /* @__PURE__ */ m.jsxs("div", { className: `flex rounded-md bg-primary p-4 py-2 lg:py-4 text-sm lg:text-base ${f.length === 0 ? "opacity-50 pointer-events-none" : ""}`, children: [
      /* @__PURE__ */ m.jsx("div", { className: "flex-1 space-y-2", children: /* @__PURE__ */ m.jsxs("div", { children: [
        /* @__PURE__ */ m.jsx("p", { className: "font-medium text-slate-400", children: "Payout" }),
        /* @__PURE__ */ m.jsx("p", { className: "font-semibold tabular-nums text-green-500", children: h >= 1 ? D(A * h) : 0 })
      ] }) }),
      /* @__PURE__ */ m.jsx("div", { className: "mx-4 w-0.5 bg-slate-600", "aria-hidden": !0 }),
      /* @__PURE__ */ m.jsx("div", { className: "flex-1 space-y-2", children: /* @__PURE__ */ m.jsxs("div", { children: [
        /* @__PURE__ */ m.jsx("p", { className: "font-medium text-slate-400", children: "Multiplier" }),
        /* @__PURE__ */ m.jsxs("p", { className: "font-semibold tabular-nums text-green-500", children: [
          h >= 1 ? h.toFixed(2) : "1.00",
          "x"
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: `space-y-2 ${ye ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ m.jsx(rt, { htmlFor: "betAmount", className: "text-sm text-gray-400", children: "Bet amount" }),
          /* @__PURE__ */ m.jsx("div", { className: G("betAmount"), children: r ? /* @__PURE__ */ m.jsxs("div", { className: "flex items-center w-full space-x-2", children: [
            /* @__PURE__ */ m.jsx(ps, { className: "h-9 w-full bg-gray-700" }),
            /* @__PURE__ */ m.jsx(ps, { className: "h-9 w-16 bg-gray-700" }),
            /* @__PURE__ */ m.jsx(ps, { className: "h-9 w-16 bg-gray-700" })
          ] }) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
            /* @__PURE__ */ m.jsxs("div", { className: "flex items-center w-full bg-primary rounded-md px-2", children: [
              /* @__PURE__ */ m.jsx("span", { className: "text-gray-400 mr-1", children: s.prefixSymbol }),
              /* @__PURE__ */ m.jsx(
                ft,
                {
                  id: "betAmount",
                  type: "number",
                  value: F,
                  onChange: N,
                  onFocus: () => L("betAmount"),
                  onBlur: H,
                  className: pe,
                  style: {
                    WebkitAppearance: "none",
                    MozAppearance: "textfield"
                  },
                  step: `0.${"0".repeat(
                    s.fractionalDigits - 1
                  )}1`
                }
              )
            ] }),
            /* @__PURE__ */ m.jsx(
              lt,
              {
                variant: "secondary",
                size: "sm",
                className: Me,
                onClick: () => {
                  const $ = Math.max(Number(F) / 2, 0);
                  O("betAmount", $, !0), j(D($));
                },
                children: "½"
              }
            ),
            /* @__PURE__ */ m.jsx(
              lt,
              {
                variant: "secondary",
                size: "sm",
                className: Me,
                onClick: () => {
                  const $ = Number(F) * 2;
                  O("betAmount", $, !0), j(D($));
                },
                children: "2×"
              }
            )
          ] }) }),
          T.betAmount && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: T.betAmount })
        ]
      }
    ),
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: `space-y-2 ${ye ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ m.jsx(rt, { className: "text-sm text-gray-400", children: "Mines" }),
          /* @__PURE__ */ m.jsxs("div", { className: "flex items-center space-x-3 bg-primary rounded-md p-3 h-11", children: [
            /* @__PURE__ */ m.jsx("img", { src: pw, width: "20", height: "20" }),
            /* @__PURE__ */ m.jsx(
              Rw,
              {
                value: [E],
                onValueChange: ($) => O("minesCount", $[0], !1),
                min: 1,
                max: 24,
                step: 1,
                disabled: ye,
                className: He
              }
            ),
            /* @__PURE__ */ m.jsx("span", { className: "text-white font-bold bg-pills rounded-md px-2 py-1 min-w-[2rem] text-center text-sm", children: E })
          ] }),
          T.minesCount && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: T.minesCount })
        ]
      }
    ),
    /* @__PURE__ */ m.jsx(
      "div",
      {
        className: "space-y-4 transition-all duration-300 ease-in-out",
        style: {
          maxHeight: g === "auto" ? "100%" : "0%",
          overflow: g === "auto" ? "visible" : "hidden"
        },
        children: g === "auto" && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              className: `space-y-2 ${ye ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ m.jsx(rt, { htmlFor: "numberOfBets", className: "text-sm text-gray-400", children: "Number of Bets" }),
                /* @__PURE__ */ m.jsxs("div", { className: G("numberOfBets"), children: [
                  /* @__PURE__ */ m.jsx(
                    ft,
                    {
                      id: "numberOfBets",
                      value: w,
                      onChange: ($) => O("numberOfBets", $.target.value, !1),
                      onFocus: () => L("numberOfBets"),
                      onBlur: () => L(null),
                      className: pe
                    }
                  ),
                  ["∞", "10", "100"].map(($) => /* @__PURE__ */ m.jsx(
                    lt,
                    {
                      variant: "secondary",
                      onClick: () => O("numberOfBets", $, !0),
                      className: Me,
                      children: $
                    },
                    $
                  ))
                ] }),
                T.numberOfBets && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: T.numberOfBets })
              ]
            }
          ),
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              className: `space-y-2 ${ye ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ m.jsx(rt, { className: "text-sm text-gray-400", children: "On Win" }),
                /* @__PURE__ */ m.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ m.jsxs("div", { className: Ee, children: [
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => O("onWinMode", "reset", !0),
                        className: `${oe} ${x === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Reset"
                      }
                    ),
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => O("onWinMode", "increase", !0),
                        className: `${oe} ${x === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Increase by"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ m.jsxs(
                    "div",
                    {
                      className: `${G("onWinValue")} ${x === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ m.jsx(
                          ft,
                          {
                            type: "number",
                            value: q,
                            onChange: ($) => O(
                              "onWinValue",
                              parseFloat($.target.value)
                            ),
                            onFocus: () => L("onWinValue"),
                            onBlur: () => L(null),
                            className: pe,
                            disabled: x === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ m.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                T.onWinValue && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: T.onWinValue })
              ]
            }
          ),
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              className: `space-y-2 ${ye ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ m.jsx(rt, { className: "text-sm text-gray-400", children: "On Loss" }),
                /* @__PURE__ */ m.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ m.jsxs("div", { className: Ee, children: [
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => O("onLossMode", "reset", !0),
                        className: `${oe} ${S === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Reset"
                      }
                    ),
                    /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        onClick: () => O("onLossMode", "increase", !0),
                        className: `${oe} ${S === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Increase by"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ m.jsxs(
                    "div",
                    {
                      className: `${G("onLossValue")} ${S === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ m.jsx(
                          ft,
                          {
                            type: "number",
                            value: C,
                            onChange: ($) => O(
                              "onLossValue",
                              parseFloat($.target.value)
                            ),
                            onFocus: () => L("onLossValue"),
                            onBlur: () => L(null),
                            className: pe,
                            disabled: S === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ m.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                T.onLossValue && /* @__PURE__ */ m.jsx("span", { className: "text-red-500 text-xs", children: T.onLossValue })
              ]
            }
          ),
          /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ m.jsx(rt, { htmlFor: "stopOnWin", className: "text-sm text-gray-400", children: "Stop on Win" }),
            /* @__PURE__ */ m.jsx("div", { className: G("stopOnWin"), children: /* @__PURE__ */ m.jsx(
              ft,
              {
                id: "stopOnWin",
                type: "number",
                value: b,
                onChange: ($) => O("stopOnWin", parseFloat($.target.value)),
                onFocus: () => L("stopOnWin"),
                onBlur: () => L(null),
                className: pe,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] }),
          /* @__PURE__ */ m.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ m.jsx(rt, { htmlFor: "stopOnLoss", className: "text-sm text-gray-400", children: "Stop on Loss" }),
            /* @__PURE__ */ m.jsx("div", { className: G("stopOnLoss"), children: /* @__PURE__ */ m.jsx(
              ft,
              {
                id: "stopOnLoss",
                type: "number",
                value: y,
                onChange: ($) => O(
                  "stopOnLoss",
                  parseFloat($.target.value)
                ),
                onFocus: () => L("stopOnLoss"),
                onBlur: () => L(null),
                className: pe,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ m.jsx("div", { className: "lg:sticky lg:bottom-0 order-first lg:order-last bg-gray-850", children: /* @__PURE__ */ m.jsx(
      lt,
      {
        className: "w-full bg-gradient-to-b from-brand-gradient-start to-brand-gradient-end hover:from-brand hover:to-brand disabled:opacity-80 text-brand-cta-text text-sm font-bold py-4 rounded-lg h-11",
        onClick: U,
        disabled: g === "auto" && f.length === 0 && !n && !i || a,
        children: X()
      }
    ) })
  ] });
}, V9 = "data:image/png;base64,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", z9 = ({ currency: t, lang: e, theme: n }) => {
  const { authToken: s } = vl(), r = Zr(), i = gt(null), { betAmount: o, minesCount: a, mode: l, updateSettings: c, validateSettings: u } = Vi(), {
    isGameActive: d,
    setIsGameActive: f,
    selectedCurrency: h,
    setCurrency: p,
    setInitializing: g,
    setBalance: A,
    balance: b,
    setTheme: y,
    setIsAutoPlaying: w,
    setCurrentAutoBet: x,
    setBetRanges: S,
    setIsFinishingBet: q,
    finishAutoPlay: C,
    isSoundMuted: E
  } = it(), {
    setGameRoundId: T,
    revealCell: k,
    setMultiplier: R,
    setRevealedCells: D,
    revealedCells: F,
    gameRoundId: j,
    endGame: B,
    resetGame: L,
    toggleSelectedCell: O,
    clearSelectedCells: N,
    selectedCells: H,
    updateBoard: U,
    board: X,
    addFetchingCell: G,
    removeFetchingCell: pe,
    fetchingCells: Me
  } = yo(), { updateProfitData: Ee } = Do(), [oe, He] = tt(!1), { addToast: ye } = Qd();
  je(() => {
    E || zb(), y(n), (async () => {
      if (s)
        await $();
      else
        throw g(!1), new Error("No authToken found.");
    })();
  }, [n, y]);
  const $ = async () => {
    if (s)
      try {
        g(!0);
        const J = await Db(s, "mines");
        if (p(J.currencyDefinition), S({
          minBet: J.allowedBets[0],
          maxBet: J.allowedBets[1]
        }), c({ betAmount: Number(J.allowedBets[0]) }), A(J.balance), J.activeRound) {
          const { id: ee, wager: ge, betData: $t, gameData: ut } = J.activeRound;
          T(ee), f(!0), R(ut.multiplier), c({
            minesCount: $t.mines,
            betAmount: ge
          }), D(ut.selected), ut.selected.forEach((_e) => {
            k(_e, "diamond");
          });
        }
      } catch (J) {
        console.error("Error fetching game data:", J);
      } finally {
        g(!1), He(!0);
      }
  }, Xe = Fe(
    async (J) => {
      if (s)
        try {
          g(!0);
          const ee = await Mb(s, J);
          p(ee.currencyDefinition), S({
            minBet: ee.allowedBets[0],
            maxBet: ee.allowedBets[1]
          }), c({ betAmount: Number(ee.allowedBets[0]) }), A(ee.balance);
        } catch (ee) {
          console.error("Error changing currency:", ee);
        } finally {
          g(!1);
        }
    },
    [s, p, A, g, S]
  );
  je(() => {
    oe && h.currencyCode !== t && Xe(t);
  }, [oe, h, t, Xe]);
  const Ue = Fe(async () => {
    if (s) {
      f(!0), L();
      try {
        const J = {
          amount: o.toString(),
          currency: h.currencyCode,
          custom: {
            mines: a
          }
        }, ee = await Ga(
          s,
          "mines",
          J
        );
        T(ee.roundId), A(ee.balance), f(ee.active);
      } catch (J) {
        ye({
          variant: "error",
          message: "There was a problem starting the game :(",
          duration: 3e3
        }), console.error("Error starting game:", J), f(!1);
      }
    }
  }, [
    o,
    T,
    a,
    L,
    h.currencyCode,
    A,
    f,
    s,
    ye
  ]), Jt = Fe(
    (J) => {
      A(J.balance);
      const ee = X.map((ge, $t) => J.custom.mines.includes($t) ? "mine" : "diamond");
      U(ee), D(J.custom.selected), J.win ? (Ft("win"), Ee(J.winAmount ?? 0, !0), R(J.multiplier ?? 0)) : (Ft("bomb"), Ee(J.winAmount ?? 0, !1)), B(J.winAmount ?? 0);
    },
    [
      A,
      U,
      D,
      Ee,
      X,
      B,
      R
    ]
  ), Z = Fe(async () => {
    if (!s) return;
    const J = (ut) => new Promise((_e) => setTimeout(_e, ut));
    w(!0), q(!1), x(1), ye({
      variant: "notice",
      message: "Starting autoplay...",
      duration: 2e3
    });
    let ee = 0;
    const ge = o;
    console.log("Original betAmount:", ge);
    const $t = async () => {
      const ut = it.getState(), _e = Vi.getState();
      if (!ut.isAutoPlaying && !ut.isFinishingBet) {
        C();
        return;
      }
      if (!u()) {
        console.error("Invalid settings, stopping auto-play"), ye({
          variant: "notice",
          message: "Stopping autoplay...",
          duration: 2e3
        }), C();
        return;
      }
      if (_e.numberOfBets !== "∞" && ut.currentAutoBet > Number(_e.numberOfBets)) {
        console.log("Reached maximum number of bets, stopping auto-play"), C();
        return;
      }
      try {
        await J(1e3);
        const en = Vi.getState().betAmount;
        console.log("Current bet amount:", en);
        const tn = {
          amount: en.toString(),
          currency: h.currencyCode,
          custom: {
            mines: a,
            selected: H
          }
        }, Ls = await Ga(
          s,
          "mines",
          tn
        );
        if (Jt(Ls), await J(1e3), ee += Ls.winAmount ?? 0, console.log("Net win:", ee), _e.stopOnWin > 0 && ee >= _e.stopOnWin) {
          ye({
            variant: "notice",
            message: "Reached win-stop condition. Stopping...",
            duration: 2e3
          }), C(), L();
          return;
        }
        if (_e.stopOnLoss > 0 && ee <= -_e.stopOnLoss) {
          ye({
            variant: "notice",
            message: "Reached loss-stop condition. Stopping...",
            duration: 2e3
          }), C(), L();
          return;
        }
        let Wt = en;
        if (Ls.win) {
          if (_e.onWinMode === "reset")
            Wt = ge;
          else if (_e.onWinMode === "increase") {
            const kt = 1 + _e.onWinValue / 100;
            Wt = en * kt;
          }
        } else if (_e.onLossMode === "reset")
          Wt = ge;
        else if (_e.onLossMode === "increase") {
          const kt = 1 + _e.onLossValue / 100;
          Wt = en * kt;
        }
        console.log("Updating betAmount to:", Wt), Wt > 0 && c({ betAmount: Wt }), L(), x((kt) => kt + 1), it.getState().isAutoPlaying ? $t() : (C(), c({ betAmount: ge }));
      } catch (en) {
        console.error("Error in auto-play:", en), C();
      }
    };
    $t();
  }, [
    s,
    o,
    h,
    a,
    H,
    x,
    Jt,
    L,
    C,
    w,
    q,
    u,
    c,
    ye
  ]), Ln = Fe(() => {
    d || !s || (_T(), l === "auto" && H.length > 0 ? Z() : Ue());
  }, [
    d,
    s,
    l,
    H,
    Z,
    Ue
  ]), Nt = Fe(
    (J, ee) => {
      if (D(J.custom.selected), R(J.multiplier), J.custom.selected.forEach((ge) => {
        k(
          ge,
          J.custom.mines.includes(ge) ? "mine" : "diamond"
        );
      }), J.active && !ee)
        Ft("diamond");
      else {
        const ge = X.map(($t, ut) => J.custom.mines.includes(ut) ? "mine" : "diamond");
        U(ge), B(J.winAmount), Ee(-o, J.win), f(!1), Ft(J.win ? "win" : "bomb");
      }
    },
    [
      o,
      B,
      k,
      f,
      R,
      D,
      Ee,
      X,
      U
    ]
  ), Rt = gt([]);
  gt(null), Fe(async () => {
    if (Rt.current.length === 0) return;
    const J = [...new Set(Rt.current)];
    if (Rt.current = [], !(!s || !d || !j))
      try {
        const ee = {
          gameRoundId: j.toString(),
          custom: { selected: J }
        }, ge = await tg(
          s,
          "mines",
          ee
        );
        Nt(ge, !1), ge.active || (B(ge.winAmount), f(!1), Ft(ge.win ? "win" : "bomb"));
      } catch (ee) {
        ee instanceof Error ? ee.message === "Game has ended" ? (console.log("Ignored request because the game has already ended"), B(0), f(!1)) : ee.message === "Duplicate request" ? console.log("Ignored duplicate request for cells:", J) : console.error("Error revealing cells:", ee) : console.error("Unexpected error:", ee);
      }
  }, [s, d, j, Nt, B, f, Ft]);
  const ns = Fe(
    async (J) => {
      if (!(!s || !d || F.includes(J) || !j || Me.includes(J))) {
        G(J);
        try {
          const ee = {
            gameRoundId: j.toString(),
            custom: { selected: [J] }
          }, ge = await tg(
            s,
            "mines",
            ee
          );
          pe(J), Nt(ge, !1), ge.active || (B(ge.winAmount), f(!1), Ft(ge.win ? "win" : "bomb"));
        } catch (ee) {
          pe(J), ee instanceof Error ? ee.message === "Game has ended" ? (console.log("Ignored request because the game has already ended"), B(0), f(!1)) : ee.message === "Duplicate request" ? console.log("Ignored duplicate request for cell:", J) : console.error("Error revealing cell:", ee) : console.error("Unexpected error:", ee);
        }
      }
    },
    [d, F, j, Nt, s, B, f, Ft, G, pe, Me]
  ), ss = Fe(async () => {
    if (!s) return;
    if (it.getState().isAutoPlaying) {
      w(!1), i.current && clearTimeout(i.current);
      return;
    }
    if (!(!d || !j)) {
      if (F.length === 0) {
        ye({
          variant: "error",
          message: "You have to select a cell before cashout.",
          duration: 2e3
        });
        return;
      }
      try {
        const ee = await JT(
          s,
          "mines",
          j.toString()
        );
        R(ee.multiplier), B(ee.winAmount);
        const ge = X.map(($t, ut) => ee.custom.mines.includes(ut) ? "mine" : "diamond");
        U(ge), A(b + ee.winAmount), Ee(ee.winAmount - o, ee.win), f(!1), Ft("win");
      } catch (ee) {
        console.error("Error cashing out:", ee);
      }
    }
  }, [
    d,
    j,
    R,
    B,
    A,
    b,
    Ee,
    f,
    w,
    o,
    X,
    U,
    s
  ]);
  je(() => {
    L(), l === "manual" && N();
  }, [l, N, L]);
  const mt = n === "betplay-alt" && !r ? { backgroundImage: `url(${V9})`, backgroundSize: "cover", backgroundPosition: "center" } : {};
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col lg:flex-row h-auto lg:h-[600px] ", children: [
      /* @__PURE__ */ m.jsx(
        F9,
        {
          handleStartGame: Ln,
          handleCashout: ss
        }
      ),
      /* @__PURE__ */ m.jsxs("div", { className: "relative flex-grow lg:p-6 flex items-center justify-center order-1 lg:order-2", style: mt, children: [
        /* @__PURE__ */ m.jsx("div", { className: "relative z-10 bg-black p-3 lg:p-2 rounded-md w-full lg:max-w-[480px] aspect-square", children: /* @__PURE__ */ m.jsx(
          A9,
          {
            handleRevealCell: ns,
            handleAutoSelection: O
          }
        ) }),
        !r && n !== "betplay-alt" && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(
            fw,
            {
              starHeight: 5,
              starWidth: 20,
              minSpeed: 5,
              maxSpeed: 20,
              trailColor: n === "betpanda" ? "#0c2d30" : "#dc016c",
              starColor: n === "betpanda" ? "#1fe88a" : "#dc016c"
            }
          ),
          /* @__PURE__ */ m.jsx(hw, { starDensity: 2e-3 })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ m.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ m.jsx(dw, {}),
      /* @__PURE__ */ m.jsx(Ov, {})
    ] })
  ] });
}, U9 = '*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:Nunito Sans,sans-serif;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}:root,:host{--background: 0 0% 100%;--foreground: 222.2 84% 4.9%;--card: 0 0% 100%;--card-foreground: 222.2 84% 4.9%;--popover: 0 0% 100%;--popover-foreground: 222.2 84% 4.9%;--primary: 222.2 47.4% 11.2%;--primary-foreground: 210 40% 98%;--secondary: 210 40% 96.1%;--secondary-foreground: 222.2 47.4% 11.2%;--muted: 210 40% 96.1%;--muted-foreground: 215.4 16.3% 46.9%;--accent: 210 40% 96.1%;--accent-foreground: 222.2 47.4% 11.2%;--destructive: 0 84.2% 60.2%;--destructive-foreground: 210 40% 98%;--border: 214.3 31.8% 91.4%;--input: 214.3 31.8% 91.4%;--ring: 222.2 84% 4.9%;--radius: .5rem;--chart-1: 12 76% 61%;--chart-2: 173 58% 39%;--chart-3: 197 37% 24%;--chart-4: 43 74% 66%;--chart-5: 27 87% 67%}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.no-scrollbar::-webkit-scrollbar{display:none}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.inset-0{top:0;right:0;bottom:0;left:0}.inset-x-0{left:0;right:0}.inset-y-0{top:0;bottom:0}.-top-2{top:-.5rem}.bottom-0{bottom:0}.bottom-16{bottom:4rem}.left-0{left:0}.left-1\\/2{left:50%}.left-2{left:.5rem}.left-3{left:.75rem}.left-4{left:1rem}.left-\\[50\\%\\]{left:50%}.right-0{right:0}.right-2{right:.5rem}.right-3{right:.75rem}.right-4{right:1rem}.top-0{top:0}.top-4{top:1rem}.top-\\[50\\%\\]{top:50%}.top-full{top:100%}.z-10{z-index:10}.z-20{z-index:20}.z-50{z-index:50}.order-1{order:1}.order-2{order:2}.order-first{order:-9999}.order-last{order:9999}.-mx-1{margin-left:-.25rem;margin-right:-.25rem}.mx-4{margin-left:1rem;margin-right:1rem}.mx-auto{margin-left:auto;margin-right:auto}.my-1{margin-top:.25rem;margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.mb-8{margin-bottom:2rem}.ml-2{margin-left:.5rem}.ml-4{margin-left:1rem}.ml-auto{margin-left:auto}.mr-1{margin-right:.25rem}.mr-2{margin-right:.5rem}.mr-4{margin-right:1rem}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.mt-24{margin-top:6rem}.mt-4{margin-top:1rem}.mt-6{margin-top:1.5rem}.mt-8{margin-top:2rem}.mt-auto{margin-top:auto}.block{display:block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.h-0{height:0px}.h-1{height:.25rem}.h-10{height:2.5rem}.h-11{height:2.75rem}.h-14{height:3.5rem}.h-16{height:4rem}.h-2{height:.5rem}.h-2\\.5{height:.625rem}.h-24{height:6rem}.h-3\\.5{height:.875rem}.h-4{height:1rem}.h-44{height:11rem}.h-5{height:1.25rem}.h-6{height:1.5rem}.h-8{height:2rem}.h-9{height:2.25rem}.h-\\[55px\\]{height:55px}.h-auto{height:auto}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-\\[90\\%\\]{max-height:90%}.min-h-screen{min-height:100vh}.w-0{width:0px}.w-0\\.5{width:.125rem}.w-1\\/2{width:50%}.w-10{width:2.5rem}.w-16{width:4rem}.w-2{width:.5rem}.w-2\\.5{width:.625rem}.w-20{width:5rem}.w-3\\.5{width:.875rem}.w-3\\/4{width:75%}.w-4{width:1rem}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-64{width:16rem}.w-72{width:18rem}.w-8{width:2rem}.w-80{width:20rem}.w-9{width:2.25rem}.w-\\[100px\\]{width:100px}.w-\\[110px\\]{width:110px}.w-\\[30\\%\\]{width:30%}.w-\\[70\\%\\]{width:70%}.w-\\[90vw\\]{width:90vw}.w-full{width:100%}.min-w-\\[2rem\\]{min-width:2rem}.min-w-\\[8rem\\]{min-width:8rem}.max-w-lg{max-width:32rem}.flex-1{flex:1 1 0%}.shrink-0{flex-shrink:0}.flex-grow,.grow{flex-grow:1}.-translate-x-1\\/2,.translate-x-\\[-50\\%\\]{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.translate-y-\\[-50\\%\\]{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes custom-pulse{0%,to{transform:scale(.95)}50%{transform:scale(1.05)}}.animate-custom-pulse{animation:custom-pulse .8s cubic-bezier(.4,0,.6,1) infinite}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-default{cursor:default}.cursor-pointer{cursor:pointer}.touch-none{touch-action:none}.select-none{-webkit-user-select:none;user-select:none}.resize{resize:both}.list-disc{list-style-type:disc}.grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.items-stretch{align-items:stretch}.justify-start{justify-content:flex-start}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1\\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-x-1>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.25rem * var(--tw-space-x-reverse));margin-left:calc(.25rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-3>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.75rem * var(--tw-space-x-reverse));margin-left:calc(.75rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-6>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1.5rem * var(--tw-space-x-reverse));margin-left:calc(1.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-1\\.5>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.375rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.375rem * var(--tw-space-y-reverse))}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.whitespace-nowrap{white-space:nowrap}.rounded{border-radius:var(--radius)}.rounded-\\[inherit\\]{border-radius:inherit}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-t-\\[10px\\]{border-top-left-radius:10px;border-top-right-radius:10px}.border{border-width:1px}.border-2{border-width:2px}.border-4{border-width:4px}.border-b{border-bottom-width:1px}.border-b-8{border-bottom-width:8px}.border-l{border-left-width:1px}.border-l-8{border-left-width:8px}.border-r{border-right-width:1px}.border-r-8{border-right-width:8px}.border-t{border-top-width:1px}.border-none{border-style:none}.border-border{border-color:hsl(var(--border))}.border-brand{--tw-border-opacity: 1;border-color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-border-opacity)))}.border-gray-700{--tw-border-opacity: 1;border-color:rgb(55 65 81 / var(--tw-border-opacity))}.border-green-500{--tw-border-opacity: 1;border-color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-border-opacity)))}.border-input{border-color:hsl(var(--input))}.border-red-500{--tw-border-opacity: 1;border-color:rgb(239 68 68 / var(--tw-border-opacity))}.border-secondary{--tw-border-opacity: 1;border-color:hsl(var(--twc-secondary) / var(--twc-secondary-opacity, var(--tw-border-opacity)))}.border-slate-600{--tw-border-opacity: 1;border-color:rgb(71 85 105 / var(--tw-border-opacity))}.border-transparent{border-color:transparent}.border-b-white{--tw-border-opacity: 1;border-bottom-color:rgb(255 255 255 / var(--tw-border-opacity))}.border-l-transparent{border-left-color:transparent}.border-t-brand{--tw-border-opacity: 1;border-top-color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-border-opacity)))}.border-t-transparent{border-top-color:transparent}.border-opacity-0{--tw-border-opacity: 0}.bg-\\[\\#04202b\\]{--tw-bg-opacity: 1;background-color:rgb(4 32 43 / var(--tw-bg-opacity))}.bg-\\[\\#0e1621\\]{--tw-bg-opacity: 1;background-color:rgb(14 22 33 / var(--tw-bg-opacity))}.bg-\\[\\#152538\\]{--tw-bg-opacity: 1;background-color:rgb(21 37 56 / var(--tw-bg-opacity))}.bg-\\[\\#2d3845\\]{--tw-bg-opacity: 1;background-color:rgb(45 56 69 / var(--tw-bg-opacity))}.bg-\\[\\#ff00ff\\]{--tw-bg-opacity: 1;background-color:rgb(255 0 255 / var(--tw-bg-opacity))}.bg-background{background-color:hsl(var(--background))}.bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.bg-black\\/80{background-color:#000c}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))}.bg-border{background-color:hsl(var(--border))}.bg-brand{--tw-bg-opacity: 1;background-color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-bg-opacity)))}.bg-destructive{background-color:hsl(var(--destructive))}.bg-gray-300{--tw-bg-opacity: 1;background-color:rgb(209 213 219 / var(--tw-bg-opacity))}.bg-gray-700{--tw-bg-opacity: 1;background-color:rgb(55 65 81 / var(--tw-bg-opacity))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity))}.bg-gray-950{--tw-bg-opacity: 1;background-color:rgb(3 7 18 / var(--tw-bg-opacity))}.bg-green-500{--tw-bg-opacity: 1;background-color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-bg-opacity)))}.bg-green-500\\/30{background-color:hsl(var(--twc-green-500) / .3)}.bg-muted{background-color:hsl(var(--muted))}.bg-pills{--tw-bg-opacity: 1;background-color:hsl(var(--twc-pills) / var(--twc-pills-opacity, var(--tw-bg-opacity)))}.bg-popover{background-color:hsl(var(--popover))}.bg-primary{--tw-bg-opacity: 1;background-color:hsl(var(--twc-primary) / var(--twc-primary-opacity, var(--tw-bg-opacity)))}.bg-red-400{--tw-bg-opacity: 1;background-color:rgb(248 113 113 / var(--tw-bg-opacity))}.bg-secondary{--tw-bg-opacity: 1;background-color:hsl(var(--twc-secondary) / var(--twc-secondary-opacity, var(--tw-bg-opacity)))}.bg-slate-600{--tw-bg-opacity: 1;background-color:rgb(71 85 105 / var(--tw-bg-opacity))}.bg-transparent{background-color:transparent}.bg-violet-700{--tw-bg-opacity: 1;background-color:rgb(109 40 217 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-white\\/40{background-color:#fff6}.bg-yellow-500{--tw-bg-opacity: 1;background-color:rgb(234 179 8 / var(--tw-bg-opacity))}.bg-gradient-to-b{background-image:linear-gradient(to bottom,var(--tw-gradient-stops))}.from-brand-gradient-start{--tw-gradient-from: hsl(var(--twc-brand-gradient-start) / var(--twc-brand-gradient-start-opacity, 1)) var(--tw-gradient-from-position);--tw-gradient-to: hsl(var(--twc-brand-gradient-start) / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.to-brand-gradient-end{--tw-gradient-to: hsl(var(--twc-brand-gradient-end) / var(--twc-brand-gradient-end-opacity, 1)) var(--tw-gradient-to-position)}.fill-current{fill:currentColor}.p-0{padding:0}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-\\[1px\\]{padding:1px}.px-0{padding-left:0;padding-right:0}.px-1{padding-left:.25rem;padding-right:.25rem}.px-1\\.5{padding-left:.375rem;padding-right:.375rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-2\\.5{padding-left:.625rem;padding-right:.625rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-0\\.5{padding-top:.125rem;padding-bottom:.125rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pb-4{padding-bottom:1rem}.pb-\\[56px\\]{padding-bottom:56px}.pl-5{padding-left:1.25rem}.pl-8{padding-left:2rem}.pr-2{padding-right:.5rem}.pr-8{padding-right:2rem}.pt-0{padding-top:0}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-black{font-weight:900}.font-bold{font-weight:700}.font-extrabold{font-weight:800}.font-medium{font-weight:500}.font-semibold{font-weight:600}.uppercase{text-transform:uppercase}.lowercase{text-transform:lowercase}.tabular-nums{--tw-numeric-spacing: tabular-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.leading-none{line-height:1}.tracking-tight{letter-spacing:-.025em}.tracking-widest{letter-spacing:.1em}.text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.text-brand{--tw-text-opacity: 1;color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-text-opacity)))}.text-brand-cta-text{--tw-text-opacity: 1;color:hsl(var(--twc-brand-cta-text) / var(--twc-brand-cta-text-opacity, var(--tw-text-opacity)))}.text-destructive-foreground{color:hsl(var(--destructive-foreground))}.text-foreground{color:hsl(var(--foreground))}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.text-green-400{--tw-text-opacity: 1;color:rgb(74 222 128 / var(--tw-text-opacity))}.text-green-500{--tw-text-opacity: 1;color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-text-opacity)))}.text-muted-foreground{color:hsl(var(--muted-foreground))}.text-popover-foreground{color:hsl(var(--popover-foreground))}.text-primary{--tw-text-opacity: 1;color:hsl(var(--twc-primary) / var(--twc-primary-opacity, var(--tw-text-opacity)))}.text-red-400{--tw-text-opacity: 1;color:rgb(248 113 113 / var(--tw-text-opacity))}.text-red-500{--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}.text-slate-400{--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline-offset-4{text-underline-offset:4px}.opacity-0{opacity:0}.opacity-100{opacity:1}.opacity-20{opacity:.2}.opacity-50{opacity:.5}.opacity-60{opacity:.6}.opacity-70{opacity:.7}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-2xl{--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / .25);--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-lg{--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-md{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.ring-1{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.ring-brand{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-ring-opacity)))}.ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.duration-200{transition-duration:.2s}.duration-300{transition-duration:.3s}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.will-change-auto{will-change:auto}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.animate-in{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.fade-in-0{--tw-enter-opacity: 0}.zoom-in-95{--tw-enter-scale: .95}.duration-200{animation-duration:.2s}.duration-300{animation-duration:.3s}.ease-in-out{animation-timing-function:cubic-bezier(.4,0,.2,1)}.betpanda,[data-theme=betpanda]{--twc-brand: 152.39999999999998 76.1% 44.3%;--twc-brand-gradient-start: 152.39999999999998 76.1% 44.3%;--twc-brand-gradient-end: 152.29999999999995 74.6% 37.1%;--twc-pills: 210.5 60% 18.6%;--twc-primary: 212.39999999999998 72.5% 10%;--twc-secondary: 212.60000000000002 45.5% 15.1%;--twc-green-500: 120.30000000000001 100% 45.3%}.betplay,[data-theme=betplay],.betplay-alt,[data-theme=betplay-alt]{--twc-brand: 333 83.3% 47.1%;--twc-brand-cta-text: 0 0% 100%;--twc-brand-gradient-start: 333 83.3% 47.1%;--twc-brand-gradient-end: 309.20000000000005 84% 32%;--twc-pills: 210.5 60% 18.6%;--twc-primary: 212.39999999999998 72.5% 10%;--twc-secondary: 212.60000000000002 45.5% 15.1%;--twc-border: 330.29999999999995 100% 43.1%;--twc-border-opacity: .64;--twc-green-500: 120.30000000000001 100% 45.3%}.theme2,[data-theme=theme2]{--twc-brand: 120 100% 25.1%;--twc-primary: 0 0% 100%;--twc-secondary: 0 0% 94.1%}.\\[border\\:calc\\(var\\(--border-width\\)\\*1px\\)_solid_transparent\\]{border:calc(var(--border-width) * 1px) solid transparent}.\\!\\[mask-clip\\:padding-box\\,border-box\\]{-webkit-mask-clip:padding-box,border-box!important;mask-clip:padding-box,border-box!important}.\\!\\[mask-composite\\:intersect\\]{-webkit-mask-composite:source-in,xor!important;mask-composite:intersect!important}.\\[mask\\:linear-gradient\\(transparent\\,transparent\\)\\,linear-gradient\\(white\\,white\\)\\]{-webkit-mask:linear-gradient(transparent,transparent),linear-gradient(white,white);mask:linear-gradient(transparent,transparent),linear-gradient(white,white)}.file\\:border-0::file-selector-button{border-width:0px}.file\\:bg-transparent::file-selector-button{background-color:transparent}.file\\:text-sm::file-selector-button{font-size:.875rem;line-height:1.25rem}.file\\:font-medium::file-selector-button{font-weight:500}.file\\:text-foreground::file-selector-button{color:hsl(var(--foreground))}.placeholder\\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.after\\:absolute:after{content:var(--tw-content);position:absolute}.after\\:aspect-square:after{content:var(--tw-content);aspect-ratio:1 / 1}.after\\:w-\\[calc\\(var\\(--size\\)\\*1px\\)\\]:after{content:var(--tw-content);width:calc(var(--size) * 1px)}@keyframes border-beam{to{content:var(--tw-content);offset-distance:100%}}.after\\:animate-border-beam:after{content:var(--tw-content);animation:border-beam calc(var(--duration)*1s) infinite linear}.after\\:\\[animation-delay\\:var\\(--delay\\)\\]:after{content:var(--tw-content);animation-delay:var(--delay)}.after\\:\\[background\\:linear-gradient\\(to_left\\,var\\(--color-from\\)\\,var\\(--color-to\\)\\,transparent\\)\\]:after{content:var(--tw-content);background:linear-gradient(to left,var(--color-from),var(--color-to),transparent)}.after\\:\\[offset-anchor\\:calc\\(var\\(--anchor\\)\\*1\\%\\)_50\\%\\]:after{content:var(--tw-content);offset-anchor:calc(var(--anchor) * 1%) 50%}.after\\:\\[offset-path\\:rect\\(0_auto_auto_0_round_calc\\(var\\(--size\\)\\*1px\\)\\)\\]:after{content:var(--tw-content);offset-path:rect(0 auto auto 0 round calc(var(--size) * 1px))}@media (hover: hover) and (pointer: fine){.hover\\:bg-\\[\\#1a2634\\]:hover{--tw-bg-opacity: 1;background-color:rgb(26 38 52 / var(--tw-bg-opacity))}.hover\\:bg-\\[\\#2d3845\\]:hover{--tw-bg-opacity: 1;background-color:rgb(45 56 69 / var(--tw-bg-opacity))}.hover\\:bg-\\[\\#ff33ff\\]:hover{--tw-bg-opacity: 1;background-color:rgb(255 51 255 / var(--tw-bg-opacity))}.hover\\:bg-accent:hover{background-color:hsl(var(--accent))}.hover\\:bg-brand\\/80:hover{background-color:hsl(var(--twc-brand) / .8)}.hover\\:bg-destructive\\/80:hover{background-color:hsl(var(--destructive) / .8)}.hover\\:bg-destructive\\/90:hover{background-color:hsl(var(--destructive) / .9)}.hover\\:bg-gray-700:hover{--tw-bg-opacity: 1;background-color:rgb(55 65 81 / var(--tw-bg-opacity))}.hover\\:bg-primary\\/80:hover{background-color:hsl(var(--twc-primary) / .8)}.hover\\:bg-primary\\/90:hover{background-color:hsl(var(--twc-primary) / .9)}.hover\\:bg-red-500:hover{--tw-bg-opacity: 1;background-color:rgb(239 68 68 / var(--tw-bg-opacity))}.hover\\:bg-secondary\\/80:hover{background-color:hsl(var(--twc-secondary) / .8)}.hover\\:bg-transparent:hover{background-color:transparent}.hover\\:bg-opacity-80:hover{--tw-bg-opacity: .8}.hover\\:from-brand:hover{--tw-gradient-from: hsl(var(--twc-brand) / var(--twc-brand-opacity, 1)) var(--tw-gradient-from-position);--tw-gradient-to: hsl(var(--twc-brand) / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.hover\\:to-brand:hover{--tw-gradient-to: hsl(var(--twc-brand) / var(--twc-brand-opacity, 1)) var(--tw-gradient-to-position)}.hover\\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.hover\\:text-white:hover{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}}.focus\\:bg-accent:focus{background-color:hsl(var(--accent))}.focus\\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-0:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.focus\\:ring-offset-0:focus{--tw-ring-offset-width: 0px}.focus\\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\\:border-0:focus-visible{border-width:0px}.focus-visible\\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\\:ring-0:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-brand:focus-visible{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-ring-opacity)))}.focus-visible\\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.focus-visible\\:ring-offset-0:focus-visible{--tw-ring-offset-width: 0px}.focus-visible\\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-100:disabled{opacity:1}.disabled\\:opacity-50:disabled{opacity:.5}.disabled\\:opacity-80:disabled{opacity:.8}@media (hover: hover) and (pointer: fine){.group:hover .group-hover\\:text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}}.peer:disabled~.peer-disabled\\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\\:opacity-70{opacity:.7}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}@keyframes accordion-up{0%{height:var(--radix-accordion-content-height)}to{height:0}}.data-\\[state\\=closed\\]\\:animate-accordion-up[data-state=closed]{animation:accordion-up .2s ease-out}@keyframes accordion-down{0%{height:0}to{height:var(--radix-accordion-content-height)}}.data-\\[state\\=open\\]\\:animate-accordion-down[data-state=open]{animation:accordion-down .2s ease-out}.data-\\[state\\=open\\]\\:bg-accent[data-state=open]{background-color:hsl(var(--accent))}.data-\\[state\\=open\\]\\:bg-secondary[data-state=open]{--tw-bg-opacity: 1;background-color:hsl(var(--twc-secondary) / var(--twc-secondary-opacity, var(--tw-bg-opacity)))}.data-\\[state\\=open\\]\\:text-muted-foreground[data-state=open]{color:hsl(var(--muted-foreground))}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[state\\=closed\\]\\:duration-300[data-state=closed]{transition-duration:.3s}.data-\\[state\\=open\\]\\:duration-500[data-state=open]{transition-duration:.5s}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.data-\\[state\\=closed\\]\\:slide-out-to-bottom[data-state=closed]{--tw-exit-translate-y: 100%}.data-\\[state\\=closed\\]\\:slide-out-to-left[data-state=closed]{--tw-exit-translate-x: -100%}.data-\\[state\\=closed\\]\\:slide-out-to-left-1\\/2[data-state=closed]{--tw-exit-translate-x: -50%}.data-\\[state\\=closed\\]\\:slide-out-to-right[data-state=closed]{--tw-exit-translate-x: 100%}.data-\\[state\\=closed\\]\\:slide-out-to-top[data-state=closed]{--tw-exit-translate-y: -100%}.data-\\[state\\=closed\\]\\:slide-out-to-top-\\[48\\%\\][data-state=closed]{--tw-exit-translate-y: -48%}.data-\\[state\\=open\\]\\:slide-in-from-bottom[data-state=open]{--tw-enter-translate-y: 100%}.data-\\[state\\=open\\]\\:slide-in-from-left[data-state=open]{--tw-enter-translate-x: -100%}.data-\\[state\\=open\\]\\:slide-in-from-left-1\\/2[data-state=open]{--tw-enter-translate-x: -50%}.data-\\[state\\=open\\]\\:slide-in-from-right[data-state=open]{--tw-enter-translate-x: 100%}.data-\\[state\\=open\\]\\:slide-in-from-top[data-state=open]{--tw-enter-translate-y: -100%}.data-\\[state\\=open\\]\\:slide-in-from-top-\\[48\\%\\][data-state=open]{--tw-enter-translate-y: -48%}.data-\\[state\\=closed\\]\\:duration-300[data-state=closed]{animation-duration:.3s}.data-\\[state\\=open\\]\\:duration-500[data-state=open]{animation-duration:.5s}@media (min-width: 640px){.sm\\:w-\\[70\\%\\]{width:70%}.sm\\:max-w-\\[425px\\]{max-width:425px}.sm\\:max-w-sm{max-width:24rem}.sm\\:flex-row{flex-direction:row}.sm\\:justify-end{justify-content:flex-end}.sm\\:space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.sm\\:rounded-lg{border-radius:var(--radius)}.sm\\:p-6{padding:1.5rem}.sm\\:text-left{text-align:left}}@media (min-width: 768px){.md\\:ml-\\[60px\\]{margin-left:60px}.md\\:flex{display:flex}.md\\:hidden{display:none}.md\\:max-w-\\[600px\\]{max-width:600px}}@media (min-width: 1024px){.lg\\:sticky{position:sticky}.lg\\:bottom-0{bottom:0}.lg\\:order-1{order:1}.lg\\:order-2{order:2}.lg\\:order-first{order:-9999}.lg\\:order-last{order:9999}.lg\\:mb-0{margin-bottom:0}.lg\\:mb-4{margin-bottom:1rem}.lg\\:mt-0{margin-top:0}.lg\\:h-\\[600px\\]{height:600px}.lg\\:min-h-screen{min-height:100vh}.lg\\:w-1\\/3{width:33.333333%}.lg\\:w-\\[23rem\\]{width:23rem}.lg\\:max-w-\\[1200px\\]{max-width:1200px}.lg\\:max-w-\\[480px\\]{max-width:480px}.lg\\:flex-row{flex-direction:row}.lg\\:rounded-lg{border-radius:var(--radius)}.lg\\:p-2{padding:.5rem}.lg\\:p-6{padding:1.5rem}.lg\\:py-4{padding-top:1rem;padding-bottom:1rem}.lg\\:text-base{font-size:1rem;line-height:1.5rem}}.\\[\\&\\>\\.sliderThumb\\]\\:h-4>.sliderThumb{height:1rem}.\\[\\&\\>\\.sliderThumb\\]\\:w-2>.sliderThumb{width:.5rem}.\\[\\&\\>\\.sliderTrack\\]\\:h-1>.sliderTrack{height:.25rem}.\\[\\&\\>\\.sliderTrack\\]\\:bg-red-500>.sliderTrack{--tw-bg-opacity: 1;background-color:rgb(239 68 68 / var(--tw-bg-opacity))}.\\[\\&\\[data-state\\=open\\]\\>svg\\]\\:rotate-180[data-state=open]>svg{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}', W9 = ({
  game: t,
  token: e,
  currency: n,
  lang: s,
  theme: r
}) => {
  const { setAuthToken: i, isInitialized: o } = vl(), [a, l] = tt(!0), [c, u] = tt(null);
  if (je(() => {
    (async () => {
      if (!e || !t) {
        u("Invalid parameters"), l(!1);
        return;
      }
      try {
        await i(e), await I1(s);
      } catch (h) {
        u(
          h instanceof Error ? h.message : "An unknown error occurred"
        );
      } finally {
        l(!1);
      }
    })();
  }, [t, e, s, o, i]), a)
    return /* @__PURE__ */ m.jsx("div", { children: "Loading..." });
  if (c)
    return /* @__PURE__ */ m.jsxs("div", { children: [
      "Error: ",
      c
    ] });
  const d = { token: e, currency: n, lang: s, theme: r };
  switch (t) {
    case "cointoss":
      return /* @__PURE__ */ m.jsx(d9, { ...d });
    case "mines":
      return /* @__PURE__ */ m.jsx(z9, { ...d });
    default:
      return /* @__PURE__ */ m.jsx("div", { children: "Unsupported game type" });
  }
}, H9 = (t) => {
  const e = gt(null);
  return je(() => {
    if (e.current) {
      const s = e.current.getRootNode();
      if (s instanceof ShadowRoot) {
        const r = document.createElement("style");
        r.textContent = U9, s.appendChild(r);
      }
    }
  }, []), /* @__PURE__ */ m.jsx("div", { ref: e, className: "w-full lg:max-w-[1200px] md:max-w-[600px] bg-gray-900 rounded-lg shadow-2xl overflow-hidden flex flex-col", "data-theme": t.theme, children: /* @__PURE__ */ m.jsx(hA, { children: /* @__PURE__ */ m.jsx(WT, { children: /* @__PURE__ */ m.jsx(W9, { ...t }) }) }) });
}, Q9 = t1(H9, {
  props: {
    game: "string",
    token: "string",
    currency: "string",
    lang: "string",
    theme: "string"
  },
  shadow: "open"
});
customElements.get("blink-launcher") || customElements.define("blink-launcher", Q9);
export {
  Q9 as default
};
