var hx = Object.defineProperty;
var fx = (e, t, n) => t in e ? hx(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var L = (e, t, n) => fx(e, typeof t != "symbol" ? t + "" : t, n);
import * as b from "react";
import P, { createContext as Ts, useContext as Wt, useId as iu, useEffect as Lt, useCallback as ce, Component as px, useLayoutEffect as ru, useRef as fe, useInsertionEffect as zg, useMemo as Ln, forwardRef as kr, Fragment as _g, createElement as Fn, Children as gx, isValidElement as mx, useState as ie } from "react";
import * as ou from "react-dom";
import Zg from "react-dom";
var Hg = { exports: {} }, va = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ax = P, yx = Symbol.for("react.element"), wx = Symbol.for("react.fragment"), bx = Object.prototype.hasOwnProperty, xx = Ax.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, vx = { key: !0, ref: !0, __self: !0, __source: !0 };
function Jg(e, t, n) {
  var s, i = {}, r = null, o = null;
  n !== void 0 && (r = "" + n), t.key !== void 0 && (r = "" + t.key), t.ref !== void 0 && (o = t.ref);
  for (s in t) bx.call(t, s) && !vx.hasOwnProperty(s) && (i[s] = t[s]);
  if (e && e.defaultProps) for (s in t = e.defaultProps, t) i[s] === void 0 && (i[s] = t[s]);
  return { $$typeof: yx, type: e, key: r, ref: o, props: i, _owner: xx.current };
}
va.Fragment = wx;
va.jsx = Jg;
va.jsxs = Jg;
Hg.exports = va;
var y = Hg.exports, Cx = Object.defineProperty, Sx = (e, t, n) => t in e ? Cx(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, vi = (e, t, n) => (Sx(e, typeof t != "symbol" ? t + "" : t, n), n), Xg, sh = Zg;
Xg = sh.createRoot, sh.hydrateRoot;
const Mx = {
  stringify: (e) => e,
  parse: (e) => e
}, Ex = {
  stringify: (e) => `${e}`,
  parse: (e) => parseFloat(e)
}, qx = {
  stringify: (e) => e ? "true" : "false",
  parse: (e) => /^[ty1-9]/i.test(e)
}, Rx = {
  stringify: (e) => e.name,
  parse: (e, t) => {
    const n = (() => {
      if (typeof window < "u" && e in window)
        return window[e];
      if (typeof global < "u" && e in global)
        return global[e];
    })();
    return typeof n == "function" ? n.bind(t) : void 0;
  }
}, kx = {
  stringify: (e) => JSON.stringify(e),
  parse: (e) => typeof e == "string" ? JSON.parse(e) : e
}, Tx = {
  string: Mx,
  number: Ex,
  boolean: qx,
  function: Rx,
  json: kx
}, Dx = "__reactProps";
function Bx(e, t, n) {
  t.props || (t.props = e.propTypes ? Object.keys(e.propTypes) : []);
  const s = (Array.isArray(t.props) ? t.props.slice() : Object.keys(t.props)).filter((a) => a !== "container"), i = {}, r = {};
  for (const a of s) {
    i[a] = Array.isArray(t.props) ? "string" : t.props[a];
    const l = Ix(a);
    r[a] = l;
  }
  class o extends HTMLElement {
    constructor() {
      super(), vi(this, "connected", !1), vi(this, "context"), vi(this, "_props", {}), vi(this, "container"), vi(this, "observer"), this.observer = new MutationObserver(
        (l) => this.attributesChanged(l)
      ), this.observer.observe(this, { attributes: !0 }), t.shadow ? this.container = this.attachShadow({
        mode: t.shadow
      }) : this.container = this, this._props.container = this.container;
    }
    set props(l) {
      this._props = {
        ...this._props,
        ...l
      }, this.update();
    }
    get props() {
      return this._props;
    }
    connectedCallback() {
      this.connected = !0;
      for (const l of s)
        this.setProps(l);
      this.mount();
    }
    disconnectedCallback() {
      this.connected = !1, this.observer.disconnect(), this.unmount();
    }
    attributesChanged(l) {
      l.forEach(({ attributeName: c }) => {
        this.setProps(c);
      }), this.update();
    }
    setProps(l) {
      const c = Object.keys(this).find((g) => g.includes(Dx)), u = c ? this[c] : {}, d = r[l], h = u[l] ?? this.getAttribute(d), f = i[l], p = Tx[f];
      l in u ? this._props[l] = h : h && p != null && p.parse && (this._props[l] = p.parse(h, this));
    }
    update() {
      this.connected && this.context && n.update(this.context, this.props);
    }
    mount() {
      if (!this.connected)
        throw new Error(`${e} is not in a DOM`);
      if (this.context)
        throw new Error(`${e} is already mounted`);
      this.context = n.mount(this.container, e, this.props);
    }
    unmount() {
      this.context && n.unmount(this.context);
    }
  }
  return o;
}
function Ix(e = "") {
  return e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
const Px = (e, t, n) => {
  const s = Xg(e), i = P.createElement(t, n);
  return s.render(i), {
    root: s,
    ReactComponent: t
  };
}, Ox = ({ root: e, ReactComponent: t }, n) => {
  const s = P.createElement(t, n);
  e.render(s);
}, Nx = ({ root: e }) => {
  e.unmount();
}, Lx = (e, t = {}) => Bx(e, t, { mount: Px, update: Ox, unmount: Nx });
function Fx(e) {
  if (typeof Proxy > "u")
    return e;
  const t = /* @__PURE__ */ new Map(), n = (...s) => e(...s);
  return new Proxy(n, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (s, i) => i === "create" ? e : (t.has(i) || t.set(i, e(i)), t.get(i))
  });
}
function $i(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
const Jl = (e) => Array.isArray(e);
function $g(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let s = 0; s < n; s++)
    if (t[s] !== e[s])
      return !1;
  return !0;
}
function tr(e) {
  return typeof e == "string" || Array.isArray(e);
}
function ih(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, s) => {
    t[0][s] = n.get(), t[1][s] = n.getVelocity();
  }), t;
}
function au(e, t, n, s) {
  if (typeof t == "function") {
    const [i, r] = ih(s);
    t = t(n !== void 0 ? n : e.custom, i, r);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, r] = ih(s);
    t = t(n !== void 0 ? n : e.custom, i, r);
  }
  return t;
}
function Ca(e, t, n) {
  const s = e.getProps();
  return au(s, t, n !== void 0 ? n : s.custom, e);
}
const lu = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], cu = ["initial", ...lu], Tr = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Xn = new Set(Tr), pn = (e) => e * 1e3, gn = (e) => e / 1e3, jx = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, Vx = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Ux = {
  type: "keyframes",
  duration: 0.8
}, Yx = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, Wx = (e, { keyframes: t }) => t.length > 2 ? Ux : Xn.has(e) ? e.startsWith("scale") ? Vx(t[1]) : jx : Yx;
function uu(e, t) {
  return e[t] || e.default || e;
}
const Qx = {
  skipAnimations: !1,
  useManualTiming: !1
}, Gx = (e) => e !== null;
function Sa(e, { repeat: t, repeatType: n = "loop" }, s) {
  const i = e.filter(Gx), r = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return !r || s === void 0 ? i[r] : s;
}
const Jt = (e) => e;
function Kx(e) {
  let t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), s = !1, i = !1;
  const r = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(c) {
    r.has(c) && (l.schedule(c), e()), c(o);
  }
  const l = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, u = !1, d = !1) => {
      const f = d && s ? t : n;
      return u && r.add(c), f.has(c) || f.add(c), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      n.delete(c), r.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (o = c, s) {
        i = !0;
        return;
      }
      s = !0, [t, n] = [n, t], n.clear(), t.forEach(a), s = !1, i && (i = !1, l.process(c));
    }
  };
  return l;
}
const Gr = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], zx = 40;
function tm(e, t) {
  let n = !1, s = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, r = () => n = !0, o = Gr.reduce((A, w) => (A[w] = Kx(r), A), {}), { read: a, resolveKeyframes: l, update: c, preRender: u, render: d, postRender: h } = o, f = () => {
    const A = performance.now();
    n = !1, i.delta = s ? 1e3 / 60 : Math.max(Math.min(A - i.timestamp, zx), 1), i.timestamp = A, i.isProcessing = !0, a.process(i), l.process(i), c.process(i), u.process(i), d.process(i), h.process(i), i.isProcessing = !1, n && t && (s = !1, e(f));
  }, p = () => {
    n = !0, s = !0, i.isProcessing || e(f);
  };
  return { schedule: Gr.reduce((A, w) => {
    const x = o[w];
    return A[w] = (v, C = !1, E = !1) => (n || p(), x.schedule(v, C, E)), A;
  }, {}), cancel: (A) => {
    for (let w = 0; w < Gr.length; w++)
      o[Gr[w]].cancel(A);
  }, state: i, steps: o };
}
const { schedule: pt, cancel: jn, state: Yt, steps: rl } = tm(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Jt, !0), em = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, _x = 1e-7, Zx = 12;
function Hx(e, t, n, s, i) {
  let r, o, a = 0;
  do
    o = t + (n - t) / 2, r = em(o, s, i) - e, r > 0 ? n = o : t = o;
  while (Math.abs(r) > _x && ++a < Zx);
  return o;
}
function Dr(e, t, n, s) {
  if (e === t && n === s)
    return Jt;
  const i = (r) => Hx(r, 0, 1, e, n);
  return (r) => r === 0 || r === 1 ? r : em(i(r), t, s);
}
const nm = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, sm = (e) => (t) => 1 - e(1 - t), im = /* @__PURE__ */ Dr(0.33, 1.53, 0.69, 0.99), du = /* @__PURE__ */ sm(im), rm = /* @__PURE__ */ nm(du), om = (e) => (e *= 2) < 1 ? 0.5 * du(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), hu = (e) => 1 - Math.sin(Math.acos(e)), am = sm(hu), lm = nm(hu), cm = (e) => /^0[^.\s]+$/u.test(e);
function Jx(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || cm(e) : !0;
}
let Xl = Jt;
const um = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), dm = (e) => (t) => typeof t == "string" && t.startsWith(e), hm = /* @__PURE__ */ dm("--"), Xx = /* @__PURE__ */ dm("var(--"), fu = (e) => Xx(e) ? $x.test(e.split("/*")[0].trim()) : !1, $x = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, tv = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function ev(e) {
  const t = tv.exec(e);
  if (!t)
    return [,];
  const [, n, s, i] = t;
  return [`--${n ?? s}`, i];
}
function fm(e, t, n = 1) {
  const [s, i] = ev(e);
  if (!s)
    return;
  const r = window.getComputedStyle(t).getPropertyValue(s);
  if (r) {
    const o = r.trim();
    return um(o) ? parseFloat(o) : o;
  }
  return fu(i) ? fm(i, t, n + 1) : i;
}
const Vn = (e, t, n) => n > t ? t : n < e ? e : n, di = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, er = {
  ...di,
  transform: (e) => Vn(0, 1, e)
}, Kr = {
  ...di,
  default: 1
}, Br = (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), Rn = /* @__PURE__ */ Br("deg"), Ge = /* @__PURE__ */ Br("%"), z = /* @__PURE__ */ Br("px"), nv = /* @__PURE__ */ Br("vh"), sv = /* @__PURE__ */ Br("vw"), rh = {
  ...Ge,
  parse: (e) => Ge.parse(e) / 100,
  transform: (e) => Ge.transform(e * 100)
}, iv = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), oh = (e) => e === di || e === z, ah = (e, t) => parseFloat(e.split(", ")[t]), lh = (e, t) => (n, { transform: s }) => {
  if (s === "none" || !s)
    return 0;
  const i = s.match(/^matrix3d\((.+)\)$/u);
  if (i)
    return ah(i[1], t);
  {
    const r = s.match(/^matrix\((.+)\)$/u);
    return r ? ah(r[1], e) : 0;
  }
}, rv = /* @__PURE__ */ new Set(["x", "y", "z"]), ov = Tr.filter((e) => !rv.has(e));
function av(e) {
  const t = [];
  return ov.forEach((n) => {
    const s = e.getValue(n);
    s !== void 0 && (t.push([n, s.get()]), s.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const Js = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: lh(4, 13),
  y: lh(5, 14)
};
Js.translateX = Js.x;
Js.translateY = Js.y;
const pm = (e) => (t) => t.test(e), lv = {
  test: (e) => e === "auto",
  parse: (e) => e
}, gm = [di, z, Ge, Rn, sv, nv, lv], ch = (e) => gm.find(pm(e)), ys = /* @__PURE__ */ new Set();
let $l = !1, tc = !1;
function mm() {
  if (tc) {
    const e = Array.from(ys).filter((s) => s.needsMeasurement), t = new Set(e.map((s) => s.element)), n = /* @__PURE__ */ new Map();
    t.forEach((s) => {
      const i = av(s);
      i.length && (n.set(s, i), s.render());
    }), e.forEach((s) => s.measureInitialState()), t.forEach((s) => {
      s.render();
      const i = n.get(s);
      i && i.forEach(([r, o]) => {
        var a;
        (a = s.getValue(r)) === null || a === void 0 || a.set(o);
      });
    }), e.forEach((s) => s.measureEndState()), e.forEach((s) => {
      s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY);
    });
  }
  tc = !1, $l = !1, ys.forEach((e) => e.complete()), ys.clear();
}
function Am() {
  ys.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (tc = !0);
  });
}
function cv() {
  Am(), mm();
}
class pu {
  constructor(t, n, s, i, r, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = s, this.motionValue = i, this.element = r, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (ys.add(this), $l || ($l = !0, pt.read(Am), pt.resolveKeyframes(mm))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: s, motionValue: i } = this;
    for (let r = 0; r < t.length; r++)
      if (t[r] === null)
        if (r === 0) {
          const o = i == null ? void 0 : i.get(), a = t[t.length - 1];
          if (o !== void 0)
            t[0] = o;
          else if (s && n) {
            const l = s.readValue(n, a);
            l != null && (t[0] = l);
          }
          t[0] === void 0 && (t[0] = a), i && o === void 0 && i.set(t[0]);
        } else
          t[r] = t[r - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), ys.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, ys.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const Qi = (e) => Math.round(e * 1e5) / 1e5, gu = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function uv(e) {
  return e == null;
}
const dv = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, mu = (e, t) => (n) => !!(typeof n == "string" && dv.test(n) && n.startsWith(e) || t && !uv(n) && Object.prototype.hasOwnProperty.call(n, t)), ym = (e, t, n) => (s) => {
  if (typeof s != "string")
    return s;
  const [i, r, o, a] = s.match(gu);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(r),
    [n]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, hv = (e) => Vn(0, 255, e), ol = {
  ...di,
  transform: (e) => Math.round(hv(e))
}, gs = {
  test: /* @__PURE__ */ mu("rgb", "red"),
  parse: /* @__PURE__ */ ym("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: s = 1 }) => "rgba(" + ol.transform(e) + ", " + ol.transform(t) + ", " + ol.transform(n) + ", " + Qi(er.transform(s)) + ")"
};
function fv(e) {
  let t = "", n = "", s = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), s = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), s = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, s += s, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(s, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const ec = {
  test: /* @__PURE__ */ mu("#"),
  parse: fv,
  transform: gs.transform
}, Fs = {
  test: /* @__PURE__ */ mu("hsl", "hue"),
  parse: /* @__PURE__ */ ym("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: s = 1 }) => "hsla(" + Math.round(e) + ", " + Ge.transform(Qi(t)) + ", " + Ge.transform(Qi(n)) + ", " + Qi(er.transform(s)) + ")"
}, _t = {
  test: (e) => gs.test(e) || ec.test(e) || Fs.test(e),
  parse: (e) => gs.test(e) ? gs.parse(e) : Fs.test(e) ? Fs.parse(e) : ec.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? gs.transform(e) : Fs.transform(e)
}, pv = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function gv(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(gu)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(pv)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const wm = "number", bm = "color", mv = "var", Av = "var(", uh = "${}", yv = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function nr(e) {
  const t = e.toString(), n = [], s = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let r = 0;
  const a = t.replace(yv, (l) => (_t.test(l) ? (s.color.push(r), i.push(bm), n.push(_t.parse(l))) : l.startsWith(Av) ? (s.var.push(r), i.push(mv), n.push(l)) : (s.number.push(r), i.push(wm), n.push(parseFloat(l))), ++r, uh)).split(uh);
  return { values: n, split: a, indexes: s, types: i };
}
function xm(e) {
  return nr(e).values;
}
function vm(e) {
  const { split: t, types: n } = nr(e), s = t.length;
  return (i) => {
    let r = "";
    for (let o = 0; o < s; o++)
      if (r += t[o], i[o] !== void 0) {
        const a = n[o];
        a === wm ? r += Qi(i[o]) : a === bm ? r += _t.transform(i[o]) : r += i[o];
      }
    return r;
  };
}
const wv = (e) => typeof e == "number" ? 0 : e;
function bv(e) {
  const t = xm(e);
  return vm(e)(t.map(wv));
}
const Un = {
  test: gv,
  parse: xm,
  createTransformer: vm,
  getAnimatableNone: bv
}, xv = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function vv(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [s] = n.match(gu) || [];
  if (!s)
    return e;
  const i = n.replace(s, "");
  let r = xv.has(t) ? 1 : 0;
  return s !== n && (r *= 100), t + "(" + r + i + ")";
}
const Cv = /\b([a-z-]*)\(.*?\)/gu, nc = {
  ...Un,
  getAnimatableNone: (e) => {
    const t = e.match(Cv);
    return t ? t.map(vv).join(" ") : e;
  }
}, Sv = {
  // Border props
  borderWidth: z,
  borderTopWidth: z,
  borderRightWidth: z,
  borderBottomWidth: z,
  borderLeftWidth: z,
  borderRadius: z,
  radius: z,
  borderTopLeftRadius: z,
  borderTopRightRadius: z,
  borderBottomRightRadius: z,
  borderBottomLeftRadius: z,
  // Positioning props
  width: z,
  maxWidth: z,
  height: z,
  maxHeight: z,
  top: z,
  right: z,
  bottom: z,
  left: z,
  // Spacing props
  padding: z,
  paddingTop: z,
  paddingRight: z,
  paddingBottom: z,
  paddingLeft: z,
  margin: z,
  marginTop: z,
  marginRight: z,
  marginBottom: z,
  marginLeft: z,
  // Misc
  backgroundPositionX: z,
  backgroundPositionY: z
}, Mv = {
  rotate: Rn,
  rotateX: Rn,
  rotateY: Rn,
  rotateZ: Rn,
  scale: Kr,
  scaleX: Kr,
  scaleY: Kr,
  scaleZ: Kr,
  skew: Rn,
  skewX: Rn,
  skewY: Rn,
  distance: z,
  translateX: z,
  translateY: z,
  translateZ: z,
  x: z,
  y: z,
  z,
  perspective: z,
  transformPerspective: z,
  opacity: er,
  originX: rh,
  originY: rh,
  originZ: z
}, dh = {
  ...di,
  transform: Math.round
}, Au = {
  ...Sv,
  ...Mv,
  zIndex: dh,
  size: z,
  // SVG
  fillOpacity: er,
  strokeOpacity: er,
  numOctaves: dh
}, Ev = {
  ...Au,
  // Color props
  color: _t,
  backgroundColor: _t,
  outlineColor: _t,
  fill: _t,
  stroke: _t,
  // Border props
  borderColor: _t,
  borderTopColor: _t,
  borderRightColor: _t,
  borderBottomColor: _t,
  borderLeftColor: _t,
  filter: nc,
  WebkitFilter: nc
}, yu = (e) => Ev[e];
function Cm(e, t) {
  let n = yu(e);
  return n !== nc && (n = Un), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const qv = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function Rv(e, t, n) {
  let s = 0, i;
  for (; s < e.length && !i; ) {
    const r = e[s];
    typeof r == "string" && !qv.has(r) && nr(r).values.length && (i = e[s]), s++;
  }
  if (i && n)
    for (const r of t)
      e[r] = Cm(n, i);
}
class Sm extends pu {
  constructor(t, n, s, i, r) {
    super(t, n, s, i, r, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: s } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let l = 0; l < t.length; l++) {
      let c = t[l];
      if (typeof c == "string" && (c = c.trim(), fu(c))) {
        const u = fm(c, n.current);
        u !== void 0 && (t[l] = u), l === t.length - 1 && (this.finalKeyframe = c);
      }
    }
    if (this.resolveNoneKeyframes(), !iv.has(s) || t.length !== 2)
      return;
    const [i, r] = t, o = ch(i), a = ch(r);
    if (o !== a)
      if (oh(o) && oh(a))
        for (let l = 0; l < t.length; l++) {
          const c = t[l];
          typeof c == "string" && (t[l] = parseFloat(c));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, s = [];
    for (let i = 0; i < t.length; i++)
      Jx(t[i]) && s.push(i);
    s.length && Rv(t, s, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: s } = this;
    if (!t || !t.current)
      return;
    s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Js[s](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(s, i).jump(i, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: s, unresolvedKeyframes: i } = this;
    if (!n || !n.current)
      return;
    const r = n.getValue(s);
    r && r.jump(this.measuredOrigin, !1);
    const o = i.length - 1, a = i[o];
    i[o] = Js[s](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([l, c]) => {
      n.getValue(l).set(c);
    }), this.resolveNoneKeyframes();
  }
}
function wu(e) {
  return typeof e == "function";
}
let Co;
function kv() {
  Co = void 0;
}
const Ke = {
  now: () => (Co === void 0 && Ke.set(Yt.isProcessing || Qx.useManualTiming ? Yt.timestamp : performance.now()), Co),
  set: (e) => {
    Co = e, queueMicrotask(kv);
  }
}, hh = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Un.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function Tv(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function Dv(e, t, n, s) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const r = e[e.length - 1], o = hh(i, t), a = hh(r, t);
  return !o || !a ? !1 : Tv(e) || (n === "spring" || wu(n)) && s;
}
const Bv = 40;
class Mm {
  constructor({ autoplay: t = !0, delay: n = 0, type: s = "keyframes", repeat: i = 0, repeatDelay: r = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Ke.now(), this.options = {
      autoplay: t,
      delay: n,
      type: s,
      repeat: i,
      repeatDelay: r,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > Bv ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && cv(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(t, n) {
    this.resolvedAt = Ke.now(), this.hasAttemptedResolve = !0;
    const { name: s, type: i, velocity: r, delay: o, onComplete: a, onUpdate: l, isGenerator: c } = this.options;
    if (!c && !Dv(t, s, i, r))
      if (o)
        this.options.duration = 0;
      else {
        l == null || l(Sa(t, this.options, n)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const u = this.initPlayback(t, n);
    u !== !1 && (this._resolved = {
      keyframes: t,
      finalKeyframe: n,
      ...u
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.currentFinishedPromise.then(t, n);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((t) => {
      this.resolveFinishedPromise = t;
    });
  }
}
function Em(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const Iv = 5;
function qm(e, t, n) {
  const s = Math.max(t - Iv, 0);
  return Em(n - e(s), t - s);
}
const al = 1e-3, Pv = 0.01, Ov = 10, Nv = 0.05, Lv = 1;
function Fv({ duration: e = 800, bounce: t = 0.25, velocity: n = 0, mass: s = 1 }) {
  let i, r, o = 1 - t;
  o = Vn(Nv, Lv, o), e = Vn(Pv, Ov, gn(e)), o < 1 ? (i = (c) => {
    const u = c * o, d = u * e, h = u - n, f = sc(c, o), p = Math.exp(-d);
    return al - h / f * p;
  }, r = (c) => {
    const d = c * o * e, h = d * n + n, f = Math.pow(o, 2) * Math.pow(c, 2) * e, p = Math.exp(-d), g = sc(Math.pow(c, 2), o);
    return (-i(c) + al > 0 ? -1 : 1) * ((h - f) * p) / g;
  }) : (i = (c) => {
    const u = Math.exp(-c * e), d = (c - n) * e + 1;
    return -al + u * d;
  }, r = (c) => {
    const u = Math.exp(-c * e), d = (n - c) * (e * e);
    return u * d;
  });
  const a = 5 / e, l = Vv(i, r, a);
  if (e = pn(e), isNaN(l))
    return {
      stiffness: 100,
      damping: 10,
      duration: e
    };
  {
    const c = Math.pow(l, 2) * s;
    return {
      stiffness: c,
      damping: o * 2 * Math.sqrt(s * c),
      duration: e
    };
  }
}
const jv = 12;
function Vv(e, t, n) {
  let s = n;
  for (let i = 1; i < jv; i++)
    s = s - e(s) / t(s);
  return s;
}
function sc(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const Uv = ["duration", "bounce"], Yv = ["stiffness", "damping", "mass"];
function fh(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function Wv(e) {
  let t = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!fh(e, Yv) && fh(e, Uv)) {
    const n = Fv(e);
    t = {
      ...t,
      ...n,
      mass: 1
    }, t.isResolvedFromDuration = !0;
  }
  return t;
}
function Rm({ keyframes: e, restDelta: t, restSpeed: n, ...s }) {
  const i = e[0], r = e[e.length - 1], o = { done: !1, value: i }, { stiffness: a, damping: l, mass: c, duration: u, velocity: d, isResolvedFromDuration: h } = Wv({
    ...s,
    velocity: -gn(s.velocity || 0)
  }), f = d || 0, p = l / (2 * Math.sqrt(a * c)), g = r - i, m = gn(Math.sqrt(a / c)), A = Math.abs(g) < 5;
  n || (n = A ? 0.01 : 2), t || (t = A ? 5e-3 : 0.5);
  let w;
  if (p < 1) {
    const x = sc(m, p);
    w = (v) => {
      const C = Math.exp(-p * m * v);
      return r - C * ((f + p * m * g) / x * Math.sin(x * v) + g * Math.cos(x * v));
    };
  } else if (p === 1)
    w = (x) => r - Math.exp(-m * x) * (g + (f + m * g) * x);
  else {
    const x = m * Math.sqrt(p * p - 1);
    w = (v) => {
      const C = Math.exp(-p * m * v), E = Math.min(x * v, 300);
      return r - C * ((f + p * m * g) * Math.sinh(E) + x * g * Math.cosh(E)) / x;
    };
  }
  return {
    calculatedDuration: h && u || null,
    next: (x) => {
      const v = w(x);
      if (h)
        o.done = x >= u;
      else {
        let C = 0;
        p < 1 && (C = x === 0 ? pn(f) : qm(w, x, v));
        const E = Math.abs(C) <= n, S = Math.abs(r - v) <= t;
        o.done = E && S;
      }
      return o.value = o.done ? r : v, o;
    }
  };
}
function ph({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: s = 325, bounceDamping: i = 10, bounceStiffness: r = 500, modifyTarget: o, min: a, max: l, restDelta: c = 0.5, restSpeed: u }) {
  const d = e[0], h = {
    done: !1,
    value: d
  }, f = (M) => a !== void 0 && M < a || l !== void 0 && M > l, p = (M) => a === void 0 ? l : l === void 0 || Math.abs(a - M) < Math.abs(l - M) ? a : l;
  let g = n * t;
  const m = d + g, A = o === void 0 ? m : o(m);
  A !== m && (g = A - d);
  const w = (M) => -g * Math.exp(-M / s), x = (M) => A + w(M), v = (M) => {
    const q = w(M), k = x(M);
    h.done = Math.abs(q) <= c, h.value = h.done ? A : k;
  };
  let C, E;
  const S = (M) => {
    f(h.value) && (C = M, E = Rm({
      keyframes: [h.value, p(h.value)],
      velocity: qm(x, M, h.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: r,
      restDelta: c,
      restSpeed: u
    }));
  };
  return S(0), {
    calculatedDuration: null,
    next: (M) => {
      let q = !1;
      return !E && C === void 0 && (q = !0, v(M), S(M)), C !== void 0 && M >= C ? E.next(M - C) : (!q && v(M), h);
    }
  };
}
const Qv = /* @__PURE__ */ Dr(0.42, 0, 1, 1), Gv = /* @__PURE__ */ Dr(0, 0, 0.58, 1), km = /* @__PURE__ */ Dr(0.42, 0, 0.58, 1), Kv = (e) => Array.isArray(e) && typeof e[0] != "number", gh = {
  linear: Jt,
  easeIn: Qv,
  easeInOut: km,
  easeOut: Gv,
  circIn: hu,
  circInOut: lm,
  circOut: am,
  backIn: du,
  backInOut: rm,
  backOut: im,
  anticipate: om
}, mh = (e) => {
  if (Array.isArray(e)) {
    Xl(e.length === 4);
    const [t, n, s, i] = e;
    return Dr(t, n, s, i);
  } else if (typeof e == "string")
    return Xl(gh[e] !== void 0), gh[e];
  return e;
}, zv = (e, t) => (n) => t(e(n)), mn = (...e) => e.reduce(zv), Xs = (e, t, n) => {
  const s = t - e;
  return s === 0 ? 1 : (n - e) / s;
}, qt = (e, t, n) => e + (t - e) * n;
function ll(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function _v({ hue: e, saturation: t, lightness: n, alpha: s }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, r = 0, o = 0;
  if (!t)
    i = r = o = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a;
    i = ll(l, a, e + 1 / 3), r = ll(l, a, e), o = ll(l, a, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(r * 255),
    blue: Math.round(o * 255),
    alpha: s
  };
}
function Wo(e, t) {
  return (n) => n > 0 ? t : e;
}
const cl = (e, t, n) => {
  const s = e * e, i = n * (t * t - s) + s;
  return i < 0 ? 0 : Math.sqrt(i);
}, Zv = [ec, gs, Fs], Hv = (e) => Zv.find((t) => t.test(e));
function Ah(e) {
  const t = Hv(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === Fs && (n = _v(n)), n;
}
const yh = (e, t) => {
  const n = Ah(e), s = Ah(t);
  if (!n || !s)
    return Wo(e, t);
  const i = { ...n };
  return (r) => (i.red = cl(n.red, s.red, r), i.green = cl(n.green, s.green, r), i.blue = cl(n.blue, s.blue, r), i.alpha = qt(n.alpha, s.alpha, r), gs.transform(i));
}, ic = /* @__PURE__ */ new Set(["none", "hidden"]);
function Jv(e, t) {
  return ic.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function Xv(e, t) {
  return (n) => qt(e, t, n);
}
function bu(e) {
  return typeof e == "number" ? Xv : typeof e == "string" ? fu(e) ? Wo : _t.test(e) ? yh : eC : Array.isArray(e) ? Tm : typeof e == "object" ? _t.test(e) ? yh : $v : Wo;
}
function Tm(e, t) {
  const n = [...e], s = n.length, i = e.map((r, o) => bu(r)(r, t[o]));
  return (r) => {
    for (let o = 0; o < s; o++)
      n[o] = i[o](r);
    return n;
  };
}
function $v(e, t) {
  const n = { ...e, ...t }, s = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (s[i] = bu(e[i])(e[i], t[i]));
  return (i) => {
    for (const r in s)
      n[r] = s[r](i);
    return n;
  };
}
function tC(e, t) {
  var n;
  const s = [], i = { color: 0, var: 0, number: 0 };
  for (let r = 0; r < t.values.length; r++) {
    const o = t.types[r], a = e.indexes[o][i[o]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0;
    s[r] = l, i[o]++;
  }
  return s;
}
const eC = (e, t) => {
  const n = Un.createTransformer(t), s = nr(e), i = nr(t);
  return s.indexes.var.length === i.indexes.var.length && s.indexes.color.length === i.indexes.color.length && s.indexes.number.length >= i.indexes.number.length ? ic.has(e) && !i.values.length || ic.has(t) && !s.values.length ? Jv(e, t) : mn(Tm(tC(s, i), i.values), n) : Wo(e, t);
};
function Dm(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? qt(e, t, n) : bu(e)(e, t);
}
function nC(e, t, n) {
  const s = [], i = n || Dm, r = e.length - 1;
  for (let o = 0; o < r; o++) {
    let a = i(e[o], e[o + 1]);
    if (t) {
      const l = Array.isArray(t) ? t[o] || Jt : t;
      a = mn(l, a);
    }
    s.push(a);
  }
  return s;
}
function sC(e, t, { clamp: n = !0, ease: s, mixer: i } = {}) {
  const r = e.length;
  if (Xl(r === t.length), r === 1)
    return () => t[0];
  if (r === 2 && e[0] === e[1])
    return () => t[1];
  e[0] > e[r - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const o = nC(t, s, i), a = o.length, l = (c) => {
    let u = 0;
    if (a > 1)
      for (; u < e.length - 2 && !(c < e[u + 1]); u++)
        ;
    const d = Xs(e[u], e[u + 1], c);
    return o[u](d);
  };
  return n ? (c) => l(Vn(e[0], e[r - 1], c)) : l;
}
function iC(e, t) {
  const n = e[e.length - 1];
  for (let s = 1; s <= t; s++) {
    const i = Xs(0, t, s);
    e.push(qt(n, 1, i));
  }
}
function rC(e) {
  const t = [0];
  return iC(t, e.length - 1), t;
}
function oC(e, t) {
  return e.map((n) => n * t);
}
function aC(e, t) {
  return e.map(() => t || km).splice(0, e.length - 1);
}
function Qo({ duration: e = 300, keyframes: t, times: n, ease: s = "easeInOut" }) {
  const i = Kv(s) ? s.map(mh) : mh(s), r = {
    done: !1,
    value: t[0]
  }, o = oC(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : rC(t),
    e
  ), a = sC(o, t, {
    ease: Array.isArray(i) ? i : aC(t, i)
  });
  return {
    calculatedDuration: e,
    next: (l) => (r.value = a(l), r.done = l >= e, r)
  };
}
const wh = 2e4;
function lC(e) {
  let t = 0;
  const n = 50;
  let s = e.next(t);
  for (; !s.done && t < wh; )
    t += n, s = e.next(t);
  return t >= wh ? 1 / 0 : t;
}
const cC = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: () => pt.update(t, !0),
    stop: () => jn(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Yt.isProcessing ? Yt.timestamp : Ke.now()
  };
}, uC = {
  decay: ph,
  inertia: ph,
  tween: Qo,
  keyframes: Qo,
  spring: Rm
}, dC = (e) => e / 100;
class xu extends Mm {
  constructor(t) {
    super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: l } = this.options;
      l && l();
    };
    const { name: n, motionValue: s, element: i, keyframes: r } = this.options, o = (i == null ? void 0 : i.KeyframeResolver) || pu, a = (l, c) => this.onKeyframesResolved(l, c);
    this.resolver = new o(r, a, n, s, i), this.resolver.scheduleResolve();
  }
  initPlayback(t) {
    const { type: n = "keyframes", repeat: s = 0, repeatDelay: i = 0, repeatType: r, velocity: o = 0 } = this.options, a = wu(n) ? n : uC[n] || Qo;
    let l, c;
    a !== Qo && typeof t[0] != "number" && (l = mn(dC, Dm(t[0], t[1])), t = [0, 100]);
    const u = a({ ...this.options, keyframes: t });
    r === "mirror" && (c = a({
      ...this.options,
      keyframes: [...t].reverse(),
      velocity: -o
    })), u.calculatedDuration === null && (u.calculatedDuration = lC(u));
    const { calculatedDuration: d } = u, h = d + i, f = h * (s + 1) - i;
    return {
      generator: u,
      mirroredGenerator: c,
      mapPercentToKeyframes: l,
      calculatedDuration: d,
      resolvedDuration: h,
      totalDuration: f
    };
  }
  onPostResolved() {
    const { autoplay: t = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(t, n = !1) {
    const { resolved: s } = this;
    if (!s) {
      const { keyframes: M } = this.options;
      return { done: !0, value: M[M.length - 1] };
    }
    const { finalKeyframe: i, generator: r, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: c, totalDuration: u, resolvedDuration: d } = s;
    if (this.startTime === null)
      return r.next(0);
    const { delay: h, repeat: f, repeatType: p, repeatDelay: g, onUpdate: m } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - u / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
    const A = this.currentTime - h * (this.speed >= 0 ? 1 : -1), w = this.speed >= 0 ? A < 0 : A > u;
    this.currentTime = Math.max(A, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u);
    let x = this.currentTime, v = r;
    if (f) {
      const M = Math.min(this.currentTime, u) / d;
      let q = Math.floor(M), k = M % 1;
      !k && M >= 1 && (k = 1), k === 1 && q--, q = Math.min(q, f + 1), !!(q % 2) && (p === "reverse" ? (k = 1 - k, g && (k -= g / d)) : p === "mirror" && (v = o)), x = Vn(0, 1, k) * d;
    }
    const C = w ? { done: !1, value: l[0] } : v.next(x);
    a && (C.value = a(C.value));
    let { done: E } = C;
    !w && c !== null && (E = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
    const S = this.holdTime === null && (this.state === "finished" || this.state === "running" && E);
    return S && i !== void 0 && (C.value = Sa(l, this.options, i)), m && m(C.value), S && this.finish(), C;
  }
  get duration() {
    const { resolved: t } = this;
    return t ? gn(t.calculatedDuration) : 0;
  }
  get time() {
    return gn(this.currentTime);
  }
  set time(t) {
    t = pn(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = gn(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: t = cC, onPlay: n, startTime: s } = this.options;
    this.driver || (this.driver = t((r) => this.tick(r))), n && n();
    const i = this.driver.now();
    this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = s ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var t;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: t } = this.options;
    t && t();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
}
const Bm = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), Im = (e) => Array.isArray(e) && typeof e[0] == "number", hC = 10, fC = (e, t) => {
  let n = "";
  const s = Math.max(Math.round(t / hC), 2);
  for (let i = 0; i < s; i++)
    n += e(Xs(0, s - 1, i)) + ", ";
  return `linear(${n.substring(0, n.length - 2)})`;
};
function vu(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const pC = {
  linearEasing: void 0
};
function gC(e, t) {
  const n = vu(e);
  return () => {
    var s;
    return (s = pC[t]) !== null && s !== void 0 ? s : n();
  };
}
const Go = /* @__PURE__ */ gC(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function Pm(e) {
  return !!(typeof e == "function" && Go() || !e || typeof e == "string" && (e in rc || Go()) || Im(e) || Array.isArray(e) && e.every(Pm));
}
const Pi = ([e, t, n, s]) => `cubic-bezier(${e}, ${t}, ${n}, ${s})`, rc = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Pi([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Pi([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Pi([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Pi([0.33, 1.53, 0.69, 0.99])
};
function Om(e, t) {
  if (e)
    return typeof e == "function" && Go() ? fC(e, t) : Im(e) ? Pi(e) : Array.isArray(e) ? e.map((n) => Om(n, t) || rc.easeOut) : rc[e];
}
function mC(e, t, n, { delay: s = 0, duration: i = 300, repeat: r = 0, repeatType: o = "loop", ease: a, times: l } = {}) {
  const c = { [t]: n };
  l && (c.offset = l);
  const u = Om(a, i);
  return Array.isArray(u) && (c.easing = u), e.animate(c, {
    delay: s,
    duration: i,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: r + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
function bh(e, t) {
  e.timeline = t, e.onfinish = null;
}
const AC = /* @__PURE__ */ vu(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Ko = 10, yC = 2e4;
function wC(e) {
  return wu(e.type) || e.type === "spring" || !Pm(e.ease);
}
function bC(e, t) {
  const n = new xu({
    ...t,
    keyframes: e,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let s = { done: !1, value: e[0] };
  const i = [];
  let r = 0;
  for (; !s.done && r < yC; )
    s = n.sample(r), i.push(s.value), r += Ko;
  return {
    times: void 0,
    keyframes: i,
    duration: r - Ko,
    ease: "linear"
  };
}
const Nm = {
  anticipate: om,
  backInOut: rm,
  circInOut: lm
};
function xC(e) {
  return e in Nm;
}
class xh extends Mm {
  constructor(t) {
    super(t);
    const { name: n, motionValue: s, element: i, keyframes: r } = this.options;
    this.resolver = new Sm(r, (o, a) => this.onKeyframesResolved(o, a), n, s, i), this.resolver.scheduleResolve();
  }
  initPlayback(t, n) {
    var s;
    let { duration: i = 300, times: r, ease: o, type: a, motionValue: l, name: c, startTime: u } = this.options;
    if (!(!((s = l.owner) === null || s === void 0) && s.current))
      return !1;
    if (typeof o == "string" && Go() && xC(o) && (o = Nm[o]), wC(this.options)) {
      const { onComplete: h, onUpdate: f, motionValue: p, element: g, ...m } = this.options, A = bC(t, m);
      t = A.keyframes, t.length === 1 && (t[1] = t[0]), i = A.duration, r = A.times, o = A.ease, a = "keyframes";
    }
    const d = mC(l.owner.current, c, t, { ...this.options, duration: i, times: r, ease: o });
    return d.startTime = u ?? this.calcStartTime(), this.pendingTimeline ? (bh(d, this.pendingTimeline), this.pendingTimeline = void 0) : d.onfinish = () => {
      const { onComplete: h } = this.options;
      l.set(Sa(t, this.options, n)), h && h(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: d,
      duration: i,
      times: r,
      type: a,
      ease: o,
      keyframes: t
    };
  }
  get duration() {
    const { resolved: t } = this;
    if (!t)
      return 0;
    const { duration: n } = t;
    return gn(n);
  }
  get time() {
    const { resolved: t } = this;
    if (!t)
      return 0;
    const { animation: n } = t;
    return gn(n.currentTime || 0);
  }
  set time(t) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: s } = n;
    s.currentTime = pn(t);
  }
  get speed() {
    const { resolved: t } = this;
    if (!t)
      return 1;
    const { animation: n } = t;
    return n.playbackRate;
  }
  set speed(t) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: s } = n;
    s.playbackRate = t;
  }
  get state() {
    const { resolved: t } = this;
    if (!t)
      return "idle";
    const { animation: n } = t;
    return n.playState;
  }
  get startTime() {
    const { resolved: t } = this;
    if (!t)
      return null;
    const { animation: n } = t;
    return n.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(t) {
    if (!this._resolved)
      this.pendingTimeline = t;
    else {
      const { resolved: n } = this;
      if (!n)
        return Jt;
      const { animation: s } = n;
      bh(s, t);
    }
    return Jt;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n } = t;
    n.playState === "finished" && this.updateFinishedPromise(), n.play();
  }
  pause() {
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n } = t;
    n.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: n, keyframes: s, duration: i, type: r, ease: o, times: a } = t;
    if (n.playState === "idle" || n.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: c, onUpdate: u, onComplete: d, element: h, ...f } = this.options, p = new xu({
        ...f,
        keyframes: s,
        duration: i,
        type: r,
        ease: o,
        times: a,
        isGenerator: !0
      }), g = pn(this.time);
      c.setWithVelocity(p.sample(g - Ko).value, p.sample(g).value, Ko);
    }
    const { onStop: l } = this.options;
    l && l(), this.cancel();
  }
  complete() {
    const { resolved: t } = this;
    t && t.animation.finish();
  }
  cancel() {
    const { resolved: t } = this;
    t && t.animation.cancel();
  }
  static supports(t) {
    const { motionValue: n, name: s, repeatDelay: i, repeatType: r, damping: o, type: a } = t;
    return AC() && s && Bm.has(s) && n && n.owner && n.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !n.owner.getProps().onUpdate && !i && r !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const vC = vu(() => window.ScrollTimeline !== void 0);
class CC {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  then(t, n) {
    return Promise.all(this.animations).then(t).catch(n);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let s = 0; s < this.animations.length; s++)
      this.animations[s][t] = n;
  }
  attachTimeline(t, n) {
    const s = this.animations.map((i) => vC() && i.attachTimeline ? i.attachTimeline(t) : n(i));
    return () => {
      s.forEach((i, r) => {
        i && i(), this.animations[r].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let t = 0;
    for (let n = 0; n < this.animations.length; n++)
      t = Math.max(t, this.animations[n].duration);
    return t;
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function SC({ when: e, delay: t, delayChildren: n, staggerChildren: s, staggerDirection: i, repeat: r, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...u }) {
  return !!Object.keys(u).length;
}
const Cu = (e, t, n, s = {}, i, r) => (o) => {
  const a = uu(s, e) || {}, l = a.delay || s.delay || 0;
  let { elapsed: c = 0 } = s;
  c = c - pn(l);
  let u = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...a,
    delay: -c,
    onUpdate: (h) => {
      t.set(h), a.onUpdate && a.onUpdate(h);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: e,
    motionValue: t,
    element: r ? void 0 : i
  };
  SC(a) || (u = {
    ...u,
    ...Wx(e, u)
  }), u.duration && (u.duration = pn(u.duration)), u.repeatDelay && (u.repeatDelay = pn(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from);
  let d = !1;
  if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0, u.delay === 0 && (d = !0)), d && !r && t.get() !== void 0) {
    const h = Sa(u.keyframes, a);
    if (h !== void 0)
      return pt.update(() => {
        u.onUpdate(h), u.onComplete();
      }), new CC([]);
  }
  return !r && xh.supports(u) ? new xh(u) : new xu(u);
}, MC = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), EC = (e) => Jl(e) ? e[e.length - 1] || 0 : e;
function Ir(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Su(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
class Mu {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return Ir(this.subscriptions, t), () => Su(this.subscriptions, t);
  }
  notify(t, n, s) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, s);
      else
        for (let r = 0; r < i; r++) {
          const o = this.subscriptions[r];
          o && o(t, n, s);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const vh = 30, qC = (e) => !isNaN(parseFloat(e));
class Lm {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(t, n = {}) {
    this.version = "11.9.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (s, i = !0) => {
      const r = Ke.now();
      this.updatedAt !== r && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Ke.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = qC(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new Mu());
    const s = this.events[t].add(n);
    return t === "change" ? () => {
      s(), pt.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : s;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, n, s) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - s;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Ke.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > vh)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, vh);
    return Em(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function sr(e, t) {
  return new Lm(e, t);
}
function RC(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, sr(n));
}
function kC(e, t) {
  const n = Ca(e, t);
  let { transitionEnd: s = {}, transition: i = {}, ...r } = n || {};
  r = { ...r, ...s };
  for (const o in r) {
    const a = EC(r[o]);
    RC(e, o, a);
  }
}
const Ma = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), TC = "framerAppearId", Fm = "data-" + Ma(TC);
function jm(e) {
  return e.props[Fm];
}
function Vm(e) {
  if (Xn.has(e))
    return "transform";
  if (Bm.has(e))
    return Ma(e);
}
class DC extends Lm {
  constructor() {
    super(...arguments), this.values = [];
  }
  add(t) {
    const n = Vm(t);
    n && (Ir(this.values, n), this.update());
  }
  update() {
    this.set(this.values.length ? this.values.join(", ") : "auto");
  }
}
const Zt = (e) => !!(e && e.getVelocity);
function BC(e) {
  return !!(Zt(e) && e.add);
}
function oc(e, t) {
  var n;
  if (!e.applyWillChange)
    return;
  let s = e.getValue("willChange");
  if (!s && !(!((n = e.props.style) === null || n === void 0) && n.willChange) && (s = new DC("auto"), e.addValue("willChange", s)), BC(s))
    return s.add(t);
}
function IC({ protectedKeys: e, needsAnimating: t }, n) {
  const s = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, s;
}
function Um(e, t, { delay: n = 0, transitionOverride: s, type: i } = {}) {
  var r;
  let { transition: o = e.getDefaultTransition(), transitionEnd: a, ...l } = t;
  s && (o = s);
  const c = [], u = i && e.animationState && e.animationState.getState()[i];
  for (const d in l) {
    const h = e.getValue(d, (r = e.latestValues[d]) !== null && r !== void 0 ? r : null), f = l[d];
    if (f === void 0 || u && IC(u, d))
      continue;
    const p = {
      delay: n,
      ...uu(o || {}, d)
    };
    let g = !1;
    if (window.MotionHandoffAnimation) {
      const A = jm(e);
      if (A) {
        const w = window.MotionHandoffAnimation(A, d, pt);
        w !== null && (p.startTime = w, g = !0);
      }
    }
    oc(e, d), h.start(Cu(d, h, f, e.shouldReduceMotion && Xn.has(d) ? { type: !1 } : p, e, g));
    const m = h.animation;
    m && c.push(m);
  }
  return a && Promise.all(c).then(() => {
    pt.update(() => {
      a && kC(e, a);
    });
  }), c;
}
function ac(e, t, n = {}) {
  var s;
  const i = Ca(e, t, n.type === "exit" ? (s = e.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0);
  let { transition: r = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (r = n.transitionOverride);
  const o = i ? () => Promise.all(Um(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: u = 0, staggerChildren: d, staggerDirection: h } = r;
    return PC(e, t, u + c, d, h, n);
  } : () => Promise.resolve(), { when: l } = r;
  if (l) {
    const [c, u] = l === "beforeChildren" ? [o, a] : [a, o];
    return c().then(() => u());
  } else
    return Promise.all([o(), a(n.delay)]);
}
function PC(e, t, n = 0, s = 0, i = 1, r) {
  const o = [], a = (e.variantChildren.size - 1) * s, l = i === 1 ? (c = 0) => c * s : (c = 0) => a - c * s;
  return Array.from(e.variantChildren).sort(OC).forEach((c, u) => {
    c.notify("AnimationStart", t), o.push(ac(c, t, {
      ...r,
      delay: n + l(u)
    }).then(() => c.notify("AnimationComplete", t)));
  }), Promise.all(o);
}
function OC(e, t) {
  return e.sortNodePosition(t);
}
function NC(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let s;
  if (Array.isArray(t)) {
    const i = t.map((r) => ac(e, r, n));
    s = Promise.all(i);
  } else if (typeof t == "string")
    s = ac(e, t, n);
  else {
    const i = typeof t == "function" ? Ca(e, t, n.custom) : t;
    s = Promise.all(Um(e, i, n));
  }
  return s.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const LC = cu.length;
function Ym(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? Ym(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < LC; n++) {
    const s = cu[n], i = e.props[s];
    (tr(i) || i === !1) && (t[s] = i);
  }
  return t;
}
const FC = [...lu].reverse(), jC = lu.length;
function VC(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: s }) => NC(e, n, s)));
}
function UC(e) {
  let t = VC(e), n = Ch(), s = !0;
  const i = (l) => (c, u) => {
    var d;
    const h = Ca(e, u, l === "exit" ? (d = e.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0);
    if (h) {
      const { transition: f, transitionEnd: p, ...g } = h;
      c = { ...c, ...g, ...p };
    }
    return c;
  };
  function r(l) {
    t = l(e);
  }
  function o(l) {
    const { props: c } = e, u = Ym(e.parent) || {}, d = [], h = /* @__PURE__ */ new Set();
    let f = {}, p = 1 / 0;
    for (let m = 0; m < jC; m++) {
      const A = FC[m], w = n[A], x = c[A] !== void 0 ? c[A] : u[A], v = tr(x), C = A === l ? w.isActive : null;
      C === !1 && (p = m);
      let E = x === u[A] && x !== c[A] && v;
      if (E && s && e.manuallyAnimateOnMount && (E = !1), w.protectedKeys = { ...f }, // If it isn't active and hasn't *just* been set as inactive
      !w.isActive && C === null || // If we didn't and don't have any defined prop for this animation type
      !x && !w.prevProp || // Or if the prop doesn't define an animation
      $i(x) || typeof x == "boolean")
        continue;
      const S = YC(w.prevProp, x);
      let M = S || // If we're making this variant active, we want to always make it active
      A === l && w.isActive && !E && v || // If we removed a higher-priority variant (i is in reverse order)
      m > p && v, q = !1;
      const k = Array.isArray(x) ? x : [x];
      let R = k.reduce(i(A), {});
      C === !1 && (R = {});
      const { prevResolvedValues: D = {} } = w, j = {
        ...D,
        ...R
      }, W = (I) => {
        M = !0, h.has(I) && (q = !0, h.delete(I)), w.needsAnimating[I] = !0;
        const F = e.getValue(I);
        F && (F.liveStyle = !1);
      };
      for (const I in j) {
        const F = R[I], Q = D[I];
        if (f.hasOwnProperty(I))
          continue;
        let J = !1;
        Jl(F) && Jl(Q) ? J = !$g(F, Q) : J = F !== Q, J ? F != null ? W(I) : h.add(I) : F !== void 0 && h.has(I) ? W(I) : w.protectedKeys[I] = !0;
      }
      w.prevProp = x, w.prevResolvedValues = R, w.isActive && (f = { ...f, ...R }), s && e.blockInitialAnimation && (M = !1), M && (!(E && S) || q) && d.push(...k.map((I) => ({
        animation: I,
        options: { type: A }
      })));
    }
    if (h.size) {
      const m = {};
      h.forEach((A) => {
        const w = e.getBaseTarget(A), x = e.getValue(A);
        x && (x.liveStyle = !0), m[A] = w ?? null;
      }), d.push({ animation: m });
    }
    let g = !!d.length;
    return s && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1), s = !1, g ? t(d) : Promise.resolve();
  }
  function a(l, c) {
    var u;
    if (n[l].isActive === c)
      return Promise.resolve();
    (u = e.variantChildren) === null || u === void 0 || u.forEach((h) => {
      var f;
      return (f = h.animationState) === null || f === void 0 ? void 0 : f.setActive(l, c);
    }), n[l].isActive = c;
    const d = o(l);
    for (const h in n)
      n[h].protectedKeys = {};
    return d;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: r,
    getState: () => n,
    reset: () => {
      n = Ch(), s = !0;
    }
  };
}
function YC(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !$g(t, e) : !1;
}
function rs(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function Ch() {
  return {
    animate: rs(!0),
    whileInView: rs(),
    whileHover: rs(),
    whileTap: rs(),
    whileDrag: rs(),
    whileFocus: rs(),
    exit: rs()
  };
}
class $n {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
class WC extends $n {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = UC(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    $i(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this);
  }
}
let QC = 0;
class GC extends $n {
  constructor() {
    super(...arguments), this.id = QC++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === s)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => n(this.id));
  }
  mount() {
    const { register: t } = this.node.presenceContext || {};
    t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const KC = {
  animation: {
    Feature: WC
  },
  exit: {
    Feature: GC
  }
}, Wm = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function Ea(e, t = "page") {
  return {
    point: {
      x: e[`${t}X`],
      y: e[`${t}Y`]
    }
  };
}
const zC = (e) => (t) => Wm(t) && e(t, Ea(t));
function un(e, t, n, s = { passive: !0 }) {
  return e.addEventListener(t, n, s), () => e.removeEventListener(t, n);
}
function An(e, t, n, s) {
  return un(e, t, zC(n), s);
}
const Sh = (e, t) => Math.abs(e - t);
function _C(e, t) {
  const n = Sh(e.x, t.x), s = Sh(e.y, t.y);
  return Math.sqrt(n ** 2 + s ** 2);
}
class Qm {
  constructor(t, n, { transformPagePoint: s, contextWindow: i, dragSnapToOrigin: r = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const d = dl(this.lastMoveEventInfo, this.history), h = this.startEvent !== null, f = _C(d.offset, { x: 0, y: 0 }) >= 3;
      if (!h && !f)
        return;
      const { point: p } = d, { timestamp: g } = Yt;
      this.history.push({ ...p, timestamp: g });
      const { onStart: m, onMove: A } = this.handlers;
      h || (m && m(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), A && A(this.lastMoveEvent, d);
    }, this.handlePointerMove = (d, h) => {
      this.lastMoveEvent = d, this.lastMoveEventInfo = ul(h, this.transformPagePoint), pt.update(this.updatePoint, !0);
    }, this.handlePointerUp = (d, h) => {
      this.end();
      const { onEnd: f, onSessionEnd: p, resumeAnimation: g } = this.handlers;
      if (this.dragSnapToOrigin && g && g(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const m = dl(d.type === "pointercancel" ? this.lastMoveEventInfo : ul(h, this.transformPagePoint), this.history);
      this.startEvent && f && f(d, m), p && p(d, m);
    }, !Wm(t))
      return;
    this.dragSnapToOrigin = r, this.handlers = n, this.transformPagePoint = s, this.contextWindow = i || window;
    const o = Ea(t), a = ul(o, this.transformPagePoint), { point: l } = a, { timestamp: c } = Yt;
    this.history = [{ ...l, timestamp: c }];
    const { onSessionStart: u } = n;
    u && u(t, dl(a, this.history)), this.removeListeners = mn(An(this.contextWindow, "pointermove", this.handlePointerMove), An(this.contextWindow, "pointerup", this.handlePointerUp), An(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), jn(this.updatePoint);
  }
}
function ul(e, t) {
  return t ? { point: t(e.point) } : e;
}
function Mh(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function dl({ point: e }, t) {
  return {
    point: e,
    delta: Mh(e, Gm(t)),
    offset: Mh(e, ZC(t)),
    velocity: HC(t, 0.1)
  };
}
function ZC(e) {
  return e[0];
}
function Gm(e) {
  return e[e.length - 1];
}
function HC(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, s = null;
  const i = Gm(e);
  for (; n >= 0 && (s = e[n], !(i.timestamp - s.timestamp > pn(t))); )
    n--;
  if (!s)
    return { x: 0, y: 0 };
  const r = gn(i.timestamp - s.timestamp);
  if (r === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (i.x - s.x) / r,
    y: (i.y - s.y) / r
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function Km(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return t === null ? (t = e, n) : !1;
  };
}
const Eh = Km("dragHorizontal"), qh = Km("dragVertical");
function zm(e) {
  let t = !1;
  if (e === "y")
    t = qh();
  else if (e === "x")
    t = Eh();
  else {
    const n = Eh(), s = qh();
    n && s ? t = () => {
      n(), s();
    } : (n && n(), s && s());
  }
  return t;
}
function _m() {
  const e = zm(!0);
  return e ? (e(), !1) : !0;
}
function js(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
const Zm = 1e-4, JC = 1 - Zm, XC = 1 + Zm, Hm = 0.01, $C = 0 - Hm, tS = 0 + Hm;
function Ce(e) {
  return e.max - e.min;
}
function eS(e, t, n) {
  return Math.abs(e - t) <= n;
}
function Rh(e, t, n, s = 0.5) {
  e.origin = s, e.originPoint = qt(t.min, t.max, e.origin), e.scale = Ce(n) / Ce(t), e.translate = qt(n.min, n.max, e.origin) - e.originPoint, (e.scale >= JC && e.scale <= XC || isNaN(e.scale)) && (e.scale = 1), (e.translate >= $C && e.translate <= tS || isNaN(e.translate)) && (e.translate = 0);
}
function Gi(e, t, n, s) {
  Rh(e.x, t.x, n.x, s ? s.originX : void 0), Rh(e.y, t.y, n.y, s ? s.originY : void 0);
}
function kh(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Ce(t);
}
function nS(e, t, n) {
  kh(e.x, t.x, n.x), kh(e.y, t.y, n.y);
}
function Th(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Ce(t);
}
function Ki(e, t, n) {
  Th(e.x, t.x, n.x), Th(e.y, t.y, n.y);
}
function sS(e, { min: t, max: n }, s) {
  return t !== void 0 && e < t ? e = s ? qt(t, e, s.min) : Math.max(e, t) : n !== void 0 && e > n && (e = s ? qt(n, e, s.max) : Math.min(e, n)), e;
}
function Dh(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function iS(e, { top: t, left: n, bottom: s, right: i }) {
  return {
    x: Dh(e.x, n, i),
    y: Dh(e.y, t, s)
  };
}
function Bh(e, t) {
  let n = t.min - e.min, s = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, s] = [s, n]), { min: n, max: s };
}
function rS(e, t) {
  return {
    x: Bh(e.x, t.x),
    y: Bh(e.y, t.y)
  };
}
function oS(e, t) {
  let n = 0.5;
  const s = Ce(e), i = Ce(t);
  return i > s ? n = Xs(t.min, t.max - s, e.min) : s > i && (n = Xs(e.min, e.max - i, t.min)), Vn(0, 1, n);
}
function aS(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const lc = 0.35;
function lS(e = lc) {
  return e === !1 ? e = 0 : e === !0 && (e = lc), {
    x: Ih(e, "left", "right"),
    y: Ih(e, "top", "bottom")
  };
}
function Ih(e, t, n) {
  return {
    min: Ph(e, t),
    max: Ph(e, n)
  };
}
function Ph(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const Oh = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Vs = () => ({
  x: Oh(),
  y: Oh()
}), Nh = () => ({ min: 0, max: 0 }), Bt = () => ({
  x: Nh(),
  y: Nh()
});
function qe(e) {
  return [e("x"), e("y")];
}
function Jm({ top: e, left: t, right: n, bottom: s }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: s }
  };
}
function cS({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function uS(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), s = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: s.y,
    right: s.x
  };
}
function hl(e) {
  return e === void 0 || e === 1;
}
function cc({ scale: e, scaleX: t, scaleY: n }) {
  return !hl(e) || !hl(t) || !hl(n);
}
function ds(e) {
  return cc(e) || Xm(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function Xm(e) {
  return Lh(e.x) || Lh(e.y);
}
function Lh(e) {
  return e && e !== "0%";
}
function zo(e, t, n) {
  const s = e - n, i = t * s;
  return n + i;
}
function Fh(e, t, n, s, i) {
  return i !== void 0 && (e = zo(e, i, s)), zo(e, n, s) + t;
}
function uc(e, t = 0, n = 1, s, i) {
  e.min = Fh(e.min, t, n, s, i), e.max = Fh(e.max, t, n, s, i);
}
function $m(e, { x: t, y: n }) {
  uc(e.x, t.translate, t.scale, t.originPoint), uc(e.y, n.translate, n.scale, n.originPoint);
}
const jh = 0.999999999999, Vh = 1.0000000000001;
function dS(e, t, n, s = !1) {
  const i = n.length;
  if (!i)
    return;
  t.x = t.y = 1;
  let r, o;
  for (let a = 0; a < i; a++) {
    r = n[a], o = r.projectionDelta;
    const { visualElement: l } = r.options;
    l && l.props.style && l.props.style.display === "contents" || (s && r.options.layoutScroll && r.scroll && r !== r.root && Ys(e, {
      x: -r.scroll.offset.x,
      y: -r.scroll.offset.y
    }), o && (t.x *= o.x.scale, t.y *= o.y.scale, $m(e, o)), s && ds(r.latestValues) && Ys(e, r.latestValues));
  }
  t.x < Vh && t.x > jh && (t.x = 1), t.y < Vh && t.y > jh && (t.y = 1);
}
function Us(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function Uh(e, t, n, s, i = 0.5) {
  const r = qt(e.min, e.max, i);
  uc(e, t, n, r, s);
}
function Ys(e, t) {
  Uh(e.x, t.x, t.scaleX, t.scale, t.originX), Uh(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function tA(e, t) {
  return Jm(uS(e.getBoundingClientRect(), t));
}
function hS(e, t, n) {
  const s = tA(e, n), { scroll: i } = t;
  return i && (Us(s.x, i.offset.x), Us(s.y, i.offset.y)), s;
}
const eA = ({ current: e }) => e ? e.ownerDocument.defaultView : null, fS = /* @__PURE__ */ new WeakMap();
class pS {
  constructor(t) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Bt(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: s } = this.visualElement;
    if (s && s.isPresent === !1)
      return;
    const i = (u) => {
      const { dragSnapToOrigin: d } = this.getProps();
      d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Ea(u, "page").point);
    }, r = (u, d) => {
      const { drag: h, dragPropagation: f, onDragStart: p } = this.getProps();
      if (h && !f && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = zm(h), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), qe((m) => {
        let A = this.getAxisMotionValue(m).get() || 0;
        if (Ge.test(A)) {
          const { projection: w } = this.visualElement;
          if (w && w.layout) {
            const x = w.layout.layoutBox[m];
            x && (A = Ce(x) * (parseFloat(A) / 100));
          }
        }
        this.originPoint[m] = A;
      }), p && pt.postRender(() => p(u, d)), oc(this.visualElement, "transform");
      const { animationState: g } = this.visualElement;
      g && g.setActive("whileDrag", !0);
    }, o = (u, d) => {
      const { dragPropagation: h, dragDirectionLock: f, onDirectionLock: p, onDrag: g } = this.getProps();
      if (!h && !this.openGlobalLock)
        return;
      const { offset: m } = d;
      if (f && this.currentDirection === null) {
        this.currentDirection = gS(m), this.currentDirection !== null && p && p(this.currentDirection);
        return;
      }
      this.updateAxis("x", d.point, m), this.updateAxis("y", d.point, m), this.visualElement.render(), g && g(u, d);
    }, a = (u, d) => this.stop(u, d), l = () => qe((u) => {
      var d;
      return this.getAnimationState(u) === "paused" && ((d = this.getAxisMotionValue(u).animation) === null || d === void 0 ? void 0 : d.play());
    }), { dragSnapToOrigin: c } = this.getProps();
    this.panSession = new Qm(t, {
      onSessionStart: i,
      onStart: r,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: l
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: c,
      contextWindow: eA(this.visualElement)
    });
  }
  stop(t, n) {
    const s = this.isDragging;
    if (this.cancel(), !s)
      return;
    const { velocity: i } = n;
    this.startAnimation(i);
    const { onDragEnd: r } = this.getProps();
    r && pt.postRender(() => r(t, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: s } = this.getProps();
    !s && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, s) {
    const { drag: i } = this.getProps();
    if (!s || !zr(t, i, this.currentDirection))
      return;
    const r = this.getAxisMotionValue(t);
    let o = this.originPoint[t] + s[t];
    this.constraints && this.constraints[t] && (o = sS(o, this.constraints[t], this.elastic[t])), r.set(o);
  }
  resolveConstraints() {
    var t;
    const { dragConstraints: n, dragElastic: s } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, r = this.constraints;
    n && js(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = iS(i.layoutBox, n) : this.constraints = !1, this.elastic = lS(s), r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && qe((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = aS(i.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !js(t))
      return !1;
    const s = t.current, { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const r = hS(s, i.root, this.visualElement.getTransformPagePoint());
    let o = rS(i.layout.layoutBox, r);
    if (n) {
      const a = n(cS(o));
      this.hasMutatedConstraints = !!a, a && (o = Jm(a));
    }
    return o;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: s, dragElastic: i, dragTransition: r, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = qe((u) => {
      if (!zr(u, n, this.currentDirection))
        return;
      let d = l && l[u] || {};
      o && (d = { min: 0, max: 0 });
      const h = i ? 200 : 1e6, f = i ? 40 : 1e7, p = {
        type: "inertia",
        velocity: s ? t[u] : 0,
        bounceStiffness: h,
        bounceDamping: f,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...r,
        ...d
      };
      return this.startAxisValueAnimation(u, p);
    });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(t, n) {
    const s = this.getAxisMotionValue(t);
    return oc(this.visualElement, t), s.start(Cu(t, s, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    qe((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    qe((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, s = this.visualElement.getProps(), i = s[n];
    return i || this.visualElement.getValue(t, (s.initial ? s.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    qe((n) => {
      const { drag: s } = this.getProps();
      if (!zr(n, s, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, r = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[n];
        r.set(t[n] - qt(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: s } = this.visualElement;
    if (!js(n) || !s || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    qe((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const l = a.get();
        i[o] = oS({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: r } = this.visualElement.getProps();
    this.visualElement.current.style.transform = r ? r({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), qe((o) => {
      if (!zr(o, t, null))
        return;
      const a = this.getAxisMotionValue(o), { min: l, max: c } = this.constraints[o];
      a.set(qt(l, c, i[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    fS.set(this.visualElement, this);
    const t = this.visualElement.current, n = An(t, "pointerdown", (l) => {
      const { drag: c, dragListener: u = !0 } = this.getProps();
      c && u && this.start(l);
    }), s = () => {
      const { dragConstraints: l } = this.getProps();
      js(l) && l.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, r = i.addEventListener("measure", s);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), pt.read(s);
    const o = un(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => {
      this.isDragging && c && (qe((u) => {
        const d = this.getAxisMotionValue(u);
        d && (this.originPoint[u] += l[u].translate, d.set(d.get() + l[u].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), n(), r(), a && a();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: s = !1, dragPropagation: i = !1, dragConstraints: r = !1, dragElastic: o = lc, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: s,
      dragPropagation: i,
      dragConstraints: r,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function zr(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function gS(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class mS extends $n {
  constructor(t) {
    super(t), this.removeGroupControls = Jt, this.removeListeners = Jt, this.controls = new pS(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Jt;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const Yh = (e) => (t, n) => {
  e && pt.postRender(() => e(t, n));
};
class AS extends $n {
  constructor() {
    super(...arguments), this.removePointerDownListener = Jt;
  }
  onPointerDown(t) {
    this.session = new Qm(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: eA(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: s, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: Yh(t),
      onStart: Yh(n),
      onMove: s,
      onEnd: (r, o) => {
        delete this.session, i && pt.postRender(() => i(r, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = An(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const qa = Ts(null);
function yS() {
  const e = Wt(qa);
  if (e === null)
    return [!0, null];
  const { isPresent: t, onExitComplete: n, register: s } = e, i = iu();
  Lt(() => s(i), []);
  const r = ce(() => n && n(i), [i, n]);
  return !t && n ? [!1, r] : [!0];
}
const Eu = Ts({}), nA = Ts({}), So = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function Wh(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const Ci = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (z.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = Wh(e, t.target.x), s = Wh(e, t.target.y);
    return `${n}% ${s}%`;
  }
}, wS = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const s = e, i = Un.parse(e);
    if (i.length > 5)
      return s;
    const r = Un.createTransformer(e), o = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y;
    i[0 + o] /= a, i[1 + o] /= l;
    const c = qt(a, l, 0.5);
    return typeof i[2 + o] == "number" && (i[2 + o] /= c), typeof i[3 + o] == "number" && (i[3 + o] /= c), r(i);
  }
}, _o = {};
function bS(e) {
  Object.assign(_o, e);
}
const { schedule: qu, cancel: kF } = tm(queueMicrotask, !1);
class xS extends px {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: s, layoutId: i } = this.props, { projection: r } = t;
    bS(vS), r && (n.group && n.group.add(r), s && s.register && i && s.register(r), r.root.didUpdate(), r.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), r.setOptions({
      ...r.options,
      onExitComplete: () => this.safeToRemove()
    })), So.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: s, drag: i, isPresent: r } = this.props, o = s.projection;
    return o && (o.isPresent = r, i || t.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), t.isPresent !== r && (r ? o.promote() : o.relegate() || pt.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), qu.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: s } = this.props, { projection: i } = t;
    i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), s && s.deregister && s.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function sA(e) {
  const [t, n] = yS(), s = Wt(Eu);
  return y.jsx(xS, { ...e, layoutGroup: s, switchLayoutGroup: Wt(nA), isPresent: t, safeToRemove: n });
}
const vS = {
  borderRadius: {
    ...Ci,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Ci,
  borderTopRightRadius: Ci,
  borderBottomLeftRadius: Ci,
  borderBottomRightRadius: Ci,
  boxShadow: wS
}, iA = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], CS = iA.length, Qh = (e) => typeof e == "string" ? parseFloat(e) : e, Gh = (e) => typeof e == "number" || z.test(e);
function SS(e, t, n, s, i, r) {
  i ? (e.opacity = qt(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    MS(s)
  ), e.opacityExit = qt(t.opacity !== void 0 ? t.opacity : 1, 0, ES(s))) : r && (e.opacity = qt(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, s));
  for (let o = 0; o < CS; o++) {
    const a = `border${iA[o]}Radius`;
    let l = Kh(t, a), c = Kh(n, a);
    if (l === void 0 && c === void 0)
      continue;
    l || (l = 0), c || (c = 0), l === 0 || c === 0 || Gh(l) === Gh(c) ? (e[a] = Math.max(qt(Qh(l), Qh(c), s), 0), (Ge.test(c) || Ge.test(l)) && (e[a] += "%")) : e[a] = c;
  }
  (t.rotate || n.rotate) && (e.rotate = qt(t.rotate || 0, n.rotate || 0, s));
}
function Kh(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const MS = /* @__PURE__ */ rA(0, 0.5, am), ES = /* @__PURE__ */ rA(0.5, 0.95, Jt);
function rA(e, t, n) {
  return (s) => s < e ? 0 : s > t ? 1 : n(Xs(e, t, s));
}
function zh(e, t) {
  e.min = t.min, e.max = t.max;
}
function Me(e, t) {
  zh(e.x, t.x), zh(e.y, t.y);
}
function _h(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
function Zh(e, t, n, s, i) {
  return e -= t, e = zo(e, 1 / n, s), i !== void 0 && (e = zo(e, 1 / i, s)), e;
}
function qS(e, t = 0, n = 1, s = 0.5, i, r = e, o = e) {
  if (Ge.test(t) && (t = parseFloat(t), t = qt(o.min, o.max, t / 100) - o.min), typeof t != "number")
    return;
  let a = qt(r.min, r.max, s);
  e === r && (a -= t), e.min = Zh(e.min, t, n, a, i), e.max = Zh(e.max, t, n, a, i);
}
function Hh(e, t, [n, s, i], r, o) {
  qS(e, t[n], t[s], t[i], t.scale, r, o);
}
const RS = ["x", "scaleX", "originX"], kS = ["y", "scaleY", "originY"];
function Jh(e, t, n, s) {
  Hh(e.x, t, RS, n ? n.x : void 0, s ? s.x : void 0), Hh(e.y, t, kS, n ? n.y : void 0, s ? s.y : void 0);
}
function Xh(e) {
  return e.translate === 0 && e.scale === 1;
}
function oA(e) {
  return Xh(e.x) && Xh(e.y);
}
function $h(e, t) {
  return e.min === t.min && e.max === t.max;
}
function TS(e, t) {
  return $h(e.x, t.x) && $h(e.y, t.y);
}
function tf(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function aA(e, t) {
  return tf(e.x, t.x) && tf(e.y, t.y);
}
function ef(e) {
  return Ce(e.x) / Ce(e.y);
}
function nf(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
class DS {
  constructor() {
    this.members = [];
  }
  add(t) {
    Ir(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Su(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let s;
    for (let i = n; i >= 0; i--) {
      const r = this.members[i];
      if (r.isPresent !== !1) {
        s = r;
        break;
      }
    }
    return s ? (this.promote(s), !0) : !1;
  }
  promote(t, n) {
    const s = this.lead;
    if (t !== s && (this.prevLead = s, this.lead = t, t.show(), s)) {
      s.instance && s.scheduleRender(), t.scheduleRender(), t.resumeFrom = s, n && (t.resumeFrom.preserveOpacity = !0), s.snapshot && (t.snapshot = s.snapshot, t.snapshot.latestValues = s.animationValues || s.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: i } = t.options;
      i === !1 && s.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: s } = t;
      n.onExitComplete && n.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function BS(e, t, n) {
  let s = "";
  const i = e.x.translate / t.x, r = e.y.translate / t.y, o = (n == null ? void 0 : n.z) || 0;
  if ((i || r || o) && (s = `translate3d(${i}px, ${r}px, ${o}px) `), (t.x !== 1 || t.y !== 1) && (s += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: c, rotate: u, rotateX: d, rotateY: h, skewX: f, skewY: p } = n;
    c && (s = `perspective(${c}px) ${s}`), u && (s += `rotate(${u}deg) `), d && (s += `rotateX(${d}deg) `), h && (s += `rotateY(${h}deg) `), f && (s += `skewX(${f}deg) `), p && (s += `skewY(${p}deg) `);
  }
  const a = e.x.scale * t.x, l = e.y.scale * t.y;
  return (a !== 1 || l !== 1) && (s += `scale(${a}, ${l})`), s || "none";
}
const IS = (e, t) => e.depth - t.depth;
class PS {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    Ir(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Su(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(IS), this.isDirty = !1, this.children.forEach(t);
  }
}
function Mo(e) {
  const t = Zt(e) ? e.get() : e;
  return MC(t) ? t.toValue() : t;
}
function OS(e, t) {
  const n = Ke.now(), s = ({ timestamp: i }) => {
    const r = i - n;
    r >= t && (jn(s), e(r - t));
  };
  return pt.read(s, !0), () => jn(s);
}
function NS(e) {
  return e instanceof SVGElement && e.tagName !== "svg";
}
function LS(e, t, n) {
  const s = Zt(e) ? e : sr(e);
  return s.start(Cu("", s, t, n)), s.animation;
}
const hs = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, Oi = typeof window < "u" && window.MotionDebug !== void 0, fl = ["", "X", "Y", "Z"], FS = { visibility: "hidden" }, sf = 1e3;
let jS = 0;
function pl(e, t, n, s) {
  const { latestValues: i } = t;
  i[e] && (n[e] = i[e], t.setStaticValue(e, 0), s && (s[e] = 0));
}
function lA(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = jm(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: i, layoutId: r } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", pt, !(i || r));
  }
  const { parent: s } = e;
  s && !s.hasCheckedOptimisedAppear && lA(s);
}
function cA({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: s, resetTransform: i }) {
  return class {
    constructor(o = {}, a = t == null ? void 0 : t()) {
      this.id = jS++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Oi && (hs.totalNodes = hs.resolvedTargetDeltas = hs.recalculatedProjection = 0), this.nodes.forEach(YS), this.nodes.forEach(zS), this.nodes.forEach(_S), this.nodes.forEach(WS), Oi && window.MotionDebug.record(hs);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new PS());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Mu()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = NS(o), this.instance = o;
      const { layoutId: l, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), e) {
        let d;
        const h = () => this.root.updateBlockedByResize = !1;
        e(o, () => {
          this.root.updateBlockedByResize = !0, d && d(), d = OS(h, 250), So.hasAnimatedSinceResize && (So.hasAnimatedSinceResize = !1, this.nodes.forEach(of));
        });
      }
      l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: h, hasRelativeTargetChanged: f, layout: p }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const g = this.options.transition || u.getDefaultTransition() || $S, { onLayoutAnimationStart: m, onLayoutAnimationComplete: A } = u.getProps(), w = !this.targetLayout || !aA(this.targetLayout, p) || f, x = !h && f;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || x || h && (w || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, x);
          const v = {
            ...uu(g, "layout"),
            onPlay: m,
            onComplete: A
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (v.delay = 0, v.type = !1), this.startAnimation(v);
        } else
          h || of(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = p;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, jn(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(ZS), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && lA(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const d = this.path[u];
        d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l)
        return;
      const c = this.getTransformTemplate();
      this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(rf);
        return;
      }
      this.isUpdating || this.nodes.forEach(GS), this.isUpdating = !1, this.nodes.forEach(KS), this.nodes.forEach(VS), this.nodes.forEach(US), this.clearAllSnapshots();
      const a = Ke.now();
      Yt.delta = Vn(0, 1e3 / 60, a - Yt.timestamp), Yt.timestamp = a, Yt.isProcessing = !0, rl.update.process(Yt), rl.preRender.process(Yt), rl.render.process(Yt), Yt.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, qu.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(QS), this.sharedNodes.forEach(HS);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, pt.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      pt.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++)
          this.path[l].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Bt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const l = s(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !oA(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue;
      o && (a || ds(this.latestValues) || u) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return o && (l = this.removeTransform(l)), tM(l), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: l,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return Bt();
      const l = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(eM))) {
        const { scroll: u } = this.root;
        u && (Us(l.x, u.offset.x), Us(l.y, u.offset.y));
      }
      return l;
    }
    removeElementScroll(o) {
      var a;
      const l = Bt();
      if (Me(l, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return l;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c], { scroll: d, options: h } = u;
        u !== this.root && d && h.layoutScroll && (d.wasRoot && Me(l, o), Us(l.x, d.offset.x), Us(l.y, d.offset.y));
      }
      return l;
    }
    applyTransform(o, a = !1) {
      const l = Bt();
      Me(l, o);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && Ys(l, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), ds(u.latestValues) && Ys(l, u.latestValues);
      }
      return ds(this.latestValues) && Ys(l, this.latestValues), l;
    }
    removeTransform(o) {
      const a = Bt();
      Me(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !ds(c.latestValues))
          continue;
        cc(c.latestValues) && c.updateSnapshot();
        const u = Bt(), d = c.measurePageBox();
        Me(u, d), Jh(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u);
      }
      return ds(this.latestValues) && Jh(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Yt.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: d, layoutId: h } = this.options;
      if (!(!this.layout || !(d || h))) {
        if (this.resolvedRelativeTargetAt = Yt.timestamp, !this.targetDelta && !this.relativeTarget) {
          const f = this.getClosestProjectingParent();
          f && f.layout && this.animationProgress !== 1 ? (this.relativeParent = f, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Bt(), this.relativeTargetOrigin = Bt(), Ki(this.relativeTargetOrigin, this.layout.layoutBox, f.layout.layoutBox), Me(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = Bt(), this.targetWithTransforms = Bt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), nS(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Me(this.target, this.layout.layoutBox), $m(this.target, this.targetDelta)) : Me(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const f = this.getClosestProjectingParent();
            f && !!f.resumingFrom == !!this.resumingFrom && !f.options.layoutScroll && f.target && this.animationProgress !== 1 ? (this.relativeParent = f, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Bt(), this.relativeTargetOrigin = Bt(), Ki(this.relativeTargetOrigin, this.target, f.target), Me(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Oi && hs.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || cc(this.parent.latestValues) || Xm(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), l = !!this.resumingFrom || this !== a;
      let c = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Yt.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: d } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d))
        return;
      Me(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x, f = this.treeScale.y;
      dS(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = Bt());
      const { target: p } = a;
      if (!p) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (_h(this.prevProjectionDelta.x, this.projectionDelta.x), _h(this.prevProjectionDelta.y, this.projectionDelta.y)), Gi(this.projectionDelta, this.layoutCorrected, p, this.latestValues), (this.treeScale.x !== h || this.treeScale.y !== f || !nf(this.projectionDelta.x, this.prevProjectionDelta.x) || !nf(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)), Oi && hs.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Vs(), this.projectionDelta = Vs(), this.projectionDeltaWithTransform = Vs();
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, d = Vs();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const h = Bt(), f = l ? l.source : void 0, p = this.layout ? this.layout.source : void 0, g = f !== p, m = this.getStack(), A = !m || m.members.length <= 1, w = !!(g && !A && this.options.crossfade === !0 && !this.path.some(XS));
      this.animationProgress = 0;
      let x;
      this.mixTargetDelta = (v) => {
        const C = v / 1e3;
        af(d.x, o.x, C), af(d.y, o.y, C), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Ki(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox), JS(this.relativeTarget, this.relativeTargetOrigin, h, C), x && TS(this.relativeTarget, x) && (this.isProjectionDirty = !1), x || (x = Bt()), Me(x, this.relativeTarget)), g && (this.animationValues = u, SS(u, c, this.latestValues, C, w, A)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (jn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = pt.update(() => {
        So.hasAnimatedSinceResize = !0, this.currentAnimation = LS(0, sf, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(sf), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = o;
      if (!(!a || !l || !c)) {
        if (this !== o && this.layout && c && uA(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
          l = this.target || Bt();
          const d = Ce(this.layout.layoutBox.x);
          l.x.min = o.target.x.min, l.x.max = l.x.min + d;
          const h = Ce(this.layout.layoutBox.y);
          l.y.min = o.target.y.min, l.y.max = l.y.min + h;
        }
        Me(a, l), Ys(a, u), Gi(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new DS()), this.sharedNodes.get(o).add(a);
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: l } = o;
      if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a)
        return;
      const c = {};
      l.z && pl("z", o, c, this.animationValues);
      for (let u = 0; u < fl.length; u++)
        pl(`rotate${fl[u]}`, o, c, this.animationValues), pl(`skew${fl[u]}`, o, c, this.animationValues);
      o.render();
      for (const u in c)
        o.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, l;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return FS;
      const c = {
        visibility: ""
      }, u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, c.opacity = "", c.pointerEvents = Mo(o == null ? void 0 : o.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c;
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const g = {};
        return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, g.pointerEvents = Mo(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !ds(this.latestValues) && (g.transform = u ? u({}, "") : "none", this.hasProjected = !1), g;
      }
      const h = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(), c.transform = BS(this.projectionDeltaWithTransform, this.treeScale, h), u && (c.transform = u(h, c.transform));
      const { x: f, y: p } = this.projectionDelta;
      c.transformOrigin = `${f.origin * 100}% ${p.origin * 100}% 0`, d.animationValues ? c.opacity = d === this ? (l = (a = h.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : h.opacityExit : c.opacity = d === this ? h.opacity !== void 0 ? h.opacity : "" : h.opacityExit !== void 0 ? h.opacityExit : 0;
      for (const g in _o) {
        if (h[g] === void 0)
          continue;
        const { correct: m, applyTo: A } = _o[g], w = c.transform === "none" ? h[g] : m(h[g], d);
        if (A) {
          const x = A.length;
          for (let v = 0; v < x; v++)
            c[A[v]] = w;
        } else
          c[g] = w;
      }
      return this.options.layoutId && (c.pointerEvents = d === this ? Mo(o == null ? void 0 : o.pointerEvents) || "" : "none"), c;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(rf), this.root.sharedNodes.clear();
    }
  };
}
function VS(e) {
  e.updateLayout();
}
function US(e) {
  var t;
  const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: s, measuredBox: i } = e.layout, { animationType: r } = e.options, o = n.source !== e.layout.source;
    r === "size" ? qe((d) => {
      const h = o ? n.measuredBox[d] : n.layoutBox[d], f = Ce(h);
      h.min = s[d].min, h.max = h.min + f;
    }) : uA(r, n.layoutBox, s) && qe((d) => {
      const h = o ? n.measuredBox[d] : n.layoutBox[d], f = Ce(s[d]);
      h.max = h.min + f, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + f);
    });
    const a = Vs();
    Gi(a, s, n.layoutBox);
    const l = Vs();
    o ? Gi(l, e.applyTransform(i, !0), n.measuredBox) : Gi(l, s, n.layoutBox);
    const c = !oA(a);
    let u = !1;
    if (!e.resumeFrom) {
      const d = e.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: h, layout: f } = d;
        if (h && f) {
          const p = Bt();
          Ki(p, n.layoutBox, h.layoutBox);
          const g = Bt();
          Ki(g, s, f.layoutBox), aA(p, g) || (u = !0), d.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = p, e.relativeParent = d);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: s,
      snapshot: n,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeTargetChanged: u
    });
  } else if (e.isLead()) {
    const { onExitComplete: s } = e.options;
    s && s();
  }
  e.options.transition = void 0;
}
function YS(e) {
  Oi && hs.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function WS(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function QS(e) {
  e.clearSnapshot();
}
function rf(e) {
  e.clearMeasurements();
}
function GS(e) {
  e.isLayoutDirty = !1;
}
function KS(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function of(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function zS(e) {
  e.resolveTargetDelta();
}
function _S(e) {
  e.calcProjection();
}
function ZS(e) {
  e.resetSkewAndRotation();
}
function HS(e) {
  e.removeLeadSnapshot();
}
function af(e, t, n) {
  e.translate = qt(t.translate, 0, n), e.scale = qt(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function lf(e, t, n, s) {
  e.min = qt(t.min, n.min, s), e.max = qt(t.max, n.max, s);
}
function JS(e, t, n, s) {
  lf(e.x, t.x, n.x, s), lf(e.y, t.y, n.y, s);
}
function XS(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const $S = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, cf = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), uf = cf("applewebkit/") && !cf("chrome/") ? Math.round : Jt;
function df(e) {
  e.min = uf(e.min), e.max = uf(e.max);
}
function tM(e) {
  df(e.x), df(e.y);
}
function uA(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !eS(ef(t), ef(n), 0.2);
}
function eM(e) {
  var t;
  return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot);
}
const nM = cA({
  attachResizeListener: (e, t) => un(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), gl = {
  current: void 0
}, dA = cA({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!gl.current) {
      const e = new nM({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), gl.current = e;
    }
    return gl.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), sM = {
  pan: {
    Feature: AS
  },
  drag: {
    Feature: mS,
    ProjectionNode: dA,
    MeasureLayout: sA
  }
};
function hf(e, t) {
  const n = t ? "pointerenter" : "pointerleave", s = t ? "onHoverStart" : "onHoverEnd", i = (r, o) => {
    if (r.pointerType === "touch" || _m())
      return;
    const a = e.getProps();
    e.animationState && a.whileHover && e.animationState.setActive("whileHover", t);
    const l = a[s];
    l && pt.postRender(() => l(r, o));
  };
  return An(e.current, n, i, {
    passive: !e.getProps()[s]
  });
}
class iM extends $n {
  mount() {
    this.unmount = mn(hf(this.node, !0), hf(this.node, !1));
  }
  unmount() {
  }
}
class rM extends $n {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = mn(un(this.node.current, "focus", () => this.onFocus()), un(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const hA = (e, t) => t ? e === t ? !0 : hA(e, t.parentElement) : !1;
function ml(e, t) {
  if (!t)
    return;
  const n = new PointerEvent("pointer" + e);
  t(n, Ea(n));
}
class oM extends $n {
  constructor() {
    super(...arguments), this.removeStartListeners = Jt, this.removeEndListeners = Jt, this.removeAccessibleListeners = Jt, this.startPointerPress = (t, n) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const s = this.node.getProps(), r = An(window, "pointerup", (a, l) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: c, onTapCancel: u, globalTapTarget: d } = this.node.getProps(), h = !d && !hA(this.node.current, a.target) ? u : c;
        h && pt.update(() => h(a, l));
      }, {
        passive: !(s.onTap || s.onPointerUp)
      }), o = An(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
        passive: !(s.onTapCancel || s.onPointerCancel)
      });
      this.removeEndListeners = mn(r, o), this.startPress(t, n);
    }, this.startAccessiblePress = () => {
      const t = (r) => {
        if (r.key !== "Enter" || this.isPressing)
          return;
        const o = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || ml("up", (l, c) => {
            const { onTap: u } = this.node.getProps();
            u && pt.postRender(() => u(l, c));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = un(this.node.current, "keyup", o), ml("down", (a, l) => {
          this.startPress(a, l);
        });
      }, n = un(this.node.current, "keydown", t), s = () => {
        this.isPressing && ml("cancel", (r, o) => this.cancelPress(r, o));
      }, i = un(this.node.current, "blur", s);
      this.removeAccessibleListeners = mn(n, i);
    };
  }
  startPress(t, n) {
    this.isPressing = !0;
    const { onTapStart: s, whileTap: i } = this.node.getProps();
    i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), s && pt.postRender(() => s(t, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !_m();
  }
  cancelPress(t, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: s } = this.node.getProps();
    s && pt.postRender(() => s(t, n));
  }
  mount() {
    const t = this.node.getProps(), n = An(t.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(t.onTapStart || t.onPointerStart)
    }), s = un(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = mn(n, s);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const dc = /* @__PURE__ */ new WeakMap(), Al = /* @__PURE__ */ new WeakMap(), aM = (e) => {
  const t = dc.get(e.target);
  t && t(e);
}, lM = (e) => {
  e.forEach(aM);
};
function cM({ root: e, ...t }) {
  const n = e || document;
  Al.has(n) || Al.set(n, {});
  const s = Al.get(n), i = JSON.stringify(t);
  return s[i] || (s[i] = new IntersectionObserver(lM, { root: e, ...t })), s[i];
}
function uM(e, t, n) {
  const s = cM(t);
  return dc.set(e, n), s.observe(e), () => {
    dc.delete(e), s.unobserve(e);
  };
}
const dM = {
  some: 0,
  all: 1
};
class hM extends $n {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: s, amount: i = "some", once: r } = t, o = {
      root: n ? n.current : void 0,
      rootMargin: s,
      threshold: typeof i == "number" ? i : dM[i]
    }, a = (l) => {
      const { isIntersecting: c } = l;
      if (this.isInView === c || (this.isInView = c, r && !c && this.hasEnteredView))
        return;
      c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
      const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(), h = c ? u : d;
      h && h(l);
    };
    return uM(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(fM(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function fM({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const pM = {
  inView: {
    Feature: hM
  },
  tap: {
    Feature: oM
  },
  focus: {
    Feature: rM
  },
  hover: {
    Feature: iM
  }
}, gM = {
  layout: {
    ProjectionNode: dA,
    MeasureLayout: sA
  }
}, Ru = Ts({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), Ra = Ts({}), ku = typeof window < "u", fA = ku ? ru : Lt, pA = Ts({ strict: !1 });
let ff = !1;
function mM(e, t, n, s, i) {
  var r;
  const { visualElement: o } = Wt(Ra), a = Wt(pA), l = Wt(qa), c = Wt(Ru).reducedMotion, u = fe();
  s = s || a.renderer, !u.current && s && (u.current = s(e, {
    visualState: t,
    parent: o,
    props: n,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: c
  }));
  const d = u.current, h = Wt(nA);
  d && !d.projection && i && (d.type === "html" || d.type === "svg") && yM(u.current, n, i, h), zg(() => {
    d && d.update(n, l);
  });
  const f = n[Fm], p = fe(!!f && !window.MotionHandoffIsComplete && ((r = window.MotionHasOptimisedAnimation) === null || r === void 0 ? void 0 : r.call(window, f)));
  return fA(() => {
    d && (d.updateFeatures(), qu.render(d.render), p.current && d.animationState && d.animationState.animateChanges());
  }), Lt(() => {
    d && (!p.current && d.animationState && d.animationState.animateChanges(), p.current = !1, ff || (ff = !0, queueMicrotask(AM)));
  }), d;
}
function AM() {
  window.MotionHandoffIsComplete = !0;
}
function yM(e, t, n, s) {
  const { layoutId: i, layout: r, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: c } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : gA(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: r,
    alwaysMeasureLayout: !!o || a && js(a),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof r == "string" ? r : "both",
    initialPromotionConfig: s,
    layoutScroll: l,
    layoutRoot: c
  });
}
function gA(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : gA(e.parent);
}
function wM(e, t, n) {
  return ce(
    (s) => {
      s && e.mount && e.mount(s), t && (s ? t.mount(s) : t.unmount()), n && (typeof n == "function" ? n(s) : js(n) && (n.current = s));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
function ka(e) {
  return $i(e.animate) || cu.some((t) => tr(e[t]));
}
function mA(e) {
  return !!(ka(e) || e.variants);
}
function bM(e, t) {
  if (ka(e)) {
    const { initial: n, animate: s } = e;
    return {
      initial: n === !1 || tr(n) ? n : void 0,
      animate: tr(s) ? s : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function xM(e) {
  const { initial: t, animate: n } = bM(e, Wt(Ra));
  return Ln(() => ({ initial: t, animate: n }), [pf(t), pf(n)]);
}
function pf(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const gf = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, $s = {};
for (const e in gf)
  $s[e] = {
    isEnabled: (t) => gf[e].some((n) => !!t[n])
  };
function vM(e) {
  for (const t in e)
    $s[t] = {
      ...$s[t],
      ...e[t]
    };
}
const CM = Symbol.for("motionComponentSymbol");
function SM({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: s, Component: i }) {
  e && vM(e);
  function r(a, l) {
    let c;
    const u = {
      ...Wt(Ru),
      ...a,
      layoutId: MM(a)
    }, { isStatic: d } = u, h = xM(a), f = s(a, d);
    if (!d && ku) {
      EM();
      const p = qM(u);
      c = p.MeasureLayout, h.visualElement = mM(i, f, u, t, p.ProjectionNode);
    }
    return y.jsxs(Ra.Provider, { value: h, children: [c && h.visualElement ? y.jsx(c, { visualElement: h.visualElement, ...u }) : null, n(i, a, wM(f, h.visualElement, l), f, d, h.visualElement)] });
  }
  const o = kr(r);
  return o[CM] = i, o;
}
function MM({ layoutId: e }) {
  const t = Wt(Eu).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function EM(e, t) {
  Wt(pA).strict;
}
function qM(e) {
  const { drag: t, layout: n } = $s;
  if (!t && !n)
    return {};
  const s = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? s.MeasureLayout : void 0,
    ProjectionNode: s.ProjectionNode
  };
}
const RM = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Tu(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(RM.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function AA(e, { style: t, vars: n }, s, i) {
  Object.assign(e.style, t, i && i.getProjectionStyles(s));
  for (const r in n)
    e.style.setProperty(r, n[r]);
}
const yA = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function wA(e, t, n, s) {
  AA(e, t, void 0, s);
  for (const i in t.attrs)
    e.setAttribute(yA.has(i) ? i : Ma(i), t.attrs[i]);
}
function bA(e, { layout: t, layoutId: n }) {
  return Xn.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!_o[e] || e === "opacity");
}
function Du(e, t, n) {
  var s;
  const { style: i } = e, r = {};
  for (const o in i)
    (Zt(i[o]) || t.style && Zt(t.style[o]) || bA(o, e) || ((s = n == null ? void 0 : n.getValue(o)) === null || s === void 0 ? void 0 : s.liveStyle) !== void 0) && (r[o] = i[o]);
  return n && i && typeof i.willChange == "string" && (n.applyWillChange = !1), r;
}
function xA(e, t, n) {
  const s = Du(e, t, n);
  for (const i in e)
    if (Zt(e[i]) || Zt(t[i])) {
      const r = Tr.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      s[r] = e[i];
    }
  return s;
}
function Bu(e) {
  const t = fe(null);
  return t.current === null && (t.current = e()), t.current;
}
function kM({ applyWillChange: e = !1, scrapeMotionValuesFromProps: t, createRenderState: n, onMount: s }, i, r, o, a) {
  const l = {
    latestValues: DM(i, r, o, a ? !1 : e, t),
    renderState: n()
  };
  return s && (l.mount = (c) => s(i, c, l)), l;
}
const vA = (e) => (t, n) => {
  const s = Wt(Ra), i = Wt(qa), r = () => kM(e, t, s, i, n);
  return n ? r() : Bu(r);
};
function TM(e, t) {
  const n = Vm(t);
  n && Ir(e, n);
}
function mf(e, t, n) {
  const s = Array.isArray(t) ? t : [t];
  for (let i = 0; i < s.length; i++) {
    const r = au(e, s[i]);
    if (r) {
      const { transitionEnd: o, transition: a, ...l } = r;
      n(l, o);
    }
  }
}
function DM(e, t, n, s, i) {
  var r;
  const o = {}, a = [], l = s && ((r = e.style) === null || r === void 0 ? void 0 : r.willChange) === void 0, c = i(e, {});
  for (const m in c)
    o[m] = Mo(c[m]);
  let { initial: u, animate: d } = e;
  const h = ka(e), f = mA(e);
  t && f && !h && e.inherit !== !1 && (u === void 0 && (u = t.initial), d === void 0 && (d = t.animate));
  let p = n ? n.initial === !1 : !1;
  p = p || u === !1;
  const g = p ? d : u;
  return g && typeof g != "boolean" && !$i(g) && mf(e, g, (m, A) => {
    for (const w in m) {
      let x = m[w];
      if (Array.isArray(x)) {
        const v = p ? x.length - 1 : 0;
        x = x[v];
      }
      x !== null && (o[w] = x);
    }
    for (const w in A)
      o[w] = A[w];
  }), l && (d && u !== !1 && !$i(d) && mf(e, d, (m) => {
    for (const A in m)
      TM(a, A);
  }), a.length && (o.willChange = a.join(","))), o;
}
const Iu = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), CA = () => ({
  ...Iu(),
  attrs: {}
}), SA = (e, t) => t && typeof e == "number" ? t.transform(e) : e, BM = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, IM = Tr.length;
function PM(e, t, n) {
  let s = "", i = !0;
  for (let r = 0; r < IM; r++) {
    const o = Tr[r], a = e[o];
    if (a === void 0)
      continue;
    let l = !0;
    if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {
      const c = SA(a, Au[o]);
      if (!l) {
        i = !1;
        const u = BM[o] || o;
        s += `${u}(${c}) `;
      }
      n && (t[o] = c);
    }
  }
  return s = s.trim(), n ? s = n(t, i ? "" : s) : i && (s = "none"), s;
}
function Pu(e, t, n) {
  const { style: s, vars: i, transformOrigin: r } = e;
  let o = !1, a = !1;
  for (const l in t) {
    const c = t[l];
    if (Xn.has(l)) {
      o = !0;
      continue;
    } else if (hm(l)) {
      i[l] = c;
      continue;
    } else {
      const u = SA(c, Au[l]);
      l.startsWith("origin") ? (a = !0, r[l] = u) : s[l] = u;
    }
  }
  if (t.transform || (o || n ? s.transform = PM(t, e.transform, n) : s.transform && (s.transform = "none")), a) {
    const { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = r;
    s.transformOrigin = `${l} ${c} ${u}`;
  }
}
function Af(e, t, n) {
  return typeof e == "string" ? e : z.transform(t + n * e);
}
function OM(e, t, n) {
  const s = Af(t, e.x, e.width), i = Af(n, e.y, e.height);
  return `${s} ${i}`;
}
const NM = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, LM = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function FM(e, t, n = 1, s = 0, i = !0) {
  e.pathLength = 1;
  const r = i ? NM : LM;
  e[r.offset] = z.transform(-s);
  const o = z.transform(t), a = z.transform(n);
  e[r.array] = `${o} ${a}`;
}
function Ou(e, {
  attrX: t,
  attrY: n,
  attrScale: s,
  originX: i,
  originY: r,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...c
}, u, d) {
  if (Pu(e, c, d), u) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: h, style: f, dimensions: p } = e;
  h.transform && (p && (f.transform = h.transform), delete h.transform), p && (i !== void 0 || r !== void 0 || f.transform) && (f.transformOrigin = OM(p, i !== void 0 ? i : 0.5, r !== void 0 ? r : 0.5)), t !== void 0 && (h.x = t), n !== void 0 && (h.y = n), s !== void 0 && (h.scale = s), o !== void 0 && FM(h, o, a, l, !1);
}
const Nu = (e) => typeof e == "string" && e.toLowerCase() === "svg", jM = {
  useVisualState: vA({
    scrapeMotionValuesFromProps: xA,
    createRenderState: CA,
    onMount: (e, t, { renderState: n, latestValues: s }) => {
      pt.read(() => {
        try {
          n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
        } catch {
          n.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), pt.render(() => {
        Ou(n, s, Nu(t.tagName), e.transformTemplate), wA(t, n);
      });
    }
  })
}, VM = {
  useVisualState: vA({
    applyWillChange: !0,
    scrapeMotionValuesFromProps: Du,
    createRenderState: Iu
  })
};
function MA(e, t, n) {
  for (const s in t)
    !Zt(t[s]) && !bA(s, n) && (e[s] = t[s]);
}
function UM({ transformTemplate: e }, t) {
  return Ln(() => {
    const n = Iu();
    return Pu(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function YM(e, t) {
  const n = e.style || {}, s = {};
  return MA(s, n, e), Object.assign(s, UM(e, t)), s;
}
function WM(e, t) {
  const n = {}, s = YM(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = s, n;
}
const QM = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Zo(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || QM.has(e);
}
let EA = (e) => !Zo(e);
function GM(e) {
  e && (EA = (t) => t.startsWith("on") ? !Zo(t) : e(t));
}
try {
  GM(require("@emotion/is-prop-valid").default);
} catch {
}
function KM(e, t, n) {
  const s = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (EA(i) || n === !0 && Zo(i) || !t && !Zo(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (s[i] = e[i]);
  return s;
}
function zM(e, t, n, s) {
  const i = Ln(() => {
    const r = CA();
    return Ou(r, t, Nu(s), e.transformTemplate), {
      ...r.attrs,
      style: { ...r.style }
    };
  }, [t]);
  if (e.style) {
    const r = {};
    MA(r, e.style, e), i.style = { ...r, ...i.style };
  }
  return i;
}
function _M(e = !1) {
  return (n, s, i, { latestValues: r }, o) => {
    const l = (Tu(n) ? zM : WM)(s, r, o, n), c = KM(s, typeof n == "string", e), u = n !== _g ? { ...c, ...l, ref: i } : {}, { children: d } = s, h = Ln(() => Zt(d) ? d.get() : d, [d]);
    return Fn(n, {
      ...u,
      children: h
    });
  };
}
function ZM(e, t) {
  return function(s, { forwardMotionProps: i } = { forwardMotionProps: !1 }) {
    const o = {
      ...Tu(s) ? jM : VM,
      preloadedFeatures: e,
      useRender: _M(i),
      createVisualElement: t,
      Component: s
    };
    return SM(o);
  };
}
const hc = { current: null }, qA = { current: !1 };
function HM() {
  if (qA.current = !0, !!ku)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => hc.current = e.matches;
      e.addListener(t), t();
    } else
      hc.current = !1;
}
function JM(e, t, n) {
  for (const s in t) {
    const i = t[s], r = n[s];
    if (Zt(i))
      e.addValue(s, i);
    else if (Zt(r))
      e.addValue(s, sr(i, { owner: e }));
    else if (r !== i)
      if (e.hasValue(s)) {
        const o = e.getValue(s);
        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i);
      } else {
        const o = e.getStaticValue(s);
        e.addValue(s, sr(o !== void 0 ? o : i, { owner: e }));
      }
  }
  for (const s in n)
    t[s] === void 0 && e.removeValue(s);
  return t;
}
const yf = /* @__PURE__ */ new WeakMap(), XM = [...gm, _t, Un], $M = (e) => XM.find(pm(e)), wf = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class tE {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, s) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: s, reducedMotionConfig: i, blockInitialAnimation: r, visualState: o }, a = {}) {
    this.applyWillChange = !1, this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = pu, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const h = Ke.now();
      this.renderScheduledAt < h && (this.renderScheduledAt = h, pt.render(this.render, !1, !0));
    };
    const { latestValues: l, renderState: c } = o;
    this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = s, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!r, this.isControllingVariants = ka(n), this.isVariantNode = mA(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: u, ...d } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const h in d) {
      const f = d[h];
      l[h] !== void 0 && Zt(f) && f.set(l[h], !1);
    }
  }
  mount(t) {
    this.current = t, yf.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, s) => this.bindToMotionValue(s, n)), qA.current || HM(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : hc.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    yf.delete(this.current), this.projection && this.projection.unmount(), jn(this.notifyUpdate), jn(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const s = Xn.has(t), i = n.on("change", (a) => {
      this.latestValues[t] = a, this.props.onUpdate && pt.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0);
    }), r = n.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), r(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in $s) {
      const n = $s[t];
      if (!n)
        continue;
      const { isEnabled: s, Feature: i } = n;
      if (!this.features[t] && i && s(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const r = this.features[t];
        r.isMounted ? r.update() : (r.mount(), r.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Bt();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let s = 0; s < wf.length; s++) {
      const i = wf[s];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const r = "on" + i, o = t[r];
      o && (this.propEventSubscriptions[i] = this.on(i, o));
    }
    this.prevMotionValues = JM(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const s = this.values.get(t);
    n !== s && (s && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let s = this.values.get(t);
    return s === void 0 && n !== void 0 && (s = sr(n === null ? void 0 : n, { owner: this }), this.addValue(t, s)), s;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    var s;
    let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (s = this.getBaseTargetFromProps(this.props, t)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, t, this.options);
    return i != null && (typeof i == "string" && (um(i) || cm(i)) ? i = parseFloat(i) : !$M(i) && Un.test(n) && (i = Cm(t, n)), this.setBaseTarget(t, Zt(i) ? i.get() : i)), Zt(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: s } = this.props;
    let i;
    if (typeof s == "string" || typeof s == "object") {
      const o = au(this.props, s, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
      o && (i = o[t]);
    }
    if (s && i !== void 0)
      return i;
    const r = this.getBaseTargetFromProps(this.props, t);
    return r !== void 0 && !Zt(r) ? r : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new Mu()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
}
class RA extends tE {
  constructor() {
    super(...arguments), this.KeyframeResolver = Sm;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: s }) {
    delete n[t], delete s[t];
  }
}
function eE(e) {
  return window.getComputedStyle(e);
}
class nE extends RA {
  constructor() {
    super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = AA;
  }
  readValueFromInstance(t, n) {
    if (Xn.has(n)) {
      const s = yu(n);
      return s && s.default || 0;
    } else {
      const s = eE(t), i = (hm(n) ? s.getPropertyValue(n) : s[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return tA(t, n);
  }
  build(t, n, s) {
    Pu(t, n, s.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, s) {
    return Du(t, n, s);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Zt(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class sE extends RA {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Bt;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (Xn.has(n)) {
      const s = yu(n);
      return s && s.default || 0;
    }
    return n = yA.has(n) ? n : Ma(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, s) {
    return xA(t, n, s);
  }
  build(t, n, s) {
    Ou(t, n, this.isSVGTag, s.transformTemplate);
  }
  renderInstance(t, n, s, i) {
    wA(t, n, s, i);
  }
  mount(t) {
    this.isSVGTag = Nu(t.tagName), super.mount(t);
  }
}
const iE = (e, t) => Tu(e) ? new sE(t) : new nE(t, {
  allowProjection: e !== _g
}), rE = /* @__PURE__ */ ZM({
  ...KC,
  ...pM,
  ...sM,
  ...gM
}, iE), yl = /* @__PURE__ */ Fx(rE);
class oE extends b.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const s = this.props.sizeRef.current;
      s.height = n.offsetHeight || 0, s.width = n.offsetWidth || 0, s.top = n.offsetTop, s.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function aE({ children: e, isPresent: t }) {
  const n = iu(), s = fe(null), i = fe({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: r } = Wt(Ru);
  return zg(() => {
    const { width: o, height: a, top: l, left: c } = i.current;
    if (t || !s.current || !o || !a)
      return;
    s.current.dataset.motionPopId = n;
    const u = document.createElement("style");
    return r && (u.nonce = r), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => {
      document.head.removeChild(u);
    };
  }, [t]), y.jsx(oE, { isPresent: t, childRef: s, sizeRef: i, children: b.cloneElement(e, { ref: s }) });
}
const lE = ({ children: e, initial: t, isPresent: n, onExitComplete: s, custom: i, presenceAffectsLayout: r, mode: o }) => {
  const a = Bu(cE), l = iu(), c = Ln(
    () => ({
      id: l,
      initial: t,
      isPresent: n,
      custom: i,
      onExitComplete: (u) => {
        a.set(u, !0);
        for (const d of a.values())
          if (!d)
            return;
        s && s();
      },
      register: (u) => (a.set(u, !1), () => a.delete(u))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    r ? [Math.random()] : [n]
  );
  return Ln(() => {
    a.forEach((u, d) => a.set(d, !1));
  }, [n]), b.useEffect(() => {
    !n && !a.size && s && s();
  }, [n]), o === "popLayout" && (e = y.jsx(aE, { isPresent: n, children: e })), y.jsx(qa.Provider, { value: c, children: e });
};
function cE() {
  return /* @__PURE__ */ new Map();
}
const _r = (e) => e.key || "";
function bf(e) {
  const t = [];
  return gx.forEach(e, (n) => {
    mx(n) && t.push(n);
  }), t;
}
const xf = ({ children: e, exitBeforeEnter: t, custom: n, initial: s = !0, onExitComplete: i, presenceAffectsLayout: r = !0, mode: o = "sync" }) => {
  const a = Ln(() => bf(e), [e]), l = a.map(_r), c = fe(!0), u = fe(a), d = Bu(() => /* @__PURE__ */ new Map()), [h, f] = ie(a), [p, g] = ie(a);
  fA(() => {
    c.current = !1, u.current = a;
    for (let w = 0; w < p.length; w++) {
      const x = _r(p[w]);
      l.includes(x) ? d.delete(x) : d.get(x) !== !0 && d.set(x, !1);
    }
  }, [p, l.length, l.join("-")]);
  const m = [];
  if (a !== h) {
    let w = [...a];
    for (let x = 0; x < p.length; x++) {
      const v = p[x], C = _r(v);
      l.includes(C) || (w.splice(x, 0, v), m.push(v));
    }
    o === "wait" && m.length && (w = m), g(bf(w)), f(a);
    return;
  }
  const { forceRender: A } = Wt(Eu);
  return y.jsx(y.Fragment, { children: p.map((w) => {
    const x = _r(w), v = a === p || l.includes(x), C = () => {
      if (d.has(x))
        d.set(x, !0);
      else
        return;
      let E = !0;
      d.forEach((S) => {
        S || (E = !1);
      }), E && (A == null || A(), g(u.current), i && i());
    };
    return y.jsx(lE, { isPresent: v, initial: !c.current || s ? void 0 : !1, custom: v ? void 0 : n, presenceAffectsLayout: r, mode: o, onExitComplete: v ? void 0 : C, children: w }, x);
  }) });
};
function uE(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function kA(...e) {
  return (t) => e.forEach((n) => uE(n, t));
}
function ct(...e) {
  return b.useCallback(kA(...e), e);
}
var ti = b.forwardRef((e, t) => {
  const { children: n, ...s } = e, i = b.Children.toArray(n), r = i.find(dE);
  if (r) {
    const o = r.props.children, a = i.map((l) => l === r ? b.Children.count(o) > 1 ? b.Children.only(null) : b.isValidElement(o) ? o.props.children : null : l);
    return /* @__PURE__ */ y.jsx(fc, { ...s, ref: t, children: b.isValidElement(o) ? b.cloneElement(o, void 0, a) : null });
  }
  return /* @__PURE__ */ y.jsx(fc, { ...s, ref: t, children: n });
});
ti.displayName = "Slot";
var fc = b.forwardRef((e, t) => {
  const { children: n, ...s } = e;
  if (b.isValidElement(n)) {
    const i = fE(n);
    return b.cloneElement(n, {
      ...hE(s, n.props),
      // @ts-ignore
      ref: t ? kA(t, i) : i
    });
  }
  return b.Children.count(n) > 1 ? b.Children.only(null) : null;
});
fc.displayName = "SlotClone";
var TA = ({ children: e }) => /* @__PURE__ */ y.jsx(y.Fragment, { children: e });
function dE(e) {
  return b.isValidElement(e) && e.type === TA;
}
function hE(e, t) {
  const n = { ...t };
  for (const s in t) {
    const i = e[s], r = t[s];
    /^on[A-Z]/.test(s) ? i && r ? n[s] = (...a) => {
      r(...a), i(...a);
    } : i && (n[s] = i) : s === "style" ? n[s] = { ...i, ...r } : s === "className" && (n[s] = [i, r].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function fE(e) {
  var s, i;
  let t = (s = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function DA(e) {
  var t, n, s = "";
  if (typeof e == "string" || typeof e == "number") s += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = DA(e[t])) && (s && (s += " "), s += n);
  else for (t in e) e[t] && (s && (s += " "), s += t);
  return s;
}
function pE() {
  for (var e, t, n = 0, s = ""; n < arguments.length; ) (e = arguments[n++]) && (t = DA(e)) && (s && (s += " "), s += t);
  return s;
}
const vf = (e) => typeof e == "boolean" ? "".concat(e) : e === 0 ? "0" : e, Cf = pE, Lu = (e, t) => (n) => {
  var s;
  if ((t == null ? void 0 : t.variants) == null) return Cf(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: i, defaultVariants: r } = t, o = Object.keys(i).map((c) => {
    const u = n == null ? void 0 : n[c], d = r == null ? void 0 : r[c];
    if (u === null) return null;
    const h = vf(u) || vf(d);
    return i[c][h];
  }), a = n && Object.entries(n).reduce((c, u) => {
    let [d, h] = u;
    return h === void 0 || (c[d] = h), c;
  }, {}), l = t == null || (s = t.compoundVariants) === null || s === void 0 ? void 0 : s.reduce((c, u) => {
    let { class: d, className: h, ...f } = u;
    return Object.entries(f).every((p) => {
      let [g, m] = p;
      return Array.isArray(m) ? m.includes({
        ...r,
        ...a
      }[g]) : {
        ...r,
        ...a
      }[g] === m;
    }) ? [
      ...c,
      d,
      h
    ] : c;
  }, []);
  return Cf(e, o, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
};
function BA(e) {
  var t, n, s = "";
  if (typeof e == "string" || typeof e == "number") s += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = BA(e[t])) && (s && (s += " "), s += n);
  } else for (n in e) e[n] && (s && (s += " "), s += n);
  return s;
}
function gE() {
  for (var e, t, n = 0, s = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = BA(e)) && (s && (s += " "), s += t);
  return s;
}
const Fu = "-", mE = (e) => {
  const t = yE(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: s
  } = e;
  return {
    getClassGroupId: (o) => {
      const a = o.split(Fu);
      return a[0] === "" && a.length !== 1 && a.shift(), IA(a, t) || AE(o);
    },
    getConflictingClassGroupIds: (o, a) => {
      const l = n[o] || [];
      return a && s[o] ? [...l, ...s[o]] : l;
    }
  };
}, IA = (e, t) => {
  var o;
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], s = t.nextPart.get(n), i = s ? IA(e.slice(1), s) : void 0;
  if (i)
    return i;
  if (t.validators.length === 0)
    return;
  const r = e.join(Fu);
  return (o = t.validators.find(({
    validator: a
  }) => a(r))) == null ? void 0 : o.classGroupId;
}, Sf = /^\[(.+)\]$/, AE = (e) => {
  if (Sf.test(e)) {
    const t = Sf.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, yE = (e) => {
  const {
    theme: t,
    prefix: n
  } = e, s = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return bE(Object.entries(e.classGroups), n).forEach(([r, o]) => {
    pc(o, s, r, t);
  }), s;
}, pc = (e, t, n, s) => {
  e.forEach((i) => {
    if (typeof i == "string") {
      const r = i === "" ? t : Mf(t, i);
      r.classGroupId = n;
      return;
    }
    if (typeof i == "function") {
      if (wE(i)) {
        pc(i(s), t, n, s);
        return;
      }
      t.validators.push({
        validator: i,
        classGroupId: n
      });
      return;
    }
    Object.entries(i).forEach(([r, o]) => {
      pc(o, Mf(t, r), n, s);
    });
  });
}, Mf = (e, t) => {
  let n = e;
  return t.split(Fu).forEach((s) => {
    n.nextPart.has(s) || n.nextPart.set(s, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(s);
  }), n;
}, wE = (e) => e.isThemeGetter, bE = (e, t) => t ? e.map(([n, s]) => {
  const i = s.map((r) => typeof r == "string" ? t + r : typeof r == "object" ? Object.fromEntries(Object.entries(r).map(([o, a]) => [t + o, a])) : r);
  return [n, i];
}) : e, xE = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  const i = (r, o) => {
    n.set(r, o), t++, t > e && (t = 0, s = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(r) {
      let o = n.get(r);
      if (o !== void 0)
        return o;
      if ((o = s.get(r)) !== void 0)
        return i(r, o), o;
    },
    set(r, o) {
      n.has(r) ? n.set(r, o) : i(r, o);
    }
  };
}, PA = "!", vE = (e) => {
  const {
    separator: t,
    experimentalParseClassName: n
  } = e, s = t.length === 1, i = t[0], r = t.length, o = (a) => {
    const l = [];
    let c = 0, u = 0, d;
    for (let m = 0; m < a.length; m++) {
      let A = a[m];
      if (c === 0) {
        if (A === i && (s || a.slice(m, m + r) === t)) {
          l.push(a.slice(u, m)), u = m + r;
          continue;
        }
        if (A === "/") {
          d = m;
          continue;
        }
      }
      A === "[" ? c++ : A === "]" && c--;
    }
    const h = l.length === 0 ? a : a.substring(u), f = h.startsWith(PA), p = f ? h.substring(1) : h, g = d && d > u ? d - u : void 0;
    return {
      modifiers: l,
      hasImportantModifier: f,
      baseClassName: p,
      maybePostfixModifierPosition: g
    };
  };
  return n ? (a) => n({
    className: a,
    parseClassName: o
  }) : o;
}, CE = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let n = [];
  return e.forEach((s) => {
    s[0] === "[" ? (t.push(...n.sort(), s), n = []) : n.push(s);
  }), t.push(...n.sort()), t;
}, SE = (e) => ({
  cache: xE(e.cacheSize),
  parseClassName: vE(e),
  ...mE(e)
}), ME = /\s+/, EE = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: s,
    getConflictingClassGroupIds: i
  } = t, r = [], o = e.trim().split(ME);
  let a = "";
  for (let l = o.length - 1; l >= 0; l -= 1) {
    const c = o[l], {
      modifiers: u,
      hasImportantModifier: d,
      baseClassName: h,
      maybePostfixModifierPosition: f
    } = n(c);
    let p = !!f, g = s(p ? h.substring(0, f) : h);
    if (!g) {
      if (!p) {
        a = c + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (g = s(h), !g) {
        a = c + (a.length > 0 ? " " + a : a);
        continue;
      }
      p = !1;
    }
    const m = CE(u).join(":"), A = d ? m + PA : m, w = A + g;
    if (r.includes(w))
      continue;
    r.push(w);
    const x = i(g, p);
    for (let v = 0; v < x.length; ++v) {
      const C = x[v];
      r.push(A + C);
    }
    a = c + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function qE() {
  let e = 0, t, n, s = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = OA(t)) && (s && (s += " "), s += n);
  return s;
}
const OA = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let s = 0; s < e.length; s++)
    e[s] && (t = OA(e[s])) && (n && (n += " "), n += t);
  return n;
};
function RE(e, ...t) {
  let n, s, i, r = o;
  function o(l) {
    const c = t.reduce((u, d) => d(u), e());
    return n = SE(c), s = n.cache.get, i = n.cache.set, r = a, a(l);
  }
  function a(l) {
    const c = s(l);
    if (c)
      return c;
    const u = EE(l, n);
    return i(l, u), u;
  }
  return function() {
    return r(qE.apply(null, arguments));
  };
}
const wt = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, NA = /^\[(?:([a-z-]+):)?(.+)\]$/i, kE = /^\d+\/\d+$/, TE = /* @__PURE__ */ new Set(["px", "full", "screen"]), DE = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, BE = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, IE = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, PE = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, OE = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, nn = (e) => Qs(e) || TE.has(e) || kE.test(e), Mn = (e) => hi(e, "length", WE), Qs = (e) => !!e && !Number.isNaN(Number(e)), wl = (e) => hi(e, "number", Qs), Si = (e) => !!e && Number.isInteger(Number(e)), NE = (e) => e.endsWith("%") && Qs(e.slice(0, -1)), et = (e) => NA.test(e), En = (e) => DE.test(e), LE = /* @__PURE__ */ new Set(["length", "size", "percentage"]), FE = (e) => hi(e, LE, LA), jE = (e) => hi(e, "position", LA), VE = /* @__PURE__ */ new Set(["image", "url"]), UE = (e) => hi(e, VE, GE), YE = (e) => hi(e, "", QE), Mi = () => !0, hi = (e, t, n) => {
  const s = NA.exec(e);
  return s ? s[1] ? typeof t == "string" ? s[1] === t : t.has(s[1]) : n(s[2]) : !1;
}, WE = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  BE.test(e) && !IE.test(e)
), LA = () => !1, QE = (e) => PE.test(e), GE = (e) => OE.test(e), KE = () => {
  const e = wt("colors"), t = wt("spacing"), n = wt("blur"), s = wt("brightness"), i = wt("borderColor"), r = wt("borderRadius"), o = wt("borderSpacing"), a = wt("borderWidth"), l = wt("contrast"), c = wt("grayscale"), u = wt("hueRotate"), d = wt("invert"), h = wt("gap"), f = wt("gradientColorStops"), p = wt("gradientColorStopPositions"), g = wt("inset"), m = wt("margin"), A = wt("opacity"), w = wt("padding"), x = wt("saturate"), v = wt("scale"), C = wt("sepia"), E = wt("skew"), S = wt("space"), M = wt("translate"), q = () => ["auto", "contain", "none"], k = () => ["auto", "hidden", "clip", "visible", "scroll"], R = () => ["auto", et, t], D = () => [et, t], j = () => ["", nn, Mn], W = () => ["auto", Qs, et], O = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], U = () => ["solid", "dashed", "dotted", "double", "none"], I = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], F = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Q = () => ["", "0", et], J = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], lt = () => [Qs, et];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Mi],
      spacing: [nn, Mn],
      blur: ["none", "", En, et],
      brightness: lt(),
      borderColor: [e],
      borderRadius: ["none", "", "full", En, et],
      borderSpacing: D(),
      borderWidth: j(),
      contrast: lt(),
      grayscale: Q(),
      hueRotate: lt(),
      invert: Q(),
      gap: D(),
      gradientColorStops: [e],
      gradientColorStopPositions: [NE, Mn],
      inset: R(),
      margin: R(),
      opacity: lt(),
      padding: D(),
      saturate: lt(),
      scale: lt(),
      sepia: Q(),
      skew: lt(),
      space: D(),
      translate: D()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", et]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [En]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": J()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": J()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...O(), et]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: k()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": k()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": k()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: q()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": q()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": q()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Si, et]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: R()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", et]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: Q()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: Q()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Si, et]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Mi]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Si, et]
        }, et]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": W()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": W()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Mi]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Si, et]
        }, et]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": W()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": W()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", et]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", et]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [h]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [h]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [h]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...F()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...F(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...F(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [w]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [w]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [w]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [w]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [w]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [w]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [w]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [w]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [w]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [m]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [m]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [m]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [m]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [m]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [m]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [m]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [m]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [m]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [S]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [S]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", et, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [et, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [et, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [En]
        }, En]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [et, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [et, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [et, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [et, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", En, Mn]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", wl]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Mi]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", et]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Qs, wl]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", nn, et]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", et]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", et]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [A]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [A]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...U(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", nn, Mn]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", nn, et]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: D()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", et]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", et]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [A]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...O(), jE]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", FE]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, UE]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [f]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [f]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [f]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [r]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [r]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [r]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [r]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [r]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [r]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [r]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [r]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [r]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [r]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [r]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [r]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [r]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [r]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [r]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [A]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...U(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [A]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: U()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...U()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [nn, et]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [nn, Mn]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: j()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [A]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [nn, Mn]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", En, YE]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Mi]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [A]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...I(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": I()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [s]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", En, et]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [x]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [C]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [s]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [A]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [x]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [C]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", et]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: lt()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", et]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: lt()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", et]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [v]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [v]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [v]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Si, et]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [M]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [M]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [E]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [E]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", et]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", et]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": D()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": D()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": D()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": D()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": D()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": D()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": D()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": D()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": D()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": D()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": D()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": D()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": D()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": D()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": D()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": D()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": D()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": D()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", et]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [nn, Mn, wl]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, zE = /* @__PURE__ */ RE(KE);
function At(...e) {
  return zE(gE(e));
}
const _E = Lu(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), se = b.forwardRef(
  ({ className: e, variant: t, size: n, asChild: s = !1, ...i }, r) => {
    const o = s ? ti : "button";
    return /* @__PURE__ */ y.jsx(
      o,
      {
        className: At(_E({ variant: t, size: n, className: e })),
        ref: r,
        ...i
      }
    );
  }
);
se.displayName = "Button";
const Ef = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), s = (c, u) => {
    const d = typeof c == "function" ? c(t) : c;
    if (!Object.is(d, t)) {
      const h = t;
      t = u ?? (typeof d != "object" || d === null) ? d : Object.assign({}, t, d), n.forEach((f) => f(t, h));
    }
  }, i = () => t, a = { setState: s, getState: i, getInitialState: () => l, subscribe: (c) => (n.add(c), () => n.delete(c)) }, l = t = e(s, i, a);
  return a;
}, ZE = (e) => e ? Ef(e) : Ef, HE = (e) => e;
function JE(e, t = HE) {
  const n = P.useSyncExternalStore(
    e.subscribe,
    () => t(e.getState()),
    () => t(e.getInitialState())
  );
  return P.useDebugValue(n), n;
}
const qf = (e) => {
  const t = ZE(e), n = (s) => JE(t, s);
  return Object.assign(n, t), n;
}, Ta = (e) => e ? qf(e) : qf, XE = {
  prefixSymbol: "",
  name: "",
  currencyCode: "",
  value: "",
  fractionalDigits: 0,
  crypto: !1,
  enabled: !0
}, $E = {
  minBet: 0,
  maxBet: 0
}, ze = Ta((e) => ({
  // Initial state
  balance: 0,
  isGameActive: !1,
  selectedCurrency: XE,
  betRanges: $E,
  initializing: !0,
  theme: "default",
  isAutoPlaying: !1,
  currentAutoBet: 0,
  isSoundMuted: !1,
  isHelpDialogOpen: !1,
  currentServerSeed: "",
  currentClientSeed: "",
  currentNonce: "0",
  newServerSeed: "",
  newClientSeed: "",
  newNonce: "0",
  isProvablyFairDialogOpen: !1,
  // Actions
  setBalance: (t) => e({ balance: t }),
  setIsGameActive: (t) => e({ isGameActive: t }),
  setCurrency: (t) => e({ selectedCurrency: t }),
  setBetRanges: (t) => e({ betRanges: t }),
  setInitializing: (t) => e({ initializing: t }),
  setTheme: (t) => e({ theme: t }),
  setIsAutoPlaying: (t) => e({ isAutoPlaying: t }),
  setCurrentAutoBet: (t) => e((n) => ({
    currentAutoBet: typeof t == "function" ? t(n.currentAutoBet) : t
  })),
  setIsSoundMuted: (t) => e({ isSoundMuted: t }),
  setIsHelpDialogOpen: (t) => e({ isHelpDialogOpen: t }),
  setCurrentServerSeed: (t) => e({ currentServerSeed: t }),
  setCurrentClientSeed: (t) => e({ currentClientSeed: t }),
  setCurrentNonce: (t) => e({ currentNonce: t }),
  setNewServerSeed: (t) => e({ newServerSeed: t }),
  setNewClientSeed: (t) => e({ newClientSeed: t }),
  setNewNonce: (t) => e({ newNonce: t }),
  setIsProvablyFairDialogOpen: (t) => e({ isProvablyFairDialogOpen: t }),
  useNewSeeds: () => e((t) => ({
    currentServerSeed: t.newServerSeed,
    currentClientSeed: t.newClientSeed,
    currentNonce: t.newNonce,
    newServerSeed: "",
    newClientSeed: "",
    newNonce: "0"
  }))
}));
function t1({ multiplier: e, amount: t }) {
  const {
    selectedCurrency: n
  } = ze();
  return /* @__PURE__ */ y.jsx("div", { className: "absolute inset-0 flex items-center justify-center z-20", children: /* @__PURE__ */ y.jsx("div", { className: "bg-primary rounded-md border-2 border-green-500 text-center animate-pop-in inline-flex flex-col justify-center", children: /* @__PURE__ */ y.jsxs("div", { className: "px-4 py-3 select-none", children: [
    /* @__PURE__ */ y.jsxs("div", { className: "text-4xl font-extrabold text-green-500 leading-none mb-2", children: [
      e.toFixed(2),
      "x"
    ] }),
    /* @__PURE__ */ y.jsx("div", { className: "w-full h-px bg-green-500/30 mb-2" }),
    /* @__PURE__ */ y.jsxs("div", { className: "text-sm text-green-500 flex items-center justify-center font-extrabold", children: [
      "+",
      n.prefixSymbol,
      t.toFixed(2)
    ] })
  ] }) }) });
}
const e1 = Lu(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function n1({ className: e, variant: t, ...n }) {
  return /* @__PURE__ */ y.jsx("div", { className: At(e1({ variant: t }), e), ...n });
}
const s1 = ({
  className: e,
  size: t = 200,
  duration: n = 15,
  anchor: s = 90,
  borderWidth: i = 1.5,
  colorFrom: r = "#ffaa40",
  colorTo: o = "#9c40ff",
  delay: a = 0
}) => /* @__PURE__ */ y.jsx(
  "div",
  {
    style: {
      "--size": t,
      "--duration": n,
      "--anchor": s,
      "--border-width": i,
      "--color-from": r,
      "--color-to": o,
      "--delay": `-${a}s`
    },
    className: At(
      "pointer-events-none absolute inset-0 rounded-[inherit] [border:calc(var(--border-width)*1px)_solid_transparent]",
      // mask styles
      "![mask-clip:padding-box,border-box] ![mask-composite:intersect] [mask:linear-gradient(transparent,transparent),linear-gradient(white,white)]",
      // pseudo styles
      "after:absolute after:aspect-square after:w-[calc(var(--size)*1px)] after:animate-border-beam after:[animation-delay:var(--delay)] after:[background:linear-gradient(to_left,var(--color-from),var(--color-to),transparent)] after:[offset-anchor:calc(var(--anchor)*1%)_50%] after:[offset-path:rect(0_auto_auto_0_round_calc(var(--size)*1px))]",
      e
    )
  }
);
function Da() {
  const [e, t] = ie(!1);
  return Lt(() => {
    function n() {
      t(window.innerWidth < 1024);
    }
    return window.addEventListener("resize", n), n(), () => window.removeEventListener("resize", n);
  }, []), e;
}
const Zr = {
  board: Array(25).fill("hidden"),
  gameRoundId: null,
  isEnded: !1,
  multiplier: 0,
  revealedCells: [],
  selectedCells: [],
  totalProfit: 0
}, ju = Ta((e) => ({
  ...Zr,
  selectedCells: [],
  initializeGame: (t) => e((n) => ({
    ...Zr,
    gameRoundId: t,
    selectedCells: n.selectedCells
    // Preserve selectedCells
  })),
  revealCell: (t, n) => e((s) => ({
    board: s.board.map((i, r) => r === t ? n : i)
  })),
  setMultiplier: (t) => e({ multiplier: t }),
  updateBoard: (t) => e({ board: t }),
  resetBoard: () => e({ board: Zr.board }),
  setRevealedCells: (t) => e({ revealedCells: t }),
  toggleSelectedCell: (t) => e((n) => ({
    selectedCells: n.selectedCells.includes(t) ? n.selectedCells.filter((s) => s !== t) : [...n.selectedCells, t]
  })),
  clearSelectedCells: () => e({ selectedCells: [] }),
  endGame: (t) => e(() => ({
    isEnded: !0,
    totalProfit: t
  })),
  resetGame: () => e((t) => ({
    ...Zr,
    selectedCells: t.selectedCells
    // Preserve selectedCells
  }))
})), Rf = {
  mode: "manual",
  betAmount: 0,
  minesCount: 5,
  stopOnWin: 0,
  stopOnLoss: 0,
  numberOfBets: "∞",
  onWinMode: "reset",
  onLossMode: "reset",
  onWinValue: 0,
  onLossValue: 0
}, Vu = Ta((e) => ({
  ...Rf,
  updateSettings: (t) => e((n) => ({ ...n, ...t })),
  resetSettings: () => e(Rf)
})), i1 = "data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//PkAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAANAAAaQAAkJCQkJCQkNjY2NjY2NjZJSUlJSUlJSVtbW1tbW1ttbW1tbW1tbYCAgICAgICAkpKSkpKSkqSkpKSkpKSktra2tra2trbJycnJycnJ29vb29vb29vt7e3t7e3t7f////////8AAAAATGF2ZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGkC8X/5HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//PkZAAf2b0AAqw8AJqYpdn3RzAAWB/H8hyq4agaK6Ram6xGcO5ZlcP25Q/jD0E4BGZ0mtJnKWvb9wAM4C2AtgEYB2BDCRi5lzOiKf5bzrfF8C8BUACsAjAOwVYh5L1HH34CsQxkqxoeo1YrE4oFYyTKcnYagTAyGR4wHIQQTQDODnEzLmh6vZ52A01HOwIYhiGODeaCggp850PUavQ8uB0OEN+/3il73veG/fv3jx48ePHjyI/fv379+/fv3jx48ePHkSke973fv38d48ePHjx48iP379+/fv37948ePHjx48iP379+/fv396UpSlKU1u973ve8d48ePHjwAAw8PDw8AAAAAAw8PDw8AAAAAAw8PDw/UBgG5LdMMmf5588bg8EggVBeAGAGAWL3toIEIcmAAAEEEAQBAHwfB8HwcBAEPygIO/KAgchh/9APg+D4PgQEAQDEDg++j/ygIBgHwfB8HygIAgGI8Hw/QoMf/5dAIAgCEeD4PvlAQOYnD6rDCAwKAyqBDVRbNfoL/MPAoIMppY3m0of/mCw8ZaGRluvGW83/mEsAWYIoNhh0BJGEEROYpRihmepS/5YhIMNIFpWowMgHjALALPHBKQy2RmzImFyMUoDMrhG//KgDhgQA//PkZGEsydkgAs54ACJ5rdQBlbAAEFACoXAIMB4AgxcwCjE2BGMPoJcw5wgjCqAz///wgDxFYwHgCggDxcQOAQML4KswbwljBGBvMG4JcwHwlgqDf///+EAeLjSICAFGLooBAChgZBBmAUDcYGYN4UBbMDIEYwRwWzALAz////9FfJTj/XB3/MEYDIwRwRzAfALMEYAowRwMwgD8wMgCjAzAfCAP///////////1//4QB4YD4BaK4QAoiuo2ioo2o2o0o2ir////////+v///X/v/1/qNKNoqqNKNqNqNIrqNoqIrqcqcIrorBACv//////////7/WX///r///////0VgFmA+A8YNwIxgZgjmBkA+FQClG0VVGlG/8GF4DLxf7gYtXwGLV/giFwOIDDAFgDBYQcDF8ZoDM2nfCPlAMOgLBlgGAmIgedk7AZURfgZBhfAwXwMd51PwYL8DDoCwDDoC0DDqCwGAs/SfgYdAWgYLQWAYLAWgYLAWhEFgRBb//AwWAtCILAiC0IgtAwWAsAwWgtCILf//BgLAMFoLYMBYDAW1f////////90VcvggsCQA5OIwDgCvMDgAlxYBxMEHCuDD2w7ww7EXqMo/5fgMWTJbQMY0DeQMFEAigME//PkZDsUUbsMAO/cABz7VaAD17AAHBGAMEHAyAGALMDAMgD8DAOACEMCCNAbiEbf//npd//oNUyQ+j3///8/8/1f/8slv////////y1//+RUio3Q9UAkAOAwCEA4AwHcCoAwFkREAwA8AIAqAHAYBCAQAYAcAEiaFgtkWrD///hEBvAwG4BvgYH2EKAYZaFQAYVCJoAZA3ZoAcRfHgc0FQgY/A3AYbx9AY+w3IgYbg3gYbg3mL///wiG7//X//9+zf/wiG/t1frvhENyP1b6/stFf3/2b/+EQ3fX8GBv//qwYG+BhvDcBhvZYuv/9+79akxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv////kkb/3+ksk+TP/JGnIWjwAcAgBkwCMAwMBEAkzAvQZAwmwcxNor7FzMBjKM8wl8xdRIDDKCbMIUFIwUgKTAxAUAQFJfqTv9JpPRQfRUEbofoyyWOWv/+e/z//PkZFwTdeEIAH/WdCMDXZAAvS00xeIT//8+f+XPnuv//kr////////8l///yUJUlhzxBQG0wMCgMAMbb4gNIQfgMGIFQAgGBZAFkYBgDBzvV//kt//+pazADAzwM4IgZ4GBng3QGFTDoYG1O95IGFTkjQGHJBU4GDdgZwUBnTE1BwM+XTFJ7er/9aPdVSulWrX4M3BHcEd2Ed8I7qgZu18GbupYR3LA9+4I74M3gzcEd6wjuo2rrUv1/3v66u39fCIzvq9Jfv/XS9bfvup2UrAxnuSA1TDOr6qdPTVTdYpNTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUP/////////6jajSjZWAFGAPgBZgGQA8YC2AjmBBANxgc4FWYOEB9GJcgcx95ExcZ9IbimIChbBgzQLmYGmBpGBBAQZgI4CMZ5mYsUiqo0iqiso2o0pwpypwpyiuioWBZYFBQ+Ys8bI+cUYdoUD2gSPNkKM+LCChWLCCpWfCMgRkCM5nhQQXRUZ0kiLJhZILPAUnBQxJNnDOkkRYeLJCsUEF0VEV/9ThTlThThTlFRFf/8MqGUDKBlRQAo//PkZLseIbsCBH9WiiVj7ZQMB+yoPG8N8bw3hvjeG/7P//iK///7f//f/////2iLiLAwBYCgZQMuYggZHwGBbAUAoFwgioRBkIppIGH6KwJjzAmAJgwJkCZMFOAmCgV3OQeWnjJHiGswrsFOMCYAmTAmQJjeLIrv/v6kAYJgKEwQChMODBMf2uuyvbBgmf8IiZ+DBMfdvVCImQYJjt/wYJj9UIiYVgwTAGJgTP/q1f/u6k0rLfZSBk1R1JFJJSC1OtD/+DBMQYJkDV0JnCImAYJn/Bgmf/4REx+DBMQiJn6VK+AAkttoAH/6janKnCK6jSjaKpWAFhAAoCQAcUABgQADqSSsQD////+YAIACGCqgZxgNIBN///lgAE/ysAFLAAIWAAUsAAhgXABWYG6A4mBiAdBgG4IuYEqBiGCjgIBguwG4YJ2DemAbBGhgxwPaYZGAPGJJB8Bi9ZxWaJ2Z7mNOCQ5iJYG4YboD2GGeiIJgGYdAYU4EJmGogS5hbASYYMOFYmCRBMJhCYJEYToBpGD/g9ZgXwRwZ9Neb1jccJJEa5uuYjPWalpEbrBkbXq+ZzOEZBLma5kEbXGkabrmYFMOZ9nMa5A8aloeZLKUY3IeaHi0aREEZpn2FD7MlyWC//PkZP8y0a0633+0xSUZoeQAt3UkHMM0yXMbjSMHirMlxGMqgyMgyDMCyXMMxuMggfMgwzMWhuMCxvMMxGCC1MWwzMMxbLAjGGQPhBHmIwZGD4jhUMjB4CwNmLA2Z8DFMgEHwM+KAUeAZ8+Ag8Ag+AoWAUfgYoUAk+AkUAoVAULgYoUERYXDAwWAoUASLCIpF0E1JMmgtJk0FIugmpnQUtwYE///////8IhQYE////wYtsGLb//KwmMJwFMBAEMBQnMBQEMJwEMRgmMJxHLAtGIwjlZLmaRfGkd2nxtOmpRpmaYPGSwjHb3hS0bJmEtzjRjFxzPMzZijZCjPnzFMiwzM+KCMhnz4VZmfFBGQz58KHgofCCwQ8M+LCp8Kiis8YsWFDwUFlYsIKBUWWBaKxWKCC6KiKqnJWEKwpYC//lgILAAsWnTYTZQLLTFpy0paYsACwEAF0CggA+MAeACysALRVLAA8YAWAZpsFpDAFgDAsAMoEAZDAfwJkwDABkMIdE8TO9HZ8xSQGBMFMAFjAfwBYwH4AxMBkAzDAFgDErAFjAMQBYwDABLAgDKYBgAYAYCXMAwAMTAKwGQEAOJgMgBUYFaAmGAgAaJgGwGKYCYBiGBKgSpgkQCUYKiCEGC0//PkZJ8uua8OAH+WuByBujigbth9BMJgjIqMYRe2fmU4r0BhEQToYu0FxmBLAqhXgTmTLNZxgCs00wSgNMjP4wMLH8sJgzKZQNZTTJkMlJkCGQxiSwMlzMhLMYn4xiZSs/GfyUZKMpYJRjElgYxmShiYXMhjEllZkMyjAxgSywMDC4XKwuYwC5hcYGFwuBjAYxCxhYLlgLAULlpwMLTC4WLAXAwsKwuWlAoWLAXLTlYWLTIFoFJslpS0xaVAtNgtMWlQK9NgtMWlQLTYTZTYQK//QLQL/////////////+GGCIFwBE1gYSgYhhhP+KoARwThAIlWoepJKwAg6nHoqorFgb8xoaNTxSxiHiqflgaKxosDRWNf5WN///F/+64cmvX4pHoq8RUCxkOeeI2BMCgDBb8C4YjQRLFcJCvKwviEFGiBCQB8Hh6wkUgc75pMyx1JlhYJFYK3j71k7HYwAQCKMAnABCwACFgAFMAEABPKwAUwAQAFMAmABDABQAQwAQAEMAEABDABQGgwGgAELADQYEWBFGBWARZgRQDQYBOAjmATgVpgE4BOYCMBWGC6ANBgEwCMYHeCqmBnikRj4GrMYfmFzmFSgIxgVgNyYDQBWGCIgZ5gdwEUYAKBnmA0//PkZIIwFbcGAH92th2x/iAAzajEgIxgNIBOVgExWAjmATAAhgIwBMVgAhgAoAKYAKATGACgI5gEwDSYFaA0GA0AApgI4AIYCMATGBFgI5gmQBOYUGCZGQ0Lrp/fBUGY3yEwGMGBx5guoMsedWnFxRgsWYKjGCE5k4KYITFgELAIYICGCApk5OZOTlgF4YKCGTApggIWAUycFLAIWAUwUmMFBSsw9AotKWmQKQLAoumyBi5AsCCwFFgIYpspsNUat5YAVSGAADVWqtWauqYQiBYAQ4Aas1ZU7VPHoGxAmogGH7Rcg/kIH6eP5Ci5iE8hP/////////f/8DAIAQDAKCcDGcucDNyEcDBMAQDAKAXCIBdf/6jPqJBwiGAcIX3XcX0bIAsCyRWQdxBkEFZBk3mSQd1+BkUIqESKgaRyKQiRTwNEiBiIGIwYjBmIIov////hFEDEf8GI+Hnh5Q8weQLIA834ecPIHnJUl4auDYBzRNw5o5wrETaGwkqS45/HMJUc6ShLY5hLEpUtOgWWnLAArIGAAhBcsCywLQKMsWAywtOWMhy2BsZZ5CwGwlbEDLwIWMuwMD/AMSwBMmCMgmRgJQVuZ1On0mI4ihRhDgHKYH+A/GCMgJZgZgCUYDKA//PkZFUlQbcOAGv1biKyGhgA3aTMygYDIMBkAMDAMADAwEoAXAwBaBgGItIWABcwBcAXAwBaBQDHwKAYAUAwAgAuBQEowEsBlMBkAzDA5QbUwrYj8M6MKtTB6QP4wlEBlMCyAFjAMQBcDAMIGAYwMAwlp0Cy05aVNgDAFqBaBXlpCwALpsoFlpfLSoFlgAWAgAuWmUaLAAWpz6nKnKjSKinKKiKqjRYACkVVOVOAwUN6GUFBBggUDDAkMFjeG8KAxvZDxcIzhDsZwuF4c4vEtOlw6cOy/nv///////////wuuDDIDKaF1uGH//8wUFMFBDEysELAqV+WBoxtTMaG/MbGjGlIsRhWN+aAgGgIBYQcImnBhpgOlxpsImmgw00GCCBgg4REGDBBQiIMGBBBgQIRCDwiEH/////wYoRQGKEUCKAxQikGLwNVCKwEUIsIoFw0RURULhQuEC4URURSIvEUC4TG4N4bg3xuig4oCN7jfjdjdQCKL7LuL8F+0CK7wFMXYX7ARdAgYoy2URijTtRIuIxYkxL9mKTANyYJ4GhgggTGKgBOYLgrp2zD/mYANCYcYGhggggGAWBOAQXDA1AmMAoBkwXQJisBgsgAACgEEGJAZGAWBOX0AABZYAZA//PkZGshTbcUAGvVbiCZ3kQAx2DEABQkAuYBQIDZzALALAABZgFgaGCcDWYjKnBzNhdmHEBqYqIOxgnATmAyBMAAGRGAUAACxIBf0Ki/BflspfdspfpAkgS/y+jZ0CRfYvsu9dpfVsq713NlXY2Rs67GytnQJtn9s/kJIQhBc8hB+IQXLH8XKLnIQhB+IWWywWiLkUIsWi2RUsFqWJb/////////////wbpAYYcQGoQUIK8Xf/8Gweo1B6jSnNBGXT/zAGD0VFOTAAwdLATCAsAqVgoYjAqYKm0ZtQKYdACYOg4VgB5gAAJgCAAGAGMGARYMQYhEBhBj//gw4MPLIx5bLIoAY0sigyKlkb5FSLFiWSLxulgY0sFrLYx5ZLB4liHEpIkXj5KHyWL5ePnTmX7GA82XTlVMQU1FU8mKp5VdWJyi+i7S/HlYDKfTEU+WAHU6DAtCwUFgBgsAxhQA5hSCyYhh2Jhh2FJmMbB//7RtWSRiaJhi6AxgsHYXAYwoCkLBSYLAsFgHDBTCwLlYDGAwDGC4DJiFYDqdBg6pimC4LmA4UGHQUJilYLmHQUBhNn7cSGJg3mHQmFgFiugx1gsumMFhgww1xzHHDD0xFOiwN6YnqeDDiwOmKmMGGKeD//PkZKUdga0aAHc1tiE58jwA5ScID1O12LvXY2RsxfZdq7GzLs8vou5snrsjMao6J1o2+FG6tF/0dHQfROt5cImLgPlw6eOHpw7nZ/////////////8SoBdRBir//0Ck2FTKlVO1dUypvTYQLKwcWAeVg8tKWkLT//lgvFgvFjnAVMmMSUYWGCBRhYloFgY8eBjhwGOHYRHhEf/+Eb4Mvgd+/hF8De/CLwY6DHYGGIDQ4rADwgNDisgPCGrgHAFYDVgDQg1eGr8NXisiq/xckfiEFz8fyFFykKP+Lm8sS1y2TEFNRTMuMTAwqqqqqqqqqqqqqqpTr/9RpVZWFRsIAEU5clylVXLVU8rAAMAAAEsAAmACAB5WACVgbFYG5gbgbmBsBuYbiD51NQYqKFgUMURzFUYrRisAKwErATABwrADAQEwEB/ysV8xUUMUFTFRXzNzYsG5YNzNzY4jdM2NjiTbys3K0cxQVNGRisU/ywKFYqYqKmKivmAABgAAVgBWAGAgBWAGAgHmAABWAFYCWAAwEBGhiDkV1VlOINctWNy3LcgrA1VUVnIg6N0FBRusvt0vdWjdaNOrRuhG6Cg84RAul07zhz//////////////Aw8wBihwMAGAGAMUAM0T//PkZOscJa0eAHt0fjVaGiwAj2i4UMUCaiVAZAGSBgAYIGAEQYKgqVgoYKAqWBGMNyIMiQ3KyIMNzdOKvLNhSIM3Q2KzcLAbGG5EGG4blgFSwCpYBUxGBTzBQFSwCnlgN////ywHRjuDpYBww6LA0mUUzPmox2QgxYFksB0YbBuYbESVhv5huG5WGxWG5huG5YDcrDcsBsEY4GVKAZQoBlCgGUKAwoDCgRKAwqDCgRKYMKwMoUwYVBhX/hikTUMUCViaQxQJqJoJVErE04muWRkSLFotlssFoixFCKSxy0WKU4U4U4RU8xQsrCeVhDChPLCYVDpIptmFCmECGFCFg0Zo0Zo0Zulgwd4RP4BwUxcBiMH6BjFH4BgbA0EQNAYGwpgYGgpQMDYGgMDYGwYFKDANgYUwNfwiIPCI7giO8DHef0IsJAx3DuBg7oGKAIAGEEIAGKAIAMCDhEIIGEAIIRCCEQgQM0bCJsGGgjTBhsImwM0aBhoGGwYbCJsDNmwM2agwIDAoMCAwIBhAkGBIRCAYQIEQoRTgwKDAkUEN4bo3AwKKDG+N4UAKBG+KBjfG7FBjdG+OeSpLjnSWJUc8lCUJT/////////////+DBYM3CL/5YP8zjys5AotIgUWn//PkZP8eNa8WAGrUajayRigAzbLULSFpE2U2QNcVnGceffXliwsWlduEQvgYXxsAaxXeAYdQ6AwOoGC0OoRBaDA6gwFoGA4HQRAcEQyBEBwGDsBwMAcBgPB2DAv/wYF4DC+F8DGwF8DGyF4DOesQDOdLMDWOVUGBfBg2AYF4IhegYXwvwiF7gwL8sWFdhXYWLSxaWLSu3yxadlvldhYsLTFpyvEDWlp0CjXWAq3lp/9AsCLIFFpQIsmwgUgWmx5aZNn0C0C/////+gjMY+gfiMUMao/oKCgoaCijX////0H0FDVMQU1FMy4xMDBVVVVdzZPbKu5diBFAg2Zd6BFsyAYGgIIBysAn/MAkAksAEmAQASYBIBHlYJ5YC6KwTjSJEmMIJgGBAwiVDCARMIBEHCMwQCDBIJLAILAI8rBHmIxH5WIvMRiMxEIiwIysRlZPLBPLBOMnE45N/zk3+NdrsycTysnBFeBiKgGIEga8SDBAGIEAYkQDBAMXQMQIgYgQDBIMEQYIAxIkIiQYJBgiBiRIMEAHIQ8gWRB5YeULIgsiCyAPMHkDzB5gsjDzSWjmksJwicxzBzo5o5pLDmkvHNz5wdp06XThw6cPc7/Pf///////////wDXoB03/KwBK", r1 = "data:audio/mpeg;base64,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", o1 = "data:audio/mpeg;base64,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x5riuJYyxljyUECT8ggOWsLQCvtVgWbeGHHhTFlM+/k3nIKCS3qanmfllSGHYkMgm4P1K37ZJGXCVRL4sRiTPUwX9pZX9LhH4zyTWOXavL8np8qGzj3sMOxLOxOH71SzYpL3/////////6wucQhqGY0/0zDUBw8f/lAkkPBMCk1VKzbu8nbeKlvdHYaAgCAQ6oo+D1hQCH2ClwlpHixmAgAtGxLCBobAMWuIjBINKwY8IDDQUATElQUpTNqE35VrBhhdNerLUtVVktHlMVZmlxcqRRmCqnibIWuvc5LLx4ZaNE+zGFtImshgaGotACQbzK4U0byIOVKHbTBZ1D8Zik/g8jM4DehHtZ9qVblcZjNmWODJo08aJSYqvYDazalkopJU4DiPfGHElNLW5KmRXqCN8n6eQ41M4ai7O3nllDSYWHjf9la74mymQqypIwRyRKZJGtAjFFD/bkptXqkdvxehf+fxhu52tep3bb+J5rmjMed7kWYFSyaD7sMswe2L4T+diluQRP2aSxZxqWpZylf9gkU5FJZZvbq//////////ulx9n6pp6O5XaXmWX/////////9ntX99/eGVhY3mTfdTN5mEAAFCpIh4DWYxgCFICSzqPKYxjEn0o6XFaYzaGX8FegEgbB80oHIqKrQcjhZimZyQ5NhiUsVFTYOloaaX1hnWA6Bs6sLHCCIvtLEmlCxzSrT/K7bcrqqszTUrRQqkiqjAbB8cUHQjKUDYRiRUbRQs5qkiodB9arTM1MzNJKwSKisEiqyvHs1rRRyrRRQsLDAqEgaDgNPWEg0mHfyKPuXubETbooCEIBgZIKrApiOlio+GBUOQCrELNMzQA2JNA0CklAEICYfkViUmuSTUm7WtptORNadO1rW7paxsO5qHXomtcOlukeRpzvRJtS1rdzade2kr/////lrZadqW1Lfcida33Xba/na1sftc6+t1t///mnW7h3LalFvKNondGpNTUqNEQlAIwO9n8qqDmAAAFIlVXyAAAAH0d4MC6KP/////////q1sd//29SZMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uQZDAP8DoASqAAAAoYgFioPSEAAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq", a1 = "data:audio/mpeg;base64,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";
let Gs = null;
const Ho = {}, l1 = {
  diamond: i1,
  bomb: r1,
  tick: o1,
  win: a1
};
async function c1(e, t) {
  if (!Gs) {
    const n = window.AudioContext || window.webkitAudioContext;
    if (!n) {
      console.error("AudioContext is not supported in this browser");
      return;
    }
    Gs = new n();
  }
  if (!Ho[e])
    try {
      const s = await (await fetch(t)).arrayBuffer(), i = await Gs.decodeAudioData(s);
      Ho[e] = i;
    } catch (n) {
      console.error(`Failed to load sound ${e}:`, n);
    }
}
async function u1() {
  await Promise.all(Object.entries(l1).map(([e, t]) => c1(e, t)));
}
function Tn(e) {
  if (!Gs || !Ho[e]) return;
  const t = Gs.createBufferSource();
  t.buffer = Ho[e], t.connect(Gs.destination), t.start();
}
const d1 = "data:image/jpeg;base64,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", h1 = "data:image/png;base64,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", FA = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2076.61%2070'%3e%3cdefs%3e%3cstyle%3e.cls-1{fill:%23051d27;}.cls-2{fill:%2306e403;}.cls-3{fill:%2305a902;}.cls-4{fill:%2301e501;}.cls-5{fill:%2300d503;}.cls-6{fill:%2309fd02;}.cls-7{fill:%23019902;}.cls-8{fill:%2301e300;}.cls-9{fill:%2357fd7f;}.cls-10{fill:%2303be02;}%3c/style%3e%3c/defs%3e%3ctitle%3e3Artboard%20710%3c/title%3e%3cg%20id='Layer_1'%20data-name='Layer%201'%3e%3cpath%20class='cls-1'%20d='M38,70h0a2.75,2.75,0,0,1-2-.92L.7,29.62a2.76,2.76,0,0,1-.31-3.25L11,8.55a2.76,2.76,0,0,1,1.27-1.12L23.12,2.71a2.77,2.77,0,0,1,.62-.19L37.74,0a3.09,3.09,0,0,1,1,0L52.62,2.52a3.38,3.38,0,0,1,.62.18L64.42,7.58l.13,0h0a2.69,2.69,0,0,1,.65.45h0a3,3,0,0,1,.4.47h0l.09.14L76.23,26.6a2.73,2.73,0,0,1-.34,3.25L40.06,69.1A2.76,2.76,0,0,1,38,70Z'/%3e%3cpath%20class='cls-2'%20d='M22.13,18.75c-2.64,7-1.74,13.65,2.09,20,6.74-3.1,11.83-8.4,14.44-17C33,18.93,27.49,17.74,22.13,18.75Z'/%3e%3cpath%20class='cls-3'%20d='M73.86,28,63.33,10.1c-6.26,1.19-8.79,4.41-9,8.91C58.67,25.3,65.39,28,73.86,28Z'/%3e%3cpath%20class='cls-4'%20d='M38.49,21.94c.15,7.77,4.2,13.31,12.19,16.57l.07,0c4.5-5.59,5.9-12,3.62-19.47C48.26,16.08,42.9,16.72,38.49,21.94Z'/%3e%3cpath%20class='cls-5'%20d='M24.22,38.76q13.19,6.43,26.46-.25L38.49,21.94Z'/%3e%3cpath%20class='cls-6'%20d='M24.22,38.76c1,9.17,6.29,18.72,13.81,28.49,7.4-9,12.5-18.4,12.72-28.77Z'/%3e%3cpath%20class='cls-7'%20d='M50.75,38.48,38,67.25,73.86,28C64.47,28.32,56.19,30.75,50.75,38.48Z'/%3e%3cpath%20class='cls-8'%20d='M2.75,27.79,38,67.25,24.22,38.76C20.11,31,11.89,28.8,2.75,27.79Z'/%3e%3cpath%20class='cls-9'%20d='M13.39,10,2.75,27.79c9.33,1.22,16.19-1.21,19.54-8.88C24.57,13.79,21.22,11,13.39,10Z'/%3e%3cpolygon%20class='cls-6'%20points='2.75%2027.79%2024.22%2038.76%2022.29%2018.91%202.75%2027.79'/%3e%3cpolygon%20class='cls-6'%20points='52.14%205.23%2038.22%202.75%2024.22%205.23%2013.39%209.96%2022.29%2018.91%2038.49%2021.94%2054.37%2019.01%2063.33%2010.1%2052.14%205.23'/%3e%3cpolygon%20class='cls-10'%20points='50.74%2038.48%2073.86%2027.99%2054.37%2019.01%2050.74%2038.48'/%3e%3cpolygon%20class='cls-9'%20points='13.89%2010.83%2024.37%205.43%2038.22%202.75%2024.22%205.23%2013.39%209.96%2013.89%2010.83'/%3e%3cpolygon%20class='cls-9'%20points='22.29%2018.91%2024.22%2038.76%2021.1%2019.05%2022.29%2018.91'/%3e%3cpolygon%20class='cls-9'%20points='22.29%2018.91%2038.49%2021.94%2038.03%2022.48%2022.29%2018.91'/%3e%3cpolygon%20class='cls-9'%20points='63.33%2010.1%2053%2019.28%2054.37%2019.01%2063.33%2010.1'/%3e%3c/g%3e%3c/svg%3e", jA = "data:image/svg+xml,%3csvg%20id='Layer_1'%20data-name='Layer%201'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2070%2070'%3e%3ctitle%3ebomb%3c/title%3e%3cpath%20d='M35,70a35.47,35.47,0,0,1-8.45-1A35,35,0,1,1,49.83,3.3c3.53-2.25,8.75-.54,12.39,4.16.15.19.3.39.44.59a11.89,11.89,0,0,1,3.61,2.31,10.6,10.6,0,0,1,3.27,7.91A9,9,0,0,1,68,23.44a32.32,32.32,0,0,1,1.14,4h0A35,35,0,0,1,35,70ZM35,6.47A28.57,28.57,0,1,0,62.85,28.84h0A27.53,27.53,0,0,0,61.34,24a3.17,3.17,0,0,1-.16-2,3.2,3.2,0,0,1-1.49-1.33c-.29-.5-.6-1-.92-1.48a3.23,3.23,0,0,1-.11-3.39.92.92,0,0,0,.06-.29,3.33,3.33,0,0,1,.77-1.79,3.16,3.16,0,0,1-1.73-1.4,11.43,11.43,0,0,0-.65-.95c-1.59-2-3.35-2.68-3.87-2.62A1.81,1.81,0,0,1,53,9l-1.37.79a3.22,3.22,0,0,1-3.14.06A28.47,28.47,0,0,0,35,6.47Z'%20style='fill:%23051d27'/%3e%3cpath%20d='M66.76,35A31.62,31.62,0,0,0,66,28.14c-2.45-.61-13.43-3.53-16.07-3.53-17.55,0-28.75,14.48-28.75,32,0,2.35,5.65,7,6.14,9.19A31.8,31.8,0,0,0,66.76,35Z'%20style='fill:%23d8003e'/%3e%3cpath%20d='M58.34,27.2a31.72,31.72,0,0,1,7.67.94A31.76,31.76,0,1,0,27.33,65.83a31.77,31.77,0,0,1,31-38.63Z'%20style='fill:%23fd013e'/%3e%3cpath%20d='M51.33,6.19,45.71,9.44c-2.24,1.74-1.7,6.17,1.19,9.9S54,24.69,56.19,23l4.55-4.64Z'%20style='fill:%23d8003e'/%3e%3cellipse%20cx='56.03'%20cy='12.26'%20rx='4.6'%20ry='7.67'%20transform='translate(4.24%2036.9)%20rotate(-37.78)'%20style='fill:%23fd013e'/%3e%3cpath%20d='M41.45,38.53a1.55,1.55,0,0,1-.37,0,1.84,1.84,0,0,1-1.44-2.17c2-9.64,10.07-12,16-13.71,4.86-1.41,7-2.24,7-4.34a3.76,3.76,0,0,0-1.11-2.89c-1.91-1.81-5.63-1.67-5.67-1.66a1.84,1.84,0,1,1-.2-3.68c.22,0,5.33-.25,8.41,2.67a7.43,7.43,0,0,1,2.26,5.56c0,5.08-4.9,6.5-9.65,7.88-5.85,1.69-11.9,3.45-13.41,10.9A1.85,1.85,0,0,1,41.45,38.53Z'%20style='fill:%232a2f3c'/%3e%3cpolygon%20points='32.81%2053.29%2033.53%2054.59%2030.13%2056.91%2030.49%2053.72%2032.81%2053.29'%20style='fill:%23fff'/%3e%3cpolygon%20points='20.47%2056.89%2020.73%2057.24%2019.67%2057.76%2019.72%2056.95%2020.47%2056.89'%20style='fill:%23fff'/%3e%3cpolygon%20points='32.15%2047.91%2032.26%2048.82%2033.05%2048.66%2032.87%2047.59%2032.15%2047.91'%20style='fill:%23fff'/%3e%3cpolygon%20points='35.28%2046.02%2034.89%2047.73%2036.14%2047.94%2036.82%2046.87%2036.39%2045.91%2035.28%2046.02'%20style='fill:%23fff'/%3e%3cpolygon%20points='38.02%2048.47%2037.97%2049.28%2039.03%2048.76%2038.77%2048.41%2038.02%2048.47'%20style='fill:%23fff'/%3e%3cpolygon%20points='41.13%2049.33%2042.21%2048.85%2042.71%2050.93%2041.48%2051.1%2041.13%2049.33'%20style='fill:%23fff'/%3e%3cpolygon%20points='32.64%2039.9%2033.07%2040.85%2032.39%2041.92%2031.14%2041.71%2031.54%2040%2032.64%2039.9'%20style='fill:%23fff'/%3e%3cpolygon%20points='44.43%2045.41%2044.62%2046.48%2043.83%2046.65%2043.71%2045.74%2044.43%2045.41'%20style='fill:%23fff'/%3e%3cpolygon%20points='47.56%2043.79%2046.62%2045.17%2049.51%2046.55%2049.95%2045.02%2047.56%2043.79'%20style='fill:%23fff'/%3e%3cpolygon%20points='52.47%2047.67%2052.42%2048.48%2053.48%2047.96%2053.22%2047.61%2052.47%2047.67'%20style='fill:%23fff'/%3e%3cpolygon%20points='51.74%2051.27%2051.31%2052.23%2052.6%2053.19%2054.63%2051.91%2051.74%2051.27'%20style='fill:%23fff'/%3e%3cpolygon%20points='51.63%2058.46%2050.91%2058.78%2051.02%2059.69%2051.82%2059.53%2051.63%2058.46'%20style='fill:%23fff'/%3e%3cpolygon%20points='46.62%2039.13%2046.86%2036.72%2048.76%2036.45%2049.38%2037.45%2046.62%2039.13'%20style='fill:%23fff'/%3e%3cpolygon%20points='61.89%2033.9%2061.84%2034.71%2062.9%2034.19%2062.64%2033.84%2061.89%2033.9'%20style='fill:%23fff'/%3e%3cpolygon%20points='47.15%2033.15%2047.73%2033.71%2047.01%2034.52%2046.57%2033.86%2047.15%2033.15'%20style='fill:%23fff'/%3e%3cpolygon%20points='36.75%2033.83%2035.69%2034.34%2035.73%2033.53%2036.48%2033.47%2036.75%2033.83'%20style='fill:%23fff'/%3e%3cpolygon%20points='35.78%2037.44%2035.05%2037.77%2035.17%2038.67%2035.96%2038.51%2035.78%2037.44'%20style='fill:%23fff'/%3e%3cpolygon%20points='33.78%2034.62%2033%2035.77%2031.73%2035.41%2031.25%2033.9%2032.46%2032.87%2033.78%2034.62'%20style='fill:%23fff'/%3e%3cpolygon%20points='28.58%2024.4%2028.76%2025.46%2027.97%2025.63%2027.85%2024.72%2028.58%2024.4'%20style='fill:%23fff'/%3e%3cpolygon%20points='47%2026.82%2043.8%2040.43%2034.23%2026.82%2041.68%2041.48%2031.04%2038.34%2037.42%2042.53%2019.33%2047.76%2039.55%2044.62%2036.36%2055.09%2042.74%2047.76%2047%2051.95%2047%2046.72%2061.89%2049.86%2048.06%2043.57%2055.51%2038.34%2047%2041.48%2047%2026.82'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='56.57%2043.61%2063.67%2041.84%2063.67%2043.61%2056.57%2043.61'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='32.63%2033.01%2026.43%2022.4%2025.54%2025.05%2032.63%2033.01'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='34.41%2052.44%2028.2%2063.04%2027.31%2060.39%2034.41%2052.44'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='46.93%2044.58%2052.19%2051.23%2044.6%2047%2042.26%2052.44%2041.09%2048.21%2033.1%2050.41%2038.17%2044.58%2032.92%2042.16%2038.17%2040.35%2036.42%2037.94%2041.09%2038.54%2039.92%2029.47%2043.43%2038.54%2044.6%2037.94%2044.6%2039.75%2049.85%2037.33%2046.93%2042.16%2053.36%2042.77%2046.93%2044.58'%20style='fill:%23fff'/%3e%3c/svg%3e";
function f1({
  handleRevealCell: e,
  handleAutoSelection: t
}) {
  const {
    board: n,
    isEnded: s,
    multiplier: i,
    revealedCells: r,
    totalProfit: o,
    selectedCells: a
  } = ju(), { mode: l } = Vu(), { isGameActive: c, theme: u, isAutoPlaying: d } = ze(), h = Da(), f = r.slice(-1).join(), p = (A) => A === "betpanda" ? d1 : h1, g = (A) => {
    l === "auto" && !c && !d ? (Tn("tick"), t(A)) : l === "manual" && c && e(A);
  }, m = (A, w) => {
    const x = l === "auto" && a.includes(A), v = {
      backgroundImage: w === "hidden" ? `url(${p(u)})` : "none",
      backgroundSize: "cover",
      transition: "all 0.3s ease",
      borderWidth: x ? "3px" : "2px",
      borderStyle: "solid",
      borderColor: x ? "#9932CC" : u === "betpanda" ? "rgba(31, 232, 138, 0.7)" : "rgba(220, 1, 108, 0.7)"
    };
    return w === "diamond" ? {
      ...v,
      borderColor: "#1fe88a",
      backgroundColor: "#1fe88a"
      // Green for gems
    } : w === "mine" ? {
      ...v,
      borderColor: "rgb(248, 113, 113)",
      backgroundColor: "rgb(248, 113, 113)"
      // Red for bombs
    } : v;
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "grid grid-cols-5 gap-2 h-full w-full", children: [
    n.map((A, w) => /* @__PURE__ */ y.jsxs(
      yl.div,
      {
        initial: !1,
        animate: { rotateY: A !== "hidden" ? 180 : 0 },
        transition: { duration: 0.3 },
        className: `w-full h-full aspect-square rounded-sm flex items-center justify-center will-change-auto
            ${s && !r.includes(w) ? "opacity-20" : ""}
          `,
        children: [
          /* @__PURE__ */ y.jsx(
            se,
            {
              onClick: () => g(w),
              style: m(w, A),
              className: `w-full h-full disabled:opacity-100 text-4xl rounded-sm p-3 select-none 
              ${A === "diamond" ? "bg-brand border-opacity-0" : A === "mine" ? "bg-red-400 text-white border-opacity-0" : "cursor-pointer"}
            `,
              disabled: d || l === "manual" && (!c || A !== "hidden"),
              children: (A !== "hidden" || s) && /* @__PURE__ */ y.jsx(
                "img",
                {
                  src: A === "mine" ? jA : FA,
                  width: "0",
                  height: "0",
                  alt: "",
                  style: { width: "100%", height: "auto" }
                }
              )
            }
          ),
          /* @__PURE__ */ y.jsx(xf, { children: A === "diamond" && parseInt(f) === w && c && l === "manual" && /* @__PURE__ */ y.jsx(
            yl.div,
            {
              initial: { opacity: 0, scale: 0.8 },
              animate: { opacity: 1, scale: 1, rotateY: 180 },
              exit: { opacity: 0, scale: 0.8 },
              transition: { duration: 0.3 },
              className: "absolute top-0 left-50",
              style: { top: "-15px" },
              children: /* @__PURE__ */ y.jsxs(n1, { variant: "secondary", className: "relative z-50 text-xs bg-violet-700 text-white font-black px-1.5 pointer-events-none", children: [
                i.toFixed(2),
                "x"
              ] })
            }
          ) })
        ]
      },
      `${w}-${u}`
    )),
    /* @__PURE__ */ y.jsx(xf, { children: l === "auto" && a.length === 0 && /* @__PURE__ */ y.jsxs(
      yl.div,
      {
        className: "absolute left-3 right-3 top-full mt-4 bg-white text-black p-4 rounded-lg shadow-lg",
        initial: { opacity: 0, y: -30 },
        animate: { opacity: 1, y: -5 },
        exit: { opacity: 0, y: -30 },
        transition: { duration: 0.3 },
        children: [
          /* @__PURE__ */ y.jsx("div", { className: "absolute -top-2 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-b-8 border-transparent border-b-white" }),
          /* @__PURE__ */ y.jsx("h2", { className: "text-sm font-bold mb-2", children: "Welcome to Auto Mode!" }),
          /* @__PURE__ */ y.jsx("p", { className: "text-sm", children: "Select the cells you want to reveal automatically. The game will play these selections for you when you start." })
        ]
      }
    ) }),
    s && i !== 0 && /* @__PURE__ */ y.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ y.jsx(t1, { multiplier: i, amount: o }) }),
    !h && !c && !d && /* @__PURE__ */ y.jsx(
      s1,
      {
        size: 600,
        duration: 8,
        colorFrom: u === "betpanda" ? "#1fe88a" : "#dc016c",
        colorTo: "#0a1d2e",
        borderWidth: 1.5
      }
    )
  ] });
}
const ye = b.forwardRef(
  ({ className: e, type: t, ...n }, s) => /* @__PURE__ */ y.jsx(
    "input",
    {
      type: t,
      className: At(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ref: s,
      ...n
    }
  )
);
ye.displayName = "Input";
var p1 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], ut = p1.reduce((e, t) => {
  const n = b.forwardRef((s, i) => {
    const { asChild: r, ...o } = s, a = r ? ti : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ y.jsx(a, { ...o, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function VA(e, t) {
  e && ou.flushSync(() => e.dispatchEvent(t));
}
var g1 = "Label", UA = b.forwardRef((e, t) => /* @__PURE__ */ y.jsx(
  ut.label,
  {
    ...e,
    ref: t,
    onMouseDown: (n) => {
      var i;
      n.target.closest("button, input, select, textarea") || ((i = e.onMouseDown) == null || i.call(e, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
UA.displayName = g1;
var YA = UA;
const m1 = Lu(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
), ne = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  YA,
  {
    ref: n,
    className: At(m1(), e),
    ...t
  }
));
ne.displayName = YA.displayName;
function zi({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      className: At("animate-pulse rounded-md bg-muted", e),
      ...t
    }
  );
}
var rt;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const r = {};
    for (const o of i)
      r[o] = o;
    return r;
  }, e.getValidEnumValues = (i) => {
    const r = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), o = {};
    for (const a of r)
      o[a] = i[a];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(r) {
    return i[r];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const r = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && r.push(o);
    return r;
  }, e.find = (i, r) => {
    for (const o of i)
      if (r(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function s(i, r = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(r);
  }
  e.joinValues = s, e.jsonStringifyReplacer = (i, r) => typeof r == "bigint" ? r.toString() : r;
})(rt || (rt = {}));
var gc;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(gc || (gc = {}));
const Y = rt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Dn = (e) => {
  switch (typeof e) {
    case "undefined":
      return Y.undefined;
    case "string":
      return Y.string;
    case "number":
      return isNaN(e) ? Y.nan : Y.number;
    case "boolean":
      return Y.boolean;
    case "function":
      return Y.function;
    case "bigint":
      return Y.bigint;
    case "symbol":
      return Y.symbol;
    case "object":
      return Array.isArray(e) ? Y.array : e === null ? Y.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Y.promise : typeof Map < "u" && e instanceof Map ? Y.map : typeof Set < "u" && e instanceof Set ? Y.set : typeof Date < "u" && e instanceof Date ? Y.date : Y.object;
    default:
      return Y.unknown;
  }
}, B = rt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), A1 = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class be extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (s) => {
      this.issues = [...this.issues, s];
    }, this.addIssues = (s = []) => {
      this.issues = [...this.issues, ...s];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(r) {
      return r.message;
    }, s = { _errors: [] }, i = (r) => {
      for (const o of r.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          s._errors.push(n(o));
        else {
          let a = s, l = 0;
          for (; l < o.path.length; ) {
            const c = o.path[l];
            l === o.path.length - 1 ? (a[c] = a[c] || { _errors: [] }, a[c]._errors.push(n(o))) : a[c] = a[c] || { _errors: [] }, a = a[c], l++;
          }
        }
    };
    return i(this), s;
  }
  static assert(t) {
    if (!(t instanceof be))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, rt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, s = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : s.push(t(i));
    return { formErrors: s, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
be.create = (e) => new be(e);
const ei = (e, t) => {
  let n;
  switch (e.code) {
    case B.invalid_type:
      e.received === Y.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case B.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, rt.jsonStringifyReplacer)}`;
      break;
    case B.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${rt.joinValues(e.keys, ", ")}`;
      break;
    case B.invalid_union:
      n = "Invalid input";
      break;
    case B.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${rt.joinValues(e.options)}`;
      break;
    case B.invalid_enum_value:
      n = `Invalid enum value. Expected ${rt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case B.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case B.invalid_return_type:
      n = "Invalid function return type";
      break;
    case B.invalid_date:
      n = "Invalid date";
      break;
    case B.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : rt.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case B.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case B.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case B.custom:
      n = "Invalid input";
      break;
    case B.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case B.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case B.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, rt.assertNever(e);
  }
  return { message: n };
};
let WA = ei;
function y1(e) {
  WA = e;
}
function Jo() {
  return WA;
}
const Xo = (e) => {
  const { data: t, path: n, errorMaps: s, issueData: i } = e, r = [...n, ...i.path || []], o = {
    ...i,
    path: r
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: r,
      message: i.message
    };
  let a = "";
  const l = s.filter((c) => !!c).slice().reverse();
  for (const c of l)
    a = c(o, { data: t, defaultError: a }).message;
  return {
    ...i,
    path: r,
    message: a
  };
}, w1 = [];
function V(e, t) {
  const n = Jo(), s = Xo({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      n,
      n === ei ? void 0 : ei
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(s);
}
class Xt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const s = [];
    for (const i of n) {
      if (i.status === "aborted")
        return Z;
      i.status === "dirty" && t.dirty(), s.push(i.value);
    }
    return { status: t.value, value: s };
  }
  static async mergeObjectAsync(t, n) {
    const s = [];
    for (const i of n) {
      const r = await i.key, o = await i.value;
      s.push({
        key: r,
        value: o
      });
    }
    return Xt.mergeObjectSync(t, s);
  }
  static mergeObjectSync(t, n) {
    const s = {};
    for (const i of n) {
      const { key: r, value: o } = i;
      if (r.status === "aborted" || o.status === "aborted")
        return Z;
      r.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), r.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (s[r.value] = o.value);
    }
    return { status: t.value, value: s };
  }
}
const Z = Object.freeze({
  status: "aborted"
}), Ws = (e) => ({ status: "dirty", value: e }), re = (e) => ({ status: "valid", value: e }), mc = (e) => e.status === "aborted", Ac = (e) => e.status === "dirty", ir = (e) => e.status === "valid", rr = (e) => typeof Promise < "u" && e instanceof Promise;
function $o(e, t, n, s) {
  if (typeof t == "function" ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t.get(e);
}
function QA(e, t, n, s, i) {
  if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
}
var K;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(K || (K = {}));
var Ni, Li;
class He {
  constructor(t, n, s, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = s, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const kf = (e, t) => {
  if (ir(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new be(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function tt(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: s, description: i } = e;
  if (t && (n || s))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, a) => {
    var l, c;
    const { message: u } = e;
    return o.code === "invalid_enum_value" ? { message: u ?? a.defaultError } : typeof a.data > "u" ? { message: (l = u ?? s) !== null && l !== void 0 ? l : a.defaultError } : o.code !== "invalid_type" ? { message: a.defaultError } : { message: (c = u ?? n) !== null && c !== void 0 ? c : a.defaultError };
  }, description: i };
}
class st {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Dn(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Dn(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Xt(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Dn(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (rr(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const s = this.safeParse(t, n);
    if (s.success)
      return s.data;
    throw s.error;
  }
  safeParse(t, n) {
    var s;
    const i = {
      common: {
        issues: [],
        async: (s = n == null ? void 0 : n.async) !== null && s !== void 0 ? s : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Dn(t)
    }, r = this._parseSync({ data: t, path: i.path, parent: i });
    return kf(i, r);
  }
  async parseAsync(t, n) {
    const s = await this.safeParseAsync(t, n);
    if (s.success)
      return s.data;
    throw s.error;
  }
  async safeParseAsync(t, n) {
    const s = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Dn(t)
    }, i = this._parse({ data: t, path: s.path, parent: s }), r = await (rr(i) ? i : Promise.resolve(i));
    return kf(s, r);
  }
  refine(t, n) {
    const s = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, r) => {
      const o = t(i), a = () => r.addIssue({
        code: B.custom,
        ...s(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((s, i) => t(s) ? !0 : (i.addIssue(typeof n == "function" ? n(s, i) : n), !1));
  }
  _refinement(t) {
    return new Ne({
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return _e.create(this, this._def);
  }
  nullable() {
    return Gn.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Pe.create(this, this._def);
  }
  promise() {
    return si.create(this, this._def);
  }
  or(t) {
    return cr.create([this, t], this._def);
  }
  and(t) {
    return ur.create(this, t, this._def);
  }
  transform(t) {
    return new Ne({
      ...tt(this._def),
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new gr({
      ...tt(this._def),
      innerType: this,
      defaultValue: n,
      typeName: _.ZodDefault
    });
  }
  brand() {
    return new Uu({
      typeName: _.ZodBranded,
      type: this,
      ...tt(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new mr({
      ...tt(this._def),
      innerType: this,
      catchValue: n,
      typeName: _.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Pr.create(this, t);
  }
  readonly() {
    return Ar.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const b1 = /^c[^\s-]{8,}$/i, x1 = /^[0-9a-z]+$/, v1 = /^[0-9A-HJKMNP-TV-Z]{26}$/, C1 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, S1 = /^[a-z0-9_-]{21}$/i, M1 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, E1 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, q1 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let bl;
const R1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, k1 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, T1 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, GA = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", D1 = new RegExp(`^${GA}$`);
function KA(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function B1(e) {
  return new RegExp(`^${KA(e)}$`);
}
function zA(e) {
  let t = `${GA}T${KA(e)}`;
  const n = [];
  return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`);
}
function I1(e, t) {
  return !!((t === "v4" || !t) && R1.test(e) || (t === "v6" || !t) && k1.test(e));
}
class Be extends st {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Y.string) {
      const r = this._getOrReturnCtx(t);
      return V(r, {
        code: B.invalid_type,
        expected: Y.string,
        received: r.parsedType
      }), Z;
    }
    const s = new Xt();
    let i;
    for (const r of this._def.checks)
      if (r.kind === "min")
        t.data.length < r.value && (i = this._getOrReturnCtx(t, i), V(i, {
          code: B.too_small,
          minimum: r.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: r.message
        }), s.dirty());
      else if (r.kind === "max")
        t.data.length > r.value && (i = this._getOrReturnCtx(t, i), V(i, {
          code: B.too_big,
          maximum: r.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: r.message
        }), s.dirty());
      else if (r.kind === "length") {
        const o = t.data.length > r.value, a = t.data.length < r.value;
        (o || a) && (i = this._getOrReturnCtx(t, i), o ? V(i, {
          code: B.too_big,
          maximum: r.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: r.message
        }) : a && V(i, {
          code: B.too_small,
          minimum: r.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: r.message
        }), s.dirty());
      } else if (r.kind === "email")
        E1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
          validation: "email",
          code: B.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "emoji")
        bl || (bl = new RegExp(q1, "u")), bl.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
          validation: "emoji",
          code: B.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "uuid")
        C1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
          validation: "uuid",
          code: B.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "nanoid")
        S1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
          validation: "nanoid",
          code: B.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "cuid")
        b1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
          validation: "cuid",
          code: B.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "cuid2")
        x1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
          validation: "cuid2",
          code: B.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "ulid")
        v1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
          validation: "ulid",
          code: B.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), V(i, {
            validation: "url",
            code: B.invalid_string,
            message: r.message
          }), s.dirty();
        }
      else r.kind === "regex" ? (r.regex.lastIndex = 0, r.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
        validation: "regex",
        code: B.invalid_string,
        message: r.message
      }), s.dirty())) : r.kind === "trim" ? t.data = t.data.trim() : r.kind === "includes" ? t.data.includes(r.value, r.position) || (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.invalid_string,
        validation: { includes: r.value, position: r.position },
        message: r.message
      }), s.dirty()) : r.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : r.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : r.kind === "startsWith" ? t.data.startsWith(r.value) || (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.invalid_string,
        validation: { startsWith: r.value },
        message: r.message
      }), s.dirty()) : r.kind === "endsWith" ? t.data.endsWith(r.value) || (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.invalid_string,
        validation: { endsWith: r.value },
        message: r.message
      }), s.dirty()) : r.kind === "datetime" ? zA(r).test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.invalid_string,
        validation: "datetime",
        message: r.message
      }), s.dirty()) : r.kind === "date" ? D1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.invalid_string,
        validation: "date",
        message: r.message
      }), s.dirty()) : r.kind === "time" ? B1(r).test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.invalid_string,
        validation: "time",
        message: r.message
      }), s.dirty()) : r.kind === "duration" ? M1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
        validation: "duration",
        code: B.invalid_string,
        message: r.message
      }), s.dirty()) : r.kind === "ip" ? I1(t.data, r.version) || (i = this._getOrReturnCtx(t, i), V(i, {
        validation: "ip",
        code: B.invalid_string,
        message: r.message
      }), s.dirty()) : r.kind === "base64" ? T1.test(t.data) || (i = this._getOrReturnCtx(t, i), V(i, {
        validation: "base64",
        code: B.invalid_string,
        message: r.message
      }), s.dirty()) : rt.assertNever(r);
    return { status: s.value, value: t.data };
  }
  _regex(t, n, s) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: B.invalid_string,
      ...K.errToObj(s)
    });
  }
  _addCheck(t) {
    return new Be({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...K.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...K.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...K.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...K.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...K.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...K.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...K.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...K.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...K.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...K.errToObj(t) });
  }
  datetime(t) {
    var n, s;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      local: (s = t == null ? void 0 : t.local) !== null && s !== void 0 ? s : !1,
      ...K.errToObj(t == null ? void 0 : t.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      ...K.errToObj(t == null ? void 0 : t.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...K.errToObj(t) });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...K.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...K.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...K.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...K.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...K.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...K.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...K.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, K.errToObj(t));
  }
  trim() {
    return new Be({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Be({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Be({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Be.create = (e) => {
  var t;
  return new Be({
    checks: [],
    typeName: _.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...tt(e)
  });
};
function P1(e, t) {
  const n = (e.toString().split(".")[1] || "").length, s = (t.toString().split(".")[1] || "").length, i = n > s ? n : s, r = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return r % o / Math.pow(10, i);
}
class Yn extends st {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Y.number) {
      const r = this._getOrReturnCtx(t);
      return V(r, {
        code: B.invalid_type,
        expected: Y.number,
        received: r.parsedType
      }), Z;
    }
    let s;
    const i = new Xt();
    for (const r of this._def.checks)
      r.kind === "int" ? rt.isInteger(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.invalid_type,
        expected: "integer",
        received: "float",
        message: r.message
      }), i.dirty()) : r.kind === "min" ? (r.inclusive ? t.data < r.value : t.data <= r.value) && (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.too_small,
        minimum: r.value,
        type: "number",
        inclusive: r.inclusive,
        exact: !1,
        message: r.message
      }), i.dirty()) : r.kind === "max" ? (r.inclusive ? t.data > r.value : t.data >= r.value) && (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.too_big,
        maximum: r.value,
        type: "number",
        inclusive: r.inclusive,
        exact: !1,
        message: r.message
      }), i.dirty()) : r.kind === "multipleOf" ? P1(t.data, r.value) !== 0 && (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.not_multiple_of,
        multipleOf: r.value,
        message: r.message
      }), i.dirty()) : r.kind === "finite" ? Number.isFinite(t.data) || (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.not_finite,
        message: r.message
      }), i.dirty()) : rt.assertNever(r);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, K.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, K.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, K.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, K.toString(n));
  }
  setLimit(t, n, s, i) {
    return new Yn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: s,
          message: K.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Yn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: K.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: K.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: K.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: K.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: K.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: K.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: K.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: K.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: K.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && rt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const s of this._def.checks) {
      if (s.kind === "finite" || s.kind === "int" || s.kind === "multipleOf")
        return !0;
      s.kind === "min" ? (n === null || s.value > n) && (n = s.value) : s.kind === "max" && (t === null || s.value < t) && (t = s.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
Yn.create = (e) => new Yn({
  checks: [],
  typeName: _.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...tt(e)
});
class Wn extends st {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Y.bigint) {
      const r = this._getOrReturnCtx(t);
      return V(r, {
        code: B.invalid_type,
        expected: Y.bigint,
        received: r.parsedType
      }), Z;
    }
    let s;
    const i = new Xt();
    for (const r of this._def.checks)
      r.kind === "min" ? (r.inclusive ? t.data < r.value : t.data <= r.value) && (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.too_small,
        type: "bigint",
        minimum: r.value,
        inclusive: r.inclusive,
        message: r.message
      }), i.dirty()) : r.kind === "max" ? (r.inclusive ? t.data > r.value : t.data >= r.value) && (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.too_big,
        type: "bigint",
        maximum: r.value,
        inclusive: r.inclusive,
        message: r.message
      }), i.dirty()) : r.kind === "multipleOf" ? t.data % r.value !== BigInt(0) && (s = this._getOrReturnCtx(t, s), V(s, {
        code: B.not_multiple_of,
        multipleOf: r.value,
        message: r.message
      }), i.dirty()) : rt.assertNever(r);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, K.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, K.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, K.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, K.toString(n));
  }
  setLimit(t, n, s, i) {
    return new Wn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: s,
          message: K.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Wn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: K.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: K.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: K.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: K.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: K.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Wn.create = (e) => {
  var t;
  return new Wn({
    checks: [],
    typeName: _.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...tt(e)
  });
};
class or extends st {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Y.boolean) {
      const s = this._getOrReturnCtx(t);
      return V(s, {
        code: B.invalid_type,
        expected: Y.boolean,
        received: s.parsedType
      }), Z;
    }
    return re(t.data);
  }
}
or.create = (e) => new or({
  typeName: _.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...tt(e)
});
class Cs extends st {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Y.date) {
      const r = this._getOrReturnCtx(t);
      return V(r, {
        code: B.invalid_type,
        expected: Y.date,
        received: r.parsedType
      }), Z;
    }
    if (isNaN(t.data.getTime())) {
      const r = this._getOrReturnCtx(t);
      return V(r, {
        code: B.invalid_date
      }), Z;
    }
    const s = new Xt();
    let i;
    for (const r of this._def.checks)
      r.kind === "min" ? t.data.getTime() < r.value && (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.too_small,
        message: r.message,
        inclusive: !0,
        exact: !1,
        minimum: r.value,
        type: "date"
      }), s.dirty()) : r.kind === "max" ? t.data.getTime() > r.value && (i = this._getOrReturnCtx(t, i), V(i, {
        code: B.too_big,
        message: r.message,
        inclusive: !0,
        exact: !1,
        maximum: r.value,
        type: "date"
      }), s.dirty()) : rt.assertNever(r);
    return {
      status: s.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Cs({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: K.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: K.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
Cs.create = (e) => new Cs({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: _.ZodDate,
  ...tt(e)
});
class ta extends st {
  _parse(t) {
    if (this._getType(t) !== Y.symbol) {
      const s = this._getOrReturnCtx(t);
      return V(s, {
        code: B.invalid_type,
        expected: Y.symbol,
        received: s.parsedType
      }), Z;
    }
    return re(t.data);
  }
}
ta.create = (e) => new ta({
  typeName: _.ZodSymbol,
  ...tt(e)
});
class ar extends st {
  _parse(t) {
    if (this._getType(t) !== Y.undefined) {
      const s = this._getOrReturnCtx(t);
      return V(s, {
        code: B.invalid_type,
        expected: Y.undefined,
        received: s.parsedType
      }), Z;
    }
    return re(t.data);
  }
}
ar.create = (e) => new ar({
  typeName: _.ZodUndefined,
  ...tt(e)
});
class lr extends st {
  _parse(t) {
    if (this._getType(t) !== Y.null) {
      const s = this._getOrReturnCtx(t);
      return V(s, {
        code: B.invalid_type,
        expected: Y.null,
        received: s.parsedType
      }), Z;
    }
    return re(t.data);
  }
}
lr.create = (e) => new lr({
  typeName: _.ZodNull,
  ...tt(e)
});
class ni extends st {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return re(t.data);
  }
}
ni.create = (e) => new ni({
  typeName: _.ZodAny,
  ...tt(e)
});
class ws extends st {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return re(t.data);
  }
}
ws.create = (e) => new ws({
  typeName: _.ZodUnknown,
  ...tt(e)
});
class yn extends st {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return V(n, {
      code: B.invalid_type,
      expected: Y.never,
      received: n.parsedType
    }), Z;
  }
}
yn.create = (e) => new yn({
  typeName: _.ZodNever,
  ...tt(e)
});
class ea extends st {
  _parse(t) {
    if (this._getType(t) !== Y.undefined) {
      const s = this._getOrReturnCtx(t);
      return V(s, {
        code: B.invalid_type,
        expected: Y.void,
        received: s.parsedType
      }), Z;
    }
    return re(t.data);
  }
}
ea.create = (e) => new ea({
  typeName: _.ZodVoid,
  ...tt(e)
});
class Pe extends st {
  _parse(t) {
    const { ctx: n, status: s } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== Y.array)
      return V(n, {
        code: B.invalid_type,
        expected: Y.array,
        received: n.parsedType
      }), Z;
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value, a = n.data.length < i.exactLength.value;
      (o || a) && (V(n, {
        code: o ? B.too_big : B.too_small,
        minimum: a ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), s.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (V(n, {
      code: B.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), s.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (V(n, {
      code: B.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), s.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, a) => i.type._parseAsync(new He(n, o, n.path, a)))).then((o) => Xt.mergeArray(s, o));
    const r = [...n.data].map((o, a) => i.type._parseSync(new He(n, o, n.path, a)));
    return Xt.mergeArray(s, r);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new Pe({
      ...this._def,
      minLength: { value: t, message: K.toString(n) }
    });
  }
  max(t, n) {
    return new Pe({
      ...this._def,
      maxLength: { value: t, message: K.toString(n) }
    });
  }
  length(t, n) {
    return new Pe({
      ...this._def,
      exactLength: { value: t, message: K.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Pe.create = (e, t) => new Pe({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _.ZodArray,
  ...tt(t)
});
function Ls(e) {
  if (e instanceof Et) {
    const t = {};
    for (const n in e.shape) {
      const s = e.shape[n];
      t[n] = _e.create(Ls(s));
    }
    return new Et({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Pe ? new Pe({
    ...e._def,
    type: Ls(e.element)
  }) : e instanceof _e ? _e.create(Ls(e.unwrap())) : e instanceof Gn ? Gn.create(Ls(e.unwrap())) : e instanceof Je ? Je.create(e.items.map((t) => Ls(t))) : e;
}
class Et extends st {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = rt.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== Y.object) {
      const c = this._getOrReturnCtx(t);
      return V(c, {
        code: B.invalid_type,
        expected: Y.object,
        received: c.parsedType
      }), Z;
    }
    const { status: s, ctx: i } = this._processInputParams(t), { shape: r, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof yn && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        o.includes(c) || a.push(c);
    const l = [];
    for (const c of o) {
      const u = r[c], d = i.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new He(i, d, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof yn) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of a)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (c === "strict")
        a.length > 0 && (V(i, {
          code: B.unrecognized_keys,
          keys: a
        }), s.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of a) {
        const d = i.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new He(i, d, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const d = await u.key, h = await u.value;
        c.push({
          key: d,
          value: h,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => Xt.mergeObjectSync(s, c)) : Xt.mergeObjectSync(s, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return K.errToObj, new Et({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, s) => {
          var i, r, o, a;
          const l = (o = (r = (i = this._def).errorMap) === null || r === void 0 ? void 0 : r.call(i, n, s).message) !== null && o !== void 0 ? o : s.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = K.errToObj(t).message) !== null && a !== void 0 ? a : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new Et({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Et({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Et({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Et({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: _.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Et({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return rt.objectKeys(t).forEach((s) => {
      t[s] && this.shape[s] && (n[s] = this.shape[s]);
    }), new Et({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return rt.objectKeys(this.shape).forEach((s) => {
      t[s] || (n[s] = this.shape[s]);
    }), new Et({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ls(this);
  }
  partial(t) {
    const n = {};
    return rt.objectKeys(this.shape).forEach((s) => {
      const i = this.shape[s];
      t && !t[s] ? n[s] = i : n[s] = i.optional();
    }), new Et({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return rt.objectKeys(this.shape).forEach((s) => {
      if (t && !t[s])
        n[s] = this.shape[s];
      else {
        let r = this.shape[s];
        for (; r instanceof _e; )
          r = r._def.innerType;
        n[s] = r;
      }
    }), new Et({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return _A(rt.objectKeys(this.shape));
  }
}
Et.create = (e, t) => new Et({
  shape: () => e,
  unknownKeys: "strip",
  catchall: yn.create(),
  typeName: _.ZodObject,
  ...tt(t)
});
Et.strictCreate = (e, t) => new Et({
  shape: () => e,
  unknownKeys: "strict",
  catchall: yn.create(),
  typeName: _.ZodObject,
  ...tt(t)
});
Et.lazycreate = (e, t) => new Et({
  shape: e,
  unknownKeys: "strip",
  catchall: yn.create(),
  typeName: _.ZodObject,
  ...tt(t)
});
class cr extends st {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), s = this._def.options;
    function i(r) {
      for (const a of r)
        if (a.result.status === "valid")
          return a.result;
      for (const a of r)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = r.map((a) => new be(a.ctx.common.issues));
      return V(n, {
        code: B.invalid_union,
        unionErrors: o
      }), Z;
    }
    if (n.common.async)
      return Promise.all(s.map(async (r) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await r._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let r;
      const o = [];
      for (const l of s) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !r && (r = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues);
      }
      if (r)
        return n.common.issues.push(...r.ctx.common.issues), r.result;
      const a = o.map((l) => new be(l));
      return V(n, {
        code: B.invalid_union,
        unionErrors: a
      }), Z;
    }
  }
  get options() {
    return this._def.options;
  }
}
cr.create = (e, t) => new cr({
  options: e,
  typeName: _.ZodUnion,
  ...tt(t)
});
const rn = (e) => e instanceof hr ? rn(e.schema) : e instanceof Ne ? rn(e.innerType()) : e instanceof fr ? [e.value] : e instanceof Qn ? e.options : e instanceof pr ? rt.objectValues(e.enum) : e instanceof gr ? rn(e._def.innerType) : e instanceof ar ? [void 0] : e instanceof lr ? [null] : e instanceof _e ? [void 0, ...rn(e.unwrap())] : e instanceof Gn ? [null, ...rn(e.unwrap())] : e instanceof Uu || e instanceof Ar ? rn(e.unwrap()) : e instanceof mr ? rn(e._def.innerType) : [];
class Ba extends st {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Y.object)
      return V(n, {
        code: B.invalid_type,
        expected: Y.object,
        received: n.parsedType
      }), Z;
    const s = this.discriminator, i = n.data[s], r = this.optionsMap.get(i);
    return r ? n.common.async ? r._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : r._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (V(n, {
      code: B.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [s]
    }), Z);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, s) {
    const i = /* @__PURE__ */ new Map();
    for (const r of n) {
      const o = rn(r.shape[t]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const a of o) {
        if (i.has(a))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
        i.set(a, r);
      }
    }
    return new Ba({
      typeName: _.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...tt(s)
    });
  }
}
function yc(e, t) {
  const n = Dn(e), s = Dn(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === Y.object && s === Y.object) {
    const i = rt.objectKeys(t), r = rt.objectKeys(e).filter((a) => i.indexOf(a) !== -1), o = { ...e, ...t };
    for (const a of r) {
      const l = yc(e[a], t[a]);
      if (!l.valid)
        return { valid: !1 };
      o[a] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === Y.array && s === Y.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r], a = t[r], l = yc(o, a);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else return n === Y.date && s === Y.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class ur extends st {
  _parse(t) {
    const { status: n, ctx: s } = this._processInputParams(t), i = (r, o) => {
      if (mc(r) || mc(o))
        return Z;
      const a = yc(r.value, o.value);
      return a.valid ? ((Ac(r) || Ac(o)) && n.dirty(), { status: n.value, value: a.data }) : (V(s, {
        code: B.invalid_intersection_types
      }), Z);
    };
    return s.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      }),
      this._def.right._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      })
    ]).then(([r, o]) => i(r, o)) : i(this._def.left._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }), this._def.right._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }));
  }
}
ur.create = (e, t, n) => new ur({
  left: e,
  right: t,
  typeName: _.ZodIntersection,
  ...tt(n)
});
class Je extends st {
  _parse(t) {
    const { status: n, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== Y.array)
      return V(s, {
        code: B.invalid_type,
        expected: Y.array,
        received: s.parsedType
      }), Z;
    if (s.data.length < this._def.items.length)
      return V(s, {
        code: B.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Z;
    !this._def.rest && s.data.length > this._def.items.length && (V(s, {
      code: B.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const r = [...s.data].map((o, a) => {
      const l = this._def.items[a] || this._def.rest;
      return l ? l._parse(new He(s, o, s.path, a)) : null;
    }).filter((o) => !!o);
    return s.common.async ? Promise.all(r).then((o) => Xt.mergeArray(n, o)) : Xt.mergeArray(n, r);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Je({
      ...this._def,
      rest: t
    });
  }
}
Je.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Je({
    items: e,
    typeName: _.ZodTuple,
    rest: null,
    ...tt(t)
  });
};
class dr extends st {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== Y.object)
      return V(s, {
        code: B.invalid_type,
        expected: Y.object,
        received: s.parsedType
      }), Z;
    const i = [], r = this._def.keyType, o = this._def.valueType;
    for (const a in s.data)
      i.push({
        key: r._parse(new He(s, a, s.path, a)),
        value: o._parse(new He(s, s.data[a], s.path, a)),
        alwaysSet: a in s.data
      });
    return s.common.async ? Xt.mergeObjectAsync(n, i) : Xt.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, s) {
    return n instanceof st ? new dr({
      keyType: t,
      valueType: n,
      typeName: _.ZodRecord,
      ...tt(s)
    }) : new dr({
      keyType: Be.create(),
      valueType: t,
      typeName: _.ZodRecord,
      ...tt(n)
    });
  }
}
class na extends st {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== Y.map)
      return V(s, {
        code: B.invalid_type,
        expected: Y.map,
        received: s.parsedType
      }), Z;
    const i = this._def.keyType, r = this._def.valueType, o = [...s.data.entries()].map(([a, l], c) => ({
      key: i._parse(new He(s, a, s.path, [c, "key"])),
      value: r._parse(new He(s, l, s.path, [c, "value"]))
    }));
    if (s.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return Z;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const l of o) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return Z;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value);
      }
      return { status: n.value, value: a };
    }
  }
}
na.create = (e, t, n) => new na({
  valueType: t,
  keyType: e,
  typeName: _.ZodMap,
  ...tt(n)
});
class Ss extends st {
  _parse(t) {
    const { status: n, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== Y.set)
      return V(s, {
        code: B.invalid_type,
        expected: Y.set,
        received: s.parsedType
      }), Z;
    const i = this._def;
    i.minSize !== null && s.data.size < i.minSize.value && (V(s, {
      code: B.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && s.data.size > i.maxSize.value && (V(s, {
      code: B.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const r = this._def.valueType;
    function o(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return Z;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    const a = [...s.data.values()].map((l, c) => r._parse(new He(s, l, s.path, c)));
    return s.common.async ? Promise.all(a).then((l) => o(l)) : o(a);
  }
  min(t, n) {
    return new Ss({
      ...this._def,
      minSize: { value: t, message: K.toString(n) }
    });
  }
  max(t, n) {
    return new Ss({
      ...this._def,
      maxSize: { value: t, message: K.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ss.create = (e, t) => new Ss({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: _.ZodSet,
  ...tt(t)
});
class Ks extends st {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Y.function)
      return V(n, {
        code: B.invalid_type,
        expected: Y.function,
        received: n.parsedType
      }), Z;
    function s(a, l) {
      return Xo({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Jo(),
          ei
        ].filter((c) => !!c),
        issueData: {
          code: B.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function i(a, l) {
      return Xo({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Jo(),
          ei
        ].filter((c) => !!c),
        issueData: {
          code: B.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const r = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof si) {
      const a = this;
      return re(async function(...l) {
        const c = new be([]), u = await a._def.args.parseAsync(l, r).catch((f) => {
          throw c.addIssue(s(l, f)), c;
        }), d = await Reflect.apply(o, this, u);
        return await a._def.returns._def.type.parseAsync(d, r).catch((f) => {
          throw c.addIssue(i(d, f)), c;
        });
      });
    } else {
      const a = this;
      return re(function(...l) {
        const c = a._def.args.safeParse(l, r);
        if (!c.success)
          throw new be([s(l, c.error)]);
        const u = Reflect.apply(o, this, c.data), d = a._def.returns.safeParse(u, r);
        if (!d.success)
          throw new be([i(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ks({
      ...this._def,
      args: Je.create(t).rest(ws.create())
    });
  }
  returns(t) {
    return new Ks({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, s) {
    return new Ks({
      args: t || Je.create([]).rest(ws.create()),
      returns: n || ws.create(),
      typeName: _.ZodFunction,
      ...tt(s)
    });
  }
}
class hr extends st {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
hr.create = (e, t) => new hr({
  getter: e,
  typeName: _.ZodLazy,
  ...tt(t)
});
class fr extends st {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return V(n, {
        received: n.data,
        code: B.invalid_literal,
        expected: this._def.value
      }), Z;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
fr.create = (e, t) => new fr({
  value: e,
  typeName: _.ZodLiteral,
  ...tt(t)
});
function _A(e, t) {
  return new Qn({
    values: e,
    typeName: _.ZodEnum,
    ...tt(t)
  });
}
class Qn extends st {
  constructor() {
    super(...arguments), Ni.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), s = this._def.values;
      return V(n, {
        expected: rt.joinValues(s),
        received: n.parsedType,
        code: B.invalid_type
      }), Z;
    }
    if ($o(this, Ni) || QA(this, Ni, new Set(this._def.values)), !$o(this, Ni).has(t.data)) {
      const n = this._getOrReturnCtx(t), s = this._def.values;
      return V(n, {
        received: n.data,
        code: B.invalid_enum_value,
        options: s
      }), Z;
    }
    return re(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return Qn.create(t, {
      ...this._def,
      ...n
    });
  }
  exclude(t, n = this._def) {
    return Qn.create(this.options.filter((s) => !t.includes(s)), {
      ...this._def,
      ...n
    });
  }
}
Ni = /* @__PURE__ */ new WeakMap();
Qn.create = _A;
class pr extends st {
  constructor() {
    super(...arguments), Li.set(this, void 0);
  }
  _parse(t) {
    const n = rt.getValidEnumValues(this._def.values), s = this._getOrReturnCtx(t);
    if (s.parsedType !== Y.string && s.parsedType !== Y.number) {
      const i = rt.objectValues(n);
      return V(s, {
        expected: rt.joinValues(i),
        received: s.parsedType,
        code: B.invalid_type
      }), Z;
    }
    if ($o(this, Li) || QA(this, Li, new Set(rt.getValidEnumValues(this._def.values))), !$o(this, Li).has(t.data)) {
      const i = rt.objectValues(n);
      return V(s, {
        received: s.data,
        code: B.invalid_enum_value,
        options: i
      }), Z;
    }
    return re(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Li = /* @__PURE__ */ new WeakMap();
pr.create = (e, t) => new pr({
  values: e,
  typeName: _.ZodNativeEnum,
  ...tt(t)
});
class si extends st {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Y.promise && n.common.async === !1)
      return V(n, {
        code: B.invalid_type,
        expected: Y.promise,
        received: n.parsedType
      }), Z;
    const s = n.parsedType === Y.promise ? n.data : Promise.resolve(n.data);
    return re(s.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
si.create = (e, t) => new si({
  type: e,
  typeName: _.ZodPromise,
  ...tt(t)
});
class Ne extends st {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: s } = this._processInputParams(t), i = this._def.effect || null, r = {
      addIssue: (o) => {
        V(s, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return s.path;
      }
    };
    if (r.addIssue = r.addIssue.bind(r), i.type === "preprocess") {
      const o = i.transform(s.data, r);
      if (s.common.async)
        return Promise.resolve(o).then(async (a) => {
          if (n.value === "aborted")
            return Z;
          const l = await this._def.schema._parseAsync({
            data: a,
            path: s.path,
            parent: s
          });
          return l.status === "aborted" ? Z : l.status === "dirty" || n.value === "dirty" ? Ws(l.value) : l;
        });
      {
        if (n.value === "aborted")
          return Z;
        const a = this._def.schema._parseSync({
          data: o,
          path: s.path,
          parent: s
        });
        return a.status === "aborted" ? Z : a.status === "dirty" || n.value === "dirty" ? Ws(a.value) : a;
      }
    }
    if (i.type === "refinement") {
      const o = (a) => {
        const l = i.refinement(a, r);
        if (s.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (s.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return a.status === "aborted" ? Z : (a.status === "dirty" && n.dirty(), o(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((a) => a.status === "aborted" ? Z : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (i.type === "transform")
      if (s.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        if (!ir(o))
          return o;
        const a = i.transform(o.value, r);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((o) => ir(o) ? Promise.resolve(i.transform(o.value, r)).then((a) => ({ status: n.value, value: a })) : o);
    rt.assertNever(i);
  }
}
Ne.create = (e, t, n) => new Ne({
  schema: e,
  typeName: _.ZodEffects,
  effect: t,
  ...tt(n)
});
Ne.createWithPreprocess = (e, t, n) => new Ne({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: _.ZodEffects,
  ...tt(n)
});
class _e extends st {
  _parse(t) {
    return this._getType(t) === Y.undefined ? re(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
_e.create = (e, t) => new _e({
  innerType: e,
  typeName: _.ZodOptional,
  ...tt(t)
});
class Gn extends st {
  _parse(t) {
    return this._getType(t) === Y.null ? re(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Gn.create = (e, t) => new Gn({
  innerType: e,
  typeName: _.ZodNullable,
  ...tt(t)
});
class gr extends st {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let s = n.data;
    return n.parsedType === Y.undefined && (s = this._def.defaultValue()), this._def.innerType._parse({
      data: s,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
gr.create = (e, t) => new gr({
  innerType: e,
  typeName: _.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...tt(t)
});
class mr extends st {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), s = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: s.data,
      path: s.path,
      parent: {
        ...s
      }
    });
    return rr(i) ? i.then((r) => ({
      status: "valid",
      value: r.status === "valid" ? r.value : this._def.catchValue({
        get error() {
          return new be(s.common.issues);
        },
        input: s.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new be(s.common.issues);
        },
        input: s.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
mr.create = (e, t) => new mr({
  innerType: e,
  typeName: _.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...tt(t)
});
class sa extends st {
  _parse(t) {
    if (this._getType(t) !== Y.nan) {
      const s = this._getOrReturnCtx(t);
      return V(s, {
        code: B.invalid_type,
        expected: Y.nan,
        received: s.parsedType
      }), Z;
    }
    return { status: "valid", value: t.data };
  }
}
sa.create = (e) => new sa({
  typeName: _.ZodNaN,
  ...tt(e)
});
const O1 = Symbol("zod_brand");
class Uu extends st {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), s = n.data;
    return this._def.type._parse({
      data: s,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Pr extends st {
  _parse(t) {
    const { status: n, ctx: s } = this._processInputParams(t);
    if (s.common.async)
      return (async () => {
        const r = await this._def.in._parseAsync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return r.status === "aborted" ? Z : r.status === "dirty" ? (n.dirty(), Ws(r.value)) : this._def.out._parseAsync({
          data: r.value,
          path: s.path,
          parent: s
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: s.data,
        path: s.path,
        parent: s
      });
      return i.status === "aborted" ? Z : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: s.path,
        parent: s
      });
    }
  }
  static create(t, n) {
    return new Pr({
      in: t,
      out: n,
      typeName: _.ZodPipeline
    });
  }
}
class Ar extends st {
  _parse(t) {
    const n = this._def.innerType._parse(t), s = (i) => (ir(i) && (i.value = Object.freeze(i.value)), i);
    return rr(n) ? n.then((i) => s(i)) : s(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ar.create = (e, t) => new Ar({
  innerType: e,
  typeName: _.ZodReadonly,
  ...tt(t)
});
function ZA(e, t = {}, n) {
  return e ? ni.create().superRefine((s, i) => {
    var r, o;
    if (!e(s)) {
      const a = typeof t == "function" ? t(s) : typeof t == "string" ? { message: t } : t, l = (o = (r = a.fatal) !== null && r !== void 0 ? r : n) !== null && o !== void 0 ? o : !0, c = typeof a == "string" ? { message: a } : a;
      i.addIssue({ code: "custom", ...c, fatal: l });
    }
  }) : ni.create();
}
const N1 = {
  object: Et.lazycreate
};
var _;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(_ || (_ = {}));
const L1 = (e, t = {
  message: `Input not instance of ${e.name}`
}) => ZA((n) => n instanceof e, t), HA = Be.create, JA = Yn.create, F1 = sa.create, j1 = Wn.create, XA = or.create, V1 = Cs.create, U1 = ta.create, Y1 = ar.create, W1 = lr.create, Q1 = ni.create, G1 = ws.create, K1 = yn.create, z1 = ea.create, _1 = Pe.create, Z1 = Et.create, H1 = Et.strictCreate, J1 = cr.create, X1 = Ba.create, $1 = ur.create, tq = Je.create, eq = dr.create, nq = na.create, sq = Ss.create, iq = Ks.create, rq = hr.create, oq = fr.create, aq = Qn.create, lq = pr.create, cq = si.create, Tf = Ne.create, uq = _e.create, dq = Gn.create, hq = Ne.createWithPreprocess, fq = Pr.create, pq = () => HA().optional(), gq = () => JA().optional(), mq = () => XA().optional(), Aq = {
  string: (e) => Be.create({ ...e, coerce: !0 }),
  number: (e) => Yn.create({ ...e, coerce: !0 }),
  boolean: (e) => or.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Wn.create({ ...e, coerce: !0 }),
  date: (e) => Cs.create({ ...e, coerce: !0 })
}, yq = Z;
var ee = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: ei,
  setErrorMap: y1,
  getErrorMap: Jo,
  makeIssue: Xo,
  EMPTY_PATH: w1,
  addIssueToContext: V,
  ParseStatus: Xt,
  INVALID: Z,
  DIRTY: Ws,
  OK: re,
  isAborted: mc,
  isDirty: Ac,
  isValid: ir,
  isAsync: rr,
  get util() {
    return rt;
  },
  get objectUtil() {
    return gc;
  },
  ZodParsedType: Y,
  getParsedType: Dn,
  ZodType: st,
  datetimeRegex: zA,
  ZodString: Be,
  ZodNumber: Yn,
  ZodBigInt: Wn,
  ZodBoolean: or,
  ZodDate: Cs,
  ZodSymbol: ta,
  ZodUndefined: ar,
  ZodNull: lr,
  ZodAny: ni,
  ZodUnknown: ws,
  ZodNever: yn,
  ZodVoid: ea,
  ZodArray: Pe,
  ZodObject: Et,
  ZodUnion: cr,
  ZodDiscriminatedUnion: Ba,
  ZodIntersection: ur,
  ZodTuple: Je,
  ZodRecord: dr,
  ZodMap: na,
  ZodSet: Ss,
  ZodFunction: Ks,
  ZodLazy: hr,
  ZodLiteral: fr,
  ZodEnum: Qn,
  ZodNativeEnum: pr,
  ZodPromise: si,
  ZodEffects: Ne,
  ZodTransformer: Ne,
  ZodOptional: _e,
  ZodNullable: Gn,
  ZodDefault: gr,
  ZodCatch: mr,
  ZodNaN: sa,
  BRAND: O1,
  ZodBranded: Uu,
  ZodPipeline: Pr,
  ZodReadonly: Ar,
  custom: ZA,
  Schema: st,
  ZodSchema: st,
  late: N1,
  get ZodFirstPartyTypeKind() {
    return _;
  },
  coerce: Aq,
  any: Q1,
  array: _1,
  bigint: j1,
  boolean: XA,
  date: V1,
  discriminatedUnion: X1,
  effect: Tf,
  enum: aq,
  function: iq,
  instanceof: L1,
  intersection: $1,
  lazy: rq,
  literal: oq,
  map: nq,
  nan: F1,
  nativeEnum: lq,
  never: K1,
  null: W1,
  nullable: dq,
  number: JA,
  object: Z1,
  oboolean: mq,
  onumber: gq,
  optional: uq,
  ostring: pq,
  pipeline: fq,
  preprocess: hq,
  promise: cq,
  record: eq,
  set: sq,
  strictObject: H1,
  string: HA,
  symbol: U1,
  transformer: Tf,
  tuple: tq,
  undefined: Y1,
  union: J1,
  unknown: G1,
  void: z1,
  NEVER: yq,
  ZodIssueCode: B,
  quotelessJson: A1,
  ZodError: be
});
function Yu(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function at(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function wq(e, t = []) {
  let n = [];
  function s(r, o) {
    const a = b.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var A;
      const { scope: h, children: f, ...p } = d, g = ((A = h == null ? void 0 : h[e]) == null ? void 0 : A[l]) || a, m = b.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ y.jsx(g.Provider, { value: m, children: f });
    };
    c.displayName = r + "Provider";
    function u(d, h) {
      var g;
      const f = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[l]) || a, p = b.useContext(f);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${r}\``);
    }
    return [c, u];
  }
  const i = () => {
    const r = n.map((o) => b.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || r;
      return b.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [s, bq(i, ...t)];
}
function bq(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const s = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(r) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(r)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return b.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Qt(e) {
  const t = b.useRef(e);
  return b.useEffect(() => {
    t.current = e;
  }), b.useMemo(() => (...n) => {
    var s;
    return (s = t.current) == null ? void 0 : s.call(t, ...n);
  }, []);
}
function fi({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [s, i] = xq({ defaultProp: t, onChange: n }), r = e !== void 0, o = r ? e : s, a = Qt(n), l = b.useCallback(
    (c) => {
      if (r) {
        const d = typeof c == "function" ? c(e) : c;
        d !== e && a(d);
      } else
        i(c);
    },
    [r, e, i, a]
  );
  return [o, l];
}
function xq({
  defaultProp: e,
  onChange: t
}) {
  const n = b.useState(e), [s] = n, i = b.useRef(s), r = Qt(t);
  return b.useEffect(() => {
    i.current !== s && (r(s), i.current = s);
  }, [s, i, r]), n;
}
var vq = b.createContext(void 0);
function Wu(e) {
  const t = b.useContext(vq);
  return e || t || "ltr";
}
function Cq(e) {
  const t = b.useRef({ value: e, previous: e });
  return b.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var oe = globalThis != null && globalThis.document ? b.useLayoutEffect : () => {
};
function $A(e) {
  const [t, n] = b.useState(void 0);
  return oe(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const s = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const r = i[0];
        let o, a;
        if ("borderBoxSize" in r) {
          const l = r.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          o = c.inlineSize, a = c.blockSize;
        } else
          o = e.offsetWidth, a = e.offsetHeight;
        n({ width: o, height: a });
      });
      return s.observe(e, { box: "border-box" }), () => s.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
function Qu(e, t = []) {
  let n = [];
  function s(r, o) {
    const a = b.createContext(o), l = n.length;
    n = [...n, o];
    function c(d) {
      const { scope: h, children: f, ...p } = d, g = (h == null ? void 0 : h[e][l]) || a, m = b.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ y.jsx(g.Provider, { value: m, children: f });
    }
    function u(d, h) {
      const f = (h == null ? void 0 : h[e][l]) || a, p = b.useContext(f);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${r}\``);
    }
    return c.displayName = r + "Provider", [c, u];
  }
  const i = () => {
    const r = n.map((o) => b.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || r;
      return b.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [s, Sq(i, ...t)];
}
function Sq(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const s = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(r) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(r)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return b.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function t0(e) {
  const t = e + "CollectionProvider", [n, s] = Qu(t), [i, r] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (f) => {
    const { scope: p, children: g } = f, m = P.useRef(null), A = P.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ y.jsx(i, { scope: p, itemMap: A, collectionRef: m, children: g });
  };
  o.displayName = t;
  const a = e + "CollectionSlot", l = P.forwardRef(
    (f, p) => {
      const { scope: g, children: m } = f, A = r(a, g), w = ct(p, A.collectionRef);
      return /* @__PURE__ */ y.jsx(ti, { ref: w, children: m });
    }
  );
  l.displayName = a;
  const c = e + "CollectionItemSlot", u = "data-radix-collection-item", d = P.forwardRef(
    (f, p) => {
      const { scope: g, children: m, ...A } = f, w = P.useRef(null), x = ct(p, w), v = r(c, g);
      return P.useEffect(() => (v.itemMap.set(w, { ref: w, ...A }), () => void v.itemMap.delete(w))), /* @__PURE__ */ y.jsx(ti, { [u]: "", ref: x, children: m });
    }
  );
  d.displayName = c;
  function h(f) {
    const p = r(e + "CollectionConsumer", f);
    return P.useCallback(() => {
      const m = p.collectionRef.current;
      if (!m) return [];
      const A = Array.from(m.querySelectorAll(`[${u}]`));
      return Array.from(p.itemMap.values()).sort(
        (v, C) => A.indexOf(v.ref.current) - A.indexOf(C.ref.current)
      );
    }, [p.collectionRef, p.itemMap]);
  }
  return [
    { Provider: o, Slot: l, ItemSlot: d },
    h,
    s
  ];
}
var e0 = ["PageUp", "PageDown"], n0 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], s0 = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, pi = "Slider", [wc, Mq, Eq] = t0(pi), [i0, DF] = wq(pi, [
  Eq
]), [qq, Ia] = i0(pi), r0 = b.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: s = 0,
      max: i = 100,
      step: r = 1,
      orientation: o = "horizontal",
      disabled: a = !1,
      minStepsBetweenThumbs: l = 0,
      defaultValue: c = [s],
      value: u,
      onValueChange: d = () => {
      },
      onValueCommit: h = () => {
      },
      inverted: f = !1,
      form: p,
      ...g
    } = e, m = b.useRef(/* @__PURE__ */ new Set()), A = b.useRef(0), x = o === "horizontal" ? Rq : kq, [v = [], C] = fi({
      prop: u,
      defaultProp: c,
      onChange: (R) => {
        var j;
        (j = [...m.current][A.current]) == null || j.focus(), d(R);
      }
    }), E = b.useRef(v);
    function S(R) {
      const D = Pq(v, R);
      k(R, D);
    }
    function M(R) {
      k(R, A.current);
    }
    function q() {
      const R = E.current[A.current];
      v[A.current] !== R && h(v);
    }
    function k(R, D, { commit: j } = { commit: !1 }) {
      const W = Fq(r), O = jq(Math.round((R - s) / r) * r + s, W), U = Yu(O, [s, i]);
      C((I = []) => {
        const F = Bq(I, U, D);
        if (Lq(F, l * r)) {
          A.current = F.indexOf(U);
          const Q = String(F) !== String(I);
          return Q && j && h(F), Q ? F : I;
        } else
          return I;
      });
    }
    return /* @__PURE__ */ y.jsx(
      qq,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: a,
        min: s,
        max: i,
        valueIndexToChangeRef: A,
        thumbs: m.current,
        values: v,
        orientation: o,
        form: p,
        children: /* @__PURE__ */ y.jsx(wc.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ y.jsx(wc.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ y.jsx(
          x,
          {
            "aria-disabled": a,
            "data-disabled": a ? "" : void 0,
            ...g,
            ref: t,
            onPointerDown: at(g.onPointerDown, () => {
              a || (E.current = v);
            }),
            min: s,
            max: i,
            inverted: f,
            onSlideStart: a ? void 0 : S,
            onSlideMove: a ? void 0 : M,
            onSlideEnd: a ? void 0 : q,
            onHomeKeyDown: () => !a && k(s, 0, { commit: !0 }),
            onEndKeyDown: () => !a && k(i, v.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: R, direction: D }) => {
              if (!a) {
                const O = e0.includes(R.key) || R.shiftKey && n0.includes(R.key) ? 10 : 1, U = A.current, I = v[U], F = r * O * D;
                k(I + F, U, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
r0.displayName = pi;
var [o0, a0] = i0(pi, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), Rq = b.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: s,
      dir: i,
      inverted: r,
      onSlideStart: o,
      onSlideMove: a,
      onSlideEnd: l,
      onStepKeyDown: c,
      ...u
    } = e, [d, h] = b.useState(null), f = ct(t, (x) => h(x)), p = b.useRef(), g = Wu(i), m = g === "ltr", A = m && !r || !m && r;
    function w(x) {
      const v = p.current || d.getBoundingClientRect(), C = [0, v.width], S = Gu(C, A ? [n, s] : [s, n]);
      return p.current = v, S(x - v.left);
    }
    return /* @__PURE__ */ y.jsx(
      o0,
      {
        scope: e.__scopeSlider,
        startEdge: A ? "left" : "right",
        endEdge: A ? "right" : "left",
        direction: A ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ y.jsx(
          l0,
          {
            dir: g,
            "data-orientation": "horizontal",
            ...u,
            ref: f,
            style: {
              ...u.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (x) => {
              const v = w(x.clientX);
              o == null || o(v);
            },
            onSlideMove: (x) => {
              const v = w(x.clientX);
              a == null || a(v);
            },
            onSlideEnd: () => {
              p.current = void 0, l == null || l();
            },
            onStepKeyDown: (x) => {
              const C = s0[A ? "from-left" : "from-right"].includes(x.key);
              c == null || c({ event: x, direction: C ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), kq = b.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: s,
      inverted: i,
      onSlideStart: r,
      onSlideMove: o,
      onSlideEnd: a,
      onStepKeyDown: l,
      ...c
    } = e, u = b.useRef(null), d = ct(t, u), h = b.useRef(), f = !i;
    function p(g) {
      const m = h.current || u.current.getBoundingClientRect(), A = [0, m.height], x = Gu(A, f ? [s, n] : [n, s]);
      return h.current = m, x(g - m.top);
    }
    return /* @__PURE__ */ y.jsx(
      o0,
      {
        scope: e.__scopeSlider,
        startEdge: f ? "bottom" : "top",
        endEdge: f ? "top" : "bottom",
        size: "height",
        direction: f ? 1 : -1,
        children: /* @__PURE__ */ y.jsx(
          l0,
          {
            "data-orientation": "vertical",
            ...c,
            ref: d,
            style: {
              ...c.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (g) => {
              const m = p(g.clientY);
              r == null || r(m);
            },
            onSlideMove: (g) => {
              const m = p(g.clientY);
              o == null || o(m);
            },
            onSlideEnd: () => {
              h.current = void 0, a == null || a();
            },
            onStepKeyDown: (g) => {
              const A = s0[f ? "from-bottom" : "from-top"].includes(g.key);
              l == null || l({ event: g, direction: A ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), l0 = b.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: s,
      onSlideMove: i,
      onSlideEnd: r,
      onHomeKeyDown: o,
      onEndKeyDown: a,
      onStepKeyDown: l,
      ...c
    } = e, u = Ia(pi, n);
    return /* @__PURE__ */ y.jsx(
      ut.span,
      {
        ...c,
        ref: t,
        onKeyDown: at(e.onKeyDown, (d) => {
          d.key === "Home" ? (o(d), d.preventDefault()) : d.key === "End" ? (a(d), d.preventDefault()) : e0.concat(n0).includes(d.key) && (l(d), d.preventDefault());
        }),
        onPointerDown: at(e.onPointerDown, (d) => {
          const h = d.target;
          h.setPointerCapture(d.pointerId), d.preventDefault(), u.thumbs.has(h) ? h.focus() : s(d);
        }),
        onPointerMove: at(e.onPointerMove, (d) => {
          d.target.hasPointerCapture(d.pointerId) && i(d);
        }),
        onPointerUp: at(e.onPointerUp, (d) => {
          const h = d.target;
          h.hasPointerCapture(d.pointerId) && (h.releasePointerCapture(d.pointerId), r(d));
        })
      }
    );
  }
), c0 = "SliderTrack", u0 = b.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...s } = e, i = Ia(c0, n);
    return /* @__PURE__ */ y.jsx(
      ut.span,
      {
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": i.orientation,
        ...s,
        ref: t
      }
    );
  }
);
u0.displayName = c0;
var bc = "SliderRange", d0 = b.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...s } = e, i = Ia(bc, n), r = a0(bc, n), o = b.useRef(null), a = ct(t, o), l = i.values.length, c = i.values.map(
      (h) => f0(h, i.min, i.max)
    ), u = l > 1 ? Math.min(...c) : 0, d = 100 - Math.max(...c);
    return /* @__PURE__ */ y.jsx(
      ut.span,
      {
        "data-orientation": i.orientation,
        "data-disabled": i.disabled ? "" : void 0,
        ...s,
        ref: a,
        style: {
          ...e.style,
          [r.startEdge]: u + "%",
          [r.endEdge]: d + "%"
        }
      }
    );
  }
);
d0.displayName = bc;
var xc = "SliderThumb", h0 = b.forwardRef(
  (e, t) => {
    const n = Mq(e.__scopeSlider), [s, i] = b.useState(null), r = ct(t, (a) => i(a)), o = b.useMemo(
      () => s ? n().findIndex((a) => a.ref.current === s) : -1,
      [n, s]
    );
    return /* @__PURE__ */ y.jsx(Tq, { ...e, ref: r, index: o });
  }
), Tq = b.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: s, name: i, ...r } = e, o = Ia(xc, n), a = a0(xc, n), [l, c] = b.useState(null), u = ct(t, (w) => c(w)), d = l ? o.form || !!l.closest("form") : !0, h = $A(l), f = o.values[s], p = f === void 0 ? 0 : f0(f, o.min, o.max), g = Iq(s, o.values.length), m = h == null ? void 0 : h[a.size], A = m ? Oq(m, p, a.direction) : 0;
    return b.useEffect(() => {
      if (l)
        return o.thumbs.add(l), () => {
          o.thumbs.delete(l);
        };
    }, [l, o.thumbs]), /* @__PURE__ */ y.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [a.startEdge]: `calc(${p}% + ${A}px)`
        },
        children: [
          /* @__PURE__ */ y.jsx(wc.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ y.jsx(
            ut.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || g,
              "aria-valuemin": o.min,
              "aria-valuenow": f,
              "aria-valuemax": o.max,
              "aria-orientation": o.orientation,
              "data-orientation": o.orientation,
              "data-disabled": o.disabled ? "" : void 0,
              tabIndex: o.disabled ? void 0 : 0,
              ...r,
              ref: u,
              style: f === void 0 ? { display: "none" } : e.style,
              onFocus: at(e.onFocus, () => {
                o.valueIndexToChangeRef.current = s;
              })
            }
          ) }),
          d && /* @__PURE__ */ y.jsx(
            Dq,
            {
              name: i ?? (o.name ? o.name + (o.values.length > 1 ? "[]" : "") : void 0),
              form: o.form,
              value: f
            },
            s
          )
        ]
      }
    );
  }
);
h0.displayName = xc;
var Dq = (e) => {
  const { value: t, ...n } = e, s = b.useRef(null), i = Cq(t);
  return b.useEffect(() => {
    const r = s.current, o = window.HTMLInputElement.prototype, l = Object.getOwnPropertyDescriptor(o, "value").set;
    if (i !== t && l) {
      const c = new Event("input", { bubbles: !0 });
      l.call(r, t), r.dispatchEvent(c);
    }
  }, [i, t]), /* @__PURE__ */ y.jsx("input", { style: { display: "none" }, ...n, ref: s, defaultValue: t });
};
function Bq(e = [], t, n) {
  const s = [...e];
  return s[n] = t, s.sort((i, r) => i - r);
}
function f0(e, t, n) {
  const r = 100 / (n - t) * (e - t);
  return Yu(r, [0, 100]);
}
function Iq(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function Pq(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((i) => Math.abs(i - t)), s = Math.min(...n);
  return n.indexOf(s);
}
function Oq(e, t, n) {
  const s = e / 2, r = Gu([0, 50], [0, s]);
  return (s - r(t) * n) * n;
}
function Nq(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function Lq(e, t) {
  if (t > 0) {
    const n = Nq(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Gu(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const s = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + s * (n - e[0]);
  };
}
function Fq(e) {
  return (String(e).split(".")[1] || "").length;
}
function jq(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var p0 = r0, Vq = u0, Uq = d0, Yq = h0;
const vc = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsxs(
  p0,
  {
    ref: n,
    className: At(
      "relative flex w-full touch-none select-none items-center",
      e
    ),
    ...t,
    children: [
      /* @__PURE__ */ y.jsx(Vq, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-gray-300", children: /* @__PURE__ */ y.jsx(Uq, { className: "absolute h-full bg-brand" }) }),
      /* @__PURE__ */ y.jsx(Yq, { className: `block h-4 w-4 rounded-full bg-white ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disable
d:pointer-events-none disabled:opacity-50 cursor-pointer` })
    ]
  }
));
vc.displayName = p0.displayName;
function Wq({
  handleStartGame: e,
  handleCashout: t
}) {
  const {
    isGameActive: n,
    balance: s,
    selectedCurrency: i,
    initializing: r,
    isAutoPlaying: o,
    currentAutoBet: a,
    betRanges: l
  } = ze(), { multiplier: c, selectedCells: u } = ju(), {
    updateSettings: d,
    mode: h,
    betAmount: f,
    stopOnWin: p,
    stopOnLoss: g,
    numberOfBets: m,
    onWinMode: A,
    onLossMode: w,
    onWinValue: x,
    onLossValue: v,
    minesCount: C
  } = Vu(), E = (G) => G.toFixed(i.fractionalDigits), [S, M] = ie(
    E(f)
  ), [q, k] = ie(null), [R, D] = ie({});
  Lt(() => {
    M(E(f));
  }, [i, f]);
  const j = ee.object({
    mode: ee.enum(["manual", "auto"]),
    betAmount: ee.number().min(l.minBet, `Your bet must be at least ${i.prefixSymbol} ${l.minBet}`).max(l.maxBet, `Your bet must be at least ${l.maxBet}`),
    minesCount: ee.number().int().min(1).max(24, "Mines count must be between 1 and 24"),
    stopOnWin: ee.number().nonnegative("Stop on win must be non-negative").max(s, "You don't have enough balance."),
    stopOnLoss: ee.number().nonnegative("Stop on loss must be non-negative"),
    numberOfBets: ee.union([
      ee.literal("∞"),
      ee.string().refine(
        (G) => !isNaN(Number(G)) && Number(G) > 0 && Number(G) <= 1e3,
        {
          message: "Number of bets must be a positive number up to 1000 or '∞'"
        }
      ),
      ee.number().int().positive().max(1e3, "Maximum 1000")
    ]).transform((G) => G === "∞" ? G : Number(G)),
    onWinMode: ee.enum(["reset", "increase"]),
    onLossMode: ee.enum(["reset", "increase"]),
    onWinValue: ee.number().nonnegative("Cannot be less than 0"),
    onLossValue: ee.number().nonnegative("Cannot be less than 0")
  }), W = () => {
    try {
      return j.parse({
        mode: h,
        betAmount: f,
        minesCount: C,
        stopOnWin: p,
        stopOnLoss: g,
        numberOfBets: m,
        onWinMode: A,
        onLossMode: w,
        onWinValue: x,
        onLossValue: v
      }), D({}), !0;
    } catch (G) {
      if (G instanceof ee.ZodError) {
        const Gt = {};
        G.issues.forEach((ae) => {
          ae.path[0] && (Gt[ae.path[0]] = ae.message);
        }), D(Gt);
      }
      return !1;
    }
  }, O = (G, Gt, ae = !1) => {
    ae && Tn("tick"), d({ [G]: Gt });
  }, U = (G) => {
    M(G.target.value);
  }, I = () => {
    const G = parseFloat(S);
    isNaN(G) ? M(E(f)) : (O("betAmount", G), M(E(G))), k(null);
  }, F = async () => {
    W() && !n && e();
  }, Q = () => o ? m === "∞" ? "Stop autobet" : `Stop autobet (${a} / ${m})` : n ? `Cash out $${c.toFixed(2)}x` : h === "auto" ? u.length > 0 ? "Start Autobet" : "Select cells to start" : "Place bet", J = (G) => `
    flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200
    ${q === G ? "ring-1 ring-brand" : ""}`, lt = "flex-grow bg-transparent border-none text-white text-sm h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0", Vt = "h-9 w-16 px-2 text-sm bg-pills text-white hover:bg-opacity-80 font-bold", Pt = "flex items-center space-x-1 bg-primary rounded-md p-1 h-11 w-1/2", kt = "flex-1 px-1 py-2 rounded text-xs font-bold whitespace-nowrap overflow-hidden", Ut = "[&>.sliderTrack]:bg-red-500 [&>.sliderTrack]:h-1 [&>.sliderThumb]:h-4 [&>.sliderThumb]:w-2", gt = n || o;
  return /* @__PURE__ */ y.jsxs("div", { className: "bg-secondary flex flex-col no-scrollbar w-full lg:w-1/3 p-4 space-y-4 order-2 lg:order-1 overflow-y-auto", children: [
    /* @__PURE__ */ y.jsxs("div", { className: `bg-primary order-last lg:order-first p-2 rounded-md flex mt-4 lg:mb-4 lg:mt-0 ${gt ? "opacity-50 pointer-events-none" : ""}`, children: [
      /* @__PURE__ */ y.jsx(
        "button",
        {
          onClick: () => O("mode", "manual", !0),
          disabled: n && h !== "manual",
          className: `flex-1 py-2 px-4 text-sm font-bold rounded-md transition-all ${h === "manual" ? "bg-brand text-black" : "text-gray-400 hover:text-white"}`,
          children: "Manual"
        }
      ),
      /* @__PURE__ */ y.jsx(
        "button",
        {
          onClick: () => O("mode", "auto", !0),
          disabled: n && h !== "auto",
          className: `flex-1 py-2 px-4 text-sm font-bold rounded-md transition-all ${h === "auto" ? "bg-brand text-black" : "text-gray-400 hover:text-white"}`,
          children: "Auto"
        }
      )
    ] }),
    /* @__PURE__ */ y.jsxs("div", { className: `space-y-2 ${gt ? "opacity-50 pointer-events-none" : ""}`, children: [
      /* @__PURE__ */ y.jsx(ne, { htmlFor: "betAmount", className: "text-sm text-gray-400", children: "Bet amount" }),
      /* @__PURE__ */ y.jsx("div", { className: J("betAmount"), children: r ? /* @__PURE__ */ y.jsxs("div", { className: "flex items-center w-full space-x-2", children: [
        /* @__PURE__ */ y.jsx(zi, { className: "h-9 w-full bg-gray-700" }),
        /* @__PURE__ */ y.jsx(zi, { className: "h-9 w-16 bg-gray-700" }),
        /* @__PURE__ */ y.jsx(zi, { className: "h-9 w-16 bg-gray-700" })
      ] }) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
        /* @__PURE__ */ y.jsxs("div", { className: "flex items-center w-full bg-primary rounded-md px-2", children: [
          /* @__PURE__ */ y.jsx("span", { className: "text-gray-400 mr-1", children: i.prefixSymbol }),
          /* @__PURE__ */ y.jsx(
            ye,
            {
              id: "betAmount",
              type: "number",
              value: S,
              onChange: U,
              onFocus: () => k("betAmount"),
              onBlur: I,
              className: lt,
              style: {
                WebkitAppearance: "none",
                MozAppearance: "textfield"
              },
              step: `0.${"0".repeat(
                i.fractionalDigits - 1
              )}1`
            }
          )
        ] }),
        /* @__PURE__ */ y.jsx(
          se,
          {
            variant: "ghost",
            size: "sm",
            className: Vt,
            onClick: () => {
              const G = Math.max(f / 2, 0);
              O("betAmount", G, !0), M(E(G));
            },
            children: "½"
          }
        ),
        /* @__PURE__ */ y.jsx(
          se,
          {
            variant: "ghost",
            size: "sm",
            className: Vt,
            onClick: () => {
              const G = f * 2;
              O("betAmount", G, !0), M(E(G));
            },
            children: "2×"
          }
        )
      ] }) }),
      R.betAmount && /* @__PURE__ */ y.jsx("span", { className: "text-red-500 text-xs", children: R.betAmount })
    ] }),
    /* @__PURE__ */ y.jsxs("div", { className: `space-y-2 ${gt ? "opacity-50 pointer-events-none" : ""}`, children: [
      /* @__PURE__ */ y.jsx(ne, { className: "text-sm text-gray-400", children: "Mines" }),
      /* @__PURE__ */ y.jsxs("div", { className: "flex items-center space-x-3 bg-primary rounded-md p-3 h-11", children: [
        /* @__PURE__ */ y.jsx("img", { src: jA, width: "20", height: "20" }),
        /* @__PURE__ */ y.jsx(
          vc,
          {
            value: [C],
            onValueChange: (G) => O("minesCount", G[0], !1),
            min: 1,
            max: 24,
            step: 1,
            disabled: gt,
            className: Ut
          }
        ),
        /* @__PURE__ */ y.jsx("span", { className: "text-white font-bold bg-secondary rounded-md px-2 py-1 min-w-[2rem] text-center text-sm", children: C })
      ] }),
      R.minesCount && /* @__PURE__ */ y.jsx("span", { className: "text-red-500 text-xs", children: R.minesCount })
    ] }),
    /* @__PURE__ */ y.jsxs("div", { className: `space-y-2 ${gt ? "opacity-50 pointer-events-none" : ""}`, children: [
      /* @__PURE__ */ y.jsx(ne, { className: "text-sm text-gray-400", children: "Gems" }),
      /* @__PURE__ */ y.jsxs("div", { className: "flex items-center space-x-3 bg-[#07182c] rounded-md p-3 h-11", children: [
        /* @__PURE__ */ y.jsx("img", { src: FA, width: "20", height: "20" }),
        /* @__PURE__ */ y.jsx(
          vc,
          {
            value: [25 - C],
            onValueChange: (G) => O("minesCount", 25 - G[0], !1),
            min: 1,
            max: 24,
            step: 1,
            className: Ut,
            disabled: gt
          }
        ),
        /* @__PURE__ */ y.jsx("span", { className: "text-white font-bold bg-pills rounded-md px-2 py-1 min-w-[2rem] text-center text-sm", children: 25 - C })
      ] })
    ] }),
    /* @__PURE__ */ y.jsx(
      "div",
      {
        className: "space-y-4 transition-all duration-300 ease-in-out",
        style: {
          maxHeight: h === "auto" ? "100%" : "0%",
          overflow: h === "auto" ? "visible" : "hidden"
        },
        children: h === "auto" && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsxs("div", { className: `space-y-2 ${gt ? "opacity-50 pointer-events-none" : ""}`, children: [
            /* @__PURE__ */ y.jsx(ne, { htmlFor: "numberOfBets", className: "text-sm text-gray-400", children: "Number of Bets" }),
            /* @__PURE__ */ y.jsxs("div", { className: J("numberOfBets"), children: [
              /* @__PURE__ */ y.jsx(
                ye,
                {
                  id: "numberOfBets",
                  value: m,
                  onChange: (G) => O("numberOfBets", G.target.value, !1),
                  onFocus: () => k("numberOfBets"),
                  onBlur: () => k(null),
                  className: lt
                }
              ),
              ["∞", "10", "100"].map((G) => /* @__PURE__ */ y.jsx(
                se,
                {
                  variant: m === G ? "secondary" : "ghost",
                  onClick: () => O("numberOfBets", G, !0),
                  className: Vt,
                  children: G
                },
                G
              ))
            ] }),
            R.numberOfBets && /* @__PURE__ */ y.jsx("span", { className: "text-red-500 text-xs", children: R.numberOfBets })
          ] }),
          /* @__PURE__ */ y.jsxs("div", { className: `space-y-2 ${gt ? "opacity-50 pointer-events-none" : ""}`, children: [
            /* @__PURE__ */ y.jsx(ne, { className: "text-sm text-gray-400", children: "On Win" }),
            /* @__PURE__ */ y.jsxs("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ y.jsxs("div", { className: Pt, children: [
                /* @__PURE__ */ y.jsx(
                  "button",
                  {
                    onClick: () => O("onWinMode", "reset", !0),
                    className: `${kt} ${A === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                    children: "Reset"
                  }
                ),
                /* @__PURE__ */ y.jsx(
                  "button",
                  {
                    onClick: () => O("onWinMode", "increase", !0),
                    className: `${kt} ${A === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                    children: "Increase by"
                  }
                )
              ] }),
              /* @__PURE__ */ y.jsxs(
                "div",
                {
                  className: `${J("onWinValue")} ${A === "reset" ? "opacity-50" : ""} flex-1`,
                  children: [
                    /* @__PURE__ */ y.jsx(
                      ye,
                      {
                        type: "number",
                        value: x,
                        onChange: (G) => O(
                          "onWinValue",
                          parseFloat(G.target.value)
                        ),
                        onFocus: () => k("onWinValue"),
                        onBlur: () => k(null),
                        className: lt,
                        disabled: A === "reset",
                        style: {
                          WebkitAppearance: "none",
                          MozAppearance: "textfield"
                        }
                      }
                    ),
                    /* @__PURE__ */ y.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                  ]
                }
              )
            ] }),
            R.onWinValue && /* @__PURE__ */ y.jsx("span", { className: "text-red-500 text-xs", children: R.onWinValue })
          ] }),
          /* @__PURE__ */ y.jsxs("div", { className: `space-y-2 ${gt ? "opacity-50 pointer-events-none" : ""}`, children: [
            /* @__PURE__ */ y.jsx(ne, { className: "text-sm text-gray-400", children: "On Loss" }),
            /* @__PURE__ */ y.jsxs("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ y.jsxs("div", { className: Pt, children: [
                /* @__PURE__ */ y.jsx(
                  "button",
                  {
                    onClick: () => O("onLossMode", "reset", !0),
                    className: `${kt} ${w === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                    children: "Reset"
                  }
                ),
                /* @__PURE__ */ y.jsx(
                  "button",
                  {
                    onClick: () => O("onLossMode", "increase", !0),
                    className: `${kt} ${w === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                    children: "Increase by"
                  }
                )
              ] }),
              /* @__PURE__ */ y.jsxs(
                "div",
                {
                  className: `${J("onLossValue")} ${w === "reset" ? "opacity-50" : ""} flex-1`,
                  children: [
                    /* @__PURE__ */ y.jsx(
                      ye,
                      {
                        type: "number",
                        value: v,
                        onChange: (G) => O(
                          "onLossValue",
                          parseFloat(G.target.value)
                        ),
                        onFocus: () => k("onLossValue"),
                        onBlur: () => k(null),
                        className: lt,
                        disabled: w === "reset",
                        style: {
                          WebkitAppearance: "none",
                          MozAppearance: "textfield"
                        }
                      }
                    ),
                    /* @__PURE__ */ y.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                  ]
                }
              )
            ] }),
            R.onLossValue && /* @__PURE__ */ y.jsx("span", { className: "text-red-500 text-xs", children: R.onLossValue })
          ] }),
          /* @__PURE__ */ y.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ y.jsx(ne, { htmlFor: "stopOnWin", className: "text-sm text-gray-400", children: "Stop on Win" }),
            /* @__PURE__ */ y.jsx("div", { className: J("stopOnWin"), children: /* @__PURE__ */ y.jsx(
              ye,
              {
                id: "stopOnWin",
                type: "number",
                value: p,
                onChange: (G) => O("stopOnWin", parseFloat(G.target.value)),
                onFocus: () => k("stopOnWin"),
                onBlur: () => k(null),
                className: lt,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] }),
          /* @__PURE__ */ y.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ y.jsx(ne, { htmlFor: "stopOnLoss", className: "text-sm text-gray-400", children: "Stop on Loss" }),
            /* @__PURE__ */ y.jsx("div", { className: J("stopOnLoss"), children: /* @__PURE__ */ y.jsx(
              ye,
              {
                id: "stopOnLoss",
                type: "number",
                value: g,
                onChange: (G) => O(
                  "stopOnLoss",
                  parseFloat(G.target.value)
                ),
                onFocus: () => k("stopOnLoss"),
                onBlur: () => k(null),
                className: lt,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ y.jsx("div", { className: "lg:sticky lg:bottom-0 order-first lg:order-last bg-gray-850", children: /* @__PURE__ */ y.jsx(
      se,
      {
        className: "w-full bg-brand hover:bg-brand/80 disabled:opacity-80 text-black text-sm font-bold py-4 rounded-lg h-11",
        onClick: n || o ? t : F,
        disabled: h === "auto" && u.length === 0 && !n && !o,
        children: Q()
      }
    ) })
  ] });
}
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Qq = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), g0 = (...e) => e.filter((t, n, s) => !!t && s.indexOf(t) === n).join(" ");
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Gq = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Kq = kr(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: s,
    className: i = "",
    children: r,
    iconNode: o,
    ...a
  }, l) => Fn(
    "svg",
    {
      ref: l,
      ...Gq,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: s ? Number(n) * 24 / Number(t) : n,
      className: g0("lucide", i),
      ...a
    },
    [
      ...o.map(([c, u]) => Fn(c, u)),
      ...Array.isArray(r) ? r : [r]
    ]
  )
);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ts = (e, t) => {
  const n = kr(
    ({ className: s, ...i }, r) => Fn(Kq, {
      ref: r,
      iconNode: t,
      className: g0(`lucide-${Qq(e)}`, s),
      ...i
    })
  );
  return n.displayName = `${e}`, n;
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const m0 = ts("ChartLine", [
  ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }],
  ["path", { d: "m19 9-5 5-4-4-3 3", key: "2osh9i" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Df = ts("CircleHelp", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zq = ts("RefreshCcw", [
  ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
  ["path", { d: "M16 16h5v5", key: "ccwih5" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _q = ts("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bf = ts("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Zq = ts("Volume2", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
  ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Hq = ts("VolumeX", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["line", { x1: "22", x2: "16", y1: "9", y2: "15", key: "1ewh16" }],
  ["line", { x1: "16", x2: "22", y1: "9", y2: "15", key: "5ykzw1" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jq = ts("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
function Xq(e, t) {
  const n = b.createContext(t), s = (r) => {
    const { children: o, ...a } = r, l = b.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ y.jsx(n.Provider, { value: l, children: o });
  };
  s.displayName = e + "Provider";
  function i(r) {
    const o = b.useContext(n);
    if (o) return o;
    if (t !== void 0) return t;
    throw new Error(`\`${r}\` must be used within \`${e}\``);
  }
  return [s, i];
}
function $q(e, t = []) {
  let n = [];
  function s(r, o) {
    const a = b.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var A;
      const { scope: h, children: f, ...p } = d, g = ((A = h == null ? void 0 : h[e]) == null ? void 0 : A[l]) || a, m = b.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ y.jsx(g.Provider, { value: m, children: f });
    };
    c.displayName = r + "Provider";
    function u(d, h) {
      var g;
      const f = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[l]) || a, p = b.useContext(f);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${r}\``);
    }
    return [c, u];
  }
  const i = () => {
    const r = n.map((o) => b.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || r;
      return b.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [s, tR(i, ...t)];
}
function tR(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const s = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(r) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(r)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return b.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var eR = b.useId || (() => {
}), nR = 0;
function zs(e) {
  const [t, n] = b.useState(eR());
  return oe(() => {
    n((s) => s ?? String(nR++));
  }, [e]), t ? `radix-${t}` : "";
}
function A0(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qt(e);
  b.useEffect(() => {
    const s = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", s, { capture: !0 }), () => t.removeEventListener("keydown", s, { capture: !0 });
  }, [n, t]);
}
var sR = "DismissableLayer", Cc = "dismissableLayer.update", iR = "dismissableLayer.pointerDownOutside", rR = "dismissableLayer.focusOutside", If, y0 = b.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), w0 = b.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: s,
      onPointerDownOutside: i,
      onFocusOutside: r,
      onInteractOutside: o,
      onDismiss: a,
      ...l
    } = e, c = b.useContext(y0), [u, d] = b.useState(null), h = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, f] = b.useState({}), p = ct(t, (S) => d(S)), g = Array.from(c.layers), [m] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), A = g.indexOf(m), w = u ? g.indexOf(u) : -1, x = c.layersWithOutsidePointerEventsDisabled.size > 0, v = w >= A, C = lR((S) => {
      const M = S.target, q = [...c.branches].some((k) => k.contains(M));
      !v || q || (i == null || i(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, h), E = cR((S) => {
      const M = S.target;
      [...c.branches].some((k) => k.contains(M)) || (r == null || r(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, h);
    return A0((S) => {
      w === c.layers.size - 1 && (s == null || s(S), !S.defaultPrevented && a && (S.preventDefault(), a()));
    }, h), b.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (If = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), Pf(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = If);
        };
    }, [u, h, n, c]), b.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), Pf());
    }, [u, c]), b.useEffect(() => {
      const S = () => f({});
      return document.addEventListener(Cc, S), () => document.removeEventListener(Cc, S);
    }, []), /* @__PURE__ */ y.jsx(
      ut.div,
      {
        ...l,
        ref: p,
        style: {
          pointerEvents: x ? v ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: at(e.onFocusCapture, E.onFocusCapture),
        onBlurCapture: at(e.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: at(
          e.onPointerDownCapture,
          C.onPointerDownCapture
        )
      }
    );
  }
);
w0.displayName = sR;
var oR = "DismissableLayerBranch", aR = b.forwardRef((e, t) => {
  const n = b.useContext(y0), s = b.useRef(null), i = ct(t, s);
  return b.useEffect(() => {
    const r = s.current;
    if (r)
      return n.branches.add(r), () => {
        n.branches.delete(r);
      };
  }, [n.branches]), /* @__PURE__ */ y.jsx(ut.div, { ...e, ref: i });
});
aR.displayName = oR;
function lR(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qt(e), s = b.useRef(!1), i = b.useRef(() => {
  });
  return b.useEffect(() => {
    const r = (a) => {
      if (a.target && !s.current) {
        let l = function() {
          b0(
            iR,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", i.current);
      s.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", r);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", r), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => s.current = !0
  };
}
function cR(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qt(e), s = b.useRef(!1);
  return b.useEffect(() => {
    const i = (r) => {
      r.target && !s.current && b0(rR, n, { originalEvent: r }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => s.current = !0,
    onBlurCapture: () => s.current = !1
  };
}
function Pf() {
  const e = new CustomEvent(Cc);
  document.dispatchEvent(e);
}
function b0(e, t, n, { discrete: s }) {
  const i = n.originalEvent.target, r = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), s ? VA(i, r) : i.dispatchEvent(r);
}
var xl = "focusScope.autoFocusOnMount", vl = "focusScope.autoFocusOnUnmount", Of = { bubbles: !1, cancelable: !0 }, uR = "FocusScope", x0 = b.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: s = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: r,
    ...o
  } = e, [a, l] = b.useState(null), c = Qt(i), u = Qt(r), d = b.useRef(null), h = ct(t, (g) => l(g)), f = b.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  b.useEffect(() => {
    if (s) {
      let g = function(x) {
        if (f.paused || !a) return;
        const v = x.target;
        a.contains(v) ? d.current = v : kn(d.current, { select: !0 });
      }, m = function(x) {
        if (f.paused || !a) return;
        const v = x.relatedTarget;
        v !== null && (a.contains(v) || kn(d.current, { select: !0 }));
      }, A = function(x) {
        if (document.activeElement === document.body)
          for (const C of x)
            C.removedNodes.length > 0 && kn(a);
      };
      document.addEventListener("focusin", g), document.addEventListener("focusout", m);
      const w = new MutationObserver(A);
      return a && w.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", g), document.removeEventListener("focusout", m), w.disconnect();
      };
    }
  }, [s, a, f.paused]), b.useEffect(() => {
    if (a) {
      Lf.add(f);
      const g = document.activeElement;
      if (!a.contains(g)) {
        const A = new CustomEvent(xl, Of);
        a.addEventListener(xl, c), a.dispatchEvent(A), A.defaultPrevented || (dR(mR(v0(a)), { select: !0 }), document.activeElement === g && kn(a));
      }
      return () => {
        a.removeEventListener(xl, c), setTimeout(() => {
          const A = new CustomEvent(vl, Of);
          a.addEventListener(vl, u), a.dispatchEvent(A), A.defaultPrevented || kn(g ?? document.body, { select: !0 }), a.removeEventListener(vl, u), Lf.remove(f);
        }, 0);
      };
    }
  }, [a, c, u, f]);
  const p = b.useCallback(
    (g) => {
      if (!n && !s || f.paused) return;
      const m = g.key === "Tab" && !g.altKey && !g.ctrlKey && !g.metaKey, A = document.activeElement;
      if (m && A) {
        const w = g.currentTarget, [x, v] = hR(w);
        x && v ? !g.shiftKey && A === v ? (g.preventDefault(), n && kn(x, { select: !0 })) : g.shiftKey && A === x && (g.preventDefault(), n && kn(v, { select: !0 })) : A === w && g.preventDefault();
      }
    },
    [n, s, f.paused]
  );
  return /* @__PURE__ */ y.jsx(ut.div, { tabIndex: -1, ...o, ref: h, onKeyDown: p });
});
x0.displayName = uR;
function dR(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const s of e)
    if (kn(s, { select: t }), document.activeElement !== n) return;
}
function hR(e) {
  const t = v0(e), n = Nf(t, e), s = Nf(t.reverse(), e);
  return [n, s];
}
function v0(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (s) => {
      const i = s.tagName === "INPUT" && s.type === "hidden";
      return s.disabled || s.hidden || i ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Nf(e, t) {
  for (const n of e)
    if (!fR(n, { upTo: t })) return n;
}
function fR(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function pR(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function kn(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && pR(e) && t && e.select();
  }
}
var Lf = gR();
function gR() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = Ff(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = Ff(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function Ff(e, t) {
  const n = [...e], s = n.indexOf(t);
  return s !== -1 && n.splice(s, 1), n;
}
function mR(e) {
  return e.filter((t) => t.tagName !== "A");
}
var AR = "Portal", C0 = b.forwardRef((e, t) => {
  var a;
  const { container: n, ...s } = e, [i, r] = b.useState(!1);
  oe(() => r(!0), []);
  const o = n || i && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
  return o ? Zg.createPortal(/* @__PURE__ */ y.jsx(ut.div, { ...s, ref: t }), o) : null;
});
C0.displayName = AR;
function yR(e, t) {
  return b.useReducer((n, s) => t[n][s] ?? n, e);
}
var Pa = (e) => {
  const { present: t, children: n } = e, s = wR(t), i = typeof n == "function" ? n({ present: s.isPresent }) : b.Children.only(n), r = ct(s.ref, bR(i));
  return typeof n == "function" || s.isPresent ? b.cloneElement(i, { ref: r }) : null;
};
Pa.displayName = "Presence";
function wR(e) {
  const [t, n] = b.useState(), s = b.useRef({}), i = b.useRef(e), r = b.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = yR(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return b.useEffect(() => {
    const c = Hr(s.current);
    r.current = a === "mounted" ? c : "none";
  }, [a]), oe(() => {
    const c = s.current, u = i.current;
    if (u !== e) {
      const h = r.current, f = Hr(c);
      e ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && h !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), oe(() => {
    if (t) {
      let c;
      const u = t.ownerDocument.defaultView ?? window, d = (f) => {
        const g = Hr(s.current).includes(f.animationName);
        if (f.target === t && g && (l("ANIMATION_END"), !i.current)) {
          const m = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = m);
          });
        }
      }, h = (f) => {
        f.target === t && (r.current = Hr(s.current));
      };
      return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
        u.clearTimeout(c), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: b.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function Hr(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function bR(e) {
  var s, i;
  let t = (s = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Cl = 0;
function xR() {
  b.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? jf()), document.body.insertAdjacentElement("beforeend", e[1] ?? jf()), Cl++, () => {
      Cl === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Cl--;
    };
  }, []);
}
function jf() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Qe = function() {
  return Qe = Object.assign || function(t) {
    for (var n, s = 1, i = arguments.length; s < i; s++) {
      n = arguments[s];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Qe.apply(this, arguments);
};
function S0(e, t) {
  var n = {};
  for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, s = Object.getOwnPropertySymbols(e); i < s.length; i++)
      t.indexOf(s[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[i]) && (n[s[i]] = e[s[i]]);
  return n;
}
function vR(e, t, n) {
  if (n || arguments.length === 2) for (var s = 0, i = t.length, r; s < i; s++)
    (r || !(s in t)) && (r || (r = Array.prototype.slice.call(t, 0, s)), r[s] = t[s]);
  return e.concat(r || Array.prototype.slice.call(t));
}
var Eo = "right-scroll-bar-position", qo = "width-before-scroll-bar", CR = "with-scroll-bars-hidden", SR = "--removed-body-scroll-bar-size";
function Sl(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function MR(e, t) {
  var n = ie(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(s) {
          var i = n.value;
          i !== s && (n.value = s, n.callback(s, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var ER = typeof window < "u" ? b.useLayoutEffect : b.useEffect, Vf = /* @__PURE__ */ new WeakMap();
function qR(e, t) {
  var n = MR(null, function(s) {
    return e.forEach(function(i) {
      return Sl(i, s);
    });
  });
  return ER(function() {
    var s = Vf.get(n);
    if (s) {
      var i = new Set(s), r = new Set(e), o = n.current;
      i.forEach(function(a) {
        r.has(a) || Sl(a, null);
      }), r.forEach(function(a) {
        i.has(a) || Sl(a, o);
      });
    }
    Vf.set(n, e);
  }, [e]), n;
}
function RR(e) {
  return e;
}
function kR(e, t) {
  t === void 0 && (t = RR);
  var n = [], s = !1, i = {
    read: function() {
      if (s)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(r) {
      var o = t(r, s);
      return n.push(o), function() {
        n = n.filter(function(a) {
          return a !== o;
        });
      };
    },
    assignSyncMedium: function(r) {
      for (s = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(r);
      }
      n = {
        push: function(a) {
          return r(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(r) {
      s = !0;
      var o = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(r), o = n;
      }
      var l = function() {
        var u = o;
        o = [], u.forEach(r);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          o.push(u), c();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return i;
}
function TR(e) {
  e === void 0 && (e = {});
  var t = kR(null);
  return t.options = Qe({ async: !0, ssr: !1 }, e), t;
}
var M0 = function(e) {
  var t = e.sideCar, n = S0(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var s = t.read();
  if (!s)
    throw new Error("Sidecar medium not found");
  return b.createElement(s, Qe({}, n));
};
M0.isSideCarExport = !0;
function DR(e, t) {
  return e.useMedium(t), M0;
}
var E0 = TR(), Ml = function() {
}, Oa = b.forwardRef(function(e, t) {
  var n = b.useRef(null), s = b.useState({
    onScrollCapture: Ml,
    onWheelCapture: Ml,
    onTouchMoveCapture: Ml
  }), i = s[0], r = s[1], o = e.forwardProps, a = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, d = e.shards, h = e.sideCar, f = e.noIsolation, p = e.inert, g = e.allowPinchZoom, m = e.as, A = m === void 0 ? "div" : m, w = e.gapMode, x = S0(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), v = h, C = qR([n, t]), E = Qe(Qe({}, x), i);
  return b.createElement(
    b.Fragment,
    null,
    u && b.createElement(v, { sideCar: E0, removeScrollBar: c, shards: d, noIsolation: f, inert: p, setCallbacks: r, allowPinchZoom: !!g, lockRef: n, gapMode: w }),
    o ? b.cloneElement(b.Children.only(a), Qe(Qe({}, E), { ref: C })) : b.createElement(A, Qe({}, E, { className: l, ref: C }), a)
  );
});
Oa.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Oa.classNames = {
  fullWidth: qo,
  zeroRight: Eo
};
var BR = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function IR() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = BR();
  return t && e.setAttribute("nonce", t), e;
}
function PR(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function OR(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var NR = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = IR()) && (PR(t, n), OR(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, LR = function() {
  var e = NR();
  return function(t, n) {
    b.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, q0 = function() {
  var e = LR(), t = function(n) {
    var s = n.styles, i = n.dynamic;
    return e(s, i), null;
  };
  return t;
}, FR = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, El = function(e) {
  return parseInt(e || "", 10) || 0;
}, jR = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], s = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [El(n), El(s), El(i)];
}, VR = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return FR;
  var t = jR(e), n = document.documentElement.clientWidth, s = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, s - n + t[2] - t[0])
  };
}, UR = q0(), _s = "data-scroll-locked", YR = function(e, t, n, s) {
  var i = e.left, r = e.top, o = e.right, a = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(CR, ` {
   overflow: hidden `).concat(s, `;
   padding-right: `).concat(a, "px ").concat(s, `;
  }
  body[`).concat(_s, `] {
    overflow: hidden `).concat(s, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(s, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(r, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(s, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(s, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Eo, ` {
    right: `).concat(a, "px ").concat(s, `;
  }
  
  .`).concat(qo, ` {
    margin-right: `).concat(a, "px ").concat(s, `;
  }
  
  .`).concat(Eo, " .").concat(Eo, ` {
    right: 0 `).concat(s, `;
  }
  
  .`).concat(qo, " .").concat(qo, ` {
    margin-right: 0 `).concat(s, `;
  }
  
  body[`).concat(_s, `] {
    `).concat(SR, ": ").concat(a, `px;
  }
`);
}, Uf = function() {
  var e = parseInt(document.body.getAttribute(_s) || "0", 10);
  return isFinite(e) ? e : 0;
}, WR = function() {
  b.useEffect(function() {
    return document.body.setAttribute(_s, (Uf() + 1).toString()), function() {
      var e = Uf() - 1;
      e <= 0 ? document.body.removeAttribute(_s) : document.body.setAttribute(_s, e.toString());
    };
  }, []);
}, QR = function(e) {
  var t = e.noRelative, n = e.noImportant, s = e.gapMode, i = s === void 0 ? "margin" : s;
  WR();
  var r = b.useMemo(function() {
    return VR(i);
  }, [i]);
  return b.createElement(UR, { styles: YR(r, !t, i, n ? "" : "!important") });
}, Sc = !1;
if (typeof window < "u")
  try {
    var Jr = Object.defineProperty({}, "passive", {
      get: function() {
        return Sc = !0, !0;
      }
    });
    window.addEventListener("test", Jr, Jr), window.removeEventListener("test", Jr, Jr);
  } catch {
    Sc = !1;
  }
var Bs = Sc ? { passive: !1 } : !1, GR = function(e) {
  return e.tagName === "TEXTAREA";
}, R0 = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !GR(e) && n[t] === "visible")
  );
}, KR = function(e) {
  return R0(e, "overflowY");
}, zR = function(e) {
  return R0(e, "overflowX");
}, Yf = function(e, t) {
  var n = t.ownerDocument, s = t;
  do {
    typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host);
    var i = k0(e, s);
    if (i) {
      var r = T0(e, s), o = r[1], a = r[2];
      if (o > a)
        return !0;
    }
    s = s.parentNode;
  } while (s && s !== n.body);
  return !1;
}, _R = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, s = e.clientHeight;
  return [
    t,
    n,
    s
  ];
}, ZR = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, s = e.clientWidth;
  return [
    t,
    n,
    s
  ];
}, k0 = function(e, t) {
  return e === "v" ? KR(t) : zR(t);
}, T0 = function(e, t) {
  return e === "v" ? _R(t) : ZR(t);
}, HR = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, JR = function(e, t, n, s, i) {
  var r = HR(e, window.getComputedStyle(t).direction), o = r * s, a = n.target, l = t.contains(a), c = !1, u = o > 0, d = 0, h = 0;
  do {
    var f = T0(e, a), p = f[0], g = f[1], m = f[2], A = g - m - r * p;
    (p || A) && k0(e, a) && (d += A, h += p), a instanceof ShadowRoot ? a = a.host : a = a.parentNode;
  } while (
    // portaled content
    !l && a !== document.body || // self content
    l && (t.contains(a) || t === a)
  );
  return (u && (Math.abs(d) < 1 || !i) || !u && (Math.abs(h) < 1 || !i)) && (c = !0), c;
}, Xr = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Wf = function(e) {
  return [e.deltaX, e.deltaY];
}, Qf = function(e) {
  return e && "current" in e ? e.current : e;
}, XR = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, $R = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, tk = 0, Is = [];
function ek(e) {
  var t = b.useRef([]), n = b.useRef([0, 0]), s = b.useRef(), i = b.useState(tk++)[0], r = b.useState(q0)[0], o = b.useRef(e);
  b.useEffect(function() {
    o.current = e;
  }, [e]), b.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var g = vR([e.lockRef.current], (e.shards || []).map(Qf), !0).filter(Boolean);
      return g.forEach(function(m) {
        return m.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), g.forEach(function(m) {
          return m.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = b.useCallback(function(g, m) {
    if ("touches" in g && g.touches.length === 2 || g.type === "wheel" && g.ctrlKey)
      return !o.current.allowPinchZoom;
    var A = Xr(g), w = n.current, x = "deltaX" in g ? g.deltaX : w[0] - A[0], v = "deltaY" in g ? g.deltaY : w[1] - A[1], C, E = g.target, S = Math.abs(x) > Math.abs(v) ? "h" : "v";
    if ("touches" in g && S === "h" && E.type === "range")
      return !1;
    var M = Yf(S, E);
    if (!M)
      return !0;
    if (M ? C = S : (C = S === "v" ? "h" : "v", M = Yf(S, E)), !M)
      return !1;
    if (!s.current && "changedTouches" in g && (x || v) && (s.current = C), !C)
      return !0;
    var q = s.current || C;
    return JR(q, m, g, q === "h" ? x : v, !0);
  }, []), l = b.useCallback(function(g) {
    var m = g;
    if (!(!Is.length || Is[Is.length - 1] !== r)) {
      var A = "deltaY" in m ? Wf(m) : Xr(m), w = t.current.filter(function(C) {
        return C.name === m.type && (C.target === m.target || m.target === C.shadowParent) && XR(C.delta, A);
      })[0];
      if (w && w.should) {
        m.cancelable && m.preventDefault();
        return;
      }
      if (!w) {
        var x = (o.current.shards || []).map(Qf).filter(Boolean).filter(function(C) {
          return C.contains(m.target);
        }), v = x.length > 0 ? a(m, x[0]) : !o.current.noIsolation;
        v && m.cancelable && m.preventDefault();
      }
    }
  }, []), c = b.useCallback(function(g, m, A, w) {
    var x = { name: g, delta: m, target: A, should: w, shadowParent: nk(A) };
    t.current.push(x), setTimeout(function() {
      t.current = t.current.filter(function(v) {
        return v !== x;
      });
    }, 1);
  }, []), u = b.useCallback(function(g) {
    n.current = Xr(g), s.current = void 0;
  }, []), d = b.useCallback(function(g) {
    c(g.type, Wf(g), g.target, a(g, e.lockRef.current));
  }, []), h = b.useCallback(function(g) {
    c(g.type, Xr(g), g.target, a(g, e.lockRef.current));
  }, []);
  b.useEffect(function() {
    return Is.push(r), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: h
    }), document.addEventListener("wheel", l, Bs), document.addEventListener("touchmove", l, Bs), document.addEventListener("touchstart", u, Bs), function() {
      Is = Is.filter(function(g) {
        return g !== r;
      }), document.removeEventListener("wheel", l, Bs), document.removeEventListener("touchmove", l, Bs), document.removeEventListener("touchstart", u, Bs);
    };
  }, []);
  var f = e.removeScrollBar, p = e.inert;
  return b.createElement(
    b.Fragment,
    null,
    p ? b.createElement(r, { styles: $R(i) }) : null,
    f ? b.createElement(QR, { gapMode: e.gapMode }) : null
  );
}
function nk(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const sk = DR(E0, ek);
var D0 = b.forwardRef(function(e, t) {
  return b.createElement(Oa, Qe({}, e, { ref: t, sideCar: sk }));
});
D0.classNames = Oa.classNames;
var ik = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Ps = /* @__PURE__ */ new WeakMap(), $r = /* @__PURE__ */ new WeakMap(), to = {}, ql = 0, B0 = function(e) {
  return e && (e.host || B0(e.parentNode));
}, rk = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var s = B0(n);
    return s && e.contains(s) ? s : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, ok = function(e, t, n, s) {
  var i = rk(t, Array.isArray(e) ? e : [e]);
  to[n] || (to[n] = /* @__PURE__ */ new WeakMap());
  var r = to[n], o = [], a = /* @__PURE__ */ new Set(), l = new Set(i), c = function(d) {
    !d || a.has(d) || (a.add(d), c(d.parentNode));
  };
  i.forEach(c);
  var u = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(h) {
      if (a.has(h))
        u(h);
      else
        try {
          var f = h.getAttribute(s), p = f !== null && f !== "false", g = (Ps.get(h) || 0) + 1, m = (r.get(h) || 0) + 1;
          Ps.set(h, g), r.set(h, m), o.push(h), g === 1 && p && $r.set(h, !0), m === 1 && h.setAttribute(n, "true"), p || h.setAttribute(s, "true");
        } catch (A) {
          console.error("aria-hidden: cannot operate on ", h, A);
        }
    });
  };
  return u(t), a.clear(), ql++, function() {
    o.forEach(function(d) {
      var h = Ps.get(d) - 1, f = r.get(d) - 1;
      Ps.set(d, h), r.set(d, f), h || ($r.has(d) || d.removeAttribute(s), $r.delete(d)), f || d.removeAttribute(n);
    }), ql--, ql || (Ps = /* @__PURE__ */ new WeakMap(), Ps = /* @__PURE__ */ new WeakMap(), $r = /* @__PURE__ */ new WeakMap(), to = {});
  };
}, ak = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var s = Array.from(Array.isArray(e) ? e : [e]), i = ik(e);
  return i ? (s.push.apply(s, Array.from(i.querySelectorAll("[aria-live]"))), ok(s, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Ku = "Dialog", [I0, BF] = $q(Ku), [lk, je] = I0(Ku), P0 = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: s,
    defaultOpen: i,
    onOpenChange: r,
    modal: o = !0
  } = e, a = b.useRef(null), l = b.useRef(null), [c = !1, u] = fi({
    prop: s,
    defaultProp: i,
    onChange: r
  });
  return /* @__PURE__ */ y.jsx(
    lk,
    {
      scope: t,
      triggerRef: a,
      contentRef: l,
      contentId: zs(),
      titleId: zs(),
      descriptionId: zs(),
      open: c,
      onOpenChange: u,
      onOpenToggle: b.useCallback(() => u((d) => !d), [u]),
      modal: o,
      children: n
    }
  );
};
P0.displayName = Ku;
var O0 = "DialogTrigger", N0 = b.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...s } = e, i = je(O0, n), r = ct(t, i.triggerRef);
    return /* @__PURE__ */ y.jsx(
      ut.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": Zu(i.open),
        ...s,
        ref: r,
        onClick: at(e.onClick, i.onOpenToggle)
      }
    );
  }
);
N0.displayName = O0;
var zu = "DialogPortal", [ck, L0] = I0(zu, {
  forceMount: void 0
}), F0 = (e) => {
  const { __scopeDialog: t, forceMount: n, children: s, container: i } = e, r = je(zu, t);
  return /* @__PURE__ */ y.jsx(ck, { scope: t, forceMount: n, children: b.Children.map(s, (o) => /* @__PURE__ */ y.jsx(Pa, { present: n || r.open, children: /* @__PURE__ */ y.jsx(C0, { asChild: !0, container: i, children: o }) })) });
};
F0.displayName = zu;
var ia = "DialogOverlay", j0 = b.forwardRef(
  (e, t) => {
    const n = L0(ia, e.__scopeDialog), { forceMount: s = n.forceMount, ...i } = e, r = je(ia, e.__scopeDialog);
    return r.modal ? /* @__PURE__ */ y.jsx(Pa, { present: s || r.open, children: /* @__PURE__ */ y.jsx(uk, { ...i, ref: t }) }) : null;
  }
);
j0.displayName = ia;
var uk = b.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...s } = e, i = je(ia, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ y.jsx(D0, { as: ti, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ y.jsx(
        ut.div,
        {
          "data-state": Zu(i.open),
          ...s,
          ref: t,
          style: { pointerEvents: "auto", ...s.style }
        }
      ) })
    );
  }
), Ms = "DialogContent", V0 = b.forwardRef(
  (e, t) => {
    const n = L0(Ms, e.__scopeDialog), { forceMount: s = n.forceMount, ...i } = e, r = je(Ms, e.__scopeDialog);
    return /* @__PURE__ */ y.jsx(Pa, { present: s || r.open, children: r.modal ? /* @__PURE__ */ y.jsx(dk, { ...i, ref: t }) : /* @__PURE__ */ y.jsx(hk, { ...i, ref: t }) });
  }
);
V0.displayName = Ms;
var dk = b.forwardRef(
  (e, t) => {
    const n = je(Ms, e.__scopeDialog), s = b.useRef(null), i = ct(t, n.contentRef, s);
    return b.useEffect(() => {
      const r = s.current;
      if (r) return ak(r);
    }, []), /* @__PURE__ */ y.jsx(
      U0,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: at(e.onCloseAutoFocus, (r) => {
          var o;
          r.preventDefault(), (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: at(e.onPointerDownOutside, (r) => {
          const o = r.detail.originalEvent, a = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || a) && r.preventDefault();
        }),
        onFocusOutside: at(
          e.onFocusOutside,
          (r) => r.preventDefault()
        )
      }
    );
  }
), hk = b.forwardRef(
  (e, t) => {
    const n = je(Ms, e.__scopeDialog), s = b.useRef(!1), i = b.useRef(!1);
    return /* @__PURE__ */ y.jsx(
      U0,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (r) => {
          var o, a;
          (o = e.onCloseAutoFocus) == null || o.call(e, r), r.defaultPrevented || (s.current || (a = n.triggerRef.current) == null || a.focus(), r.preventDefault()), s.current = !1, i.current = !1;
        },
        onInteractOutside: (r) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, r), r.defaultPrevented || (s.current = !0, r.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const o = r.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && r.preventDefault(), r.detail.originalEvent.type === "focusin" && i.current && r.preventDefault();
        }
      }
    );
  }
), U0 = b.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: s, onOpenAutoFocus: i, onCloseAutoFocus: r, ...o } = e, a = je(Ms, n), l = b.useRef(null), c = ct(t, l);
    return xR(), /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        x0,
        {
          asChild: !0,
          loop: !0,
          trapped: s,
          onMountAutoFocus: i,
          onUnmountAutoFocus: r,
          children: /* @__PURE__ */ y.jsx(
            w0,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": Zu(a.open),
              ...o,
              ref: c,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
        /* @__PURE__ */ y.jsx(fk, { titleId: a.titleId }),
        /* @__PURE__ */ y.jsx(gk, { contentRef: l, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), _u = "DialogTitle", Y0 = b.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...s } = e, i = je(_u, n);
    return /* @__PURE__ */ y.jsx(ut.h2, { id: i.titleId, ...s, ref: t });
  }
);
Y0.displayName = _u;
var W0 = "DialogDescription", Q0 = b.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...s } = e, i = je(W0, n);
    return /* @__PURE__ */ y.jsx(ut.p, { id: i.descriptionId, ...s, ref: t });
  }
);
Q0.displayName = W0;
var G0 = "DialogClose", K0 = b.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...s } = e, i = je(G0, n);
    return /* @__PURE__ */ y.jsx(
      ut.button,
      {
        type: "button",
        ...s,
        ref: t,
        onClick: at(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
K0.displayName = G0;
function Zu(e) {
  return e ? "open" : "closed";
}
var z0 = "DialogTitleWarning", [IF, _0] = Xq(z0, {
  contentName: Ms,
  titleName: _u,
  docsSlug: "dialog"
}), fk = ({ titleId: e }) => {
  const t = _0(z0), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return b.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, pk = "DialogDescriptionWarning", gk = ({ contentRef: e, descriptionId: t }) => {
  const s = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${_0(pk).contentName}}.`;
  return b.useEffect(() => {
    var r;
    const i = (r = e.current) == null ? void 0 : r.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(s));
  }, [s, e, t]), null;
}, Z0 = P0, H0 = N0, mk = F0, Hu = j0, Ju = V0, Xu = Y0, $u = Q0, td = K0;
function J0(e, t) {
  if (e == null) return {};
  var n = {}, s = Object.keys(e), i, r;
  for (r = 0; r < s.length; r++)
    i = s[r], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Ak = ["color"], yk = /* @__PURE__ */ kr(function(e, t) {
  var n = e.color, s = n === void 0 ? "currentColor" : n, i = J0(e, Ak);
  return Fn("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i, {
    ref: t
  }), Fn("path", {
    d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
    fill: s,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}), wk = ["color"], bk = /* @__PURE__ */ kr(function(e, t) {
  var n = e.color, s = n === void 0 ? "currentColor" : n, i = J0(e, wk);
  return Fn("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i, {
    ref: t
  }), Fn("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: s,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
const X0 = Z0, $0 = H0, ty = td, ey = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  Hu,
  {
    ref: n,
    className: At(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      e
    ),
    ...t
  }
));
ey.displayName = Hu.displayName;
const ed = b.forwardRef(({ className: e, children: t, ...n }, s) => /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
  /* @__PURE__ */ y.jsx(ey, {}),
  /* @__PURE__ */ y.jsxs(
    Ju,
    {
      ref: s,
      className: At(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        e
      ),
      ...n,
      children: [
        t,
        /* @__PURE__ */ y.jsxs(td, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ y.jsx(bk, { className: "h-4 w-4" }),
          /* @__PURE__ */ y.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
ed.displayName = Ju.displayName;
const nd = ({
  className: e,
  ...t
}) => /* @__PURE__ */ y.jsx(
  "div",
  {
    className: At(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      e
    ),
    ...t
  }
);
nd.displayName = "DialogHeader";
const sd = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  Xu,
  {
    ref: n,
    className: At(
      "text-lg font-semibold leading-none tracking-tight",
      e
    ),
    ...t
  }
));
sd.displayName = Xu.displayName;
const xk = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  $u,
  {
    ref: n,
    className: At("text-sm text-muted-foreground", e),
    ...t
  }
));
xk.displayName = $u.displayName;
function vk(e) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
const ny = P.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: !1,
  isOpen: !1,
  isDragging: !1,
  keyboardIsOpen: {
    current: !1
  },
  snapPointsOffset: null,
  snapPoints: null,
  handleOnly: !1,
  modal: !1,
  shouldFade: !1,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  closeDrawer: () => {
  },
  direction: "bottom",
  shouldScaleBackground: !1,
  setBackgroundColorOnScale: !0,
  noBodyStyles: !1,
  container: null,
  autoFocus: !1
}), gi = () => {
  const e = P.useContext(ny);
  if (!e)
    throw new Error("useDrawerContext must be used within a Drawer.Root");
  return e;
};
vk(`[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(
[data-state=closed]
){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,100%,0)}}@keyframes slideFromTop{from{transform:translate3d(0,-100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,-100%,0)}}@keyframes slideFromLeft{from{transform:translate3d(-100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(-100%,0,0)}}@keyframes slideFromRight{from{transform:translate3d(100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(100%,0,0)}}`);
const Ck = 24, Sk = typeof window < "u" ? ru : Lt;
function Gf(...e) {
  return (...t) => {
    for (let n of e)
      typeof n == "function" && n(...t);
  };
}
function Mk() {
  return id(/^Mac/);
}
function Ek() {
  return id(/^iPhone/);
}
function Kf() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function qk() {
  return id(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  Mk() && navigator.maxTouchPoints > 1;
}
function sy() {
  return Ek() || qk();
}
function id(e) {
  return typeof window < "u" && window.navigator != null ? e.test(window.navigator.platform) : void 0;
}
const Rl = typeof document < "u" && window.visualViewport;
function zf(e) {
  let t = window.getComputedStyle(e);
  return /(auto|scroll)/.test(t.overflow + t.overflowX + t.overflowY);
}
function iy(e) {
  for (zf(e) && (e = e.parentElement); e && !zf(e); )
    e = e.parentElement;
  return e || document.scrollingElement || document.documentElement;
}
const Rk = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let eo = 0, kl;
function kk(e = {}) {
  let { isDisabled: t } = e;
  Sk(() => {
    if (!t)
      return eo++, eo === 1 && sy() && (kl = Tk()), () => {
        eo--, eo === 0 && (kl == null || kl());
      };
  }, [
    t
  ]);
}
function Tk() {
  let e, t = 0, n = (d) => {
    e = iy(d.target), !(e === document.documentElement && e === document.body) && (t = d.changedTouches[0].pageY);
  }, s = (d) => {
    if (!e || e === document.documentElement || e === document.body) {
      d.preventDefault();
      return;
    }
    let h = d.changedTouches[0].pageY, f = e.scrollTop, p = e.scrollHeight - e.clientHeight;
    p !== 0 && ((f <= 0 && h > t || f >= p && h < t) && d.preventDefault(), t = h);
  }, i = (d) => {
    let h = d.target;
    Mc(h) && h !== document.activeElement && (d.preventDefault(), h.style.transform = "translateY(-2000px)", h.focus(), requestAnimationFrame(() => {
      h.style.transform = "";
    }));
  }, r = (d) => {
    let h = d.target;
    Mc(h) && (h.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      h.style.transform = "", Rl && (Rl.height < window.innerHeight ? requestAnimationFrame(() => {
        _f(h);
      }) : Rl.addEventListener("resize", () => _f(h), {
        once: !0
      }));
    }));
  }, o = () => {
    window.scrollTo(0, 0);
  }, a = window.pageXOffset, l = window.pageYOffset, c = Gf(Dk(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let u = Gf(Ei(document, "touchstart", n, {
    passive: !1,
    capture: !0
  }), Ei(document, "touchmove", s, {
    passive: !1,
    capture: !0
  }), Ei(document, "touchend", i, {
    passive: !1,
    capture: !0
  }), Ei(document, "focus", r, !0), Ei(window, "scroll", o));
  return () => {
    c(), u(), window.scrollTo(a, l);
  };
}
function Dk(e, t, n) {
  let s = e.style[t];
  return e.style[t] = n, () => {
    e.style[t] = s;
  };
}
function Ei(e, t, n, s) {
  return e.addEventListener(t, n, s), () => {
    e.removeEventListener(t, n, s);
  };
}
function _f(e) {
  let t = document.scrollingElement || document.documentElement;
  for (; e && e !== t; ) {
    let n = iy(e);
    if (n !== document.documentElement && n !== document.body && n !== e) {
      let s = n.getBoundingClientRect().top, i = e.getBoundingClientRect().top, r = e.getBoundingClientRect().bottom;
      const o = n.getBoundingClientRect().bottom + Ck;
      r > o && (n.scrollTop += i - s);
    }
    e = n.parentElement;
  }
}
function Mc(e) {
  return e instanceof HTMLInputElement && !Rk.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable;
}
function Bk(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function Ik(...e) {
  return (t) => e.forEach((n) => Bk(n, t));
}
function ry(...e) {
  return b.useCallback(Ik(...e), e);
}
const oy = /* @__PURE__ */ new WeakMap();
function Ot(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement)) return;
  let s = {};
  Object.entries(t).forEach(([i, r]) => {
    if (i.startsWith("--")) {
      e.style.setProperty(i, r);
      return;
    }
    s[i] = e.style[i], e.style[i] = r;
  }), !n && oy.set(e, s);
}
function Pk(e, t) {
  if (!e || !(e instanceof HTMLElement)) return;
  let n = oy.get(e);
  n && (e.style[t] = n[t]);
}
const Nt = (e) => {
  switch (e) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return e;
  }
};
function no(e, t) {
  if (!e)
    return null;
  const n = window.getComputedStyle(e), s = (
    // @ts-ignore
    n.transform || n.webkitTransform || n.mozTransform
  );
  let i = s.match(/^matrix3d\((.+)\)$/);
  return i ? parseFloat(i[1].split(", ")[Nt(t) ? 13 : 12]) : (i = s.match(/^matrix\((.+)\)$/), i ? parseFloat(i[1].split(", ")[Nt(t) ? 5 : 4]) : null);
}
function Ok(e) {
  return 8 * (Math.log(e + 1) - 2);
}
function Tl(e, t) {
  if (!e) return () => {
  };
  const n = e.style.cssText;
  return Object.assign(e.style, t), () => {
    e.style.cssText = n;
  };
}
function Nk(...e) {
  return (...t) => {
    for (const n of e)
      typeof n == "function" && n(...t);
  };
}
const Mt = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
}, ay = 0.4, Lk = 0.25, Fk = 100, ly = 8, os = 16, Ec = 26, Dl = "vaul-dragging";
function cy(e) {
  const t = P.useRef(e);
  return P.useEffect(() => {
    t.current = e;
  }), P.useMemo(() => (...n) => t.current == null ? void 0 : t.current.call(t, ...n), []);
}
function jk({ defaultProp: e, onChange: t }) {
  const n = P.useState(e), [s] = n, i = P.useRef(s), r = cy(t);
  return P.useEffect(() => {
    i.current !== s && (r(s), i.current = s);
  }, [
    s,
    i,
    r
  ]), n;
}
function uy({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [s, i] = jk({
    defaultProp: t,
    onChange: n
  }), r = e !== void 0, o = r ? e : s, a = cy(n), l = P.useCallback((c) => {
    if (r) {
      const d = typeof c == "function" ? c(e) : c;
      d !== e && a(d);
    } else
      i(c);
  }, [
    r,
    e,
    i,
    a
  ]);
  return [
    o,
    l
  ];
}
function Vk({ activeSnapPointProp: e, setActiveSnapPointProp: t, snapPoints: n, drawerRef: s, overlayRef: i, fadeFromIndex: r, onSnapPointChange: o, direction: a = "bottom", container: l, snapToSequentialPoint: c }) {
  const [u, d] = uy({
    prop: e,
    defaultProp: n == null ? void 0 : n[0],
    onChange: t
  }), [h, f] = P.useState(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  P.useEffect(() => {
    function S() {
      f({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }
    return window.addEventListener("resize", S), () => window.removeEventListener("resize", S);
  }, []);
  const p = P.useMemo(() => u === (n == null ? void 0 : n[n.length - 1]) || null, [
    n,
    u
  ]), g = P.useMemo(() => n == null ? void 0 : n.findIndex((S) => S === u), [
    n,
    u
  ]), m = n && n.length > 0 && (r || r === 0) && !Number.isNaN(r) && n[r] === u || !n, A = P.useMemo(() => {
    const S = l ? {
      width: l.getBoundingClientRect().width,
      height: l.getBoundingClientRect().height
    } : typeof window < "u" ? {
      width: window.innerWidth,
      height: window.innerHeight
    } : {
      width: 0,
      height: 0
    };
    var M;
    return (M = n == null ? void 0 : n.map((q) => {
      const k = typeof q == "string";
      let R = 0;
      if (k && (R = parseInt(q, 10)), Nt(a)) {
        const j = k ? R : h ? q * S.height : 0;
        return h ? a === "bottom" ? S.height - j : -S.height + j : j;
      }
      const D = k ? R : h ? q * S.width : 0;
      return h ? a === "right" ? S.width - D : -S.width + D : D;
    })) != null ? M : [];
  }, [
    n,
    h,
    l
  ]), w = P.useMemo(() => g !== null ? A == null ? void 0 : A[g] : null, [
    A,
    g
  ]), x = P.useCallback((S) => {
    var M;
    const q = (M = A == null ? void 0 : A.findIndex((k) => k === S)) != null ? M : null;
    o(q), Ot(s.current, {
      transition: `transform ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`,
      transform: Nt(a) ? `translate3d(0, ${S}px, 0)` : `translate3d(${S}px, 0, 0)`
    }), A && q !== A.length - 1 && q !== r && q < r ? Ot(i.current, {
      transition: `opacity ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`,
      opacity: "0"
    }) : Ot(i.current, {
      transition: `opacity ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`,
      opacity: "1"
    }), d(n == null ? void 0 : n[Math.max(q, 0)]);
  }, [
    s.current,
    n,
    A,
    r,
    i,
    d
  ]);
  P.useEffect(() => {
    if (u || e) {
      var S;
      const M = (S = n == null ? void 0 : n.findIndex((q) => q === e || q === u)) != null ? S : -1;
      A && M !== -1 && typeof A[M] == "number" && x(A[M]);
    }
  }, [
    u,
    e,
    n,
    A,
    x
  ]);
  function v({ draggedDistance: S, closeDrawer: M, velocity: q, dismissible: k }) {
    if (r === void 0) return;
    const R = a === "bottom" || a === "right" ? (w ?? 0) - S : (w ?? 0) + S, D = g === r - 1, j = g === 0, W = S > 0;
    if (D && Ot(i.current, {
      transition: `opacity ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`
    }), !c && q > 2 && !W) {
      k ? M() : x(A[0]);
      return;
    }
    if (!c && q > 2 && W && A && n) {
      x(A[n.length - 1]);
      return;
    }
    const O = A == null ? void 0 : A.reduce((I, F) => typeof I != "number" || typeof F != "number" ? I : Math.abs(F - R) < Math.abs(I - R) ? F : I), U = Nt(a) ? window.innerHeight : window.innerWidth;
    if (q > ay && Math.abs(S) < U * 0.4) {
      const I = W ? 1 : -1;
      if (I > 0 && p) {
        x(A[n.length - 1]);
        return;
      }
      if (j && I < 0 && k && M(), g === null) return;
      x(A[g + I]);
      return;
    }
    x(O);
  }
  function C({ draggedDistance: S }) {
    if (w === null) return;
    const M = a === "bottom" || a === "right" ? w - S : w + S;
    (a === "bottom" || a === "right") && M < A[A.length - 1] || (a === "top" || a === "left") && M > A[A.length - 1] || Ot(s.current, {
      transform: Nt(a) ? `translate3d(0, ${M}px, 0)` : `translate3d(${M}px, 0, 0)`
    });
  }
  function E(S, M) {
    if (!n || typeof g != "number" || !A || r === void 0) return null;
    const q = g === r - 1;
    if (g >= r && M)
      return 0;
    if (q && !M) return 1;
    if (!m && !q) return null;
    const R = q ? g + 1 : g - 1, D = q ? A[R] - A[R - 1] : A[R + 1] - A[R], j = S / Math.abs(D);
    return q ? 1 - j : j;
  }
  return {
    isLastSnapPoint: p,
    activeSnapPoint: u,
    shouldFade: m,
    getPercentageDragged: E,
    setActiveSnapPoint: d,
    activeSnapPointIndex: g,
    onRelease: v,
    onDrag: C,
    snapPointsOffset: A
  };
}
const Uk = () => () => {
};
function Yk() {
  const { direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: s, noBodyStyles: i } = gi(), r = P.useRef(null), o = Ln(() => document.body.style.backgroundColor, []);
  function a() {
    return (window.innerWidth - Ec) / window.innerWidth;
  }
  P.useEffect(() => {
    if (t && n) {
      r.current && clearTimeout(r.current);
      const l = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!l) return;
      Nk(s && !i ? Tl(document.body, {
        background: "black"
      }) : Uk, Tl(l, {
        transformOrigin: Nt(e) ? "top" : "left",
        transitionProperty: "transform, border-radius",
        transitionDuration: `${Mt.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${Mt.EASE.join(",")})`
      }));
      const c = Tl(l, {
        borderRadius: `${ly}px`,
        overflow: "hidden",
        ...Nt(e) ? {
          transform: `scale(${a()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${a()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      return () => {
        c(), r.current = window.setTimeout(() => {
          o ? document.body.style.background = o : document.body.style.removeProperty("background");
        }, Mt.DURATION * 1e3);
      };
    }
  }, [
    t,
    n,
    o
  ]);
}
let qi = null;
function Wk({ isOpen: e, modal: t, nested: n, hasBeenOpened: s, preventScrollRestoration: i, noBodyStyles: r }) {
  const [o, a] = P.useState(() => typeof window < "u" ? window.location.href : ""), l = P.useRef(0), c = P.useCallback(() => {
    if (Kf() && qi === null && e && !r) {
      qi = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX: d, innerHeight: h } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-l.current}px`,
        left: `${-d}px`,
        right: "0px",
        height: "auto"
      }), window.setTimeout(() => window.requestAnimationFrame(() => {
        const f = h - window.innerHeight;
        f && l.current >= h && (document.body.style.top = `${-(l.current + f)}px`);
      }), 300);
    }
  }, [
    e
  ]), u = P.useCallback(() => {
    if (Kf() && qi !== null && !r) {
      const d = -parseInt(document.body.style.top, 10), h = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, qi), window.requestAnimationFrame(() => {
        if (i && o !== window.location.href) {
          a(window.location.href);
          return;
        }
        window.scrollTo(h, d);
      }), qi = null;
    }
  }, [
    o
  ]);
  return P.useEffect(() => {
    function d() {
      l.current = window.scrollY;
    }
    return d(), window.addEventListener("scroll", d), () => {
      window.removeEventListener("scroll", d);
    };
  }, []), P.useEffect(() => {
    n || !s || (e ? (!window.matchMedia("(display-mode: standalone)").matches && c(), t || window.setTimeout(() => {
      u();
    }, 500)) : u());
  }, [
    e,
    s,
    o,
    t,
    n,
    c,
    u
  ]), {
    restorePositionSetting: u
  };
}
function dy({ open: e, onOpenChange: t, children: n, onDrag: s, onRelease: i, snapPoints: r, shouldScaleBackground: o = !1, setBackgroundColorOnScale: a = !0, closeThreshold: l = Lk, scrollLockTimeout: c = Fk, dismissible: u = !0, handleOnly: d = !1, fadeFromIndex: h = r && r.length - 1, activeSnapPoint: f, setActiveSnapPoint: p, fixed: g, modal: m = !0, onClose: A, nested: w, noBodyStyles: x, direction: v = "bottom", defaultOpen: C = !1, disablePreventScroll: E = !0, snapToSequentialPoint: S = !1, preventScrollRestoration: M = !1, repositionInputs: q = !0, onAnimationEnd: k, container: R, autoFocus: D = !1 }) {
  var j, W;
  const [O = !1, U] = uy({
    defaultProp: C,
    prop: e,
    onChange: (H) => {
      t == null || t(H), !H && !w && ix(), setTimeout(() => {
        k == null || k(H);
      }, Mt.DURATION * 1e3), H && !m && typeof window < "u" && window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      }), H || (document.body.style.pointerEvents = "auto");
    }
  }), [I, F] = P.useState(!1), [Q, J] = P.useState(!1), [lt, Vt] = P.useState(!1), Pt = P.useRef(null), kt = P.useRef(null), Ut = P.useRef(null), gt = P.useRef(null), G = P.useRef(null), Gt = P.useRef(!1), ae = P.useRef(null), Cn = P.useRef(0), ke = P.useRef(!1), ns = P.useRef(0), N = P.useRef(null), nt = P.useRef(((j = N.current) == null ? void 0 : j.getBoundingClientRect().height) || 0), vt = P.useRef(((W = N.current) == null ? void 0 : W.getBoundingClientRect().width) || 0), Kt = P.useRef(0), Te = P.useCallback((H) => {
    r && H === bi.length - 1 && (kt.current = /* @__PURE__ */ new Date());
  }, []), { activeSnapPoint: ss, activeSnapPointIndex: pe, setActiveSnapPoint: Xd, onRelease: ex, snapPointsOffset: bi, onDrag: nx, shouldFade: $d, getPercentageDragged: sx } = Vk({
    snapPoints: r,
    activeSnapPointProp: f,
    setActiveSnapPointProp: p,
    drawerRef: N,
    fadeFromIndex: h,
    overlayRef: Pt,
    onSnapPointChange: Te,
    direction: v,
    container: R,
    snapToSequentialPoint: S
  });
  kk({
    isDisabled: !O || Q || !m || lt || !I || !q || !E
  });
  const { restorePositionSetting: ix } = Wk({
    isOpen: O,
    modal: m,
    nested: w,
    hasBeenOpened: I,
    preventScrollRestoration: M,
    noBodyStyles: x
  });
  function Wr() {
    return (window.innerWidth - Ec) / window.innerWidth;
  }
  function rx(H) {
    var ht, yt;
    !u && !r || N.current && !N.current.contains(H.target) || (nt.current = ((ht = N.current) == null ? void 0 : ht.getBoundingClientRect().height) || 0, vt.current = ((yt = N.current) == null ? void 0 : yt.getBoundingClientRect().width) || 0, J(!0), Ut.current = /* @__PURE__ */ new Date(), sy() && window.addEventListener("touchend", () => Gt.current = !1, {
      once: !0
    }), H.target.setPointerCapture(H.pointerId), Cn.current = Nt(v) ? H.pageY : H.pageX);
  }
  function th(H, ht) {
    var yt, Ct;
    let ft = H;
    const Se = (yt = window.getSelection()) == null ? void 0 : yt.toString(), te = N.current ? no(N.current, v) : null, ge = /* @__PURE__ */ new Date();
    if (ft.hasAttribute("data-vaul-no-drag") || ft.closest("[data-vaul-no-drag]"))
      return !1;
    if (v === "right" || v === "left")
      return !0;
    if (kt.current && ge.getTime() - kt.current.getTime() < 500)
      return !1;
    if (te !== null && (v === "bottom" ? te > 0 : te < 0))
      return !0;
    if (Se && Se.length > 0)
      return !1;
    if (ge.getTime() - ((Ct = G.current) == null ? void 0 : Ct.getTime()) < c && te === 0 || ht)
      return G.current = ge, !1;
    for (; ft; ) {
      if (ft.scrollHeight > ft.clientHeight) {
        if (ft.scrollTop !== 0)
          return G.current = /* @__PURE__ */ new Date(), !1;
        if (ft.getAttribute("role") === "dialog")
          return !0;
      }
      ft = ft.parentNode;
    }
    return !0;
  }
  function ox(H) {
    if (N.current && Q) {
      const ht = v === "bottom" || v === "right" ? 1 : -1, yt = (Cn.current - (Nt(v) ? H.pageY : H.pageX)) * ht, Ct = yt > 0, ft = r && !u && !Ct;
      if (ft && pe === 0) return;
      const Se = Math.abs(yt), te = document.querySelector("[data-vaul-drawer-wrapper]"), ge = v === "bottom" || v === "top" ? nt.current : vt.current;
      let De = Se / ge;
      const is = sx(Se, Ct);
      if (is !== null && (De = is), ft && De >= 1 || !Gt.current && !th(H.target, Ct)) return;
      if (N.current.classList.add(Dl), Gt.current = !0, Ot(N.current, {
        transition: "none"
      }), Ot(Pt.current, {
        transition: "none"
      }), r && nx({
        draggedDistance: yt
      }), Ct && !r) {
        const Ue = Ok(yt), Qr = Math.min(Ue * -1, 0) * ht;
        Ot(N.current, {
          transform: Nt(v) ? `translate3d(0, ${Qr}px, 0)` : `translate3d(${Qr}px, 0, 0)`
        });
        return;
      }
      const Sn = 1 - De;
      if (($d || h && pe === h - 1) && (s == null || s(H, De), Ot(Pt.current, {
        opacity: `${Sn}`,
        transition: "none"
      }, !0)), te && Pt.current && o) {
        const Ue = Math.min(Wr() + De * (1 - Wr()), 1), Qr = 8 - De * 8, nh = Math.max(0, 14 - De * 14);
        Ot(te, {
          borderRadius: `${Qr}px`,
          transform: Nt(v) ? `scale(${Ue}) translate3d(0, ${nh}px, 0)` : `scale(${Ue}) translate3d(${nh}px, 0, 0)`,
          transition: "none"
        }, !0);
      }
      if (!r) {
        const Ue = Se * ht;
        Ot(N.current, {
          transform: Nt(v) ? `translate3d(0, ${Ue}px, 0)` : `translate3d(${Ue}px, 0, 0)`
        });
      }
    }
  }
  P.useEffect(() => {
    var H;
    function ht() {
      if (!N.current || !q) return;
      const yt = document.activeElement;
      if (Mc(yt) || ke.current) {
        var Ct;
        const ft = ((Ct = window.visualViewport) == null ? void 0 : Ct.height) || 0, Se = window.innerHeight;
        let te = Se - ft;
        const ge = N.current.getBoundingClientRect().height || 0, De = ge > Se * 0.8;
        Kt.current || (Kt.current = ge);
        const is = N.current.getBoundingClientRect().top;
        if (Math.abs(ns.current - te) > 60 && (ke.current = !ke.current), r && r.length > 0 && bi && pe) {
          const Sn = bi[pe] || 0;
          te += Sn;
        }
        if (ns.current = te, ge > ft || ke.current) {
          const Sn = N.current.getBoundingClientRect().height;
          let Ue = Sn;
          Sn > ft && (Ue = ft - (De ? is : Ec)), g ? N.current.style.height = `${Sn - Math.max(te, 0)}px` : N.current.style.height = `${Math.max(Ue, ft - is)}px`;
        } else
          N.current.style.height = `${Kt.current}px`;
        r && r.length > 0 && !ke.current ? N.current.style.bottom = "0px" : N.current.style.bottom = `${Math.max(te, 0)}px`;
      }
    }
    return (H = window.visualViewport) == null || H.addEventListener("resize", ht), () => {
      var yt;
      return (yt = window.visualViewport) == null ? void 0 : yt.removeEventListener("resize", ht);
    };
  }, [
    pe,
    r,
    bi
  ]);
  function xi(H) {
    ax(), A == null || A(), H || U(!1), setTimeout(() => {
      r && Xd(r[0]);
    }, Mt.DURATION * 1e3);
  }
  function eh() {
    if (!N.current) return;
    const H = document.querySelector("[data-vaul-drawer-wrapper]"), ht = no(N.current, v);
    Ot(N.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`
    }), Ot(Pt.current, {
      transition: `opacity ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`,
      opacity: "1"
    }), o && ht && ht > 0 && O && Ot(H, {
      borderRadius: `${ly}px`,
      overflow: "hidden",
      ...Nt(v) ? {
        transform: `scale(${Wr()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
        transformOrigin: "top"
      } : {
        transform: `scale(${Wr()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
        transformOrigin: "left"
      },
      transitionProperty: "transform, border-radius",
      transitionDuration: `${Mt.DURATION}s`,
      transitionTimingFunction: `cubic-bezier(${Mt.EASE.join(",")})`
    }, !0);
  }
  function ax() {
    !Q || !N.current || (N.current.classList.remove(Dl), Gt.current = !1, J(!1), gt.current = /* @__PURE__ */ new Date());
  }
  function lx(H) {
    if (!Q || !N.current) return;
    N.current.classList.remove(Dl), Gt.current = !1, J(!1), gt.current = /* @__PURE__ */ new Date();
    const ht = no(N.current, v);
    if (!th(H.target, !1) || !ht || Number.isNaN(ht) || Ut.current === null) return;
    const yt = gt.current.getTime() - Ut.current.getTime(), Ct = Cn.current - (Nt(v) ? H.pageY : H.pageX), ft = Math.abs(Ct) / yt;
    if (ft > 0.05 && (Vt(!0), setTimeout(() => {
      Vt(!1);
    }, 200)), r) {
      ex({
        draggedDistance: Ct * (v === "bottom" || v === "right" ? 1 : -1),
        closeDrawer: xi,
        velocity: ft,
        dismissible: u
      }), i == null || i(H, !0);
      return;
    }
    if (v === "bottom" || v === "right" ? Ct > 0 : Ct < 0) {
      eh(), i == null || i(H, !0);
      return;
    }
    if (ft > ay) {
      xi(), i == null || i(H, !1);
      return;
    }
    var Se;
    const te = Math.min((Se = N.current.getBoundingClientRect().height) != null ? Se : 0, window.innerHeight);
    var ge;
    const De = Math.min((ge = N.current.getBoundingClientRect().width) != null ? ge : 0, window.innerWidth), is = v === "left" || v === "right";
    if (Math.abs(ht) >= (is ? De : te) * l) {
      xi(), i == null || i(H, !1);
      return;
    }
    i == null || i(H, !0), eh();
  }
  P.useEffect(() => (O && (Ot(document.documentElement, {
    scrollBehavior: "auto"
  }), kt.current = /* @__PURE__ */ new Date()), () => {
    Pk(document.documentElement, "scrollBehavior");
  }), [
    O
  ]);
  function cx(H) {
    const ht = H ? (window.innerWidth - os) / window.innerWidth : 1, yt = H ? -os : 0;
    ae.current && window.clearTimeout(ae.current), Ot(N.current, {
      transition: `transform ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`,
      transform: `scale(${ht}) translate3d(0, ${yt}px, 0)`
    }), !H && N.current && (ae.current = setTimeout(() => {
      const Ct = no(N.current, v);
      Ot(N.current, {
        transition: "none",
        transform: Nt(v) ? `translate3d(0, ${Ct}px, 0)` : `translate3d(${Ct}px, 0, 0)`
      });
    }, 500));
  }
  function ux(H, ht) {
    if (ht < 0) return;
    const yt = (window.innerWidth - os) / window.innerWidth, Ct = yt + ht * (1 - yt), ft = -os + ht * os;
    Ot(N.current, {
      transform: Nt(v) ? `scale(${Ct}) translate3d(0, ${ft}px, 0)` : `scale(${Ct}) translate3d(${ft}px, 0, 0)`,
      transition: "none"
    });
  }
  function dx(H, ht) {
    const yt = Nt(v) ? window.innerHeight : window.innerWidth, Ct = ht ? (yt - os) / yt : 1, ft = ht ? -os : 0;
    ht && Ot(N.current, {
      transition: `transform ${Mt.DURATION}s cubic-bezier(${Mt.EASE.join(",")})`,
      transform: Nt(v) ? `scale(${Ct}) translate3d(0, ${ft}px, 0)` : `scale(${Ct}) translate3d(${ft}px, 0, 0)`
    });
  }
  return /* @__PURE__ */ P.createElement(Z0, {
    defaultOpen: C,
    onOpenChange: (H) => {
      !u && !H || (H ? F(!0) : xi(!0), U(H));
    },
    open: O
  }, /* @__PURE__ */ P.createElement(ny.Provider, {
    value: {
      activeSnapPoint: ss,
      snapPoints: r,
      setActiveSnapPoint: Xd,
      drawerRef: N,
      overlayRef: Pt,
      onOpenChange: t,
      onPress: rx,
      onRelease: lx,
      onDrag: ox,
      dismissible: u,
      handleOnly: d,
      isOpen: O,
      isDragging: Q,
      shouldFade: $d,
      closeDrawer: xi,
      onNestedDrag: ux,
      onNestedOpenChange: cx,
      onNestedRelease: dx,
      keyboardIsOpen: ke,
      modal: m,
      snapPointsOffset: bi,
      direction: v,
      shouldScaleBackground: o,
      setBackgroundColorOnScale: a,
      noBodyStyles: x,
      container: R,
      autoFocus: D
    }
  }, n));
}
const hy = /* @__PURE__ */ P.forwardRef(function({ ...e }, t) {
  const { overlayRef: n, snapPoints: s, onRelease: i, shouldFade: r, isOpen: o, modal: a } = gi(), l = ry(t, n), c = s && s.length > 0;
  return a ? /* @__PURE__ */ P.createElement(Hu, {
    onMouseUp: i,
    ref: l,
    "data-vaul-overlay": "",
    "data-vaul-snap-points": o && c ? "true" : "false",
    "data-vaul-snap-points-overlay": o && r ? "true" : "false",
    ...e
  }) : (typeof window < "u" && window.requestAnimationFrame(() => {
    document.body.style.pointerEvents = "auto";
  }), null);
});
hy.displayName = "Drawer.Overlay";
const fy = /* @__PURE__ */ P.forwardRef(function({ onPointerDownOutside: e, style: t, onOpenAutoFocus: n, ...s }, i) {
  const { drawerRef: r, onPress: o, onRelease: a, onDrag: l, keyboardIsOpen: c, snapPointsOffset: u, modal: d, isOpen: h, direction: f, snapPoints: p, container: g, handleOnly: m, autoFocus: A } = gi(), [w, x] = P.useState(!1), v = ry(i, r), C = P.useRef(null), E = P.useRef(null), S = P.useRef(!1), M = p && p.length > 0;
  Yk();
  const q = (R, D, j = 0) => {
    if (S.current) return !0;
    const W = Math.abs(R.y), O = Math.abs(R.x), U = O > W, I = [
      "bottom",
      "right"
    ].includes(D) ? 1 : -1;
    if (D === "left" || D === "right") {
      if (!(R.x * I < 0) && O >= 0 && O <= j)
        return U;
    } else if (!(R.y * I < 0) && W >= 0 && W <= j)
      return !U;
    return S.current = !0, !0;
  };
  P.useEffect(() => {
    M && window.requestAnimationFrame(() => {
      x(!0);
    });
  }, []);
  function k(R) {
    C.current = null, S.current = !1, a(R);
  }
  return /* @__PURE__ */ P.createElement(Ju, {
    "data-vaul-drawer-direction": f,
    "data-vaul-drawer": "",
    "data-vaul-delayed-snap-points": w ? "true" : "false",
    "data-vaul-snap-points": h && M ? "true" : "false",
    "data-vaul-custom-container": g ? "true" : "false",
    ...s,
    ref: v,
    style: u && u.length > 0 ? {
      "--snap-point-height": `${u[0]}px`,
      ...t
    } : t,
    onPointerDown: (R) => {
      m || (s.onPointerDown == null || s.onPointerDown.call(s, R), C.current = {
        x: R.pageX,
        y: R.pageY
      }, o(R));
    },
    onOpenAutoFocus: (R) => {
      n == null || n(R), A || R.preventDefault();
    },
    onPointerDownOutside: (R) => {
      if (e == null || e(R), !d || R.defaultPrevented) {
        R.preventDefault();
        return;
      }
      c.current && (c.current = !1);
    },
    onFocusOutside: (R) => {
      if (!d) {
        R.preventDefault();
        return;
      }
    },
    onPointerMove: (R) => {
      if (E.current = R, m || (s.onPointerMove == null || s.onPointerMove.call(s, R), !C.current)) return;
      const D = R.pageY - C.current.y, j = R.pageX - C.current.x, W = R.pointerType === "touch" ? 10 : 2;
      q({
        x: j,
        y: D
      }, f, W) ? l(R) : (Math.abs(j) > W || Math.abs(D) > W) && (C.current = null);
    },
    onPointerUp: (R) => {
      s.onPointerUp == null || s.onPointerUp.call(s, R), C.current = null, S.current = !1, a(R);
    },
    onPointerOut: (R) => {
      s.onPointerOut == null || s.onPointerOut.call(s, R), k(E.current);
    },
    onContextMenu: (R) => {
      s.onContextMenu == null || s.onContextMenu.call(s, R), k(E.current);
    }
  });
});
fy.displayName = "Drawer.Content";
const Qk = 250, Gk = 120, py = /* @__PURE__ */ P.forwardRef(function({ preventCycle: e = !1, children: t, ...n }, s) {
  const { closeDrawer: i, isDragging: r, snapPoints: o, activeSnapPoint: a, setActiveSnapPoint: l, dismissible: c, handleOnly: u, isOpen: d, onPress: h, onDrag: f } = gi(), p = P.useRef(null), g = P.useRef(!1);
  function m() {
    if (g.current) {
      x();
      return;
    }
    window.setTimeout(() => {
      A();
    }, Gk);
  }
  function A() {
    if (r || e || g.current) {
      x();
      return;
    }
    if (x(), (!o || o.length === 0) && c) {
      i();
      return;
    }
    if (a === o[o.length - 1] && c) {
      i();
      return;
    }
    const C = o.findIndex((S) => S === a);
    if (C === -1) return;
    const E = o[C + 1];
    l(E);
  }
  function w() {
    p.current = window.setTimeout(() => {
      g.current = !0;
    }, Qk);
  }
  function x() {
    window.clearTimeout(p.current), g.current = !1;
  }
  return /* @__PURE__ */ P.createElement("div", {
    onClick: m,
    onPointerCancel: x,
    onPointerDown: (v) => {
      u && h(v), w();
    },
    onPointerMove: (v) => {
      u && f(v);
    },
    // onPointerUp is already handled by the content component
    ref: s,
    "data-vaul-drawer-visible": d ? "true" : "false",
    "data-vaul-handle": "",
    "aria-hidden": "true",
    ...n
  }, /* @__PURE__ */ P.createElement("span", {
    "data-vaul-handle-hitarea": "",
    "aria-hidden": "true"
  }, t));
});
py.displayName = "Drawer.Handle";
function Kk({ onDrag: e, onOpenChange: t, ...n }) {
  const { onNestedDrag: s, onNestedOpenChange: i, onNestedRelease: r } = gi();
  if (!s)
    throw new Error("Drawer.NestedRoot must be placed in another drawer");
  return /* @__PURE__ */ P.createElement(dy, {
    nested: !0,
    onClose: () => {
      i(!1);
    },
    onDrag: (o, a) => {
      s(o, a), e == null || e(o, a);
    },
    onOpenChange: (o) => {
      o && i(o);
    },
    onRelease: r,
    ...n
  });
}
function zk(e) {
  const t = gi(), { container: n = t.container, ...s } = e;
  return /* @__PURE__ */ P.createElement(mk, {
    container: n,
    ...s
  });
}
const $e = {
  Root: dy,
  NestedRoot: Kk,
  Content: fy,
  Overlay: hy,
  Trigger: H0,
  Portal: zk,
  Handle: py,
  Close: td,
  Title: Xu,
  Description: $u
}, rd = ({
  shouldScaleBackground: e = !0,
  ...t
}) => /* @__PURE__ */ y.jsx(
  $e.Root,
  {
    shouldScaleBackground: e,
    ...t
  }
);
rd.displayName = "Drawer";
const gy = $e.Trigger, my = $e.Close, Ay = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  $e.Overlay,
  {
    ref: n,
    className: At("fixed inset-0 z-50 bg-black/80", e),
    ...t
  }
));
Ay.displayName = $e.Overlay.displayName;
const od = b.forwardRef(({ className: e, children: t, ...n }, s) => /* @__PURE__ */ y.jsx(y.Fragment, { children: /* @__PURE__ */ y.jsx(Ay, { children: /* @__PURE__ */ y.jsxs(
  $e.Content,
  {
    ref: s,
    className: At(
      "fixed inset-x-0 bottom-0 max-h-[90%] z-50 mt-24 flex flex-col rounded-t-[10px] border bg-background",
      e
    ),
    ...n,
    children: [
      /* @__PURE__ */ y.jsx("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
      t
    ]
  }
) }) }));
od.displayName = "DrawerContent";
const ad = ({
  className: e,
  ...t
}) => /* @__PURE__ */ y.jsx(
  "div",
  {
    className: At("grid gap-1.5 p-4 text-center sm:text-left", e),
    ...t
  }
);
ad.displayName = "DrawerHeader";
const ld = ({
  className: e,
  ...t
}) => /* @__PURE__ */ y.jsx(
  "div",
  {
    className: At("mt-auto flex flex-col gap-2 p-4", e),
    ...t
  }
);
ld.displayName = "DrawerFooter";
const cd = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  $e.Title,
  {
    ref: n,
    className: At(
      "text-lg font-semibold leading-none tracking-tight",
      e
    ),
    ...t
  }
));
cd.displayName = $e.Title.displayName;
const _k = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  $e.Description,
  {
    ref: n,
    className: At("text-sm text-muted-foreground", e),
    ...t
  }
));
_k.displayName = $e.Description.displayName;
function Zk(e, t) {
  return b.useReducer((n, s) => t[n][s] ?? n, e);
}
var Or = (e) => {
  const { present: t, children: n } = e, s = Hk(t), i = typeof n == "function" ? n({ present: s.isPresent }) : b.Children.only(n), r = ct(s.ref, Jk(i));
  return typeof n == "function" || s.isPresent ? b.cloneElement(i, { ref: r }) : null;
};
Or.displayName = "Presence";
function Hk(e) {
  const [t, n] = b.useState(), s = b.useRef({}), i = b.useRef(e), r = b.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = Zk(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return b.useEffect(() => {
    const c = so(s.current);
    r.current = a === "mounted" ? c : "none";
  }, [a]), oe(() => {
    const c = s.current, u = i.current;
    if (u !== e) {
      const h = r.current, f = so(c);
      e ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && h !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), oe(() => {
    if (t) {
      let c;
      const u = t.ownerDocument.defaultView ?? window, d = (f) => {
        const g = so(s.current).includes(f.animationName);
        if (f.target === t && g && (l("ANIMATION_END"), !i.current)) {
          const m = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = m);
          });
        }
      }, h = (f) => {
        f.target === t && (r.current = so(s.current));
      };
      return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
        u.clearTimeout(c), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: b.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function so(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function Jk(e) {
  var s, i;
  let t = (s = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function Xk(e, t = []) {
  let n = [];
  function s(r, o) {
    const a = b.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var A;
      const { scope: h, children: f, ...p } = d, g = ((A = h == null ? void 0 : h[e]) == null ? void 0 : A[l]) || a, m = b.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ y.jsx(g.Provider, { value: m, children: f });
    };
    c.displayName = r + "Provider";
    function u(d, h) {
      var g;
      const f = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[l]) || a, p = b.useContext(f);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${r}\``);
    }
    return [c, u];
  }
  const i = () => {
    const r = n.map((o) => b.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || r;
      return b.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [s, $k(i, ...t)];
}
function $k(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const s = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(r) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(r)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return b.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function tT(e, t) {
  return b.useReducer((n, s) => t[n][s] ?? n, e);
}
var ud = "ScrollArea", [yy, PF] = Xk(ud), [eT, Re] = yy(ud), wy = b.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: n,
      type: s = "hover",
      dir: i,
      scrollHideDelay: r = 600,
      ...o
    } = e, [a, l] = b.useState(null), [c, u] = b.useState(null), [d, h] = b.useState(null), [f, p] = b.useState(null), [g, m] = b.useState(null), [A, w] = b.useState(0), [x, v] = b.useState(0), [C, E] = b.useState(!1), [S, M] = b.useState(!1), q = ct(t, (R) => l(R)), k = Wu(i);
    return /* @__PURE__ */ y.jsx(
      eT,
      {
        scope: n,
        type: s,
        dir: k,
        scrollHideDelay: r,
        scrollArea: a,
        viewport: c,
        onViewportChange: u,
        content: d,
        onContentChange: h,
        scrollbarX: f,
        onScrollbarXChange: p,
        scrollbarXEnabled: C,
        onScrollbarXEnabledChange: E,
        scrollbarY: g,
        onScrollbarYChange: m,
        scrollbarYEnabled: S,
        onScrollbarYEnabledChange: M,
        onCornerWidthChange: w,
        onCornerHeightChange: v,
        children: /* @__PURE__ */ y.jsx(
          ut.div,
          {
            dir: k,
            ...o,
            ref: q,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": A + "px",
              "--radix-scroll-area-corner-height": x + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
wy.displayName = ud;
var by = "ScrollAreaViewport", xy = b.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, children: s, asChild: i, nonce: r, ...o } = e, a = Re(by, n), l = b.useRef(null), c = ct(t, l, a.onViewportChange);
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `
[data-radix-scroll-area-viewport] {
  scrollbar-width: none;
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
}
[data-radix-scroll-area-viewport]::-webkit-scrollbar {
  display: none;
}
:where([data-radix-scroll-area-viewport]) {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
:where([data-radix-scroll-area-content]) {
  flex-grow: 1;
}
`
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ y.jsx(
        ut.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o,
          asChild: i,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: dT({ asChild: i, children: s }, (u) => /* @__PURE__ */ y.jsx(
            "div",
            {
              "data-radix-scroll-area-content": "",
              ref: a.onContentChange,
              style: { minWidth: a.scrollbarXEnabled ? "fit-content" : void 0 },
              children: u
            }
          ))
        }
      )
    ] });
  }
);
xy.displayName = by;
var tn = "ScrollAreaScrollbar", dd = b.forwardRef(
  (e, t) => {
    const { forceMount: n, ...s } = e, i = Re(tn, e.__scopeScrollArea), { onScrollbarXEnabledChange: r, onScrollbarYEnabledChange: o } = i, a = e.orientation === "horizontal";
    return b.useEffect(() => (a ? r(!0) : o(!0), () => {
      a ? r(!1) : o(!1);
    }), [a, r, o]), i.type === "hover" ? /* @__PURE__ */ y.jsx(nT, { ...s, ref: t, forceMount: n }) : i.type === "scroll" ? /* @__PURE__ */ y.jsx(sT, { ...s, ref: t, forceMount: n }) : i.type === "auto" ? /* @__PURE__ */ y.jsx(vy, { ...s, ref: t, forceMount: n }) : i.type === "always" ? /* @__PURE__ */ y.jsx(hd, { ...s, ref: t }) : null;
  }
);
dd.displayName = tn;
var nT = b.forwardRef((e, t) => {
  const { forceMount: n, ...s } = e, i = Re(tn, e.__scopeScrollArea), [r, o] = b.useState(!1);
  return b.useEffect(() => {
    const a = i.scrollArea;
    let l = 0;
    if (a) {
      const c = () => {
        window.clearTimeout(l), o(!0);
      }, u = () => {
        l = window.setTimeout(() => o(!1), i.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", c), a.addEventListener("pointerleave", u), () => {
        window.clearTimeout(l), a.removeEventListener("pointerenter", c), a.removeEventListener("pointerleave", u);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ y.jsx(Or, { present: n || r, children: /* @__PURE__ */ y.jsx(
    vy,
    {
      "data-state": r ? "visible" : "hidden",
      ...s,
      ref: t
    }
  ) });
}), sT = b.forwardRef((e, t) => {
  const { forceMount: n, ...s } = e, i = Re(tn, e.__scopeScrollArea), r = e.orientation === "horizontal", o = La(() => l("SCROLL_END"), 100), [a, l] = tT("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return b.useEffect(() => {
    if (a === "idle") {
      const c = window.setTimeout(() => l("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(c);
    }
  }, [a, i.scrollHideDelay, l]), b.useEffect(() => {
    const c = i.viewport, u = r ? "scrollLeft" : "scrollTop";
    if (c) {
      let d = c[u];
      const h = () => {
        const f = c[u];
        d !== f && (l("SCROLL"), o()), d = f;
      };
      return c.addEventListener("scroll", h), () => c.removeEventListener("scroll", h);
    }
  }, [i.viewport, r, l, o]), /* @__PURE__ */ y.jsx(Or, { present: n || a !== "hidden", children: /* @__PURE__ */ y.jsx(
    hd,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...s,
      ref: t,
      onPointerEnter: at(e.onPointerEnter, () => l("POINTER_ENTER")),
      onPointerLeave: at(e.onPointerLeave, () => l("POINTER_LEAVE"))
    }
  ) });
}), vy = b.forwardRef((e, t) => {
  const n = Re(tn, e.__scopeScrollArea), { forceMount: s, ...i } = e, [r, o] = b.useState(!1), a = e.orientation === "horizontal", l = La(() => {
    if (n.viewport) {
      const c = n.viewport.offsetWidth < n.viewport.scrollWidth, u = n.viewport.offsetHeight < n.viewport.scrollHeight;
      o(a ? c : u);
    }
  }, 10);
  return ii(n.viewport, l), ii(n.content, l), /* @__PURE__ */ y.jsx(Or, { present: s || r, children: /* @__PURE__ */ y.jsx(
    hd,
    {
      "data-state": r ? "visible" : "hidden",
      ...i,
      ref: t
    }
  ) });
}), hd = b.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...s } = e, i = Re(tn, e.__scopeScrollArea), r = b.useRef(null), o = b.useRef(0), [a, l] = b.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), c = qy(a.viewport, a.content), u = {
    ...s,
    sizes: a,
    onSizesChange: l,
    hasThumb: c > 0 && c < 1,
    onThumbChange: (h) => r.current = h,
    onThumbPointerUp: () => o.current = 0,
    onThumbPointerDown: (h) => o.current = h
  };
  function d(h, f) {
    return cT(h, o.current, a, f);
  }
  return n === "horizontal" ? /* @__PURE__ */ y.jsx(
    iT,
    {
      ...u,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && r.current) {
          const h = i.viewport.scrollLeft, f = Zf(h, a, i.dir);
          r.current.style.transform = `translate3d(${f}px, 0, 0)`;
        }
      },
      onWheelScroll: (h) => {
        i.viewport && (i.viewport.scrollLeft = h);
      },
      onDragScroll: (h) => {
        i.viewport && (i.viewport.scrollLeft = d(h, i.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ y.jsx(
    rT,
    {
      ...u,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && r.current) {
          const h = i.viewport.scrollTop, f = Zf(h, a);
          r.current.style.transform = `translate3d(0, ${f}px, 0)`;
        }
      },
      onWheelScroll: (h) => {
        i.viewport && (i.viewport.scrollTop = h);
      },
      onDragScroll: (h) => {
        i.viewport && (i.viewport.scrollTop = d(h));
      }
    }
  ) : null;
}), iT = b.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: s, ...i } = e, r = Re(tn, e.__scopeScrollArea), [o, a] = b.useState(), l = b.useRef(null), c = ct(t, l, r.onScrollbarXChange);
  return b.useEffect(() => {
    l.current && a(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ y.jsx(
    Sy,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: c,
      sizes: n,
      style: {
        bottom: 0,
        left: r.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: r.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Na(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (u) => e.onThumbPointerDown(u.x),
      onDragScroll: (u) => e.onDragScroll(u.x),
      onWheelScroll: (u, d) => {
        if (r.viewport) {
          const h = r.viewport.scrollLeft + u.deltaX;
          e.onWheelScroll(h), ky(h, d) && u.preventDefault();
        }
      },
      onResize: () => {
        l.current && r.viewport && o && s({
          content: r.viewport.scrollWidth,
          viewport: r.viewport.offsetWidth,
          scrollbar: {
            size: l.current.clientWidth,
            paddingStart: oa(o.paddingLeft),
            paddingEnd: oa(o.paddingRight)
          }
        });
      }
    }
  );
}), rT = b.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: s, ...i } = e, r = Re(tn, e.__scopeScrollArea), [o, a] = b.useState(), l = b.useRef(null), c = ct(t, l, r.onScrollbarYChange);
  return b.useEffect(() => {
    l.current && a(getComputedStyle(l.current));
  }, [l]), /* @__PURE__ */ y.jsx(
    Sy,
    {
      "data-orientation": "vertical",
      ...i,
      ref: c,
      sizes: n,
      style: {
        top: 0,
        right: r.dir === "ltr" ? 0 : void 0,
        left: r.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Na(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (u) => e.onThumbPointerDown(u.y),
      onDragScroll: (u) => e.onDragScroll(u.y),
      onWheelScroll: (u, d) => {
        if (r.viewport) {
          const h = r.viewport.scrollTop + u.deltaY;
          e.onWheelScroll(h), ky(h, d) && u.preventDefault();
        }
      },
      onResize: () => {
        l.current && r.viewport && o && s({
          content: r.viewport.scrollHeight,
          viewport: r.viewport.offsetHeight,
          scrollbar: {
            size: l.current.clientHeight,
            paddingStart: oa(o.paddingTop),
            paddingEnd: oa(o.paddingBottom)
          }
        });
      }
    }
  );
}), [oT, Cy] = yy(tn), Sy = b.forwardRef((e, t) => {
  const {
    __scopeScrollArea: n,
    sizes: s,
    hasThumb: i,
    onThumbChange: r,
    onThumbPointerUp: o,
    onThumbPointerDown: a,
    onThumbPositionChange: l,
    onDragScroll: c,
    onWheelScroll: u,
    onResize: d,
    ...h
  } = e, f = Re(tn, n), [p, g] = b.useState(null), m = ct(t, (q) => g(q)), A = b.useRef(null), w = b.useRef(""), x = f.viewport, v = s.content - s.viewport, C = Qt(u), E = Qt(l), S = La(d, 10);
  function M(q) {
    if (A.current) {
      const k = q.clientX - A.current.left, R = q.clientY - A.current.top;
      c({ x: k, y: R });
    }
  }
  return b.useEffect(() => {
    const q = (k) => {
      const R = k.target;
      (p == null ? void 0 : p.contains(R)) && C(k, v);
    };
    return document.addEventListener("wheel", q, { passive: !1 }), () => document.removeEventListener("wheel", q, { passive: !1 });
  }, [x, p, v, C]), b.useEffect(E, [s, E]), ii(p, S), ii(f.content, S), /* @__PURE__ */ y.jsx(
    oT,
    {
      scope: n,
      scrollbar: p,
      hasThumb: i,
      onThumbChange: Qt(r),
      onThumbPointerUp: Qt(o),
      onThumbPositionChange: E,
      onThumbPointerDown: Qt(a),
      children: /* @__PURE__ */ y.jsx(
        ut.div,
        {
          ...h,
          ref: m,
          style: { position: "absolute", ...h.style },
          onPointerDown: at(e.onPointerDown, (q) => {
            q.button === 0 && (q.target.setPointerCapture(q.pointerId), A.current = p.getBoundingClientRect(), w.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", f.viewport && (f.viewport.style.scrollBehavior = "auto"), M(q));
          }),
          onPointerMove: at(e.onPointerMove, M),
          onPointerUp: at(e.onPointerUp, (q) => {
            const k = q.target;
            k.hasPointerCapture(q.pointerId) && k.releasePointerCapture(q.pointerId), document.body.style.webkitUserSelect = w.current, f.viewport && (f.viewport.style.scrollBehavior = ""), A.current = null;
          })
        }
      )
    }
  );
}), ra = "ScrollAreaThumb", My = b.forwardRef(
  (e, t) => {
    const { forceMount: n, ...s } = e, i = Cy(ra, e.__scopeScrollArea);
    return /* @__PURE__ */ y.jsx(Or, { present: n || i.hasThumb, children: /* @__PURE__ */ y.jsx(aT, { ref: t, ...s }) });
  }
), aT = b.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, style: s, ...i } = e, r = Re(ra, n), o = Cy(ra, n), { onThumbPositionChange: a } = o, l = ct(
      t,
      (d) => o.onThumbChange(d)
    ), c = b.useRef(), u = La(() => {
      c.current && (c.current(), c.current = void 0);
    }, 100);
    return b.useEffect(() => {
      const d = r.viewport;
      if (d) {
        const h = () => {
          if (u(), !c.current) {
            const f = uT(d, a);
            c.current = f, a();
          }
        };
        return a(), d.addEventListener("scroll", h), () => d.removeEventListener("scroll", h);
      }
    }, [r.viewport, u, a]), /* @__PURE__ */ y.jsx(
      ut.div,
      {
        "data-state": o.hasThumb ? "visible" : "hidden",
        ...i,
        ref: l,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...s
        },
        onPointerDownCapture: at(e.onPointerDownCapture, (d) => {
          const f = d.target.getBoundingClientRect(), p = d.clientX - f.left, g = d.clientY - f.top;
          o.onThumbPointerDown({ x: p, y: g });
        }),
        onPointerUp: at(e.onPointerUp, o.onThumbPointerUp)
      }
    );
  }
);
My.displayName = ra;
var fd = "ScrollAreaCorner", Ey = b.forwardRef(
  (e, t) => {
    const n = Re(fd, e.__scopeScrollArea), s = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && s ? /* @__PURE__ */ y.jsx(lT, { ...e, ref: t }) : null;
  }
);
Ey.displayName = fd;
var lT = b.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...s } = e, i = Re(fd, n), [r, o] = b.useState(0), [a, l] = b.useState(0), c = !!(r && a);
  return ii(i.scrollbarX, () => {
    var d;
    const u = ((d = i.scrollbarX) == null ? void 0 : d.offsetHeight) || 0;
    i.onCornerHeightChange(u), l(u);
  }), ii(i.scrollbarY, () => {
    var d;
    const u = ((d = i.scrollbarY) == null ? void 0 : d.offsetWidth) || 0;
    i.onCornerWidthChange(u), o(u);
  }), c ? /* @__PURE__ */ y.jsx(
    ut.div,
    {
      ...s,
      ref: t,
      style: {
        width: r,
        height: a,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function oa(e) {
  return e ? parseInt(e, 10) : 0;
}
function qy(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function Na(e) {
  const t = qy(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, s = (e.scrollbar.size - n) * t;
  return Math.max(s, 18);
}
function cT(e, t, n, s = "ltr") {
  const i = Na(n), r = i / 2, o = t || r, a = i - o, l = n.scrollbar.paddingStart + o, c = n.scrollbar.size - n.scrollbar.paddingEnd - a, u = n.content - n.viewport, d = s === "ltr" ? [0, u] : [u * -1, 0];
  return Ry([l, c], d)(e);
}
function Zf(e, t, n = "ltr") {
  const s = Na(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = t.scrollbar.size - i, o = t.content - t.viewport, a = r - s, l = n === "ltr" ? [0, o] : [o * -1, 0], c = Yu(e, l);
  return Ry([0, o], [0, a])(c);
}
function Ry(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const s = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + s * (n - e[0]);
  };
}
function ky(e, t) {
  return e > 0 && e < t;
}
var uT = (e, t = () => {
}) => {
  let n = { left: e.scrollLeft, top: e.scrollTop }, s = 0;
  return function i() {
    const r = { left: e.scrollLeft, top: e.scrollTop }, o = n.left !== r.left, a = n.top !== r.top;
    (o || a) && t(), n = r, s = window.requestAnimationFrame(i);
  }(), () => window.cancelAnimationFrame(s);
};
function La(e, t) {
  const n = Qt(e), s = b.useRef(0);
  return b.useEffect(() => () => window.clearTimeout(s.current), []), b.useCallback(() => {
    window.clearTimeout(s.current), s.current = window.setTimeout(n, t);
  }, [n, t]);
}
function ii(e, t) {
  const n = Qt(t);
  oe(() => {
    let s = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(s), s = window.requestAnimationFrame(n);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(s), i.unobserve(e);
      };
    }
  }, [e, n]);
}
function dT(e, t) {
  const { asChild: n, children: s } = e;
  if (!n) return typeof t == "function" ? t(s) : t;
  const i = b.Children.only(s);
  return b.cloneElement(i, {
    children: typeof t == "function" ? t(i.props.children) : t
  });
}
var Ty = wy, hT = xy, fT = Ey;
const Dy = b.forwardRef(({ className: e, children: t, ...n }, s) => /* @__PURE__ */ y.jsxs(
  Ty,
  {
    ref: s,
    className: At("relative overflow-hidden", e),
    ...n,
    children: [
      /* @__PURE__ */ y.jsx(hT, { className: "h-full w-full rounded-[inherit]", children: t }),
      /* @__PURE__ */ y.jsx(By, {}),
      /* @__PURE__ */ y.jsx(fT, {})
    ]
  }
));
Dy.displayName = Ty.displayName;
const By = b.forwardRef(({ className: e, orientation: t = "vertical", ...n }, s) => /* @__PURE__ */ y.jsx(
  dd,
  {
    ref: s,
    orientation: t,
    className: At(
      "flex touch-none select-none transition-colors",
      t === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      e
    ),
    ...n,
    children: /* @__PURE__ */ y.jsx(My, { className: "relative flex-1 rounded-full bg-border" })
  }
));
By.displayName = dd.displayName;
function pT() {
  const {
    currentServerSeed: e,
    currentClientSeed: t,
    currentNonce: n,
    newServerSeed: s,
    newClientSeed: i,
    newNonce: r,
    setNewServerSeed: o,
    setNewClientSeed: a,
    setNewNonce: l,
    useNewSeeds: c,
    isProvablyFairDialogOpen: u,
    setIsProvablyFairDialogOpen: d
  } = ze(), h = Da(), f = () => {
    const x = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    a(x);
  }, p = () => {
    c(), d(!1);
  }, g = "flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200", m = "flex-grow bg-transparent border-none text-white text-xs h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0 focus:ring-1 focus:ring-brand", A = "text-xs text-gray-400", w = ({ isDrawer: x = !1 }) => /* @__PURE__ */ y.jsxs("div", { className: `space-y-6 px-4 ${x ? "pb-5" : ""}`, children: [
    /* @__PURE__ */ y.jsx("div", { className: "bg-primary rounded-lg p-4 mb-4", children: /* @__PURE__ */ y.jsx("p", { className: "text-white text-sm", children: "You may use this function to set a new server seed + a new client seed. They can be randomly generated or customized (at least 10 characters), and the number of bets will be reset to zero." }) }),
    /* @__PURE__ */ y.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ y.jsxs("div", { className: "flex items-center justify-center space-x-4", children: [
        /* @__PURE__ */ y.jsx("div", { className: "h-px bg-gray-700 flex-grow" }),
        /* @__PURE__ */ y.jsx("h3", { className: "text-sm font-semibold text-gray-400", children: "Current seeds" }),
        /* @__PURE__ */ y.jsx("div", { className: "h-px bg-gray-700 flex-grow" })
      ] }),
      /* @__PURE__ */ y.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ y.jsx(ne, { htmlFor: "current-server-seed", className: A, children: "Server Seed (hash)" }),
        /* @__PURE__ */ y.jsx("div", { className: g, children: /* @__PURE__ */ y.jsx(
          ye,
          {
            id: "current-server-seed",
            value: e,
            readOnly: !0,
            className: m
          }
        ) })
      ] }),
      /* @__PURE__ */ y.jsxs("div", { className: "flex space-x-4", children: [
        /* @__PURE__ */ y.jsxs("div", { className: "space-y-2 w-[70%]", children: [
          /* @__PURE__ */ y.jsx(ne, { htmlFor: "current-client-seed", className: A, children: "Client Seed" }),
          /* @__PURE__ */ y.jsx("div", { className: g, children: /* @__PURE__ */ y.jsx(
            ye,
            {
              id: "current-client-seed",
              value: t,
              readOnly: !0,
              className: m
            }
          ) })
        ] }),
        /* @__PURE__ */ y.jsxs("div", { className: "space-y-2 w-[30%]", children: [
          /* @__PURE__ */ y.jsx(ne, { htmlFor: "current-nonce", className: A, children: "Nonce" }),
          /* @__PURE__ */ y.jsx("div", { className: g, children: /* @__PURE__ */ y.jsx(
            ye,
            {
              id: "current-nonce",
              value: n,
              readOnly: !0,
              className: m
            }
          ) })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ y.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ y.jsxs("div", { className: "flex items-center justify-center space-x-4", children: [
        /* @__PURE__ */ y.jsx("div", { className: "h-px bg-gray-700 flex-grow" }),
        /* @__PURE__ */ y.jsx("h3", { className: "text-sm font-semibold text-gray-400", children: "New seeds" }),
        /* @__PURE__ */ y.jsx("div", { className: "h-px bg-gray-700 flex-grow" })
      ] }),
      /* @__PURE__ */ y.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ y.jsx(ne, { htmlFor: "new-server-seed", className: A, children: "Server Seed (hash)" }),
        /* @__PURE__ */ y.jsx("div", { className: g, children: /* @__PURE__ */ y.jsx(
          ye,
          {
            id: "new-server-seed",
            value: s,
            onChange: (v) => o(v.target.value),
            className: m,
            placeholder: "Enter new server seed"
          }
        ) })
      ] }),
      /* @__PURE__ */ y.jsxs("div", { className: "flex space-x-4", children: [
        /* @__PURE__ */ y.jsxs("div", { className: "space-y-2 w-[70%]", children: [
          /* @__PURE__ */ y.jsx(
            ne,
            {
              htmlFor: "new-client-seed",
              className: `${A} text-white`,
              children: "Client Seed"
            }
          ),
          /* @__PURE__ */ y.jsxs("div", { className: `${g} relative`, children: [
            /* @__PURE__ */ y.jsx(
              ye,
              {
                id: "new-client-seed",
                value: i,
                onChange: (v) => a(v.target.value),
                className: `${m} pr-8`,
                placeholder: "Enter new client seed"
              }
            ),
            /* @__PURE__ */ y.jsxs(
              se,
              {
                type: "button",
                variant: "ghost",
                size: "icon",
                className: "absolute right-0 top-0 h-full hover:bg-transparent focus:ring-0 focus:ring-offset-0 group",
                onClick: f,
                children: [
                  /* @__PURE__ */ y.jsx(_q, { className: "h-4 w-4 text-gray-400 transition-colors duration-200 group-hover:text-white" }),
                  /* @__PURE__ */ y.jsx("span", { className: "sr-only", children: "Generate random seed" })
                ]
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ y.jsxs("div", { className: "space-y-2 w-[30%]", children: [
          /* @__PURE__ */ y.jsx(ne, { htmlFor: "new-nonce", className: A, children: "Nonce" }),
          /* @__PURE__ */ y.jsx("div", { className: g, children: /* @__PURE__ */ y.jsx(
            ye,
            {
              id: "new-nonce",
              value: r,
              onChange: (v) => l(v.target.value),
              className: m,
              placeholder: "Enter new nonce"
            }
          ) })
        ] })
      ] })
    ] })
  ] });
  return h ? /* @__PURE__ */ y.jsxs(
    rd,
    {
      open: u,
      onOpenChange: d,
      children: [
        /* @__PURE__ */ y.jsx(gy, { asChild: !0, children: /* @__PURE__ */ y.jsx("button", { className: "text-gray-400 hover:text-white", children: /* @__PURE__ */ y.jsx(Bf, { size: 20 }) }) }),
        /* @__PURE__ */ y.jsxs(od, { className: "bg-secondary p-2 border-brand", children: [
          /* @__PURE__ */ y.jsx(ad, { className: "text-center text-white ", children: /* @__PURE__ */ y.jsx(cd, { children: "Provably Fair" }) }),
          /* @__PURE__ */ y.jsx(Dy, { className: "overflow-y-auto no-scrollbar", children: /* @__PURE__ */ y.jsx(w, { isDrawer: !0 }) }),
          /* @__PURE__ */ y.jsxs(ld, { className: "mt-2 space-y-2", children: [
            /* @__PURE__ */ y.jsx(
              se,
              {
                className: "w-full bg-brand hover:bg-brand/80 text-black text-sm",
                onClick: p,
                children: "Use New Seeds"
              }
            ),
            /* @__PURE__ */ y.jsx(my, { asChild: !0, children: /* @__PURE__ */ y.jsx(se, { variant: "outline", className: "w-full", children: "Close" }) })
          ] })
        ] })
      ]
    }
  ) : /* @__PURE__ */ y.jsxs(
    X0,
    {
      open: u,
      onOpenChange: d,
      children: [
        /* @__PURE__ */ y.jsx($0, { asChild: !0, children: /* @__PURE__ */ y.jsx("button", { className: "text-gray-400 hover:text-white", children: /* @__PURE__ */ y.jsx(Bf, { size: 20 }) }) }),
        /* @__PURE__ */ y.jsxs(ed, { className: "sm:max-w-[425px] p-3 sm:p-6 bg-secondary border-brand", children: [
          /* @__PURE__ */ y.jsx(nd, { children: /* @__PURE__ */ y.jsx(sd, { className: "text-white text-center", children: "Provably Fair" }) }),
          /* @__PURE__ */ y.jsx(w, {}),
          /* @__PURE__ */ y.jsxs("div", { className: "mt-4 space-y-2", children: [
            /* @__PURE__ */ y.jsx(
              se,
              {
                className: "w-full bg-brand hover:bg-brand/80 text-black text-sm font-bold py-3 rounded-md",
                onClick: p,
                children: "Use New Seeds"
              }
            ),
            /* @__PURE__ */ y.jsx(ty, { asChild: !0, children: /* @__PURE__ */ y.jsx(se, { variant: "outline", className: "w-full py-3 rounded-md", children: "Close" }) })
          ] })
        ] })
      ]
    }
  );
}
function gT(e, t = []) {
  let n = [];
  function s(r, o) {
    const a = b.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var A;
      const { scope: h, children: f, ...p } = d, g = ((A = h == null ? void 0 : h[e]) == null ? void 0 : A[l]) || a, m = b.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ y.jsx(g.Provider, { value: m, children: f });
    };
    c.displayName = r + "Provider";
    function u(d, h) {
      var g;
      const f = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[l]) || a, p = b.useContext(f);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${r}\``);
    }
    return [c, u];
  }
  const i = () => {
    const r = n.map((o) => b.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || r;
      return b.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [s, mT(i, ...t)];
}
function mT(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const s = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(r) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(r)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return b.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function AT(e, t = []) {
  let n = [];
  function s(r, o) {
    const a = b.createContext(o), l = n.length;
    n = [...n, o];
    const c = (d) => {
      var A;
      const { scope: h, children: f, ...p } = d, g = ((A = h == null ? void 0 : h[e]) == null ? void 0 : A[l]) || a, m = b.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ y.jsx(g.Provider, { value: m, children: f });
    };
    c.displayName = r + "Provider";
    function u(d, h) {
      var g;
      const f = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[l]) || a, p = b.useContext(f);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${r}\``);
    }
    return [c, u];
  }
  const i = () => {
    const r = n.map((o) => b.createContext(o));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || r;
      return b.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return i.scopeName = e, [s, yT(i, ...t)];
}
function yT(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const s = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(r) {
      const o = s.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(r)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return b.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function wT(e, t) {
  return b.useReducer((n, s) => t[n][s] ?? n, e);
}
var Iy = (e) => {
  const { present: t, children: n } = e, s = bT(t), i = typeof n == "function" ? n({ present: s.isPresent }) : b.Children.only(n), r = ct(s.ref, xT(i));
  return typeof n == "function" || s.isPresent ? b.cloneElement(i, { ref: r }) : null;
};
Iy.displayName = "Presence";
function bT(e) {
  const [t, n] = b.useState(), s = b.useRef({}), i = b.useRef(e), r = b.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = wT(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return b.useEffect(() => {
    const c = io(s.current);
    r.current = a === "mounted" ? c : "none";
  }, [a]), oe(() => {
    const c = s.current, u = i.current;
    if (u !== e) {
      const h = r.current, f = io(c);
      e ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && h !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), oe(() => {
    if (t) {
      let c;
      const u = t.ownerDocument.defaultView ?? window, d = (f) => {
        const g = io(s.current).includes(f.animationName);
        if (f.target === t && g && (l("ANIMATION_END"), !i.current)) {
          const m = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = m);
          });
        }
      }, h = (f) => {
        f.target === t && (r.current = io(s.current));
      };
      return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
        u.clearTimeout(c), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: b.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function io(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function xT(e) {
  var s, i;
  let t = (s = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var pd = "Collapsible", [vT, Py] = AT(pd), [CT, gd] = vT(pd), Oy = b.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: n,
      open: s,
      defaultOpen: i,
      disabled: r,
      onOpenChange: o,
      ...a
    } = e, [l = !1, c] = fi({
      prop: s,
      defaultProp: i,
      onChange: o
    });
    return /* @__PURE__ */ y.jsx(
      CT,
      {
        scope: n,
        disabled: r,
        contentId: zs(),
        open: l,
        onOpenToggle: b.useCallback(() => c((u) => !u), [c]),
        children: /* @__PURE__ */ y.jsx(
          ut.div,
          {
            "data-state": Ad(l),
            "data-disabled": r ? "" : void 0,
            ...a,
            ref: t
          }
        )
      }
    );
  }
);
Oy.displayName = pd;
var Ny = "CollapsibleTrigger", Ly = b.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: n, ...s } = e, i = gd(Ny, n);
    return /* @__PURE__ */ y.jsx(
      ut.button,
      {
        type: "button",
        "aria-controls": i.contentId,
        "aria-expanded": i.open || !1,
        "data-state": Ad(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        disabled: i.disabled,
        ...s,
        ref: t,
        onClick: at(e.onClick, i.onOpenToggle)
      }
    );
  }
);
Ly.displayName = Ny;
var md = "CollapsibleContent", Fy = b.forwardRef(
  (e, t) => {
    const { forceMount: n, ...s } = e, i = gd(md, e.__scopeCollapsible);
    return /* @__PURE__ */ y.jsx(Iy, { present: n || i.open, children: ({ present: r }) => /* @__PURE__ */ y.jsx(ST, { ...s, ref: t, present: r }) });
  }
);
Fy.displayName = md;
var ST = b.forwardRef((e, t) => {
  const { __scopeCollapsible: n, present: s, children: i, ...r } = e, o = gd(md, n), [a, l] = b.useState(s), c = b.useRef(null), u = ct(t, c), d = b.useRef(0), h = d.current, f = b.useRef(0), p = f.current, g = o.open || a, m = b.useRef(g), A = b.useRef();
  return b.useEffect(() => {
    const w = requestAnimationFrame(() => m.current = !1);
    return () => cancelAnimationFrame(w);
  }, []), oe(() => {
    const w = c.current;
    if (w) {
      A.current = A.current || {
        transitionDuration: w.style.transitionDuration,
        animationName: w.style.animationName
      }, w.style.transitionDuration = "0s", w.style.animationName = "none";
      const x = w.getBoundingClientRect();
      d.current = x.height, f.current = x.width, m.current || (w.style.transitionDuration = A.current.transitionDuration, w.style.animationName = A.current.animationName), l(s);
    }
  }, [o.open, s]), /* @__PURE__ */ y.jsx(
    ut.div,
    {
      "data-state": Ad(o.open),
      "data-disabled": o.disabled ? "" : void 0,
      id: o.contentId,
      hidden: !g,
      ...r,
      ref: u,
      style: {
        "--radix-collapsible-content-height": h ? `${h}px` : void 0,
        "--radix-collapsible-content-width": p ? `${p}px` : void 0,
        ...e.style
      },
      children: g && i
    }
  );
});
function Ad(e) {
  return e ? "open" : "closed";
}
var MT = Oy, ET = Ly, qT = Fy, xn = "Accordion", RT = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [yd, kT, TT] = t0(xn), [Fa, OF] = gT(xn, [
  TT,
  Py
]), wd = Py(), jy = P.forwardRef(
  (e, t) => {
    const { type: n, ...s } = e, i = s, r = s;
    return /* @__PURE__ */ y.jsx(yd.Provider, { scope: e.__scopeAccordion, children: n === "multiple" ? /* @__PURE__ */ y.jsx(PT, { ...r, ref: t }) : /* @__PURE__ */ y.jsx(IT, { ...i, ref: t }) });
  }
);
jy.displayName = xn;
var [Vy, DT] = Fa(xn), [Uy, BT] = Fa(
  xn,
  { collapsible: !1 }
), IT = P.forwardRef(
  (e, t) => {
    const {
      value: n,
      defaultValue: s,
      onValueChange: i = () => {
      },
      collapsible: r = !1,
      ...o
    } = e, [a, l] = fi({
      prop: n,
      defaultProp: s,
      onChange: i
    });
    return /* @__PURE__ */ y.jsx(
      Vy,
      {
        scope: e.__scopeAccordion,
        value: a ? [a] : [],
        onItemOpen: l,
        onItemClose: P.useCallback(() => r && l(""), [r, l]),
        children: /* @__PURE__ */ y.jsx(Uy, { scope: e.__scopeAccordion, collapsible: r, children: /* @__PURE__ */ y.jsx(Yy, { ...o, ref: t }) })
      }
    );
  }
), PT = P.forwardRef((e, t) => {
  const {
    value: n,
    defaultValue: s,
    onValueChange: i = () => {
    },
    ...r
  } = e, [o = [], a] = fi({
    prop: n,
    defaultProp: s,
    onChange: i
  }), l = P.useCallback(
    (u) => a((d = []) => [...d, u]),
    [a]
  ), c = P.useCallback(
    (u) => a((d = []) => d.filter((h) => h !== u)),
    [a]
  );
  return /* @__PURE__ */ y.jsx(
    Vy,
    {
      scope: e.__scopeAccordion,
      value: o,
      onItemOpen: l,
      onItemClose: c,
      children: /* @__PURE__ */ y.jsx(Uy, { scope: e.__scopeAccordion, collapsible: !0, children: /* @__PURE__ */ y.jsx(Yy, { ...r, ref: t }) })
    }
  );
}), [OT, ja] = Fa(xn), Yy = P.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, disabled: s, dir: i, orientation: r = "vertical", ...o } = e, a = P.useRef(null), l = ct(a, t), c = kT(n), d = Wu(i) === "ltr", h = at(e.onKeyDown, (f) => {
      var M;
      if (!RT.includes(f.key)) return;
      const p = f.target, g = c().filter((q) => {
        var k;
        return !((k = q.ref.current) != null && k.disabled);
      }), m = g.findIndex((q) => q.ref.current === p), A = g.length;
      if (m === -1) return;
      f.preventDefault();
      let w = m;
      const x = 0, v = A - 1, C = () => {
        w = m + 1, w > v && (w = x);
      }, E = () => {
        w = m - 1, w < x && (w = v);
      };
      switch (f.key) {
        case "Home":
          w = x;
          break;
        case "End":
          w = v;
          break;
        case "ArrowRight":
          r === "horizontal" && (d ? C() : E());
          break;
        case "ArrowDown":
          r === "vertical" && C();
          break;
        case "ArrowLeft":
          r === "horizontal" && (d ? E() : C());
          break;
        case "ArrowUp":
          r === "vertical" && E();
          break;
      }
      const S = w % A;
      (M = g[S].ref.current) == null || M.focus();
    });
    return /* @__PURE__ */ y.jsx(
      OT,
      {
        scope: n,
        disabled: s,
        direction: i,
        orientation: r,
        children: /* @__PURE__ */ y.jsx(yd.Slot, { scope: n, children: /* @__PURE__ */ y.jsx(
          ut.div,
          {
            ...o,
            "data-orientation": r,
            ref: l,
            onKeyDown: s ? void 0 : h
          }
        ) })
      }
    );
  }
), aa = "AccordionItem", [NT, bd] = Fa(aa), Wy = P.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, value: s, ...i } = e, r = ja(aa, n), o = DT(aa, n), a = wd(n), l = zs(), c = s && o.value.includes(s) || !1, u = r.disabled || e.disabled;
    return /* @__PURE__ */ y.jsx(
      NT,
      {
        scope: n,
        open: c,
        disabled: u,
        triggerId: l,
        children: /* @__PURE__ */ y.jsx(
          MT,
          {
            "data-orientation": r.orientation,
            "data-state": Zy(c),
            ...a,
            ...i,
            ref: t,
            disabled: u,
            open: c,
            onOpenChange: (d) => {
              d ? o.onItemOpen(s) : o.onItemClose(s);
            }
          }
        )
      }
    );
  }
);
Wy.displayName = aa;
var Qy = "AccordionHeader", Gy = P.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, ...s } = e, i = ja(xn, n), r = bd(Qy, n);
    return /* @__PURE__ */ y.jsx(
      ut.h3,
      {
        "data-orientation": i.orientation,
        "data-state": Zy(r.open),
        "data-disabled": r.disabled ? "" : void 0,
        ...s,
        ref: t
      }
    );
  }
);
Gy.displayName = Qy;
var qc = "AccordionTrigger", Ky = P.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, ...s } = e, i = ja(xn, n), r = bd(qc, n), o = BT(qc, n), a = wd(n);
    return /* @__PURE__ */ y.jsx(yd.ItemSlot, { scope: n, children: /* @__PURE__ */ y.jsx(
      ET,
      {
        "aria-disabled": r.open && !o.collapsible || void 0,
        "data-orientation": i.orientation,
        id: r.triggerId,
        ...a,
        ...s,
        ref: t
      }
    ) });
  }
);
Ky.displayName = qc;
var zy = "AccordionContent", _y = P.forwardRef(
  (e, t) => {
    const { __scopeAccordion: n, ...s } = e, i = ja(xn, n), r = bd(zy, n), o = wd(n);
    return /* @__PURE__ */ y.jsx(
      qT,
      {
        role: "region",
        "aria-labelledby": r.triggerId,
        "data-orientation": i.orientation,
        ...o,
        ...s,
        ref: t,
        style: {
          "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
          "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
          ...e.style
        }
      }
    );
  }
);
_y.displayName = zy;
function Zy(e) {
  return e ? "open" : "closed";
}
var LT = jy, FT = Wy, jT = Gy, Hy = Ky, Jy = _y;
const VT = LT, Ro = b.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ y.jsx(
  FT,
  {
    ref: n,
    className: At("border-b", e),
    ...t
  }
));
Ro.displayName = "AccordionItem";
const ko = b.forwardRef(({ className: e, children: t, ...n }, s) => /* @__PURE__ */ y.jsx(jT, { className: "flex", children: /* @__PURE__ */ y.jsxs(
  Hy,
  {
    ref: s,
    className: At(
      "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
      e
    ),
    ...n,
    children: [
      t,
      /* @__PURE__ */ y.jsx(yk, { className: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
    ]
  }
) }));
ko.displayName = Hy.displayName;
const To = b.forwardRef(({ className: e, children: t, ...n }, s) => /* @__PURE__ */ y.jsx(
  Jy,
  {
    ref: s,
    className: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
    ...n,
    children: /* @__PURE__ */ y.jsx("div", { className: At("pb-4 pt-0", e), children: t })
  }
));
To.displayName = Jy.displayName;
function UT() {
  const {
    isHelpDialogOpen: e,
    setIsHelpDialogOpen: t,
    selectedCurrency: n
  } = ze(), s = Da(), i = () => /* @__PURE__ */ y.jsxs(VT, { type: "single", collapsible: !0, defaultValue: "how-to-play", className: "w-full", children: [
    /* @__PURE__ */ y.jsxs(Ro, { value: "how-to-play", children: [
      /* @__PURE__ */ y.jsx(ko, { className: "font-bold", children: "How to Play" }),
      /* @__PURE__ */ y.jsxs(To, { children: [
        /* @__PURE__ */ y.jsx("p", { children: "Here's how to play the game:" }),
        /* @__PURE__ */ y.jsxs("ul", { className: "list-disc pl-5 mt-2", children: [
          /* @__PURE__ */ y.jsx("li", { children: "Select your bet amount" }),
          /* @__PURE__ */ y.jsx("li", { children: "Click the 'Play' button to start the game" }),
          /* @__PURE__ */ y.jsx("li", { children: "Watch as the multiplier increases" }),
          /* @__PURE__ */ y.jsx("li", { children: "Cash out before the game crashes to win!" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ y.jsxs(Ro, { value: "rules", children: [
      /* @__PURE__ */ y.jsx(ko, { className: "font-bold", children: "Rules" }),
      /* @__PURE__ */ y.jsxs(To, { children: [
        /* @__PURE__ */ y.jsx("p", { children: "Game rules and regulations:" }),
        /* @__PURE__ */ y.jsxs("ul", { className: "list-disc pl-5 mt-2", children: [
          /* @__PURE__ */ y.jsxs("li", { children: [
            "Minimum bet: ",
            n.prefixSymbol,
            n.fractionalDigits
          ] }),
          /* @__PURE__ */ y.jsxs("li", { children: [
            "Maximum bet: ",
            n.prefixSymbol,
            "1000"
          ] }),
          /* @__PURE__ */ y.jsx("li", { children: "The game can crash at any moment" }),
          /* @__PURE__ */ y.jsx("li", { children: "Your potential winnings increase as the multiplier grows" }),
          /* @__PURE__ */ y.jsx("li", { children: "If you don't cash out before the crash, you lose your bet" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ y.jsxs(Ro, { value: "faq", children: [
      /* @__PURE__ */ y.jsx(ko, { className: "font-bold", children: "FAQ" }),
      /* @__PURE__ */ y.jsx(To, { children: /* @__PURE__ */ y.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ y.jsxs("div", { children: [
          /* @__PURE__ */ y.jsx("h4", { className: "font-semibold", children: "Q: Is the game fair?" }),
          /* @__PURE__ */ y.jsx("p", { children: "A: Yes, the game uses a provably fair algorithm." })
        ] }),
        /* @__PURE__ */ y.jsxs("div", { children: [
          /* @__PURE__ */ y.jsx("h4", { className: "font-semibold", children: "Q: Can I play on mobile?" }),
          /* @__PURE__ */ y.jsx("p", { children: "A: Yes, the game is fully responsive and works on all devices." })
        ] }),
        /* @__PURE__ */ y.jsxs("div", { children: [
          /* @__PURE__ */ y.jsx("h4", { className: "font-semibold", children: "Q: How do I deposit?" }),
          /* @__PURE__ */ y.jsx("p", { children: "A: You can deposit using various cryptocurrencies or traditional payment methods." })
        ] })
      ] }) })
    ] })
  ] });
  return s ? /* @__PURE__ */ y.jsxs(
    rd,
    {
      open: e,
      onOpenChange: t,
      children: [
        /* @__PURE__ */ y.jsx(gy, { asChild: !0, children: /* @__PURE__ */ y.jsx("button", { className: "text-gray-400 hover:text-white px-2", children: /* @__PURE__ */ y.jsx(Df, { size: 20 }) }) }),
        /* @__PURE__ */ y.jsxs(od, { className: "bg-secondary text-white p-2", children: [
          /* @__PURE__ */ y.jsx(ad, { className: "text-center", children: /* @__PURE__ */ y.jsx(cd, { children: "Game Information" }) }),
          /* @__PURE__ */ y.jsx("div", { className: "px-4 flex-1 overflow-y-auto", children: /* @__PURE__ */ y.jsx(i, {}) }),
          /* @__PURE__ */ y.jsx(ld, { className: "mt-2", children: /* @__PURE__ */ y.jsx(my, { asChild: !0, children: /* @__PURE__ */ y.jsx(se, { variant: "outline", className: "w-full py-3 rounded-md text-black", children: "Close" }) }) })
        ] })
      ]
    }
  ) : /* @__PURE__ */ y.jsxs(
    X0,
    {
      open: e,
      onOpenChange: t,
      children: [
        /* @__PURE__ */ y.jsx($0, { asChild: !0, children: /* @__PURE__ */ y.jsx("button", { className: "text-gray-400 hover:text-white px-2", children: /* @__PURE__ */ y.jsx(Df, { size: 20 }) }) }),
        /* @__PURE__ */ y.jsxs(ed, { className: "sm:max-w-[425px] p-3 sm:p-6 bg-secondary flex flex-col text-white border-brand", children: [
          /* @__PURE__ */ y.jsx(nd, { children: /* @__PURE__ */ y.jsx(sd, { className: "text-center", children: "Game Information" }) }),
          /* @__PURE__ */ y.jsx("div", { className: "flex-grow overflow-y-auto", children: /* @__PURE__ */ y.jsx(i, {}) }),
          /* @__PURE__ */ y.jsx("div", { className: "mt-4 text-black", children: /* @__PURE__ */ y.jsx(ty, { asChild: !0, children: /* @__PURE__ */ y.jsx(se, { variant: "outline", className: "w-full py-3 rounded-md", children: "Close" }) }) })
        ] })
      ]
    }
  );
}
function YT({
  setLiveStatsOpen: e
}) {
  const {
    balance: t,
    selectedCurrency: n,
    initializing: s,
    isSoundMuted: i,
    setIsSoundMuted: r
  } = ze(), o = t.toFixed(n.fractionalDigits), a = () => {
    r(!i);
  };
  return /* @__PURE__ */ y.jsxs("div", { className: "h-[55px] bg-[#152538] border-t border-gray-700 flex items-center justify-between px-4", children: [
    /* @__PURE__ */ y.jsx("div", { className: "flex items-center space-x-4 text-gray-400", children: s ? /* @__PURE__ */ y.jsxs("div", { className: "h-8 w-[110px] flex items-center w-full space-x-2", children: [
      /* @__PURE__ */ y.jsx(zi, { className: "h-8 w-20 bg-gray-700" }),
      /* @__PURE__ */ y.jsx(zi, { className: "h-8 w-5 bg-gray-700 rounded-full" })
    ] }) : /* @__PURE__ */ y.jsxs("span", { className: "text-xl font-bold text-white w-full justify-between", children: [
      n.prefixSymbol,
      o
    ] }) }),
    /* @__PURE__ */ y.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ y.jsx(
        "button",
        {
          className: `hover:text-white px-2 ${i ? "text-gray-400" : "text-green-400"}`,
          onClick: a,
          children: i ? /* @__PURE__ */ y.jsx(Hq, { size: 20 }) : /* @__PURE__ */ y.jsx(Zq, { size: 20 })
        }
      ),
      /* @__PURE__ */ y.jsx(
        "button",
        {
          className: "text-gray-400 px-2 hover:text-white",
          onClick: () => e(!0),
          children: /* @__PURE__ */ y.jsx(m0, { size: 20 })
        }
      ),
      /* @__PURE__ */ y.jsx(UT, {}),
      /* @__PURE__ */ y.jsx(pT, {})
    ] })
  ] });
}
var WT = "DismissableLayer", Rc = "dismissableLayer.update", QT = "dismissableLayer.pointerDownOutside", GT = "dismissableLayer.focusOutside", Hf, Xy = b.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), $y = b.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: s,
      onPointerDownOutside: i,
      onFocusOutside: r,
      onInteractOutside: o,
      onDismiss: a,
      ...l
    } = e, c = b.useContext(Xy), [u, d] = b.useState(null), h = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, f] = b.useState({}), p = ct(t, (S) => d(S)), g = Array.from(c.layers), [m] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), A = g.indexOf(m), w = u ? g.indexOf(u) : -1, x = c.layersWithOutsidePointerEventsDisabled.size > 0, v = w >= A, C = _T((S) => {
      const M = S.target, q = [...c.branches].some((k) => k.contains(M));
      !v || q || (i == null || i(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, h), E = ZT((S) => {
      const M = S.target;
      [...c.branches].some((k) => k.contains(M)) || (r == null || r(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, h);
    return A0((S) => {
      w === c.layers.size - 1 && (s == null || s(S), !S.defaultPrevented && a && (S.preventDefault(), a()));
    }, h), b.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (Hf = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), Jf(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = Hf);
        };
    }, [u, h, n, c]), b.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), Jf());
    }, [u, c]), b.useEffect(() => {
      const S = () => f({});
      return document.addEventListener(Rc, S), () => document.removeEventListener(Rc, S);
    }, []), /* @__PURE__ */ y.jsx(
      ut.div,
      {
        ...l,
        ref: p,
        style: {
          pointerEvents: x ? v ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: at(e.onFocusCapture, E.onFocusCapture),
        onBlurCapture: at(e.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: at(
          e.onPointerDownCapture,
          C.onPointerDownCapture
        )
      }
    );
  }
);
$y.displayName = WT;
var KT = "DismissableLayerBranch", zT = b.forwardRef((e, t) => {
  const n = b.useContext(Xy), s = b.useRef(null), i = ct(t, s);
  return b.useEffect(() => {
    const r = s.current;
    if (r)
      return n.branches.add(r), () => {
        n.branches.delete(r);
      };
  }, [n.branches]), /* @__PURE__ */ y.jsx(ut.div, { ...e, ref: i });
});
zT.displayName = KT;
function _T(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qt(e), s = b.useRef(!1), i = b.useRef(() => {
  });
  return b.useEffect(() => {
    const r = (a) => {
      if (a.target && !s.current) {
        let l = function() {
          tw(
            QT,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", i.current);
      s.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", r);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", r), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => s.current = !0
  };
}
function ZT(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qt(e), s = b.useRef(!1);
  return b.useEffect(() => {
    const i = (r) => {
      r.target && !s.current && tw(GT, n, { originalEvent: r }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => s.current = !0,
    onBlurCapture: () => s.current = !1
  };
}
function Jf() {
  const e = new CustomEvent(Rc);
  document.dispatchEvent(e);
}
function tw(e, t, n, { discrete: s }) {
  const i = n.originalEvent.target, r = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), s ? VA(i, r) : i.dispatchEvent(r);
}
const HT = ["top", "right", "bottom", "left"], Kn = Math.min, we = Math.max, la = Math.round, ro = Math.floor, zn = (e) => ({
  x: e,
  y: e
}), JT = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, XT = {
  start: "end",
  end: "start"
};
function kc(e, t, n) {
  return we(e, Kn(t, n));
}
function wn(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function bn(e) {
  return e.split("-")[0];
}
function mi(e) {
  return e.split("-")[1];
}
function xd(e) {
  return e === "x" ? "y" : "x";
}
function vd(e) {
  return e === "y" ? "height" : "width";
}
function _n(e) {
  return ["top", "bottom"].includes(bn(e)) ? "y" : "x";
}
function Cd(e) {
  return xd(_n(e));
}
function $T(e, t, n) {
  n === void 0 && (n = !1);
  const s = mi(e), i = Cd(e), r = vd(i);
  let o = i === "x" ? s === (n ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (o = ca(o)), [o, ca(o)];
}
function tD(e) {
  const t = ca(e);
  return [Tc(e), t, Tc(t)];
}
function Tc(e) {
  return e.replace(/start|end/g, (t) => XT[t]);
}
function eD(e, t, n) {
  const s = ["left", "right"], i = ["right", "left"], r = ["top", "bottom"], o = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? i : s : t ? s : i;
    case "left":
    case "right":
      return t ? r : o;
    default:
      return [];
  }
}
function nD(e, t, n, s) {
  const i = mi(e);
  let r = eD(bn(e), n === "start", s);
  return i && (r = r.map((o) => o + "-" + i), t && (r = r.concat(r.map(Tc)))), r;
}
function ca(e) {
  return e.replace(/left|right|bottom|top/g, (t) => JT[t]);
}
function sD(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function ew(e) {
  return typeof e != "number" ? sD(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function ua(e) {
  const {
    x: t,
    y: n,
    width: s,
    height: i
  } = e;
  return {
    width: s,
    height: i,
    top: n,
    left: t,
    right: t + s,
    bottom: n + i,
    x: t,
    y: n
  };
}
function Xf(e, t, n) {
  let {
    reference: s,
    floating: i
  } = e;
  const r = _n(t), o = Cd(t), a = vd(o), l = bn(t), c = r === "y", u = s.x + s.width / 2 - i.width / 2, d = s.y + s.height / 2 - i.height / 2, h = s[a] / 2 - i[a] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: u,
        y: s.y - i.height
      };
      break;
    case "bottom":
      f = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      f = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: s.x - i.width,
        y: d
      };
      break;
    default:
      f = {
        x: s.x,
        y: s.y
      };
  }
  switch (mi(t)) {
    case "start":
      f[o] -= h * (n && c ? -1 : 1);
      break;
    case "end":
      f[o] += h * (n && c ? -1 : 1);
      break;
  }
  return f;
}
const iD = async (e, t, n) => {
  const {
    placement: s = "bottom",
    strategy: i = "absolute",
    middleware: r = [],
    platform: o
  } = n, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: u,
    y: d
  } = Xf(c, s, l), h = s, f = {}, p = 0;
  for (let g = 0; g < a.length; g++) {
    const {
      name: m,
      fn: A
    } = a[g], {
      x: w,
      y: x,
      data: v,
      reset: C
    } = await A({
      x: u,
      y: d,
      initialPlacement: s,
      placement: h,
      strategy: i,
      middlewareData: f,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = w ?? u, d = x ?? d, f = {
      ...f,
      [m]: {
        ...f[m],
        ...v
      }
    }, C && p <= 50 && (p++, typeof C == "object" && (C.placement && (h = C.placement), C.rects && (c = C.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : C.rects), {
      x: u,
      y: d
    } = Xf(c, h, l)), g = -1);
  }
  return {
    x: u,
    y: d,
    placement: h,
    strategy: i,
    middlewareData: f
  };
};
async function yr(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: s,
    y: i,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: h = !1,
    padding: f = 0
  } = wn(t, e), p = ew(f), m = a[h ? d === "floating" ? "reference" : "floating" : d], A = ua(await r.getClippingRect({
    element: (n = await (r.isElement == null ? void 0 : r.isElement(m))) == null || n ? m : m.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), w = d === "floating" ? {
    x: s,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, x = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), v = await (r.isElement == null ? void 0 : r.isElement(x)) ? await (r.getScale == null ? void 0 : r.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = ua(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: w,
    offsetParent: x,
    strategy: l
  }) : w);
  return {
    top: (A.top - C.top + p.top) / v.y,
    bottom: (C.bottom - A.bottom + p.bottom) / v.y,
    left: (A.left - C.left + p.left) / v.x,
    right: (C.right - A.right + p.right) / v.x
  };
}
const rD = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: s,
      placement: i,
      rects: r,
      platform: o,
      elements: a,
      middlewareData: l
    } = t, {
      element: c,
      padding: u = 0
    } = wn(e, t) || {};
    if (c == null)
      return {};
    const d = ew(u), h = {
      x: n,
      y: s
    }, f = Cd(i), p = vd(f), g = await o.getDimensions(c), m = f === "y", A = m ? "top" : "left", w = m ? "bottom" : "right", x = m ? "clientHeight" : "clientWidth", v = r.reference[p] + r.reference[f] - h[f] - r.floating[p], C = h[f] - r.reference[f], E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
    let S = E ? E[x] : 0;
    (!S || !await (o.isElement == null ? void 0 : o.isElement(E))) && (S = a.floating[x] || r.floating[p]);
    const M = v / 2 - C / 2, q = S / 2 - g[p] / 2 - 1, k = Kn(d[A], q), R = Kn(d[w], q), D = k, j = S - g[p] - R, W = S / 2 - g[p] / 2 + M, O = kc(D, W, j), U = !l.arrow && mi(i) != null && W !== O && r.reference[p] / 2 - (W < D ? k : R) - g[p] / 2 < 0, I = U ? W < D ? W - D : W - j : 0;
    return {
      [f]: h[f] + I,
      data: {
        [f]: O,
        centerOffset: W - O - I,
        ...U && {
          alignmentOffset: I
        }
      },
      reset: U
    };
  }
}), oD = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, s;
      const {
        placement: i,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: h,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: g = !0,
        ...m
      } = wn(e, t);
      if ((n = r.arrow) != null && n.alignmentOffset)
        return {};
      const A = bn(i), w = _n(a), x = bn(a) === a, v = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), C = h || (x || !g ? [ca(a)] : tD(a)), E = p !== "none";
      !h && E && C.push(...nD(a, g, p, v));
      const S = [a, ...C], M = await yr(t, m), q = [];
      let k = ((s = r.flip) == null ? void 0 : s.overflows) || [];
      if (u && q.push(M[A]), d) {
        const W = $T(i, o, v);
        q.push(M[W[0]], M[W[1]]);
      }
      if (k = [...k, {
        placement: i,
        overflows: q
      }], !q.every((W) => W <= 0)) {
        var R, D;
        const W = (((R = r.flip) == null ? void 0 : R.index) || 0) + 1, O = S[W];
        if (O)
          return {
            data: {
              index: W,
              overflows: k
            },
            reset: {
              placement: O
            }
          };
        let U = (D = k.filter((I) => I.overflows[0] <= 0).sort((I, F) => I.overflows[1] - F.overflows[1])[0]) == null ? void 0 : D.placement;
        if (!U)
          switch (f) {
            case "bestFit": {
              var j;
              const I = (j = k.filter((F) => {
                if (E) {
                  const Q = _n(F.placement);
                  return Q === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Q === "y";
                }
                return !0;
              }).map((F) => [F.placement, F.overflows.filter((Q) => Q > 0).reduce((Q, J) => Q + J, 0)]).sort((F, Q) => F[1] - Q[1])[0]) == null ? void 0 : j[0];
              I && (U = I);
              break;
            }
            case "initialPlacement":
              U = a;
              break;
          }
        if (i !== U)
          return {
            reset: {
              placement: U
            }
          };
      }
      return {};
    }
  };
};
function $f(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function tp(e) {
  return HT.some((t) => e[t] >= 0);
}
const aD = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: s = "referenceHidden",
        ...i
      } = wn(e, t);
      switch (s) {
        case "referenceHidden": {
          const r = await yr(t, {
            ...i,
            elementContext: "reference"
          }), o = $f(r, n.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: tp(o)
            }
          };
        }
        case "escaped": {
          const r = await yr(t, {
            ...i,
            altBoundary: !0
          }), o = $f(r, n.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: tp(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function lD(e, t) {
  const {
    placement: n,
    platform: s,
    elements: i
  } = e, r = await (s.isRTL == null ? void 0 : s.isRTL(i.floating)), o = bn(n), a = mi(n), l = _n(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = r && l ? -1 : 1, d = wn(t, e);
  let {
    mainAxis: h,
    crossAxis: f,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof p == "number" && (f = a === "end" ? p * -1 : p), l ? {
    x: f * u,
    y: h * c
  } : {
    x: h * c,
    y: f * u
  };
}
const cD = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, s;
      const {
        x: i,
        y: r,
        placement: o,
        middlewareData: a
      } = t, l = await lD(t, e);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: i + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, uD = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: s,
        placement: i
      } = t, {
        mainAxis: r = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (m) => {
            let {
              x: A,
              y: w
            } = m;
            return {
              x: A,
              y: w
            };
          }
        },
        ...l
      } = wn(e, t), c = {
        x: n,
        y: s
      }, u = await yr(t, l), d = _n(bn(i)), h = xd(d);
      let f = c[h], p = c[d];
      if (r) {
        const m = h === "y" ? "top" : "left", A = h === "y" ? "bottom" : "right", w = f + u[m], x = f - u[A];
        f = kc(w, f, x);
      }
      if (o) {
        const m = d === "y" ? "top" : "left", A = d === "y" ? "bottom" : "right", w = p + u[m], x = p - u[A];
        p = kc(w, p, x);
      }
      const g = a.fn({
        ...t,
        [h]: f,
        [d]: p
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - s,
          enabled: {
            [h]: r,
            [d]: o
          }
        }
      };
    }
  };
}, dD = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: s,
        placement: i,
        rects: r,
        middlewareData: o
      } = t, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = wn(e, t), u = {
        x: n,
        y: s
      }, d = _n(i), h = xd(d);
      let f = u[h], p = u[d];
      const g = wn(a, t), m = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (l) {
        const x = h === "y" ? "height" : "width", v = r.reference[h] - r.floating[x] + m.mainAxis, C = r.reference[h] + r.reference[x] - m.mainAxis;
        f < v ? f = v : f > C && (f = C);
      }
      if (c) {
        var A, w;
        const x = h === "y" ? "width" : "height", v = ["top", "left"].includes(bn(i)), C = r.reference[d] - r.floating[x] + (v && ((A = o.offset) == null ? void 0 : A[d]) || 0) + (v ? 0 : m.crossAxis), E = r.reference[d] + r.reference[x] + (v ? 0 : ((w = o.offset) == null ? void 0 : w[d]) || 0) - (v ? m.crossAxis : 0);
        p < C ? p = C : p > E && (p = E);
      }
      return {
        [h]: f,
        [d]: p
      };
    }
  };
}, hD = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, s;
      const {
        placement: i,
        rects: r,
        platform: o,
        elements: a
      } = t, {
        apply: l = () => {
        },
        ...c
      } = wn(e, t), u = await yr(t, c), d = bn(i), h = mi(i), f = _n(i) === "y", {
        width: p,
        height: g
      } = r.floating;
      let m, A;
      d === "top" || d === "bottom" ? (m = d, A = h === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (A = d, m = h === "end" ? "top" : "bottom");
      const w = g - u.top - u.bottom, x = p - u.left - u.right, v = Kn(g - u[m], w), C = Kn(p - u[A], x), E = !t.middlewareData.shift;
      let S = v, M = C;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (M = x), (s = t.middlewareData.shift) != null && s.enabled.y && (S = w), E && !h) {
        const k = we(u.left, 0), R = we(u.right, 0), D = we(u.top, 0), j = we(u.bottom, 0);
        f ? M = p - 2 * (k !== 0 || R !== 0 ? k + R : we(u.left, u.right)) : S = g - 2 * (D !== 0 || j !== 0 ? D + j : we(u.top, u.bottom));
      }
      await l({
        ...t,
        availableWidth: M,
        availableHeight: S
      });
      const q = await o.getDimensions(a.floating);
      return p !== q.width || g !== q.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Va() {
  return typeof window < "u";
}
function Ai(e) {
  return nw(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function xe(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function en(e) {
  var t;
  return (t = (nw(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function nw(e) {
  return Va() ? e instanceof Node || e instanceof xe(e).Node : !1;
}
function Le(e) {
  return Va() ? e instanceof Element || e instanceof xe(e).Element : !1;
}
function Xe(e) {
  return Va() ? e instanceof HTMLElement || e instanceof xe(e).HTMLElement : !1;
}
function ep(e) {
  return !Va() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof xe(e).ShadowRoot;
}
function Nr(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: s,
    display: i
  } = Fe(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + n) && !["inline", "contents"].includes(i);
}
function fD(e) {
  return ["table", "td", "th"].includes(Ai(e));
}
function Ua(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Sd(e) {
  const t = Md(), n = Le(e) ? Fe(e) : e;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (n.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (n.contain || "").includes(s));
}
function pD(e) {
  let t = Zn(e);
  for (; Xe(t) && !ri(t); ) {
    if (Sd(t))
      return t;
    if (Ua(t))
      return null;
    t = Zn(t);
  }
  return null;
}
function Md() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ri(e) {
  return ["html", "body", "#document"].includes(Ai(e));
}
function Fe(e) {
  return xe(e).getComputedStyle(e);
}
function Ya(e) {
  return Le(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Zn(e) {
  if (Ai(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    ep(e) && e.host || // Fallback.
    en(e)
  );
  return ep(t) ? t.host : t;
}
function sw(e) {
  const t = Zn(e);
  return ri(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Xe(t) && Nr(t) ? t : sw(t);
}
function wr(e, t, n) {
  var s;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = sw(e), r = i === ((s = e.ownerDocument) == null ? void 0 : s.body), o = xe(i);
  if (r) {
    const a = Dc(o);
    return t.concat(o, o.visualViewport || [], Nr(i) ? i : [], a && n ? wr(a) : []);
  }
  return t.concat(i, wr(i, [], n));
}
function Dc(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function iw(e) {
  const t = Fe(e);
  let n = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const i = Xe(e), r = i ? e.offsetWidth : n, o = i ? e.offsetHeight : s, a = la(n) !== r || la(s) !== o;
  return a && (n = r, s = o), {
    width: n,
    height: s,
    $: a
  };
}
function Ed(e) {
  return Le(e) ? e : e.contextElement;
}
function Zs(e) {
  const t = Ed(e);
  if (!Xe(t))
    return zn(1);
  const n = t.getBoundingClientRect(), {
    width: s,
    height: i,
    $: r
  } = iw(t);
  let o = (r ? la(n.width) : n.width) / s, a = (r ? la(n.height) : n.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const gD = /* @__PURE__ */ zn(0);
function rw(e) {
  const t = xe(e);
  return !Md() || !t.visualViewport ? gD : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function mD(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== xe(e) ? !1 : t;
}
function Es(e, t, n, s) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), r = Ed(e);
  let o = zn(1);
  t && (s ? Le(s) && (o = Zs(s)) : o = Zs(e));
  const a = mD(r, n, s) ? rw(r) : zn(0);
  let l = (i.left + a.x) / o.x, c = (i.top + a.y) / o.y, u = i.width / o.x, d = i.height / o.y;
  if (r) {
    const h = xe(r), f = s && Le(s) ? xe(s) : s;
    let p = h, g = Dc(p);
    for (; g && s && f !== p; ) {
      const m = Zs(g), A = g.getBoundingClientRect(), w = Fe(g), x = A.left + (g.clientLeft + parseFloat(w.paddingLeft)) * m.x, v = A.top + (g.clientTop + parseFloat(w.paddingTop)) * m.y;
      l *= m.x, c *= m.y, u *= m.x, d *= m.y, l += x, c += v, p = xe(g), g = Dc(p);
    }
  }
  return ua({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function AD(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: s,
    strategy: i
  } = e;
  const r = i === "fixed", o = en(s), a = t ? Ua(t.floating) : !1;
  if (s === o || a && r)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = zn(1);
  const u = zn(0), d = Xe(s);
  if ((d || !d && !r) && ((Ai(s) !== "body" || Nr(o)) && (l = Ya(s)), Xe(s))) {
    const h = Es(s);
    c = Zs(s), u.x = h.x + s.clientLeft, u.y = h.y + s.clientTop;
  }
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y
  };
}
function yD(e) {
  return Array.from(e.getClientRects());
}
function Bc(e, t) {
  const n = Ya(e).scrollLeft;
  return t ? t.left + n : Es(en(e)).left + n;
}
function wD(e) {
  const t = en(e), n = Ya(e), s = e.ownerDocument.body, i = we(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), r = we(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -n.scrollLeft + Bc(e);
  const a = -n.scrollTop;
  return Fe(s).direction === "rtl" && (o += we(t.clientWidth, s.clientWidth) - i), {
    width: i,
    height: r,
    x: o,
    y: a
  };
}
function bD(e, t) {
  const n = xe(e), s = en(e), i = n.visualViewport;
  let r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;
  if (i) {
    r = i.width, o = i.height;
    const c = Md();
    (!c || c && t === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function xD(e, t) {
  const n = Es(e, !0, t === "fixed"), s = n.top + e.clientTop, i = n.left + e.clientLeft, r = Xe(e) ? Zs(e) : zn(1), o = e.clientWidth * r.x, a = e.clientHeight * r.y, l = i * r.x, c = s * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function np(e, t, n) {
  let s;
  if (t === "viewport")
    s = bD(e, n);
  else if (t === "document")
    s = wD(en(e));
  else if (Le(t))
    s = xD(t, n);
  else {
    const i = rw(e);
    s = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return ua(s);
}
function ow(e, t) {
  const n = Zn(e);
  return n === t || !Le(n) || ri(n) ? !1 : Fe(n).position === "fixed" || ow(n, t);
}
function vD(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let s = wr(e, [], !1).filter((a) => Le(a) && Ai(a) !== "body"), i = null;
  const r = Fe(e).position === "fixed";
  let o = r ? Zn(e) : e;
  for (; Le(o) && !ri(o); ) {
    const a = Fe(o), l = Sd(o);
    !l && a.position === "fixed" && (i = null), (r ? !l && !i : !l && a.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Nr(o) && !l && ow(e, o)) ? s = s.filter((u) => u !== o) : i = a, o = Zn(o);
  }
  return t.set(e, s), s;
}
function CD(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: s,
    strategy: i
  } = e;
  const o = [...n === "clippingAncestors" ? Ua(t) ? [] : vD(t, this._c) : [].concat(n), s], a = o[0], l = o.reduce((c, u) => {
    const d = np(t, u, i);
    return c.top = we(d.top, c.top), c.right = Kn(d.right, c.right), c.bottom = Kn(d.bottom, c.bottom), c.left = we(d.left, c.left), c;
  }, np(t, a, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function SD(e) {
  const {
    width: t,
    height: n
  } = iw(e);
  return {
    width: t,
    height: n
  };
}
function MD(e, t, n) {
  const s = Xe(t), i = en(t), r = n === "fixed", o = Es(e, !0, r, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = zn(0);
  if (s || !s && !r)
    if ((Ai(t) !== "body" || Nr(i)) && (a = Ya(t)), s) {
      const f = Es(t, !0, r, t);
      l.x = f.x + t.clientLeft, l.y = f.y + t.clientTop;
    } else i && (l.x = Bc(i));
  let c = 0, u = 0;
  if (i && !s && !r) {
    const f = i.getBoundingClientRect();
    u = f.top + a.scrollTop, c = f.left + a.scrollLeft - // RTL <body> scrollbar.
    Bc(i, f);
  }
  const d = o.left + a.scrollLeft - l.x - c, h = o.top + a.scrollTop - l.y - u;
  return {
    x: d,
    y: h,
    width: o.width,
    height: o.height
  };
}
function Bl(e) {
  return Fe(e).position === "static";
}
function sp(e, t) {
  if (!Xe(e) || Fe(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return en(e) === n && (n = n.ownerDocument.body), n;
}
function aw(e, t) {
  const n = xe(e);
  if (Ua(e))
    return n;
  if (!Xe(e)) {
    let i = Zn(e);
    for (; i && !ri(i); ) {
      if (Le(i) && !Bl(i))
        return i;
      i = Zn(i);
    }
    return n;
  }
  let s = sp(e, t);
  for (; s && fD(s) && Bl(s); )
    s = sp(s, t);
  return s && ri(s) && Bl(s) && !Sd(s) ? n : s || pD(e) || n;
}
const ED = async function(e) {
  const t = this.getOffsetParent || aw, n = this.getDimensions, s = await n(e.floating);
  return {
    reference: MD(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: s.width,
      height: s.height
    }
  };
};
function qD(e) {
  return Fe(e).direction === "rtl";
}
const RD = {
  convertOffsetParentRelativeRectToViewportRelativeRect: AD,
  getDocumentElement: en,
  getClippingRect: CD,
  getOffsetParent: aw,
  getElementRects: ED,
  getClientRects: yD,
  getDimensions: SD,
  getScale: Zs,
  isElement: Le,
  isRTL: qD
};
function kD(e, t) {
  let n = null, s;
  const i = en(e);
  function r() {
    var a;
    clearTimeout(s), (a = n) == null || a.disconnect(), n = null;
  }
  function o(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), r();
    const {
      left: c,
      top: u,
      width: d,
      height: h
    } = e.getBoundingClientRect();
    if (a || t(), !d || !h)
      return;
    const f = ro(u), p = ro(i.clientWidth - (c + d)), g = ro(i.clientHeight - (u + h)), m = ro(c), w = {
      rootMargin: -f + "px " + -p + "px " + -g + "px " + -m + "px",
      threshold: we(0, Kn(1, l)) || 1
    };
    let x = !0;
    function v(C) {
      const E = C[0].intersectionRatio;
      if (E !== l) {
        if (!x)
          return o();
        E ? o(!1, E) : s = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      x = !1;
    }
    try {
      n = new IntersectionObserver(v, {
        ...w,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(v, w);
    }
    n.observe(e);
  }
  return o(!0), r;
}
function TD(e, t, n, s) {
  s === void 0 && (s = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: r = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = s, c = Ed(e), u = i || r ? [...c ? wr(c) : [], ...wr(t)] : [];
  u.forEach((A) => {
    i && A.addEventListener("scroll", n, {
      passive: !0
    }), r && A.addEventListener("resize", n);
  });
  const d = c && a ? kD(c, n) : null;
  let h = -1, f = null;
  o && (f = new ResizeObserver((A) => {
    let [w] = A;
    w && w.target === c && f && (f.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var x;
      (x = f) == null || x.observe(t);
    })), n();
  }), c && !l && f.observe(c), f.observe(t));
  let p, g = l ? Es(e) : null;
  l && m();
  function m() {
    const A = Es(e);
    g && (A.x !== g.x || A.y !== g.y || A.width !== g.width || A.height !== g.height) && n(), g = A, p = requestAnimationFrame(m);
  }
  return n(), () => {
    var A;
    u.forEach((w) => {
      i && w.removeEventListener("scroll", n), r && w.removeEventListener("resize", n);
    }), d == null || d(), (A = f) == null || A.disconnect(), f = null, l && cancelAnimationFrame(p);
  };
}
const DD = cD, BD = uD, ID = oD, PD = hD, OD = aD, ip = rD, ND = dD, LD = (e, t, n) => {
  const s = /* @__PURE__ */ new Map(), i = {
    platform: RD,
    ...n
  }, r = {
    ...i.platform,
    _c: s
  };
  return iD(e, t, {
    ...i,
    platform: r
  });
};
var Do = typeof document < "u" ? ru : Lt;
function da(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, s, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (s = n; s-- !== 0; )
        if (!da(e[s], t[s]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (s = n; s-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[s]))
        return !1;
    for (s = n; s-- !== 0; ) {
      const r = i[s];
      if (!(r === "_owner" && e.$$typeof) && !da(e[r], t[r]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function lw(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function rp(e, t) {
  const n = lw(e);
  return Math.round(t * n) / n;
}
function Il(e) {
  const t = b.useRef(e);
  return Do(() => {
    t.current = e;
  }), t;
}
function FD(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: s = [],
    platform: i,
    elements: {
      reference: r,
      floating: o
    } = {},
    transform: a = !0,
    whileElementsMounted: l,
    open: c
  } = e, [u, d] = b.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [h, f] = b.useState(s);
  da(h, s) || f(s);
  const [p, g] = b.useState(null), [m, A] = b.useState(null), w = b.useCallback((F) => {
    F !== E.current && (E.current = F, g(F));
  }, []), x = b.useCallback((F) => {
    F !== S.current && (S.current = F, A(F));
  }, []), v = r || p, C = o || m, E = b.useRef(null), S = b.useRef(null), M = b.useRef(u), q = l != null, k = Il(l), R = Il(i), D = Il(c), j = b.useCallback(() => {
    if (!E.current || !S.current)
      return;
    const F = {
      placement: t,
      strategy: n,
      middleware: h
    };
    R.current && (F.platform = R.current), LD(E.current, S.current, F).then((Q) => {
      const J = {
        ...Q,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: D.current !== !1
      };
      W.current && !da(M.current, J) && (M.current = J, ou.flushSync(() => {
        d(J);
      }));
    });
  }, [h, t, n, R, D]);
  Do(() => {
    c === !1 && M.current.isPositioned && (M.current.isPositioned = !1, d((F) => ({
      ...F,
      isPositioned: !1
    })));
  }, [c]);
  const W = b.useRef(!1);
  Do(() => (W.current = !0, () => {
    W.current = !1;
  }), []), Do(() => {
    if (v && (E.current = v), C && (S.current = C), v && C) {
      if (k.current)
        return k.current(v, C, j);
      j();
    }
  }, [v, C, j, k, q]);
  const O = b.useMemo(() => ({
    reference: E,
    floating: S,
    setReference: w,
    setFloating: x
  }), [w, x]), U = b.useMemo(() => ({
    reference: v,
    floating: C
  }), [v, C]), I = b.useMemo(() => {
    const F = {
      position: n,
      left: 0,
      top: 0
    };
    if (!U.floating)
      return F;
    const Q = rp(U.floating, u.x), J = rp(U.floating, u.y);
    return a ? {
      ...F,
      transform: "translate(" + Q + "px, " + J + "px)",
      ...lw(U.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Q,
      top: J
    };
  }, [n, a, U.floating, u.x, u.y]);
  return b.useMemo(() => ({
    ...u,
    update: j,
    refs: O,
    elements: U,
    floatingStyles: I
  }), [u, j, O, U, I]);
}
const jD = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: s,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return s && t(s) ? s.current != null ? ip({
        element: s.current,
        padding: i
      }).fn(n) : {} : s ? ip({
        element: s,
        padding: i
      }).fn(n) : {};
    }
  };
}, VD = (e, t) => ({
  ...DD(e),
  options: [e, t]
}), UD = (e, t) => ({
  ...BD(e),
  options: [e, t]
}), YD = (e, t) => ({
  ...ND(e),
  options: [e, t]
}), WD = (e, t) => ({
  ...ID(e),
  options: [e, t]
}), QD = (e, t) => ({
  ...PD(e),
  options: [e, t]
}), GD = (e, t) => ({
  ...OD(e),
  options: [e, t]
}), KD = (e, t) => ({
  ...jD(e),
  options: [e, t]
});
var zD = "Arrow", cw = b.forwardRef((e, t) => {
  const { children: n, width: s = 10, height: i = 5, ...r } = e;
  return /* @__PURE__ */ y.jsx(
    ut.svg,
    {
      ...r,
      ref: t,
      width: s,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ y.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
cw.displayName = zD;
var _D = cw, qd = "Popper", [uw, dw] = Qu(qd), [ZD, hw] = uw(qd), fw = (e) => {
  const { __scopePopper: t, children: n } = e, [s, i] = b.useState(null);
  return /* @__PURE__ */ y.jsx(ZD, { scope: t, anchor: s, onAnchorChange: i, children: n });
};
fw.displayName = qd;
var pw = "PopperAnchor", gw = b.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: s, ...i } = e, r = hw(pw, n), o = b.useRef(null), a = ct(t, o);
    return b.useEffect(() => {
      r.onAnchorChange((s == null ? void 0 : s.current) || o.current);
    }), s ? null : /* @__PURE__ */ y.jsx(ut.div, { ...i, ref: a });
  }
);
gw.displayName = pw;
var Rd = "PopperContent", [HD, JD] = uw(Rd), mw = b.forwardRef(
  (e, t) => {
    var G, Gt, ae, Cn, ke, ns;
    const {
      __scopePopper: n,
      side: s = "bottom",
      sideOffset: i = 0,
      align: r = "center",
      alignOffset: o = 0,
      arrowPadding: a = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: d = "partial",
      hideWhenDetached: h = !1,
      updatePositionStrategy: f = "optimized",
      onPlaced: p,
      ...g
    } = e, m = hw(Rd, n), [A, w] = b.useState(null), x = ct(t, (N) => w(N)), [v, C] = b.useState(null), E = $A(v), S = (E == null ? void 0 : E.width) ?? 0, M = (E == null ? void 0 : E.height) ?? 0, q = s + (r !== "center" ? "-" + r : ""), k = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, R = Array.isArray(c) ? c : [c], D = R.length > 0, j = {
      padding: k,
      boundary: R.filter($D),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: D
    }, { refs: W, floatingStyles: O, placement: U, isPositioned: I, middlewareData: F } = FD({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: q,
      whileElementsMounted: (...N) => TD(...N, {
        animationFrame: f === "always"
      }),
      elements: {
        reference: m.anchor
      },
      middleware: [
        VD({ mainAxis: i + M, alignmentAxis: o }),
        l && UD({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? YD() : void 0,
          ...j
        }),
        l && WD({ ...j }),
        QD({
          ...j,
          apply: ({ elements: N, rects: nt, availableWidth: vt, availableHeight: Kt }) => {
            const { width: Te, height: ss } = nt.reference, pe = N.floating.style;
            pe.setProperty("--radix-popper-available-width", `${vt}px`), pe.setProperty("--radix-popper-available-height", `${Kt}px`), pe.setProperty("--radix-popper-anchor-width", `${Te}px`), pe.setProperty("--radix-popper-anchor-height", `${ss}px`);
          }
        }),
        v && KD({ element: v, padding: a }),
        tB({ arrowWidth: S, arrowHeight: M }),
        h && GD({ strategy: "referenceHidden", ...j })
      ]
    }), [Q, J] = ww(U), lt = Qt(p);
    oe(() => {
      I && (lt == null || lt());
    }, [I, lt]);
    const Vt = (G = F.arrow) == null ? void 0 : G.x, Pt = (Gt = F.arrow) == null ? void 0 : Gt.y, kt = ((ae = F.arrow) == null ? void 0 : ae.centerOffset) !== 0, [Ut, gt] = b.useState();
    return oe(() => {
      A && gt(window.getComputedStyle(A).zIndex);
    }, [A]), /* @__PURE__ */ y.jsx(
      "div",
      {
        ref: W.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...O,
          transform: I ? O.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Ut,
          "--radix-popper-transform-origin": [
            (Cn = F.transformOrigin) == null ? void 0 : Cn.x,
            (ke = F.transformOrigin) == null ? void 0 : ke.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((ns = F.hide) == null ? void 0 : ns.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ y.jsx(
          HD,
          {
            scope: n,
            placedSide: Q,
            onArrowChange: C,
            arrowX: Vt,
            arrowY: Pt,
            shouldHideArrow: kt,
            children: /* @__PURE__ */ y.jsx(
              ut.div,
              {
                "data-side": Q,
                "data-align": J,
                ...g,
                ref: x,
                style: {
                  ...g.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: I ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
mw.displayName = Rd;
var Aw = "PopperArrow", XD = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, yw = b.forwardRef(function(t, n) {
  const { __scopePopper: s, ...i } = t, r = JD(Aw, s), o = XD[r.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ y.jsx(
      "span",
      {
        ref: r.onArrowChange,
        style: {
          position: "absolute",
          left: r.arrowX,
          top: r.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[r.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[r.placedSide],
          visibility: r.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ y.jsx(
          _D,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
yw.displayName = Aw;
function $D(e) {
  return e !== null;
}
var tB = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var m, A, w;
    const { placement: n, rects: s, middlewareData: i } = t, o = ((m = i.arrow) == null ? void 0 : m.centerOffset) !== 0, a = o ? 0 : e.arrowWidth, l = o ? 0 : e.arrowHeight, [c, u] = ww(n), d = { start: "0%", center: "50%", end: "100%" }[u], h = (((A = i.arrow) == null ? void 0 : A.x) ?? 0) + a / 2, f = (((w = i.arrow) == null ? void 0 : w.y) ?? 0) + l / 2;
    let p = "", g = "";
    return c === "bottom" ? (p = o ? d : `${h}px`, g = `${-l}px`) : c === "top" ? (p = o ? d : `${h}px`, g = `${s.floating.height + l}px`) : c === "right" ? (p = `${-l}px`, g = o ? d : `${f}px`) : c === "left" && (p = `${s.floating.width + l}px`, g = o ? d : `${f}px`), { data: { x: p, y: g } };
  }
});
function ww(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var eB = fw, nB = gw, sB = mw, iB = yw;
function rB(e, t) {
  return b.useReducer((n, s) => t[n][s] ?? n, e);
}
var bw = (e) => {
  const { present: t, children: n } = e, s = oB(t), i = typeof n == "function" ? n({ present: s.isPresent }) : b.Children.only(n), r = ct(s.ref, aB(i));
  return typeof n == "function" || s.isPresent ? b.cloneElement(i, { ref: r }) : null;
};
bw.displayName = "Presence";
function oB(e) {
  const [t, n] = b.useState(), s = b.useRef({}), i = b.useRef(e), r = b.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = rB(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return b.useEffect(() => {
    const c = oo(s.current);
    r.current = a === "mounted" ? c : "none";
  }, [a]), oe(() => {
    const c = s.current, u = i.current;
    if (u !== e) {
      const h = r.current, f = oo(c);
      e ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && h !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), oe(() => {
    if (t) {
      const c = (d) => {
        const f = oo(s.current).includes(d.animationName);
        d.target === t && f && ou.flushSync(() => l("ANIMATION_END"));
      }, u = (d) => {
        d.target === t && (r.current = oo(s.current));
      };
      return t.addEventListener("animationstart", u), t.addEventListener("animationcancel", c), t.addEventListener("animationend", c), () => {
        t.removeEventListener("animationstart", u), t.removeEventListener("animationcancel", c), t.removeEventListener("animationend", c);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: b.useCallback((c) => {
      c && (s.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function oo(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function aB(e) {
  var s, i;
  let t = (s = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var lB = "VisuallyHidden", xw = b.forwardRef(
  (e, t) => /* @__PURE__ */ y.jsx(
    ut.span,
    {
      ...e,
      ref: t,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
      }
    }
  )
);
xw.displayName = lB;
var cB = xw, [Wa, NF] = Qu("Tooltip", [
  dw
]), Qa = dw(), vw = "TooltipProvider", uB = 700, Ic = "tooltip.open", [dB, kd] = Wa(vw), Cw = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = uB,
    skipDelayDuration: s = 300,
    disableHoverableContent: i = !1,
    children: r
  } = e, [o, a] = b.useState(!0), l = b.useRef(!1), c = b.useRef(0);
  return b.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ y.jsx(
    dB,
    {
      scope: t,
      isOpenDelayed: o,
      delayDuration: n,
      onOpen: b.useCallback(() => {
        window.clearTimeout(c.current), a(!1);
      }, []),
      onClose: b.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => a(!0),
          s
        );
      }, [s]),
      isPointerInTransitRef: l,
      onPointerInTransitChange: b.useCallback((u) => {
        l.current = u;
      }, []),
      disableHoverableContent: i,
      children: r
    }
  );
};
Cw.displayName = vw;
var Ga = "Tooltip", [hB, Ka] = Wa(Ga), Sw = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: s,
    defaultOpen: i = !1,
    onOpenChange: r,
    disableHoverableContent: o,
    delayDuration: a
  } = e, l = kd(Ga, e.__scopeTooltip), c = Qa(t), [u, d] = b.useState(null), h = zs(), f = b.useRef(0), p = o ?? l.disableHoverableContent, g = a ?? l.delayDuration, m = b.useRef(!1), [A = !1, w] = fi({
    prop: s,
    defaultProp: i,
    onChange: (S) => {
      S ? (l.onOpen(), document.dispatchEvent(new CustomEvent(Ic))) : l.onClose(), r == null || r(S);
    }
  }), x = b.useMemo(() => A ? m.current ? "delayed-open" : "instant-open" : "closed", [A]), v = b.useCallback(() => {
    window.clearTimeout(f.current), m.current = !1, w(!0);
  }, [w]), C = b.useCallback(() => {
    window.clearTimeout(f.current), w(!1);
  }, [w]), E = b.useCallback(() => {
    window.clearTimeout(f.current), f.current = window.setTimeout(() => {
      m.current = !0, w(!0);
    }, g);
  }, [g, w]);
  return b.useEffect(() => () => window.clearTimeout(f.current), []), /* @__PURE__ */ y.jsx(eB, { ...c, children: /* @__PURE__ */ y.jsx(
    hB,
    {
      scope: t,
      contentId: h,
      open: A,
      stateAttribute: x,
      trigger: u,
      onTriggerChange: d,
      onTriggerEnter: b.useCallback(() => {
        l.isOpenDelayed ? E() : v();
      }, [l.isOpenDelayed, E, v]),
      onTriggerLeave: b.useCallback(() => {
        p ? C() : window.clearTimeout(f.current);
      }, [C, p]),
      onOpen: v,
      onClose: C,
      disableHoverableContent: p,
      children: n
    }
  ) });
};
Sw.displayName = Ga;
var Pc = "TooltipTrigger", Mw = b.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...s } = e, i = Ka(Pc, n), r = kd(Pc, n), o = Qa(n), a = b.useRef(null), l = ct(t, a, i.onTriggerChange), c = b.useRef(!1), u = b.useRef(!1), d = b.useCallback(() => c.current = !1, []);
    return b.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), /* @__PURE__ */ y.jsx(nB, { asChild: !0, ...o, children: /* @__PURE__ */ y.jsx(
      ut.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...s,
        ref: l,
        onPointerMove: at(e.onPointerMove, (h) => {
          h.pointerType !== "touch" && !u.current && !r.isPointerInTransitRef.current && (i.onTriggerEnter(), u.current = !0);
        }),
        onPointerLeave: at(e.onPointerLeave, () => {
          i.onTriggerLeave(), u.current = !1;
        }),
        onPointerDown: at(e.onPointerDown, () => {
          c.current = !0, document.addEventListener("pointerup", d, { once: !0 });
        }),
        onFocus: at(e.onFocus, () => {
          c.current || i.onOpen();
        }),
        onBlur: at(e.onBlur, i.onClose),
        onClick: at(e.onClick, i.onClose)
      }
    ) });
  }
);
Mw.displayName = Pc;
var fB = "TooltipPortal", [LF, pB] = Wa(fB, {
  forceMount: void 0
}), oi = "TooltipContent", Ew = b.forwardRef(
  (e, t) => {
    const n = pB(oi, e.__scopeTooltip), { forceMount: s = n.forceMount, side: i = "top", ...r } = e, o = Ka(oi, e.__scopeTooltip);
    return /* @__PURE__ */ y.jsx(bw, { present: s || o.open, children: o.disableHoverableContent ? /* @__PURE__ */ y.jsx(qw, { side: i, ...r, ref: t }) : /* @__PURE__ */ y.jsx(gB, { side: i, ...r, ref: t }) });
  }
), gB = b.forwardRef((e, t) => {
  const n = Ka(oi, e.__scopeTooltip), s = kd(oi, e.__scopeTooltip), i = b.useRef(null), r = ct(t, i), [o, a] = b.useState(null), { trigger: l, onClose: c } = n, u = i.current, { onPointerInTransitChange: d } = s, h = b.useCallback(() => {
    a(null), d(!1);
  }, [d]), f = b.useCallback(
    (p, g) => {
      const m = p.currentTarget, A = { x: p.clientX, y: p.clientY }, w = wB(A, m.getBoundingClientRect()), x = bB(A, w), v = xB(g.getBoundingClientRect()), C = CB([...x, ...v]);
      a(C), d(!0);
    },
    [d]
  );
  return b.useEffect(() => () => h(), [h]), b.useEffect(() => {
    if (l && u) {
      const p = (m) => f(m, u), g = (m) => f(m, l);
      return l.addEventListener("pointerleave", p), u.addEventListener("pointerleave", g), () => {
        l.removeEventListener("pointerleave", p), u.removeEventListener("pointerleave", g);
      };
    }
  }, [l, u, f, h]), b.useEffect(() => {
    if (o) {
      const p = (g) => {
        const m = g.target, A = { x: g.clientX, y: g.clientY }, w = (l == null ? void 0 : l.contains(m)) || (u == null ? void 0 : u.contains(m)), x = !vB(A, o);
        w ? h() : x && (h(), c());
      };
      return document.addEventListener("pointermove", p), () => document.removeEventListener("pointermove", p);
    }
  }, [l, u, o, c, h]), /* @__PURE__ */ y.jsx(qw, { ...e, ref: r });
}), [mB, AB] = Wa(Ga, { isInside: !1 }), qw = b.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: s,
      "aria-label": i,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      ...a
    } = e, l = Ka(oi, n), c = Qa(n), { onClose: u } = l;
    return b.useEffect(() => (document.addEventListener(Ic, u), () => document.removeEventListener(Ic, u)), [u]), b.useEffect(() => {
      if (l.trigger) {
        const d = (h) => {
          const f = h.target;
          f != null && f.contains(l.trigger) && u();
        };
        return window.addEventListener("scroll", d, { capture: !0 }), () => window.removeEventListener("scroll", d, { capture: !0 });
      }
    }, [l.trigger, u]), /* @__PURE__ */ y.jsx(
      $y,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: o,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: u,
        children: /* @__PURE__ */ y.jsxs(
          sB,
          {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: t,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ y.jsx(TA, { children: s }),
              /* @__PURE__ */ y.jsx(mB, { scope: n, isInside: !0, children: /* @__PURE__ */ y.jsx(cB, { id: l.contentId, role: "tooltip", children: i || s }) })
            ]
          }
        )
      }
    );
  }
);
Ew.displayName = oi;
var Rw = "TooltipArrow", yB = b.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...s } = e, i = Qa(n);
    return AB(
      Rw,
      n
    ).isInside ? null : /* @__PURE__ */ y.jsx(iB, { ...i, ...s, ref: t });
  }
);
yB.displayName = Rw;
function wB(e, t) {
  const n = Math.abs(t.top - e.y), s = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), r = Math.abs(t.left - e.x);
  switch (Math.min(n, s, i, r)) {
    case r:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case s:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function bB(e, t, n = 5) {
  const s = [];
  switch (t) {
    case "top":
      s.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      s.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      s.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      s.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return s;
}
function xB(e) {
  const { top: t, right: n, bottom: s, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: s },
    { x: i, y: s }
  ];
}
function vB(e, t) {
  const { x: n, y: s } = e;
  let i = !1;
  for (let r = 0, o = t.length - 1; r < t.length; o = r++) {
    const a = t[r].x, l = t[r].y, c = t[o].x, u = t[o].y;
    l > s != u > s && n < (c - a) * (s - l) / (u - l) + a && (i = !i);
  }
  return i;
}
function CB(e) {
  const t = e.slice();
  return t.sort((n, s) => n.x < s.x ? -1 : n.x > s.x ? 1 : n.y < s.y ? -1 : n.y > s.y ? 1 : 0), SB(t);
}
function SB(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let s = 0; s < e.length; s++) {
    const i = e[s];
    for (; t.length >= 2; ) {
      const r = t[t.length - 1], o = t[t.length - 2];
      if ((r.x - o.x) * (i.y - o.y) >= (r.y - o.y) * (i.x - o.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let s = e.length - 1; s >= 0; s--) {
    const i = e[s];
    for (; n.length >= 2; ) {
      const r = n[n.length - 1], o = n[n.length - 2];
      if ((r.x - o.x) * (i.y - o.y) >= (r.y - o.y) * (i.x - o.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var MB = Cw, EB = Sw, qB = Mw, kw = Ew;
const RB = MB, kB = EB, TB = qB, Tw = b.forwardRef(({ className: e, sideOffset: t = 4, ...n }, s) => /* @__PURE__ */ y.jsx(
  kw,
  {
    ref: s,
    sideOffset: t,
    className: At(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...n
  }
));
Tw.displayName = kw.displayName;
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function Lr(e) {
  return e + 0.5 | 0;
}
const Bn = (e, t, n) => Math.max(Math.min(e, n), t);
function Fi(e) {
  return Bn(Lr(e * 2.55), 0, 255);
}
function Nn(e) {
  return Bn(Lr(e * 255), 0, 255);
}
function ln(e) {
  return Bn(Lr(e / 2.55) / 100, 0, 1);
}
function op(e) {
  return Bn(Lr(e * 100), 0, 100);
}
const Ee = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Oc = [..."0123456789ABCDEF"], DB = (e) => Oc[e & 15], BB = (e) => Oc[(e & 240) >> 4] + Oc[e & 15], ao = (e) => (e & 240) >> 4 === (e & 15), IB = (e) => ao(e.r) && ao(e.g) && ao(e.b) && ao(e.a);
function PB(e) {
  var t = e.length, n;
  return e[0] === "#" && (t === 4 || t === 5 ? n = {
    r: 255 & Ee[e[1]] * 17,
    g: 255 & Ee[e[2]] * 17,
    b: 255 & Ee[e[3]] * 17,
    a: t === 5 ? Ee[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (n = {
    r: Ee[e[1]] << 4 | Ee[e[2]],
    g: Ee[e[3]] << 4 | Ee[e[4]],
    b: Ee[e[5]] << 4 | Ee[e[6]],
    a: t === 9 ? Ee[e[7]] << 4 | Ee[e[8]] : 255
  })), n;
}
const OB = (e, t) => e < 255 ? t(e) : "";
function NB(e) {
  var t = IB(e) ? DB : BB;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + OB(e.a, t) : void 0;
}
const LB = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Dw(e, t, n) {
  const s = t * Math.min(n, 1 - n), i = (r, o = (r + e / 30) % 12) => n - s * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [i(0), i(8), i(4)];
}
function FB(e, t, n) {
  const s = (i, r = (i + e / 60) % 6) => n - n * t * Math.max(Math.min(r, 4 - r, 1), 0);
  return [s(5), s(3), s(1)];
}
function jB(e, t, n) {
  const s = Dw(e, 1, 0.5);
  let i;
  for (t + n > 1 && (i = 1 / (t + n), t *= i, n *= i), i = 0; i < 3; i++)
    s[i] *= 1 - t - n, s[i] += t;
  return s;
}
function VB(e, t, n, s, i) {
  return e === i ? (t - n) / s + (t < n ? 6 : 0) : t === i ? (n - e) / s + 2 : (e - t) / s + 4;
}
function Td(e) {
  const n = e.r / 255, s = e.g / 255, i = e.b / 255, r = Math.max(n, s, i), o = Math.min(n, s, i), a = (r + o) / 2;
  let l, c, u;
  return r !== o && (u = r - o, c = a > 0.5 ? u / (2 - r - o) : u / (r + o), l = VB(n, s, i, u, r), l = l * 60 + 0.5), [l | 0, c || 0, a];
}
function Dd(e, t, n, s) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, s)).map(Nn);
}
function Bd(e, t, n) {
  return Dd(Dw, e, t, n);
}
function UB(e, t, n) {
  return Dd(jB, e, t, n);
}
function YB(e, t, n) {
  return Dd(FB, e, t, n);
}
function Bw(e) {
  return (e % 360 + 360) % 360;
}
function WB(e) {
  const t = LB.exec(e);
  let n = 255, s;
  if (!t)
    return;
  t[5] !== s && (n = t[6] ? Fi(+t[5]) : Nn(+t[5]));
  const i = Bw(+t[2]), r = +t[3] / 100, o = +t[4] / 100;
  return t[1] === "hwb" ? s = UB(i, r, o) : t[1] === "hsv" ? s = YB(i, r, o) : s = Bd(i, r, o), {
    r: s[0],
    g: s[1],
    b: s[2],
    a: n
  };
}
function QB(e, t) {
  var n = Td(e);
  n[0] = Bw(n[0] + t), n = Bd(n), e.r = n[0], e.g = n[1], e.b = n[2];
}
function GB(e) {
  if (!e)
    return;
  const t = Td(e), n = t[0], s = op(t[1]), i = op(t[2]);
  return e.a < 255 ? `hsla(${n}, ${s}%, ${i}%, ${ln(e.a)})` : `hsl(${n}, ${s}%, ${i}%)`;
}
const ap = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, lp = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function KB() {
  const e = {}, t = Object.keys(lp), n = Object.keys(ap);
  let s, i, r, o, a;
  for (s = 0; s < t.length; s++) {
    for (o = a = t[s], i = 0; i < n.length; i++)
      r = n[i], a = a.replace(r, ap[r]);
    r = parseInt(lp[o], 16), e[a] = [r >> 16 & 255, r >> 8 & 255, r & 255];
  }
  return e;
}
let lo;
function zB(e) {
  lo || (lo = KB(), lo.transparent = [0, 0, 0, 0]);
  const t = lo[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const _B = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function ZB(e) {
  const t = _B.exec(e);
  let n = 255, s, i, r;
  if (t) {
    if (t[7] !== s) {
      const o = +t[7];
      n = t[8] ? Fi(o) : Bn(o * 255, 0, 255);
    }
    return s = +t[1], i = +t[3], r = +t[5], s = 255 & (t[2] ? Fi(s) : Bn(s, 0, 255)), i = 255 & (t[4] ? Fi(i) : Bn(i, 0, 255)), r = 255 & (t[6] ? Fi(r) : Bn(r, 0, 255)), {
      r: s,
      g: i,
      b: r,
      a: n
    };
  }
}
function HB(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${ln(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const Pl = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, Os = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function JB(e, t, n) {
  const s = Os(ln(e.r)), i = Os(ln(e.g)), r = Os(ln(e.b));
  return {
    r: Nn(Pl(s + n * (Os(ln(t.r)) - s))),
    g: Nn(Pl(i + n * (Os(ln(t.g)) - i))),
    b: Nn(Pl(r + n * (Os(ln(t.b)) - r))),
    a: e.a + n * (t.a - e.a)
  };
}
function co(e, t, n) {
  if (e) {
    let s = Td(e);
    s[t] = Math.max(0, Math.min(s[t] + s[t] * n, t === 0 ? 360 : 1)), s = Bd(s), e.r = s[0], e.g = s[1], e.b = s[2];
  }
}
function Iw(e, t) {
  return e && Object.assign(t || {}, e);
}
function cp(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Nn(e[3]))) : (t = Iw(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Nn(t.a)), t;
}
function XB(e) {
  return e.charAt(0) === "r" ? ZB(e) : WB(e);
}
class br {
  constructor(t) {
    if (t instanceof br)
      return t;
    const n = typeof t;
    let s;
    n === "object" ? s = cp(t) : n === "string" && (s = PB(t) || zB(t) || XB(t)), this._rgb = s, this._valid = !!s;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = Iw(this._rgb);
    return t && (t.a = ln(t.a)), t;
  }
  set rgb(t) {
    this._rgb = cp(t);
  }
  rgbString() {
    return this._valid ? HB(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? NB(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? GB(this._rgb) : void 0;
  }
  mix(t, n) {
    if (t) {
      const s = this.rgb, i = t.rgb;
      let r;
      const o = n === r ? 0.5 : n, a = 2 * o - 1, l = s.a - i.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
      r = 1 - c, s.r = 255 & c * s.r + r * i.r + 0.5, s.g = 255 & c * s.g + r * i.g + 0.5, s.b = 255 & c * s.b + r * i.b + 0.5, s.a = o * s.a + (1 - o) * i.a, this.rgb = s;
    }
    return this;
  }
  interpolate(t, n) {
    return t && (this._rgb = JB(this._rgb, t._rgb, n)), this;
  }
  clone() {
    return new br(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = Nn(t), this;
  }
  clearer(t) {
    const n = this._rgb;
    return n.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, n = Lr(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = n, this;
  }
  opaquer(t) {
    const n = this._rgb;
    return n.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return co(this._rgb, 2, t), this;
  }
  darken(t) {
    return co(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return co(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return co(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return QB(this._rgb, t), this;
  }
}
/*!
 * Chart.js v4.4.4
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
function sn() {
}
const $B = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function ot(e) {
  return e === null || typeof e > "u";
}
function St(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function it(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function Tt(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function me(e, t) {
  return Tt(e) ? e : t;
}
function $(e, t) {
  return typeof e > "u" ? t : e;
}
const t2 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, Pw = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function mt(e, t, n) {
  if (e && typeof e.call == "function")
    return e.apply(n, t);
}
function dt(e, t, n, s) {
  let i, r, o;
  if (St(e))
    for (r = e.length, i = 0; i < r; i++)
      t.call(n, e[i], i);
  else if (it(e))
    for (o = Object.keys(e), r = o.length, i = 0; i < r; i++)
      t.call(n, e[o[i]], o[i]);
}
function ha(e, t) {
  let n, s, i, r;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (n = 0, s = e.length; n < s; ++n)
    if (i = e[n], r = t[n], i.datasetIndex !== r.datasetIndex || i.index !== r.index)
      return !1;
  return !0;
}
function fa(e) {
  if (St(e))
    return e.map(fa);
  if (it(e)) {
    const t = /* @__PURE__ */ Object.create(null), n = Object.keys(e), s = n.length;
    let i = 0;
    for (; i < s; ++i)
      t[n[i]] = fa(e[n[i]]);
    return t;
  }
  return e;
}
function Ow(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function e2(e, t, n, s) {
  if (!Ow(e))
    return;
  const i = t[e], r = n[e];
  it(i) && it(r) ? xr(i, r, s) : t[e] = fa(r);
}
function xr(e, t, n) {
  const s = St(t) ? t : [
    t
  ], i = s.length;
  if (!it(e))
    return e;
  n = n || {};
  const r = n.merger || e2;
  let o;
  for (let a = 0; a < i; ++a) {
    if (o = s[a], !it(o))
      continue;
    const l = Object.keys(o);
    for (let c = 0, u = l.length; c < u; ++c)
      r(l[c], e, o, n);
  }
  return e;
}
function _i(e, t) {
  return xr(e, t, {
    merger: n2
  });
}
function n2(e, t, n) {
  if (!Ow(e))
    return;
  const s = t[e], i = n[e];
  it(s) && it(i) ? _i(s, i) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = fa(i));
}
const up = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function s2(e) {
  const t = e.split("."), n = [];
  let s = "";
  for (const i of t)
    s += i, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (n.push(s), s = "");
  return n;
}
function i2(e) {
  const t = s2(e);
  return (n) => {
    for (const s of t) {
      if (s === "")
        break;
      n = n && n[s];
    }
    return n;
  };
}
function Hn(e, t) {
  return (up[t] || (up[t] = i2(t)))(e);
}
function Id(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const vr = (e) => typeof e < "u", Jn = (e) => typeof e == "function", dp = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
};
function r2(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const xt = Math.PI, bt = 2 * xt, o2 = bt + xt, pa = Number.POSITIVE_INFINITY, a2 = xt / 180, It = xt / 2, as = xt / 4, hp = xt * 2 / 3, In = Math.log10, Ze = Math.sign;
function Zi(e, t, n) {
  return Math.abs(e - t) < n;
}
function fp(e) {
  const t = Math.round(e);
  e = Zi(e, t, e / 1e3) ? t : e;
  const n = Math.pow(10, Math.floor(In(e))), s = e / n;
  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * n;
}
function l2(e) {
  const t = [], n = Math.sqrt(e);
  let s;
  for (s = 1; s < n; s++)
    e % s === 0 && (t.push(s), t.push(e / s));
  return n === (n | 0) && t.push(n), t.sort((i, r) => i - r).pop(), t;
}
function ai(e) {
  return !isNaN(parseFloat(e)) && isFinite(e);
}
function c2(e, t) {
  const n = Math.round(e);
  return n - t <= e && n + t >= e;
}
function Nw(e, t, n) {
  let s, i, r;
  for (s = 0, i = e.length; s < i; s++)
    r = e[s][n], isNaN(r) || (t.min = Math.min(t.min, r), t.max = Math.max(t.max, r));
}
function Ie(e) {
  return e * (xt / 180);
}
function Pd(e) {
  return e * (180 / xt);
}
function pp(e) {
  if (!Tt(e))
    return;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n++;
  return n;
}
function Lw(e, t) {
  const n = t.x - e.x, s = t.y - e.y, i = Math.sqrt(n * n + s * s);
  let r = Math.atan2(s, n);
  return r < -0.5 * xt && (r += bt), {
    angle: r,
    distance: i
  };
}
function Nc(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function u2(e, t) {
  return (e - t + o2) % bt - xt;
}
function Ae(e) {
  return (e % bt + bt) % bt;
}
function Cr(e, t, n, s) {
  const i = Ae(e), r = Ae(t), o = Ae(n), a = Ae(r - i), l = Ae(o - i), c = Ae(i - r), u = Ae(i - o);
  return i === r || i === o || s && r === o || a > l && c < u;
}
function jt(e, t, n) {
  return Math.max(t, Math.min(n, e));
}
function d2(e) {
  return jt(e, -32768, 32767);
}
function dn(e, t, n, s = 1e-6) {
  return e >= Math.min(t, n) - s && e <= Math.max(t, n) + s;
}
function Od(e, t, n) {
  n = n || ((o) => e[o] < t);
  let s = e.length - 1, i = 0, r;
  for (; s - i > 1; )
    r = i + s >> 1, n(r) ? i = r : s = r;
  return {
    lo: i,
    hi: s
  };
}
const hn = (e, t, n, s) => Od(e, n, s ? (i) => {
  const r = e[i][t];
  return r < n || r === n && e[i + 1][t] === n;
} : (i) => e[i][t] < n), h2 = (e, t, n) => Od(e, n, (s) => e[s][t] >= n);
function f2(e, t, n) {
  let s = 0, i = e.length;
  for (; s < i && e[s] < t; )
    s++;
  for (; i > s && e[i - 1] > n; )
    i--;
  return s > 0 || i < e.length ? e.slice(s, i) : e;
}
const Fw = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function p2(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), Fw.forEach((n) => {
    const s = "_onData" + Id(n), i = e[n];
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      value(...r) {
        const o = i.apply(this, r);
        return e._chartjs.listeners.forEach((a) => {
          typeof a[s] == "function" && a[s](...r);
        }), o;
      }
    });
  });
}
function gp(e, t) {
  const n = e._chartjs;
  if (!n)
    return;
  const s = n.listeners, i = s.indexOf(t);
  i !== -1 && s.splice(i, 1), !(s.length > 0) && (Fw.forEach((r) => {
    delete e[r];
  }), delete e._chartjs);
}
function jw(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const Vw = function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
}();
function Uw(e, t) {
  let n = [], s = !1;
  return function(...i) {
    n = i, s || (s = !0, Vw.call(window, () => {
      s = !1, e.apply(t, n);
    }));
  };
}
function g2(e, t) {
  let n;
  return function(...s) {
    return t ? (clearTimeout(n), n = setTimeout(e, t, s)) : e.apply(this, s), t;
  };
}
const Nd = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", zt = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2, m2 = (e, t, n, s) => e === (s ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t;
function Yw(e, t, n) {
  const s = t.length;
  let i = 0, r = s;
  if (e._sorted) {
    const { iScale: o, _parsed: a } = e, l = o.axis, { min: c, max: u, minDefined: d, maxDefined: h } = o.getUserBounds();
    d && (i = jt(Math.min(
      // @ts-expect-error Need to type _parsed
      hn(a, l, c).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? s : hn(t, l, o.getPixelForValue(c)).lo
    ), 0, s - 1)), h ? r = jt(Math.max(
      // @ts-expect-error Need to type _parsed
      hn(a, o.axis, u, !0).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? 0 : hn(t, l, o.getPixelForValue(u), !0).hi + 1
    ), i, s) - i : r = s - i;
  }
  return {
    start: i,
    count: r
  };
}
function Ww(e) {
  const { xScale: t, yScale: n, _scaleRanges: s } = e, i = {
    xmin: t.min,
    xmax: t.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!s)
    return e._scaleRanges = i, !0;
  const r = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== n.min || s.ymax !== n.max;
  return Object.assign(s, i), r;
}
const uo = (e) => e === 0 || e === 1, mp = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * bt / n)), Ap = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * bt / n) + 1, Hi = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * It) + 1,
  easeOutSine: (e) => Math.sin(e * It),
  easeInOutSine: (e) => -0.5 * (Math.cos(xt * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => uo(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => uo(e) ? e : mp(e, 0.075, 0.3),
  easeOutElastic: (e) => uo(e) ? e : Ap(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return uo(e) ? e : e < 0.5 ? 0.5 * mp(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * Ap(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - Hi.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? Hi.easeInBounce(e * 2) * 0.5 : Hi.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function Ld(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function yp(e) {
  return Ld(e) ? e : new br(e);
}
function Ol(e) {
  return Ld(e) ? e : new br(e).saturate(0.5).darken(0.1).hexString();
}
const A2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], y2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function w2(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: y2
    },
    numbers: {
      type: "number",
      properties: A2
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function b2(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const wp = /* @__PURE__ */ new Map();
function x2(e, t) {
  t = t || {};
  const n = e + JSON.stringify(t);
  let s = wp.get(n);
  return s || (s = new Intl.NumberFormat(e, t), wp.set(n, s)), s;
}
function Fr(e, t, n) {
  return x2(t, n).format(e);
}
const Qw = {
  values(e) {
    return St(e) ? e : "" + e;
  },
  numeric(e, t, n) {
    if (e === 0)
      return "0";
    const s = this.chart.options.locale;
    let i, r = e;
    if (n.length > 1) {
      const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (c < 1e-4 || c > 1e15) && (i = "scientific"), r = v2(e, n);
    }
    const o = In(Math.abs(r)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = {
      notation: i,
      minimumFractionDigits: a,
      maximumFractionDigits: a
    };
    return Object.assign(l, this.options.ticks.format), Fr(e, s, l);
  },
  logarithmic(e, t, n) {
    if (e === 0)
      return "0";
    const s = n[t].significand || e / Math.pow(10, Math.floor(In(e)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(s) || t > 0.8 * n.length ? Qw.numeric.call(this, e, t, n) : "";
  }
};
function v2(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n;
}
var za = {
  formatters: Qw
};
function C2(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: za.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const qs = /* @__PURE__ */ Object.create(null), Lc = /* @__PURE__ */ Object.create(null);
function Ji(e, t) {
  if (!t)
    return e;
  const n = t.split(".");
  for (let s = 0, i = n.length; s < i; ++s) {
    const r = n[s];
    e = e[r] || (e[r] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function Nl(e, t, n) {
  return typeof t == "string" ? xr(Ji(e, t), n) : xr(Ji(e, ""), t);
}
class S2 {
  constructor(t, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (s) => s.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (s, i) => Ol(i.backgroundColor), this.hoverBorderColor = (s, i) => Ol(i.borderColor), this.hoverColor = (s, i) => Ol(i.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(n);
  }
  set(t, n) {
    return Nl(this, t, n);
  }
  get(t) {
    return Ji(this, t);
  }
  describe(t, n) {
    return Nl(Lc, t, n);
  }
  override(t, n) {
    return Nl(qs, t, n);
  }
  route(t, n, s, i) {
    const r = Ji(this, t), o = Ji(this, s), a = "_" + n;
    Object.defineProperties(r, {
      [a]: {
        value: r[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const l = this[a], c = o[i];
          return it(l) ? Object.assign({}, c, l) : $(l, c);
        },
        set(l) {
          this[a] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((n) => n(this));
  }
}
var Dt = /* @__PURE__ */ new S2({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  w2,
  b2,
  C2
]);
function M2(e) {
  return !e || ot(e.size) || ot(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function ga(e, t, n, s, i) {
  let r = t[i];
  return r || (r = t[i] = e.measureText(i).width, n.push(i)), r > s && (s = r), s;
}
function E2(e, t, n, s) {
  s = s || {};
  let i = s.data = s.data || {}, r = s.garbageCollect = s.garbageCollect || [];
  s.font !== t && (i = s.data = {}, r = s.garbageCollect = [], s.font = t), e.save(), e.font = t;
  let o = 0;
  const a = n.length;
  let l, c, u, d, h;
  for (l = 0; l < a; l++)
    if (d = n[l], d != null && !St(d))
      o = ga(e, i, r, o, d);
    else if (St(d))
      for (c = 0, u = d.length; c < u; c++)
        h = d[c], h != null && !St(h) && (o = ga(e, i, r, o, h));
  e.restore();
  const f = r.length / 2;
  if (f > n.length) {
    for (l = 0; l < f; l++)
      delete i[r[l]];
    r.splice(0, f);
  }
  return o;
}
function ls(e, t, n) {
  const s = e.currentDevicePixelRatio, i = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((t - i) * s) / s + i;
}
function bp(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function Fc(e, t, n, s) {
  Gw(e, t, n, s, null);
}
function Gw(e, t, n, s, i) {
  let r, o, a, l, c, u, d, h;
  const f = t.pointStyle, p = t.rotation, g = t.radius;
  let m = (p || 0) * a2;
  if (f && typeof f == "object" && (r = f.toString(), r === "[object HTMLImageElement]" || r === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(n, s), e.rotate(m), e.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), e.restore();
    return;
  }
  if (!(isNaN(g) || g <= 0)) {
    switch (e.beginPath(), f) {
      default:
        i ? e.ellipse(n, s, i / 2, g, 0, 0, bt) : e.arc(n, s, g, 0, bt), e.closePath();
        break;
      case "triangle":
        u = i ? i / 2 : g, e.moveTo(n + Math.sin(m) * u, s - Math.cos(m) * g), m += hp, e.lineTo(n + Math.sin(m) * u, s - Math.cos(m) * g), m += hp, e.lineTo(n + Math.sin(m) * u, s - Math.cos(m) * g), e.closePath();
        break;
      case "rectRounded":
        c = g * 0.516, l = g - c, o = Math.cos(m + as) * l, d = Math.cos(m + as) * (i ? i / 2 - c : l), a = Math.sin(m + as) * l, h = Math.sin(m + as) * (i ? i / 2 - c : l), e.arc(n - d, s - a, c, m - xt, m - It), e.arc(n + h, s - o, c, m - It, m), e.arc(n + d, s + a, c, m, m + It), e.arc(n - h, s + o, c, m + It, m + xt), e.closePath();
        break;
      case "rect":
        if (!p) {
          l = Math.SQRT1_2 * g, u = i ? i / 2 : l, e.rect(n - u, s - l, 2 * u, 2 * l);
          break;
        }
        m += as;
      case "rectRot":
        d = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, s - a), e.lineTo(n + h, s - o), e.lineTo(n + d, s + a), e.lineTo(n - h, s + o), e.closePath();
        break;
      case "crossRot":
        m += as;
      case "cross":
        d = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, s - a), e.lineTo(n + d, s + a), e.moveTo(n + h, s - o), e.lineTo(n - h, s + o);
        break;
      case "star":
        d = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, s - a), e.lineTo(n + d, s + a), e.moveTo(n + h, s - o), e.lineTo(n - h, s + o), m += as, d = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, s - a), e.lineTo(n + d, s + a), e.moveTo(n + h, s - o), e.lineTo(n - h, s + o);
        break;
      case "line":
        o = i ? i / 2 : Math.cos(m) * g, a = Math.sin(m) * g, e.moveTo(n - o, s - a), e.lineTo(n + o, s + a);
        break;
      case "dash":
        e.moveTo(n, s), e.lineTo(n + Math.cos(m) * (i ? i / 2 : g), s + Math.sin(m) * g);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function fn(e, t, n) {
  return n = n || 0.5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n;
}
function _a(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function Za(e) {
  e.restore();
}
function q2(e, t, n, s, i) {
  if (!t)
    return e.lineTo(n.x, n.y);
  if (i === "middle") {
    const r = (t.x + n.x) / 2;
    e.lineTo(r, t.y), e.lineTo(r, n.y);
  } else i === "after" != !!s ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
  e.lineTo(n.x, n.y);
}
function R2(e, t, n, s) {
  if (!t)
    return e.lineTo(n.x, n.y);
  e.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? n.cp2x : n.cp1x, s ? n.cp2y : n.cp1y, n.x, n.y);
}
function k2(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), ot(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function T2(e, t, n, s, i) {
  if (i.strikethrough || i.underline) {
    const r = e.measureText(s), o = t - r.actualBoundingBoxLeft, a = t + r.actualBoundingBoxRight, l = n - r.actualBoundingBoxAscent, c = n + r.actualBoundingBoxDescent, u = i.strikethrough ? (l + c) / 2 : c;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = i.decorationWidth || 2, e.moveTo(o, u), e.lineTo(a, u), e.stroke();
  }
}
function D2(e, t) {
  const n = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n;
}
function Rs(e, t, n, s, i, r = {}) {
  const o = St(t) ? t : [
    t
  ], a = r.strokeWidth > 0 && r.strokeColor !== "";
  let l, c;
  for (e.save(), e.font = i.string, k2(e, r), l = 0; l < o.length; ++l)
    c = o[l], r.backdrop && D2(e, r.backdrop), a && (r.strokeColor && (e.strokeStyle = r.strokeColor), ot(r.strokeWidth) || (e.lineWidth = r.strokeWidth), e.strokeText(c, n, s, r.maxWidth)), e.fillText(c, n, s, r.maxWidth), T2(e, n, s, c, r), s += Number(i.lineHeight);
  e.restore();
}
function Sr(e, t) {
  const { x: n, y: s, w: i, h: r, radius: o } = t;
  e.arc(n + o.topLeft, s + o.topLeft, o.topLeft, 1.5 * xt, xt, !0), e.lineTo(n, s + r - o.bottomLeft), e.arc(n + o.bottomLeft, s + r - o.bottomLeft, o.bottomLeft, xt, It, !0), e.lineTo(n + i - o.bottomRight, s + r), e.arc(n + i - o.bottomRight, s + r - o.bottomRight, o.bottomRight, It, 0, !0), e.lineTo(n + i, s + o.topRight), e.arc(n + i - o.topRight, s + o.topRight, o.topRight, 0, -It, !0), e.lineTo(n + o.topLeft, s);
}
const B2 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, I2 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function P2(e, t) {
  const n = ("" + e).match(B2);
  if (!n || n[1] === "normal")
    return t * 1.2;
  switch (e = +n[2], n[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const O2 = (e) => +e || 0;
function Fd(e, t) {
  const n = {}, s = it(t), i = s ? Object.keys(t) : t, r = it(e) ? s ? (o) => $(e[o], e[t[o]]) : (o) => e[o] : () => e;
  for (const o of i)
    n[o] = O2(r(o));
  return n;
}
function Kw(e) {
  return Fd(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function bs(e) {
  return Fd(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function $t(e) {
  const t = Kw(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function Ft(e, t) {
  e = e || {}, t = t || Dt.font;
  let n = $(e.size, t.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let s = $(e.style, t.style);
  s && !("" + s).match(I2) && (console.warn('Invalid font style specified: "' + s + '"'), s = void 0);
  const i = {
    family: $(e.family, t.family),
    lineHeight: P2($(e.lineHeight, t.lineHeight), n),
    size: n,
    style: s,
    weight: $(e.weight, t.weight),
    string: ""
  };
  return i.string = M2(i), i;
}
function ji(e, t, n, s) {
  let i, r, o;
  for (i = 0, r = e.length; i < r; ++i)
    if (o = e[i], o !== void 0 && o !== void 0)
      return o;
}
function N2(e, t, n) {
  const { min: s, max: i } = e, r = Pw(t, (i - s) / 2), o = (a, l) => n && a === 0 ? 0 : a + l;
  return {
    min: o(s, -Math.abs(r)),
    max: o(i, r)
  };
}
function es(e, t) {
  return Object.assign(Object.create(e), t);
}
function jd(e, t = [
  ""
], n, s, i = () => e[0]) {
  const r = n || e;
  typeof s > "u" && (s = Hw("_fallback", e));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: r,
    _fallback: s,
    _getTarget: i,
    override: (a) => jd([
      a,
      ...e
    ], t, r, s)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, l) {
      return delete a[l], delete a._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, l) {
      return _w(a, l, () => Q2(l, t, e, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, l) {
      return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(a, l) {
      return vp(a).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(a) {
      return vp(a);
    },
    /**
    * A trap for setting property values.
    */
    set(a, l, c) {
      const u = a._storage || (a._storage = i());
      return a[l] = u[l] = c, delete a._keys, !0;
    }
  });
}
function li(e, t, n, s) {
  const i = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: zw(e, s),
    setContext: (r) => li(e, r, n, s),
    override: (r) => li(e.override(r), t, n, s)
  };
  return new Proxy(i, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(r, o) {
      return delete r[o], delete e[o], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(r, o, a) {
      return _w(r, o, () => F2(r, o, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(r, o) {
      return r._descriptors.allKeys ? Reflect.has(e, o) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, o);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(r, o) {
      return Reflect.has(e, o);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(r, o, a) {
      return e[o] = a, delete r[o], !0;
    }
  });
}
function zw(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = t.scriptable, _indexable: s = t.indexable, _allKeys: i = t.allKeys } = e;
  return {
    allKeys: i,
    scriptable: n,
    indexable: s,
    isScriptable: Jn(n) ? n : () => n,
    isIndexable: Jn(s) ? s : () => s
  };
}
const L2 = (e, t) => e ? e + Id(t) : t, Vd = (e, t) => it(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function _w(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const s = n();
  return e[t] = s, s;
}
function F2(e, t, n) {
  const { _proxy: s, _context: i, _subProxy: r, _descriptors: o } = e;
  let a = s[t];
  return Jn(a) && o.isScriptable(t) && (a = j2(t, a, e, n)), St(a) && a.length && (a = V2(t, a, e, o.isIndexable)), Vd(t, a) && (a = li(a, i, r && r[t], o)), a;
}
function j2(e, t, n, s) {
  const { _proxy: i, _context: r, _subProxy: o, _stack: a } = n;
  if (a.has(e))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + e);
  a.add(e);
  let l = t(r, o || s);
  return a.delete(e), Vd(e, l) && (l = Ud(i._scopes, i, e, l)), l;
}
function V2(e, t, n, s) {
  const { _proxy: i, _context: r, _subProxy: o, _descriptors: a } = n;
  if (typeof r.index < "u" && s(e))
    return t[r.index % t.length];
  if (it(t[0])) {
    const l = t, c = i._scopes.filter((u) => u !== l);
    t = [];
    for (const u of l) {
      const d = Ud(c, i, e, u);
      t.push(li(d, r, o && o[e], a));
    }
  }
  return t;
}
function Zw(e, t, n) {
  return Jn(e) ? e(t, n) : e;
}
const U2 = (e, t) => e === !0 ? t : typeof e == "string" ? Hn(t, e) : void 0;
function Y2(e, t, n, s, i) {
  for (const r of t) {
    const o = U2(n, r);
    if (o) {
      e.add(o);
      const a = Zw(o._fallback, n, i);
      if (typeof a < "u" && a !== n && a !== s)
        return a;
    } else if (o === !1 && typeof s < "u" && n !== s)
      return null;
  }
  return !1;
}
function Ud(e, t, n, s) {
  const i = t._rootScopes, r = Zw(t._fallback, n, s), o = [
    ...e,
    ...i
  ], a = /* @__PURE__ */ new Set();
  a.add(s);
  let l = xp(a, o, n, r || n, s);
  return l === null || typeof r < "u" && r !== n && (l = xp(a, o, r, l, s), l === null) ? !1 : jd(Array.from(a), [
    ""
  ], i, r, () => W2(t, n, s));
}
function xp(e, t, n, s, i) {
  for (; n; )
    n = Y2(e, t, n, s, i);
  return n;
}
function W2(e, t, n) {
  const s = e._getTarget();
  t in s || (s[t] = {});
  const i = s[t];
  return St(i) && it(n) ? n : i || {};
}
function Q2(e, t, n, s) {
  let i;
  for (const r of t)
    if (i = Hw(L2(r, e), n), typeof i < "u")
      return Vd(e, i) ? Ud(n, s, e, i) : i;
}
function Hw(e, t) {
  for (const n of t) {
    if (!n)
      continue;
    const s = n[e];
    if (typeof s < "u")
      return s;
  }
}
function vp(e) {
  let t = e._keys;
  return t || (t = e._keys = G2(e._scopes)), t;
}
function G2(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const s of Object.keys(n).filter((i) => !i.startsWith("_")))
      t.add(s);
  return Array.from(t);
}
function Jw(e, t, n, s) {
  const { iScale: i } = e, { key: r = "r" } = this._parsing, o = new Array(s);
  let a, l, c, u;
  for (a = 0, l = s; a < l; ++a)
    c = a + n, u = t[c], o[a] = {
      r: i.parse(Hn(u, r), c)
    };
  return o;
}
const K2 = Number.EPSILON || 1e-14, ci = (e, t) => t < e.length && !e[t].skip && e[t], Xw = (e) => e === "x" ? "y" : "x";
function z2(e, t, n, s) {
  const i = e.skip ? t : e, r = t, o = n.skip ? t : n, a = Nc(r, i), l = Nc(o, r);
  let c = a / (a + l), u = l / (a + l);
  c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
  const d = s * c, h = s * u;
  return {
    previous: {
      x: r.x - d * (o.x - i.x),
      y: r.y - d * (o.y - i.y)
    },
    next: {
      x: r.x + h * (o.x - i.x),
      y: r.y + h * (o.y - i.y)
    }
  };
}
function _2(e, t, n) {
  const s = e.length;
  let i, r, o, a, l, c = ci(e, 0);
  for (let u = 0; u < s - 1; ++u)
    if (l = c, c = ci(e, u + 1), !(!l || !c)) {
      if (Zi(t[u], 0, K2)) {
        n[u] = n[u + 1] = 0;
        continue;
      }
      i = n[u] / t[u], r = n[u + 1] / t[u], a = Math.pow(i, 2) + Math.pow(r, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[u] = i * o * t[u], n[u + 1] = r * o * t[u]);
    }
}
function Z2(e, t, n = "x") {
  const s = Xw(n), i = e.length;
  let r, o, a, l = ci(e, 0);
  for (let c = 0; c < i; ++c) {
    if (o = a, a = l, l = ci(e, c + 1), !a)
      continue;
    const u = a[n], d = a[s];
    o && (r = (u - o[n]) / 3, a[`cp1${n}`] = u - r, a[`cp1${s}`] = d - r * t[c]), l && (r = (l[n] - u) / 3, a[`cp2${n}`] = u + r, a[`cp2${s}`] = d + r * t[c]);
  }
}
function H2(e, t = "x") {
  const n = Xw(t), s = e.length, i = Array(s).fill(0), r = Array(s);
  let o, a, l, c = ci(e, 0);
  for (o = 0; o < s; ++o)
    if (a = l, l = c, c = ci(e, o + 1), !!l) {
      if (c) {
        const u = c[t] - l[t];
        i[o] = u !== 0 ? (c[n] - l[n]) / u : 0;
      }
      r[o] = a ? c ? Ze(i[o - 1]) !== Ze(i[o]) ? 0 : (i[o - 1] + i[o]) / 2 : i[o - 1] : i[o];
    }
  _2(e, i, r), Z2(e, r, t);
}
function ho(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
function J2(e, t) {
  let n, s, i, r, o, a = fn(e[0], t);
  for (n = 0, s = e.length; n < s; ++n)
    o = r, r = a, a = n < s - 1 && fn(e[n + 1], t), r && (i = e[n], o && (i.cp1x = ho(i.cp1x, t.left, t.right), i.cp1y = ho(i.cp1y, t.top, t.bottom)), a && (i.cp2x = ho(i.cp2x, t.left, t.right), i.cp2y = ho(i.cp2y, t.top, t.bottom)));
}
function X2(e, t, n, s, i) {
  let r, o, a, l;
  if (t.spanGaps && (e = e.filter((c) => !c.skip)), t.cubicInterpolationMode === "monotone")
    H2(e, i);
  else {
    let c = s ? e[e.length - 1] : e[0];
    for (r = 0, o = e.length; r < o; ++r)
      a = e[r], l = z2(c, a, e[Math.min(r + 1, o - (s ? 0 : 1)) % o], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
  }
  t.capBezierPoints && J2(e, n);
}
function Yd() {
  return typeof window < "u" && typeof document < "u";
}
function Wd(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function ma(e, t, n) {
  let s;
  return typeof e == "string" ? (s = parseInt(e, 10), e.indexOf("%") !== -1 && (s = s / 100 * t.parentNode[n])) : s = e, s;
}
const Ha = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function $2(e, t) {
  return Ha(e).getPropertyValue(t);
}
const tI = [
  "top",
  "right",
  "bottom",
  "left"
];
function xs(e, t, n) {
  const s = {};
  n = n ? "-" + n : "";
  for (let i = 0; i < 4; i++) {
    const r = tI[i];
    s[r] = parseFloat(e[t + "-" + r + n]) || 0;
  }
  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;
}
const eI = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function nI(e, t) {
  const n = e.touches, s = n && n.length ? n[0] : e, { offsetX: i, offsetY: r } = s;
  let o = !1, a, l;
  if (eI(i, r, e.target))
    a = i, l = r;
  else {
    const c = t.getBoundingClientRect();
    a = s.clientX - c.left, l = s.clientY - c.top, o = !0;
  }
  return {
    x: a,
    y: l,
    box: o
  };
}
function fs(e, t) {
  if ("native" in e)
    return e;
  const { canvas: n, currentDevicePixelRatio: s } = t, i = Ha(n), r = i.boxSizing === "border-box", o = xs(i, "padding"), a = xs(i, "border", "width"), { x: l, y: c, box: u } = nI(e, n), d = o.left + (u && a.left), h = o.top + (u && a.top);
  let { width: f, height: p } = t;
  return r && (f -= o.width + a.width, p -= o.height + a.height), {
    x: Math.round((l - d) / f * n.width / s),
    y: Math.round((c - h) / p * n.height / s)
  };
}
function sI(e, t, n) {
  let s, i;
  if (t === void 0 || n === void 0) {
    const r = e && Wd(e);
    if (!r)
      t = e.clientWidth, n = e.clientHeight;
    else {
      const o = r.getBoundingClientRect(), a = Ha(r), l = xs(a, "border", "width"), c = xs(a, "padding");
      t = o.width - c.width - l.width, n = o.height - c.height - l.height, s = ma(a.maxWidth, r, "clientWidth"), i = ma(a.maxHeight, r, "clientHeight");
    }
  }
  return {
    width: t,
    height: n,
    maxWidth: s || pa,
    maxHeight: i || pa
  };
}
const fo = (e) => Math.round(e * 10) / 10;
function iI(e, t, n, s) {
  const i = Ha(e), r = xs(i, "margin"), o = ma(i.maxWidth, e, "clientWidth") || pa, a = ma(i.maxHeight, e, "clientHeight") || pa, l = sI(e, t, n);
  let { width: c, height: u } = l;
  if (i.boxSizing === "content-box") {
    const h = xs(i, "border", "width"), f = xs(i, "padding");
    c -= f.width + h.width, u -= f.height + h.height;
  }
  return c = Math.max(0, c - r.width), u = Math.max(0, s ? c / s : u - r.height), c = fo(Math.min(c, o, l.maxWidth)), u = fo(Math.min(u, a, l.maxHeight)), c && !u && (u = fo(c / 2)), (t !== void 0 || n !== void 0) && s && l.height && u > l.height && (u = l.height, c = fo(Math.floor(u * s))), {
    width: c,
    height: u
  };
}
function Cp(e, t, n) {
  const s = t || 1, i = Math.floor(e.height * s), r = Math.floor(e.width * s);
  e.height = Math.floor(e.height), e.width = Math.floor(e.width);
  const o = e.canvas;
  return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${e.height}px`, o.style.width = `${e.width}px`), e.currentDevicePixelRatio !== s || o.height !== i || o.width !== r ? (e.currentDevicePixelRatio = s, o.height = i, o.width = r, e.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;
}
const rI = function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    Yd() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
}();
function Sp(e, t) {
  const n = $2(e, t), s = n && n.match(/^(\d+)(\.\d+)?px$/);
  return s ? +s[1] : void 0;
}
function ps(e, t, n, s) {
  return {
    x: e.x + n * (t.x - e.x),
    y: e.y + n * (t.y - e.y)
  };
}
function oI(e, t, n, s) {
  return {
    x: e.x + n * (t.x - e.x),
    y: s === "middle" ? n < 0.5 ? e.y : t.y : s === "after" ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y
  };
}
function aI(e, t, n, s) {
  const i = {
    x: e.cp2x,
    y: e.cp2y
  }, r = {
    x: t.cp1x,
    y: t.cp1y
  }, o = ps(e, i, n), a = ps(i, r, n), l = ps(r, t, n), c = ps(o, a, n), u = ps(a, l, n);
  return ps(c, u, n);
}
const lI = function(e, t) {
  return {
    x(n) {
      return e + e + t - n;
    },
    setWidth(n) {
      t = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, s) {
      return n - s;
    },
    leftForLtr(n, s) {
      return n - s;
    }
  };
}, cI = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function Hs(e, t, n) {
  return e ? lI(t, n) : cI();
}
function $w(e, t) {
  let n, s;
  (t === "ltr" || t === "rtl") && (n = e.canvas.style, s = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", t, "important"), e.prevTextDirection = s);
}
function tb(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function eb(e) {
  return e === "angle" ? {
    between: Cr,
    compare: u2,
    normalize: Ae
  } : {
    between: dn,
    compare: (t, n) => t - n,
    normalize: (t) => t
  };
}
function Mp({ start: e, end: t, count: n, loop: s, style: i }) {
  return {
    start: e % n,
    end: t % n,
    loop: s && (t - e + 1) % n === 0,
    style: i
  };
}
function uI(e, t, n) {
  const { property: s, start: i, end: r } = n, { between: o, normalize: a } = eb(s), l = t.length;
  let { start: c, end: u, loop: d } = e, h, f;
  if (d) {
    for (c += l, u += l, h = 0, f = l; h < f && o(a(t[c % l][s]), i, r); ++h)
      c--, u--;
    c %= l, u %= l;
  }
  return u < c && (u += l), {
    start: c,
    end: u,
    loop: d,
    style: e.style
  };
}
function nb(e, t, n) {
  if (!n)
    return [
      e
    ];
  const { property: s, start: i, end: r } = n, o = t.length, { compare: a, between: l, normalize: c } = eb(s), { start: u, end: d, loop: h, style: f } = uI(e, t, n), p = [];
  let g = !1, m = null, A, w, x;
  const v = () => l(i, x, A) && a(i, x) !== 0, C = () => a(r, A) === 0 || l(r, x, A), E = () => g || v(), S = () => !g || C();
  for (let M = u, q = u; M <= d; ++M)
    w = t[M % o], !w.skip && (A = c(w[s]), A !== x && (g = l(A, i, r), m === null && E() && (m = a(A, i) === 0 ? M : q), m !== null && S() && (p.push(Mp({
      start: m,
      end: M,
      loop: h,
      count: o,
      style: f
    })), m = null), q = M, x = A));
  return m !== null && p.push(Mp({
    start: m,
    end: d,
    loop: h,
    count: o,
    style: f
  })), p;
}
function sb(e, t) {
  const n = [], s = e.segments;
  for (let i = 0; i < s.length; i++) {
    const r = nb(s[i], e.points, t);
    r.length && n.push(...r);
  }
  return n;
}
function dI(e, t, n, s) {
  let i = 0, r = t - 1;
  if (n && !s)
    for (; i < t && !e[i].skip; )
      i++;
  for (; i < t && e[i].skip; )
    i++;
  for (i %= t, n && (r += i); r > i && e[r % t].skip; )
    r--;
  return r %= t, {
    start: i,
    end: r
  };
}
function hI(e, t, n, s) {
  const i = e.length, r = [];
  let o = t, a = e[t], l;
  for (l = t + 1; l <= n; ++l) {
    const c = e[l % i];
    c.skip || c.stop ? a.skip || (s = !1, r.push({
      start: t % i,
      end: (l - 1) % i,
      loop: s
    }), t = o = c.stop ? l : null) : (o = l, a.skip && (t = l)), a = c;
  }
  return o !== null && r.push({
    start: t % i,
    end: o % i,
    loop: s
  }), r;
}
function fI(e, t) {
  const n = e.points, s = e.options.spanGaps, i = n.length;
  if (!i)
    return [];
  const r = !!e._loop, { start: o, end: a } = dI(n, i, r, s);
  if (s === !0)
    return Ep(e, [
      {
        start: o,
        end: a,
        loop: r
      }
    ], n, t);
  const l = a < o ? a + i : a, c = !!e._fullLoop && o === 0 && a === i - 1;
  return Ep(e, hI(n, o, l, c), n, t);
}
function Ep(e, t, n, s) {
  return !s || !s.setContext || !n ? t : pI(e, t, n, s);
}
function pI(e, t, n, s) {
  const i = e._chart.getContext(), r = qp(e.options), { _datasetIndex: o, options: { spanGaps: a } } = e, l = n.length, c = [];
  let u = r, d = t[0].start, h = d;
  function f(p, g, m, A) {
    const w = a ? -1 : 1;
    if (p !== g) {
      for (p += l; n[p % l].skip; )
        p -= w;
      for (; n[g % l].skip; )
        g += w;
      p % l !== g % l && (c.push({
        start: p % l,
        end: g % l,
        loop: m,
        style: A
      }), u = A, d = g % l);
    }
  }
  for (const p of t) {
    d = a ? d : p.start;
    let g = n[d % l], m;
    for (h = d + 1; h <= p.end; h++) {
      const A = n[h % l];
      m = qp(s.setContext(es(i, {
        type: "segment",
        p0: g,
        p1: A,
        p0DataIndex: (h - 1) % l,
        p1DataIndex: h % l,
        datasetIndex: o
      }))), gI(m, u) && f(d, h - 1, p.loop, u), g = A, u = m;
    }
    d < h - 1 && f(d, h - 1, p.loop, u);
  }
  return c;
}
function qp(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function gI(e, t) {
  if (!t)
    return !1;
  const n = [], s = function(i, r) {
    return Ld(r) ? (n.includes(r) || n.push(r), n.indexOf(r)) : r;
  };
  return JSON.stringify(e, s) !== JSON.stringify(t, s);
}
/*!
 * Chart.js v4.4.4
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class mI {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, n, s, i) {
    const r = n.listeners[i], o = n.duration;
    r.forEach((a) => a({
      chart: t,
      initial: n.initial,
      numSteps: o,
      currentStep: Math.min(s - n.start, o)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Vw.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let n = 0;
    this._charts.forEach((s, i) => {
      if (!s.running || !s.items.length)
        return;
      const r = s.items;
      let o = r.length - 1, a = !1, l;
      for (; o >= 0; --o)
        l = r[o], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (r[o] = r[r.length - 1], r.pop());
      a && (i.draw(), this._notify(i, s, t, "progress")), r.length || (s.running = !1, this._notify(i, s, t, "complete"), s.initial = !1), n += r.length;
    }), this._lastDate = t, n === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const n = this._charts;
    let s = n.get(t);
    return s || (s = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(t, s)), s;
  }
  listen(t, n, s) {
    this._getAnims(t).listeners[n].push(s);
  }
  add(t, n) {
    !n || !n.length || this._getAnims(t).items.push(...n);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const n = this._charts.get(t);
    n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((s, i) => Math.max(s, i._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const n = this._charts.get(t);
    return !(!n || !n.running || !n.items.length);
  }
  stop(t) {
    const n = this._charts.get(t);
    if (!n || !n.items.length)
      return;
    const s = n.items;
    let i = s.length - 1;
    for (; i >= 0; --i)
      s[i].cancel();
    n.items = [], this._notify(t, n, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var on = /* @__PURE__ */ new mI();
const Rp = "transparent", AI = {
  boolean(e, t, n) {
    return n > 0.5 ? t : e;
  },
  color(e, t, n) {
    const s = yp(e || Rp), i = s.valid && yp(t || Rp);
    return i && i.valid ? i.mix(s, n).hexString() : t;
  },
  number(e, t, n) {
    return e + (t - e) * n;
  }
};
class yI {
  constructor(t, n, s, i) {
    const r = n[s];
    i = ji([
      t.to,
      i,
      r,
      t.from
    ]);
    const o = ji([
      t.from,
      r,
      i
    ]);
    this._active = !0, this._fn = t.fn || AI[t.type || typeof o], this._easing = Hi[t.easing] || Hi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = n, this._prop = s, this._from = o, this._to = i, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, n, s) {
    if (this._active) {
      this._notify(!1);
      const i = this._target[this._prop], r = s - this._start, o = this._duration - r;
      this._start = s, this._duration = Math.floor(Math.max(o, t.duration)), this._total += r, this._loop = !!t.loop, this._to = ji([
        t.to,
        n,
        i,
        t.from
      ]), this._from = ji([
        t.from,
        i,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const n = t - this._start, s = this._duration, i = this._prop, r = this._from, o = this._loop, a = this._to;
    let l;
    if (this._active = r !== a && (o || n < s), !this._active) {
      this._target[i] = a, this._notify(!0);
      return;
    }
    if (n < 0) {
      this._target[i] = r;
      return;
    }
    l = n / s % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(r, a, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((n, s) => {
      t.push({
        res: n,
        rej: s
      });
    });
  }
  _notify(t) {
    const n = t ? "res" : "rej", s = this._promises || [];
    for (let i = 0; i < s.length; i++)
      s[i][n]();
  }
}
class ib {
  constructor(t, n) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(t) {
    if (!it(t))
      return;
    const n = Object.keys(Dt.animation), s = this._properties;
    Object.getOwnPropertyNames(t).forEach((i) => {
      const r = t[i];
      if (!it(r))
        return;
      const o = {};
      for (const a of n)
        o[a] = r[a];
      (St(r.properties) && r.properties || [
        i
      ]).forEach((a) => {
        (a === i || !s.has(a)) && s.set(a, o);
      });
    });
  }
  _animateOptions(t, n) {
    const s = n.options, i = bI(t, s);
    if (!i)
      return [];
    const r = this._createAnimations(i, s);
    return s.$shared && wI(t.options.$animations, s).then(() => {
      t.options = s;
    }, () => {
    }), r;
  }
  _createAnimations(t, n) {
    const s = this._properties, i = [], r = t.$animations || (t.$animations = {}), o = Object.keys(n), a = Date.now();
    let l;
    for (l = o.length - 1; l >= 0; --l) {
      const c = o[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        i.push(...this._animateOptions(t, n));
        continue;
      }
      const u = n[c];
      let d = r[c];
      const h = s.get(c);
      if (d)
        if (h && d.active()) {
          d.update(h, u, a);
          continue;
        } else
          d.cancel();
      if (!h || !h.duration) {
        t[c] = u;
        continue;
      }
      r[c] = d = new yI(h, t, c, u), i.push(d);
    }
    return i;
  }
  update(t, n) {
    if (this._properties.size === 0) {
      Object.assign(t, n);
      return;
    }
    const s = this._createAnimations(t, n);
    if (s.length)
      return on.add(this._chart, s), !0;
  }
}
function wI(e, t) {
  const n = [], s = Object.keys(t);
  for (let i = 0; i < s.length; i++) {
    const r = e[s[i]];
    r && r.active() && n.push(r.wait());
  }
  return Promise.all(n);
}
function bI(e, t) {
  if (!t)
    return;
  let n = e.options;
  if (!n) {
    e.options = t;
    return;
  }
  return n.$shared && (e.options = n = Object.assign({}, n, {
    $shared: !1,
    $animations: {}
  })), n;
}
function kp(e, t) {
  const n = e && e.options || {}, s = n.reverse, i = n.min === void 0 ? t : 0, r = n.max === void 0 ? t : 0;
  return {
    start: s ? r : i,
    end: s ? i : r
  };
}
function xI(e, t, n) {
  if (n === !1)
    return !1;
  const s = kp(e, n), i = kp(t, n);
  return {
    top: i.end,
    right: s.end,
    bottom: i.start,
    left: s.start
  };
}
function vI(e) {
  let t, n, s, i;
  return it(e) ? (t = e.top, n = e.right, s = e.bottom, i = e.left) : t = n = s = i = e, {
    top: t,
    right: n,
    bottom: s,
    left: i,
    disabled: e === !1
  };
}
function rb(e, t) {
  const n = [], s = e._getSortedDatasetMetas(t);
  let i, r;
  for (i = 0, r = s.length; i < r; ++i)
    n.push(s[i].index);
  return n;
}
function Tp(e, t, n, s = {}) {
  const i = e.keys, r = s.mode === "single";
  let o, a, l, c;
  if (t !== null) {
    for (o = 0, a = i.length; o < a; ++o) {
      if (l = +i[o], l === n) {
        if (s.all)
          continue;
        break;
      }
      c = e.values[l], Tt(c) && (r || t === 0 || Ze(t) === Ze(c)) && (t += c);
    }
    return t;
  }
}
function CI(e, t) {
  const { iScale: n, vScale: s } = t, i = n.axis === "x" ? "x" : "y", r = s.axis === "x" ? "x" : "y", o = Object.keys(e), a = new Array(o.length);
  let l, c, u;
  for (l = 0, c = o.length; l < c; ++l)
    u = o[l], a[l] = {
      [i]: u,
      [r]: e[u]
    };
  return a;
}
function Dp(e, t) {
  const n = e && e.options.stacked;
  return n || n === void 0 && t.stack !== void 0;
}
function SI(e, t, n) {
  return `${e.id}.${t.id}.${n.stack || n.type}`;
}
function MI(e) {
  const { min: t, max: n, minDefined: s, maxDefined: i } = e.getUserBounds();
  return {
    min: s ? t : Number.NEGATIVE_INFINITY,
    max: i ? n : Number.POSITIVE_INFINITY
  };
}
function EI(e, t, n) {
  const s = e[t] || (e[t] = {});
  return s[n] || (s[n] = {});
}
function Bp(e, t, n, s) {
  for (const i of t.getMatchingVisibleMetas(s).reverse()) {
    const r = e[i.index];
    if (n && r > 0 || !n && r < 0)
      return i.index;
  }
  return null;
}
function Ip(e, t) {
  const { chart: n, _cachedMeta: s } = e, i = n._stacks || (n._stacks = {}), { iScale: r, vScale: o, index: a } = s, l = r.axis, c = o.axis, u = SI(r, o, s), d = t.length;
  let h;
  for (let f = 0; f < d; ++f) {
    const p = t[f], { [l]: g, [c]: m } = p, A = p._stacks || (p._stacks = {});
    h = A[c] = EI(i, u, g), h[a] = m, h._top = Bp(h, o, !0, s.type), h._bottom = Bp(h, o, !1, s.type);
    const w = h._visualValues || (h._visualValues = {});
    w[a] = m;
  }
}
function Ll(e, t) {
  const n = e.scales;
  return Object.keys(n).filter((s) => n[s].axis === t).shift();
}
function qI(e, t) {
  return es(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function RI(e, t, n) {
  return es(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: t,
    mode: "default",
    type: "data"
  });
}
function Ri(e, t) {
  const n = e.controller.index, s = e.vScale && e.vScale.axis;
  if (s) {
    t = t || e._parsed;
    for (const i of t) {
      const r = i._stacks;
      if (!r || r[s] === void 0 || r[s][n] === void 0)
        return;
      delete r[s][n], r[s]._visualValues !== void 0 && r[s]._visualValues[n] !== void 0 && delete r[s]._visualValues[n];
    }
  }
}
const Fl = (e) => e === "reset" || e === "none", Pp = (e, t) => t ? e : Object.assign({}, e), kI = (e, t, n) => e && !t.hidden && t._stacked && {
  keys: rb(n, !0),
  values: null
};
class Oe {
  constructor(t, n) {
    this.chart = t, this._ctx = t.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = Dp(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && Ri(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, n = this._cachedMeta, s = this.getDataset(), i = (d, h, f, p) => d === "x" ? h : d === "r" ? p : f, r = n.xAxisID = $(s.xAxisID, Ll(t, "x")), o = n.yAxisID = $(s.yAxisID, Ll(t, "y")), a = n.rAxisID = $(s.rAxisID, Ll(t, "r")), l = n.indexAxis, c = n.iAxisID = i(l, r, o, a), u = n.vAxisID = i(l, o, r, a);
    n.xScale = this.getScaleForId(r), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const n = this._cachedMeta;
    return t === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && gp(this._data, this), t._stacked && Ri(t);
  }
  _dataCheck() {
    const t = this.getDataset(), n = t.data || (t.data = []), s = this._data;
    if (it(n)) {
      const i = this._cachedMeta;
      this._data = CI(n, i);
    } else if (s !== n) {
      if (s) {
        gp(s, this);
        const i = this._cachedMeta;
        Ri(i), i._parsed = [];
      }
      n && Object.isExtensible(n) && p2(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const n = this._cachedMeta, s = this.getDataset();
    let i = !1;
    this._dataCheck();
    const r = n._stacked;
    n._stacked = Dp(n.vScale, n), n.stack !== s.stack && (i = !0, Ri(n), n.stack = s.stack), this._resyncElements(t), (i || r !== n._stacked) && Ip(this, n._parsed);
  }
  configure() {
    const t = this.chart.config, n = t.datasetScopeKeys(this._type), s = t.getOptionScopes(this.getDataset(), n, !0);
    this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, n) {
    const { _cachedMeta: s, _data: i } = this, { iScale: r, _stacked: o } = s, a = r.axis;
    let l = t === 0 && n === i.length ? !0 : s._sorted, c = t > 0 && s._parsed[t - 1], u, d, h;
    if (this._parsing === !1)
      s._parsed = i, s._sorted = !0, h = i;
    else {
      St(i[t]) ? h = this.parseArrayData(s, i, t, n) : it(i[t]) ? h = this.parseObjectData(s, i, t, n) : h = this.parsePrimitiveData(s, i, t, n);
      const f = () => d[a] === null || c && d[a] < c[a];
      for (u = 0; u < n; ++u)
        s._parsed[u + t] = d = h[u], l && (f() && (l = !1), c = d);
      s._sorted = l;
    }
    o && Ip(this, h);
  }
  parsePrimitiveData(t, n, s, i) {
    const { iScale: r, vScale: o } = t, a = r.axis, l = o.axis, c = r.getLabels(), u = r === o, d = new Array(i);
    let h, f, p;
    for (h = 0, f = i; h < f; ++h)
      p = h + s, d[h] = {
        [a]: u || r.parse(c[p], p),
        [l]: o.parse(n[p], p)
      };
    return d;
  }
  parseArrayData(t, n, s, i) {
    const { xScale: r, yScale: o } = t, a = new Array(i);
    let l, c, u, d;
    for (l = 0, c = i; l < c; ++l)
      u = l + s, d = n[u], a[l] = {
        x: r.parse(d[0], u),
        y: o.parse(d[1], u)
      };
    return a;
  }
  parseObjectData(t, n, s, i) {
    const { xScale: r, yScale: o } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(i);
    let u, d, h, f;
    for (u = 0, d = i; u < d; ++u)
      h = u + s, f = n[h], c[u] = {
        x: r.parse(Hn(f, a), h),
        y: o.parse(Hn(f, l), h)
      };
    return c;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, n, s) {
    const i = this.chart, r = this._cachedMeta, o = n[t.axis], a = {
      keys: rb(i, !0),
      values: n._stacks[t.axis]._visualValues
    };
    return Tp(a, o, r.index, {
      mode: s
    });
  }
  updateRangeFromParsed(t, n, s, i) {
    const r = s[n.axis];
    let o = r === null ? NaN : r;
    const a = i && s._stacks[n.axis];
    i && a && (i.values = a, o = Tp(i, r, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);
  }
  getMinMax(t, n) {
    const s = this._cachedMeta, i = s._parsed, r = s._sorted && t === s.iScale, o = i.length, a = this._getOtherScale(t), l = kI(n, s, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: d } = MI(a);
    let h, f;
    function p() {
      f = i[h];
      const g = f[a.axis];
      return !Tt(f[t.axis]) || u > g || d < g;
    }
    for (h = 0; h < o && !(!p() && (this.updateRangeFromParsed(c, t, f, l), r)); ++h)
      ;
    if (r) {
      for (h = o - 1; h >= 0; --h)
        if (!p()) {
          this.updateRangeFromParsed(c, t, f, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(t) {
    const n = this._cachedMeta._parsed, s = [];
    let i, r, o;
    for (i = 0, r = n.length; i < r; ++i)
      o = n[i][t.axis], Tt(o) && s.push(o);
    return s;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, s = n.iScale, i = n.vScale, r = this.getParsed(t);
    return {
      label: s ? "" + s.getLabelForValue(r[s.axis]) : "",
      value: i ? "" + i.getLabelForValue(r[i.axis]) : ""
    };
  }
  _update(t) {
    const n = this._cachedMeta;
    this.update(t || "default"), n._clip = vI($(this.options.clip, xI(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, n = this.chart, s = this._cachedMeta, i = s.data || [], r = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || i.length - a, c = this.options.drawActiveElementsOnTop;
    let u;
    for (s.dataset && s.dataset.draw(t, r, a, l), u = a; u < a + l; ++u) {
      const d = i[u];
      d.hidden || (d.active && c ? o.push(d) : d.draw(t, r));
    }
    for (u = 0; u < o.length; ++u)
      o[u].draw(t, r);
  }
  getStyle(t, n) {
    const s = n ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);
  }
  getContext(t, n, s) {
    const i = this.getDataset();
    let r;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[t];
      r = o.$context || (o.$context = RI(this.getContext(), t, o)), r.parsed = this.getParsed(t), r.raw = i.data[t], r.index = r.dataIndex = t;
    } else
      r = this.$context || (this.$context = qI(this.chart.getContext(), this.index)), r.dataset = i, r.index = r.datasetIndex = this.index;
    return r.active = !!n, r.mode = s, r;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, t);
  }
  _resolveElementOptions(t, n = "default", s) {
    const i = n === "active", r = this._cachedDataOpts, o = t + "-" + n, a = r[o], l = this.enableOptionSharing && vr(s);
    if (a)
      return Pp(a, l);
    const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, t), d = i ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], h = c.getOptionScopes(this.getDataset(), u), f = Object.keys(Dt.elements[t]), p = () => this.getContext(s, i, n), g = c.resolveNamedOptions(h, f, p, d);
    return g.$shared && (g.$shared = l, r[o] = Object.freeze(Pp(g, l))), g;
  }
  _resolveAnimations(t, n, s) {
    const i = this.chart, r = this._cachedDataOpts, o = `animation-${n}`, a = r[o];
    if (a)
      return a;
    let l;
    if (i.options.animation !== !1) {
      const u = this.chart.config, d = u.datasetAnimationScopeKeys(this._type, n), h = u.getOptionScopes(this.getDataset(), d);
      l = u.createResolver(h, this.getContext(t, s, n));
    }
    const c = new ib(i, l && l.animations);
    return l && l._cacheable && (r[o] = Object.freeze(c)), c;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, n) {
    return !n || Fl(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, n) {
    const s = this.resolveDataElementOptions(t, n), i = this._sharedOptions, r = this.getSharedOptions(s), o = this.includeOptions(n, r) || r !== i;
    return this.updateSharedOptions(r, n, s), {
      sharedOptions: r,
      includeOptions: o
    };
  }
  updateElement(t, n, s, i) {
    Fl(i) ? Object.assign(t, s) : this._resolveAnimations(n, i).update(t, s);
  }
  updateSharedOptions(t, n, s) {
    t && !Fl(n) && this._resolveAnimations(void 0, n).update(t, s);
  }
  _setStyle(t, n, s, i) {
    t.active = i;
    const r = this.getStyle(n, i);
    this._resolveAnimations(n, s, i).update(t, {
      options: !i && this.getSharedOptions(r) || r
    });
  }
  removeHoverStyle(t, n, s) {
    this._setStyle(t, s, "active", !1);
  }
  setHoverStyle(t, n, s) {
    this._setStyle(t, s, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const n = this._data, s = this._cachedMeta.data;
    for (const [a, l, c] of this._syncList)
      this[a](l, c);
    this._syncList = [];
    const i = s.length, r = n.length, o = Math.min(r, i);
    o && this.parse(0, o), r > i ? this._insertElements(i, r - i, t) : r < i && this._removeElements(r, i - r);
  }
  _insertElements(t, n, s = !0) {
    const i = this._cachedMeta, r = i.data, o = t + n;
    let a;
    const l = (c) => {
      for (c.length += n, a = c.length - 1; a >= o; a--)
        c[a] = c[a - n];
    };
    for (l(r), a = t; a < o; ++a)
      r[a] = new this.dataElementType();
    this._parsing && l(i._parsed), this.parse(t, n), s && this.updateElements(r, t, n, "reset");
  }
  updateElements(t, n, s, i) {
  }
  _removeElements(t, n) {
    const s = this._cachedMeta;
    if (this._parsing) {
      const i = s._parsed.splice(t, n);
      s._stacked && Ri(s, i);
    }
    s.data.splice(t, n);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [n, s, i] = t;
      this[n](s, i);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, n) {
    n && this._sync([
      "_removeElements",
      t,
      n
    ]);
    const s = arguments.length - 2;
    s && this._sync([
      "_insertElements",
      t,
      s
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
L(Oe, "defaults", {}), L(Oe, "datasetElementType", null), L(Oe, "dataElementType", null);
function TI(e, t) {
  if (!e._cache.$bar) {
    const n = e.getMatchingVisibleMetas(t);
    let s = [];
    for (let i = 0, r = n.length; i < r; i++)
      s = s.concat(n[i].controller.getAllParsedValues(e));
    e._cache.$bar = jw(s.sort((i, r) => i - r));
  }
  return e._cache.$bar;
}
function DI(e) {
  const t = e.iScale, n = TI(t, e.type);
  let s = t._length, i, r, o, a;
  const l = () => {
    o === 32767 || o === -32768 || (vr(a) && (s = Math.min(s, Math.abs(o - a) || s)), a = o);
  };
  for (i = 0, r = n.length; i < r; ++i)
    o = t.getPixelForValue(n[i]), l();
  for (a = void 0, i = 0, r = t.ticks.length; i < r; ++i)
    o = t.getPixelForTick(i), l();
  return s;
}
function BI(e, t, n, s) {
  const i = n.barThickness;
  let r, o;
  return ot(i) ? (r = t.min * n.categoryPercentage, o = n.barPercentage) : (r = i * s, o = 1), {
    chunk: r / s,
    ratio: o,
    start: t.pixels[e] - r / 2
  };
}
function II(e, t, n, s) {
  const i = t.pixels, r = i[e];
  let o = e > 0 ? i[e - 1] : null, a = e < i.length - 1 ? i[e + 1] : null;
  const l = n.categoryPercentage;
  o === null && (o = r - (a === null ? t.end - t.start : a - r)), a === null && (a = r + r - o);
  const c = r - (r - Math.min(o, a)) / 2 * l;
  return {
    chunk: Math.abs(a - o) / 2 * l / s,
    ratio: n.barPercentage,
    start: c
  };
}
function PI(e, t, n, s) {
  const i = n.parse(e[0], s), r = n.parse(e[1], s), o = Math.min(i, r), a = Math.max(i, r);
  let l = o, c = a;
  Math.abs(o) > Math.abs(a) && (l = a, c = o), t[n.axis] = c, t._custom = {
    barStart: l,
    barEnd: c,
    start: i,
    end: r,
    min: o,
    max: a
  };
}
function ob(e, t, n, s) {
  return St(e) ? PI(e, t, n, s) : t[n.axis] = n.parse(e, s), t;
}
function Op(e, t, n, s) {
  const i = e.iScale, r = e.vScale, o = i.getLabels(), a = i === r, l = [];
  let c, u, d, h;
  for (c = n, u = n + s; c < u; ++c)
    h = t[c], d = {}, d[i.axis] = a || i.parse(o[c], c), l.push(ob(h, d, r, c));
  return l;
}
function jl(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function OI(e, t, n) {
  return e !== 0 ? Ze(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1);
}
function NI(e) {
  let t, n, s, i, r;
  return e.horizontal ? (t = e.base > e.x, n = "left", s = "right") : (t = e.base < e.y, n = "bottom", s = "top"), t ? (i = "end", r = "start") : (i = "start", r = "end"), {
    start: n,
    end: s,
    reverse: t,
    top: i,
    bottom: r
  };
}
function LI(e, t, n, s) {
  let i = t.borderSkipped;
  const r = {};
  if (!i) {
    e.borderSkipped = r;
    return;
  }
  if (i === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: o, end: a, reverse: l, top: c, bottom: u } = NI(e);
  i === "middle" && n && (e.enableBorderRadius = !0, (n._top || 0) === s ? i = c : (n._bottom || 0) === s ? i = u : (r[Np(u, o, a, l)] = !0, i = c)), r[Np(i, o, a, l)] = !0, e.borderSkipped = r;
}
function Np(e, t, n, s) {
  return s ? (e = FI(e, t, n), e = Lp(e, n, t)) : e = Lp(e, t, n), e;
}
function FI(e, t, n) {
  return e === t ? n : e === n ? t : e;
}
function Lp(e, t, n) {
  return e === "start" ? t : e === "end" ? n : e;
}
function jI(e, { inflateAmount: t }, n) {
  e.inflateAmount = t === "auto" ? n === 1 ? 0.33 : 0 : t;
}
class Bo extends Oe {
  parsePrimitiveData(t, n, s, i) {
    return Op(t, n, s, i);
  }
  parseArrayData(t, n, s, i) {
    return Op(t, n, s, i);
  }
  parseObjectData(t, n, s, i) {
    const { iScale: r, vScale: o } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = r.axis === "x" ? a : l, u = o.axis === "x" ? a : l, d = [];
    let h, f, p, g;
    for (h = s, f = s + i; h < f; ++h)
      g = n[h], p = {}, p[r.axis] = r.parse(Hn(g, c), h), d.push(ob(Hn(g, u), p, o, h));
    return d;
  }
  updateRangeFromParsed(t, n, s, i) {
    super.updateRangeFromParsed(t, n, s, i);
    const r = s._custom;
    r && n === this._cachedMeta.vScale && (t.min = Math.min(t.min, r.min), t.max = Math.max(t.max, r.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, { iScale: s, vScale: i } = n, r = this.getParsed(t), o = r._custom, a = jl(o) ? "[" + o.start + ", " + o.end + "]" : "" + i.getLabelForValue(r[i.axis]);
    return {
      label: "" + s.getLabelForValue(r[s.axis]),
      value: a
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const n = this._cachedMeta;
    this.updateElements(n.data, 0, n.data.length, t);
  }
  updateElements(t, n, s, i) {
    const r = i === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), u = this._getRuler(), { sharedOptions: d, includeOptions: h } = this._getSharedOptions(n, i);
    for (let f = n; f < n + s; f++) {
      const p = this.getParsed(f), g = r || ot(p[a.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(f), m = this._calculateBarIndexPixels(f, u), A = (p._stacks || {})[a.axis], w = {
        horizontal: c,
        base: g.base,
        enableBorderRadius: !A || jl(p._custom) || o === A._top || o === A._bottom,
        x: c ? g.head : m.center,
        y: c ? m.center : g.head,
        height: c ? m.size : Math.abs(g.size),
        width: c ? Math.abs(g.size) : m.size
      };
      h && (w.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : i));
      const x = w.options || t[f].options;
      LI(w, x, A, o), jI(w, x, u.ratio), this.updateElement(t[f], f, w, i);
    }
  }
  _getStacks(t, n) {
    const { iScale: s } = this._cachedMeta, i = s.getMatchingVisibleMetas(this._type).filter((u) => u.controller.options.grouped), r = s.options.stacked, o = [], a = this._cachedMeta.controller.getParsed(n), l = a && a[s.axis], c = (u) => {
      const d = u._parsed.find((f) => f[s.axis] === l), h = d && d[u.vScale.axis];
      if (ot(h) || isNaN(h))
        return !0;
    };
    for (const u of i)
      if (!(n !== void 0 && c(u)) && ((r === !1 || o.indexOf(u.stack) === -1 || r === void 0 && u.stack === void 0) && o.push(u.stack), u.index === t))
        break;
    return o.length || o.push(void 0), o;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getStackIndex(t, n, s) {
    const i = this._getStacks(t, s), r = n !== void 0 ? i.indexOf(n) : -1;
    return r === -1 ? i.length - 1 : r;
  }
  _getRuler() {
    const t = this.options, n = this._cachedMeta, s = n.iScale, i = [];
    let r, o;
    for (r = 0, o = n.data.length; r < o; ++r)
      i.push(s.getPixelForValue(this.getParsed(r)[s.axis], r));
    const a = t.barThickness;
    return {
      min: a || DI(n),
      pixels: i,
      start: s._startPixel,
      end: s._endPixel,
      stackCount: this._getStackCount(),
      scale: s,
      grouped: t.grouped,
      ratio: a ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: n, _stacked: s, index: i }, options: { base: r, minBarLength: o } } = this, a = r || 0, l = this.getParsed(t), c = l._custom, u = jl(c);
    let d = l[n.axis], h = 0, f = s ? this.applyStack(n, l, s) : d, p, g;
    f !== d && (h = f - d, f = d), u && (d = c.barStart, f = c.barEnd - c.barStart, d !== 0 && Ze(d) !== Ze(c.barEnd) && (h = 0), h += d);
    const m = !ot(r) && !u ? r : h;
    let A = n.getPixelForValue(m);
    if (this.chart.getDataVisibility(t) ? p = n.getPixelForValue(h + f) : p = A, g = p - A, Math.abs(g) < o) {
      g = OI(g, n, a) * o, d === a && (A -= g / 2);
      const w = n.getPixelForDecimal(0), x = n.getPixelForDecimal(1), v = Math.min(w, x), C = Math.max(w, x);
      A = Math.max(Math.min(A, C), v), p = A + g, s && !u && (l._stacks[n.axis]._visualValues[i] = n.getValueForPixel(p) - n.getValueForPixel(A));
    }
    if (A === n.getPixelForValue(a)) {
      const w = Ze(g) * n.getLineWidthForValue(a) / 2;
      A += w, g -= w;
    }
    return {
      size: g,
      base: A,
      head: p,
      center: p + g / 2
    };
  }
  _calculateBarIndexPixels(t, n) {
    const s = n.scale, i = this.options, r = i.skipNull, o = $(i.maxBarThickness, 1 / 0);
    let a, l;
    if (n.grouped) {
      const c = r ? this._getStackCount(t) : n.stackCount, u = i.barThickness === "flex" ? II(t, n, i, c) : BI(t, n, i, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, r ? t : void 0);
      a = u.start + u.chunk * d + u.chunk / 2, l = Math.min(o, u.chunk * u.ratio);
    } else
      a = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(o, n.min * n.ratio);
    return {
      base: a - l / 2,
      head: a + l / 2,
      center: a,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, n = t.vScale, s = t.data, i = s.length;
    let r = 0;
    for (; r < i; ++r)
      this.getParsed(r)[n.axis] !== null && !s[r].hidden && s[r].draw(this._ctx);
  }
}
L(Bo, "id", "bar"), L(Bo, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), L(Bo, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class Io extends Oe {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(t, n, s, i) {
    const r = super.parsePrimitiveData(t, n, s, i);
    for (let o = 0; o < r.length; o++)
      r[o]._custom = this.resolveDataElementOptions(o + s).radius;
    return r;
  }
  parseArrayData(t, n, s, i) {
    const r = super.parseArrayData(t, n, s, i);
    for (let o = 0; o < r.length; o++) {
      const a = n[s + o];
      r[o]._custom = $(a[2], this.resolveDataElementOptions(o + s).radius);
    }
    return r;
  }
  parseObjectData(t, n, s, i) {
    const r = super.parseObjectData(t, n, s, i);
    for (let o = 0; o < r.length; o++) {
      const a = n[s + o];
      r[o]._custom = $(a && a.r && +a.r, this.resolveDataElementOptions(o + s).radius);
    }
    return r;
  }
  getMaxOverflow() {
    const t = this._cachedMeta.data;
    let n = 0;
    for (let s = t.length - 1; s >= 0; --s)
      n = Math.max(n, t[s].size(this.resolveDataElementOptions(s)) / 2);
    return n > 0 && n;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, s = this.chart.data.labels || [], { xScale: i, yScale: r } = n, o = this.getParsed(t), a = i.getLabelForValue(o.x), l = r.getLabelForValue(o.y), c = o._custom;
    return {
      label: s[t] || "",
      value: "(" + a + ", " + l + (c ? ", " + c : "") + ")"
    };
  }
  update(t) {
    const n = this._cachedMeta.data;
    this.updateElements(n, 0, n.length, t);
  }
  updateElements(t, n, s, i) {
    const r = i === "reset", { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(n, i), u = o.axis, d = a.axis;
    for (let h = n; h < n + s; h++) {
      const f = t[h], p = !r && this.getParsed(h), g = {}, m = g[u] = r ? o.getPixelForDecimal(0.5) : o.getPixelForValue(p[u]), A = g[d] = r ? a.getBasePixel() : a.getPixelForValue(p[d]);
      g.skip = isNaN(m) || isNaN(A), c && (g.options = l || this.resolveDataElementOptions(h, f.active ? "active" : i), r && (g.options.radius = 0)), this.updateElement(f, h, g, i);
    }
  }
  resolveDataElementOptions(t, n) {
    const s = this.getParsed(t);
    let i = super.resolveDataElementOptions(t, n);
    i.$shared && (i = Object.assign({}, i, {
      $shared: !1
    }));
    const r = i.radius;
    return n !== "active" && (i.radius = 0), i.radius += $(s && s._custom, r), i;
  }
}
L(Io, "id", "bubble"), L(Io, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), L(Io, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function VI(e, t, n) {
  let s = 1, i = 1, r = 0, o = 0;
  if (t < bt) {
    const a = e, l = a + t, c = Math.cos(a), u = Math.sin(a), d = Math.cos(l), h = Math.sin(l), f = (x, v, C) => Cr(x, a, l, !0) ? 1 : Math.max(v, v * n, C, C * n), p = (x, v, C) => Cr(x, a, l, !0) ? -1 : Math.min(v, v * n, C, C * n), g = f(0, c, d), m = f(It, u, h), A = p(xt, c, d), w = p(xt + It, u, h);
    s = (g - A) / 2, i = (m - w) / 2, r = -(g + A) / 2, o = -(m + w) / 2;
  }
  return {
    ratioX: s,
    ratioY: i,
    offsetX: r,
    offsetY: o
  };
}
class ms extends Oe {
  constructor(t, n) {
    super(t, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, n) {
    const s = this.getDataset().data, i = this._cachedMeta;
    if (this._parsing === !1)
      i._parsed = s;
    else {
      let r = (l) => +s[l];
      if (it(s[t])) {
        const { key: l = "value" } = this._parsing;
        r = (c) => +Hn(s[c], l);
      }
      let o, a;
      for (o = t, a = t + n; o < a; ++o)
        i._parsed[o] = r(o);
    }
  }
  _getRotation() {
    return Ie(this.options.rotation - 90);
  }
  _getCircumference() {
    return Ie(this.options.circumference);
  }
  _getRotationExtents() {
    let t = bt, n = -bt;
    for (let s = 0; s < this.chart.data.datasets.length; ++s)
      if (this.chart.isDatasetVisible(s) && this.chart.getDatasetMeta(s).type === this._type) {
        const i = this.chart.getDatasetMeta(s).controller, r = i._getRotation(), o = i._getCircumference();
        t = Math.min(t, r), n = Math.max(n, r + o);
      }
    return {
      rotation: t,
      circumference: n - t
    };
  }
  update(t) {
    const n = this.chart, { chartArea: s } = n, i = this._cachedMeta, r = i.data, o = this.getMaxBorderWidth() + this.getMaxOffset(r) + this.options.spacing, a = Math.max((Math.min(s.width, s.height) - o) / 2, 0), l = Math.min(t2(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: h, ratioY: f, offsetX: p, offsetY: g } = VI(d, u, l), m = (s.width - o) / h, A = (s.height - o) / f, w = Math.max(Math.min(m, A) / 2, 0), x = Pw(this.options.radius, w), v = Math.max(x * l, 0), C = (x - v) / this._getVisibleDatasetWeightTotal();
    this.offsetX = p * x, this.offsetY = g * x, i.total = this.calculateTotal(), this.outerRadius = x - C * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - C * c, 0), this.updateElements(r, 0, r.length, t);
  }
  _circumference(t, n) {
    const s = this.options, i = this._cachedMeta, r = this._getCircumference();
    return n && s.animation.animateRotate || !this.chart.getDataVisibility(t) || i._parsed[t] === null || i.data[t].hidden ? 0 : this.calculateCircumference(i._parsed[t] * r / bt);
  }
  updateElements(t, n, s, i) {
    const r = i === "reset", o = this.chart, a = o.chartArea, c = o.options.animation, u = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, h = r && c.animateScale, f = h ? 0 : this.innerRadius, p = h ? 0 : this.outerRadius, { sharedOptions: g, includeOptions: m } = this._getSharedOptions(n, i);
    let A = this._getRotation(), w;
    for (w = 0; w < n; ++w)
      A += this._circumference(w, r);
    for (w = n; w < n + s; ++w) {
      const x = this._circumference(w, r), v = t[w], C = {
        x: u + this.offsetX,
        y: d + this.offsetY,
        startAngle: A,
        endAngle: A + x,
        circumference: x,
        outerRadius: p,
        innerRadius: f
      };
      m && (C.options = g || this.resolveDataElementOptions(w, v.active ? "active" : i)), A += x, this.updateElement(v, w, C, i);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, n = t.data;
    let s = 0, i;
    for (i = 0; i < n.length; i++) {
      const r = t._parsed[i];
      r !== null && !isNaN(r) && this.chart.getDataVisibility(i) && !n[i].hidden && (s += Math.abs(r));
    }
    return s;
  }
  calculateCircumference(t) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(t) ? bt * (Math.abs(t) / n) : 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, s = this.chart, i = s.data.labels || [], r = Fr(n._parsed[t], s.options.locale);
    return {
      label: i[t] || "",
      value: r
    };
  }
  getMaxBorderWidth(t) {
    let n = 0;
    const s = this.chart;
    let i, r, o, a, l;
    if (!t) {
      for (i = 0, r = s.data.datasets.length; i < r; ++i)
        if (s.isDatasetVisible(i)) {
          o = s.getDatasetMeta(i), t = o.data, a = o.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (i = 0, r = t.length; i < r; ++i)
      l = a.resolveDataElementOptions(i), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(t) {
    let n = 0;
    for (let s = 0, i = t.length; s < i; ++s) {
      const r = this.resolveDataElementOptions(s);
      n = Math.max(n, r.offset || 0, r.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(t) {
    let n = 0;
    for (let s = 0; s < t; ++s)
      this.chart.isDatasetVisible(s) && (n += this._getRingWeight(s));
    return n;
  }
  _getRingWeight(t) {
    return Math.max($(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
L(ms, "id", "doughnut"), L(ms, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), L(ms, "descriptors", {
  _scriptable: (t) => t !== "spacing",
  _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
}), L(ms, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(t) {
          const n = t.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: s, color: i } } = t.legend.options;
            return n.labels.map((r, o) => {
              const l = t.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: r,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: i,
                lineWidth: l.borderWidth,
                pointStyle: s,
                hidden: !t.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(t, n, s) {
        s.chart.toggleDataVisibility(n.index), s.chart.update();
      }
    }
  }
});
class Po extends Oe {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const n = this._cachedMeta, { dataset: s, data: i = [], _dataset: r } = n, o = this.chart._animationsDisabled;
    let { start: a, count: l } = Yw(n, i, o);
    this._drawStart = a, this._drawCount = l, Ww(n) && (a = 0, l = i.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!r._decimated, s.points = i;
    const c = this.resolveDatasetElementOptions(t);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {
      animated: !o,
      options: c
    }, t), this.updateElements(i, a, l, t);
  }
  updateElements(t, n, s, i) {
    const r = i === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, i), h = o.axis, f = a.axis, { spanGaps: p, segment: g } = this.options, m = ai(p) ? p : Number.POSITIVE_INFINITY, A = this.chart._animationsDisabled || r || i === "none", w = n + s, x = t.length;
    let v = n > 0 && this.getParsed(n - 1);
    for (let C = 0; C < x; ++C) {
      const E = t[C], S = A ? E : {};
      if (C < n || C >= w) {
        S.skip = !0;
        continue;
      }
      const M = this.getParsed(C), q = ot(M[f]), k = S[h] = o.getPixelForValue(M[h], C), R = S[f] = r || q ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[f], C);
      S.skip = isNaN(k) || isNaN(R) || q, S.stop = C > 0 && Math.abs(M[h] - v[h]) > m, g && (S.parsed = M, S.raw = c.data[C]), d && (S.options = u || this.resolveDataElementOptions(C, E.active ? "active" : i)), A || this.updateElement(E, C, S, i), v = M;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, n = t.dataset, s = n.options && n.options.borderWidth || 0, i = t.data || [];
    if (!i.length)
      return s;
    const r = i[0].size(this.resolveDataElementOptions(0)), o = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
    return Math.max(s, r, o) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
L(Po, "id", "line"), L(Po, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), L(Po, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class Xi extends Oe {
  constructor(t, n) {
    super(t, n), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, s = this.chart, i = s.data.labels || [], r = Fr(n._parsed[t].r, s.options.locale);
    return {
      label: i[t] || "",
      value: r
    };
  }
  parseObjectData(t, n, s, i) {
    return Jw.bind(this)(t, n, s, i);
  }
  update(t) {
    const n = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(n, 0, n.length, t);
  }
  getMinMax() {
    const t = this._cachedMeta, n = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return t.data.forEach((s, i) => {
      const r = this.getParsed(i).r;
      !isNaN(r) && this.chart.getDataVisibility(i) && (r < n.min && (n.min = r), r > n.max && (n.max = r));
    }), n;
  }
  _updateRadius() {
    const t = this.chart, n = t.chartArea, s = t.options, i = Math.min(n.right - n.left, n.bottom - n.top), r = Math.max(i / 2, 0), o = Math.max(s.cutoutPercentage ? r / 100 * s.cutoutPercentage : 1, 0), a = (r - o) / t.getVisibleDatasetCount();
    this.outerRadius = r - a * this.index, this.innerRadius = this.outerRadius - a;
  }
  updateElements(t, n, s, i) {
    const r = i === "reset", o = this.chart, l = o.options.animation, c = this._cachedMeta.rScale, u = c.xCenter, d = c.yCenter, h = c.getIndexAngle(0) - 0.5 * xt;
    let f = h, p;
    const g = 360 / this.countVisibleElements();
    for (p = 0; p < n; ++p)
      f += this._computeAngle(p, i, g);
    for (p = n; p < n + s; p++) {
      const m = t[p];
      let A = f, w = f + this._computeAngle(p, i, g), x = o.getDataVisibility(p) ? c.getDistanceFromCenterForValue(this.getParsed(p).r) : 0;
      f = w, r && (l.animateScale && (x = 0), l.animateRotate && (A = w = h));
      const v = {
        x: u,
        y: d,
        innerRadius: 0,
        outerRadius: x,
        startAngle: A,
        endAngle: w,
        options: this.resolveDataElementOptions(p, m.active ? "active" : i)
      };
      this.updateElement(m, p, v, i);
    }
  }
  countVisibleElements() {
    const t = this._cachedMeta;
    let n = 0;
    return t.data.forEach((s, i) => {
      !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && n++;
    }), n;
  }
  _computeAngle(t, n, s) {
    return this.chart.getDataVisibility(t) ? Ie(this.resolveDataElementOptions(t, n).angle || s) : 0;
  }
}
L(Xi, "id", "polarArea"), L(Xi, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), L(Xi, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(t) {
          const n = t.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: s, color: i } } = t.legend.options;
            return n.labels.map((r, o) => {
              const l = t.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: r,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: i,
                lineWidth: l.borderWidth,
                pointStyle: s,
                hidden: !t.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(t, n, s) {
        s.chart.toggleDataVisibility(n.index), s.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class jc extends ms {
}
L(jc, "id", "pie"), L(jc, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class Oo extends Oe {
  getLabelAndValue(t) {
    const n = this._cachedMeta.vScale, s = this.getParsed(t);
    return {
      label: n.getLabels()[t],
      value: "" + n.getLabelForValue(s[n.axis])
    };
  }
  parseObjectData(t, n, s, i) {
    return Jw.bind(this)(t, n, s, i);
  }
  update(t) {
    const n = this._cachedMeta, s = n.dataset, i = n.data || [], r = n.iScale.getLabels();
    if (s.points = i, t !== "resize") {
      const o = this.resolveDatasetElementOptions(t);
      this.options.showLine || (o.borderWidth = 0);
      const a = {
        _loop: !0,
        _fullLoop: r.length === i.length,
        options: o
      };
      this.updateElement(s, void 0, a, t);
    }
    this.updateElements(i, 0, i.length, t);
  }
  updateElements(t, n, s, i) {
    const r = this._cachedMeta.rScale, o = i === "reset";
    for (let a = n; a < n + s; a++) {
      const l = t[a], c = this.resolveDataElementOptions(a, l.active ? "active" : i), u = r.getPointPositionForValue(a, this.getParsed(a).r), d = o ? r.xCenter : u.x, h = o ? r.yCenter : u.y, f = {
        x: d,
        y: h,
        angle: u.angle,
        skip: isNaN(d) || isNaN(h),
        options: c
      };
      this.updateElement(l, a, f, i);
    }
  }
}
L(Oo, "id", "radar"), L(Oo, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), L(Oo, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class No extends Oe {
  getLabelAndValue(t) {
    const n = this._cachedMeta, s = this.chart.data.labels || [], { xScale: i, yScale: r } = n, o = this.getParsed(t), a = i.getLabelForValue(o.x), l = r.getLabelForValue(o.y);
    return {
      label: s[t] || "",
      value: "(" + a + ", " + l + ")"
    };
  }
  update(t) {
    const n = this._cachedMeta, { data: s = [] } = n, i = this.chart._animationsDisabled;
    let { start: r, count: o } = Yw(n, s, i);
    if (this._drawStart = r, this._drawCount = o, Ww(n) && (r = 0, o = s.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: a, _dataset: l } = n;
      a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;
      const c = this.resolveDatasetElementOptions(t);
      c.segment = this.options.segment, this.updateElement(a, void 0, {
        animated: !i,
        options: c
      }, t);
    } else this.datasetElementType && (delete n.dataset, this.datasetElementType = !1);
    this.updateElements(s, r, o, t);
  }
  addElements() {
    const { showLine: t } = this.options;
    !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(t, n, s, i) {
    const r = i === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, u = this.resolveDataElementOptions(n, i), d = this.getSharedOptions(u), h = this.includeOptions(i, d), f = o.axis, p = a.axis, { spanGaps: g, segment: m } = this.options, A = ai(g) ? g : Number.POSITIVE_INFINITY, w = this.chart._animationsDisabled || r || i === "none";
    let x = n > 0 && this.getParsed(n - 1);
    for (let v = n; v < n + s; ++v) {
      const C = t[v], E = this.getParsed(v), S = w ? C : {}, M = ot(E[p]), q = S[f] = o.getPixelForValue(E[f], v), k = S[p] = r || M ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, E, l) : E[p], v);
      S.skip = isNaN(q) || isNaN(k) || M, S.stop = v > 0 && Math.abs(E[f] - x[f]) > A, m && (S.parsed = E, S.raw = c.data[v]), h && (S.options = d || this.resolveDataElementOptions(v, C.active ? "active" : i)), w || this.updateElement(C, v, S, i), x = E;
    }
    this.updateSharedOptions(d, i, u);
  }
  getMaxOverflow() {
    const t = this._cachedMeta, n = t.data || [];
    if (!this.options.showLine) {
      let a = 0;
      for (let l = n.length - 1; l >= 0; --l)
        a = Math.max(a, n[l].size(this.resolveDataElementOptions(l)) / 2);
      return a > 0 && a;
    }
    const s = t.dataset, i = s.options && s.options.borderWidth || 0;
    if (!n.length)
      return i;
    const r = n[0].size(this.resolveDataElementOptions(0)), o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));
    return Math.max(i, r, o) / 2;
  }
}
L(No, "id", "scatter"), L(No, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), L(No, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var UI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: Bo,
  BubbleController: Io,
  DoughnutController: ms,
  LineController: Po,
  PieController: jc,
  PolarAreaController: Xi,
  RadarController: Oo,
  ScatterController: No
});
function cs() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Qd {
  constructor(t) {
    L(this, "options");
    this.options = t || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(Qd.prototype, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return cs();
  }
  parse() {
    return cs();
  }
  format() {
    return cs();
  }
  add() {
    return cs();
  }
  diff() {
    return cs();
  }
  startOf() {
    return cs();
  }
  endOf() {
    return cs();
  }
}
var YI = {
  _date: Qd
};
function WI(e, t, n, s) {
  const { controller: i, data: r, _sorted: o } = e, a = i._cachedMeta.iScale;
  if (a && t === a.axis && t !== "r" && o && r.length) {
    const l = a._reversePixels ? h2 : hn;
    if (s) {
      if (i._sharedOptions) {
        const c = r[0], u = typeof c.getRange == "function" && c.getRange(t);
        if (u) {
          const d = l(r, t, n - u), h = l(r, t, n + u);
          return {
            lo: d.lo,
            hi: h.hi
          };
        }
      }
    } else return l(r, t, n);
  }
  return {
    lo: 0,
    hi: r.length - 1
  };
}
function jr(e, t, n, s, i) {
  const r = e.getSortedVisibleDatasetMetas(), o = n[t];
  for (let a = 0, l = r.length; a < l; ++a) {
    const { index: c, data: u } = r[a], { lo: d, hi: h } = WI(r[a], t, o, i);
    for (let f = d; f <= h; ++f) {
      const p = u[f];
      p.skip || s(p, c, f);
    }
  }
}
function QI(e) {
  const t = e.indexOf("x") !== -1, n = e.indexOf("y") !== -1;
  return function(s, i) {
    const r = t ? Math.abs(s.x - i.x) : 0, o = n ? Math.abs(s.y - i.y) : 0;
    return Math.sqrt(Math.pow(r, 2) + Math.pow(o, 2));
  };
}
function Vl(e, t, n, s, i) {
  const r = [];
  return !i && !e.isPointInArea(t) || jr(e, n, t, function(a, l, c) {
    !i && !fn(a, e.chartArea, 0) || a.inRange(t.x, t.y, s) && r.push({
      element: a,
      datasetIndex: l,
      index: c
    });
  }, !0), r;
}
function GI(e, t, n, s) {
  let i = [];
  function r(o, a, l) {
    const { startAngle: c, endAngle: u } = o.getProps([
      "startAngle",
      "endAngle"
    ], s), { angle: d } = Lw(o, {
      x: t.x,
      y: t.y
    });
    Cr(d, c, u) && i.push({
      element: o,
      datasetIndex: a,
      index: l
    });
  }
  return jr(e, n, t, r), i;
}
function KI(e, t, n, s, i, r) {
  let o = [];
  const a = QI(n);
  let l = Number.POSITIVE_INFINITY;
  function c(u, d, h) {
    const f = u.inRange(t.x, t.y, i);
    if (s && !f)
      return;
    const p = u.getCenterPoint(i);
    if (!(!!r || e.isPointInArea(p)) && !f)
      return;
    const m = a(t, p);
    m < l ? (o = [
      {
        element: u,
        datasetIndex: d,
        index: h
      }
    ], l = m) : m === l && o.push({
      element: u,
      datasetIndex: d,
      index: h
    });
  }
  return jr(e, n, t, c), o;
}
function Ul(e, t, n, s, i, r) {
  return !r && !e.isPointInArea(t) ? [] : n === "r" && !s ? GI(e, t, n, i) : KI(e, t, n, s, i, r);
}
function Fp(e, t, n, s, i) {
  const r = [], o = n === "x" ? "inXRange" : "inYRange";
  let a = !1;
  return jr(e, n, t, (l, c, u) => {
    l[o] && l[o](t[n], i) && (r.push({
      element: l,
      datasetIndex: c,
      index: u
    }), a = a || l.inRange(t.x, t.y, i));
  }), s && !a ? [] : r;
}
var zI = {
  evaluateInteractionItems: jr,
  modes: {
    index(e, t, n, s) {
      const i = fs(t, e), r = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? Vl(e, i, r, s, o) : Ul(e, i, r, !1, s, o), l = [];
      return a.length ? (e.getSortedVisibleDatasetMetas().forEach((c) => {
        const u = a[0].index, d = c.data[u];
        d && !d.skip && l.push({
          element: d,
          datasetIndex: c.index,
          index: u
        });
      }), l) : [];
    },
    dataset(e, t, n, s) {
      const i = fs(t, e), r = n.axis || "xy", o = n.includeInvisible || !1;
      let a = n.intersect ? Vl(e, i, r, s, o) : Ul(e, i, r, !1, s, o);
      if (a.length > 0) {
        const l = a[0].datasetIndex, c = e.getDatasetMeta(l).data;
        a = [];
        for (let u = 0; u < c.length; ++u)
          a.push({
            element: c[u],
            datasetIndex: l,
            index: u
          });
      }
      return a;
    },
    point(e, t, n, s) {
      const i = fs(t, e), r = n.axis || "xy", o = n.includeInvisible || !1;
      return Vl(e, i, r, s, o);
    },
    nearest(e, t, n, s) {
      const i = fs(t, e), r = n.axis || "xy", o = n.includeInvisible || !1;
      return Ul(e, i, r, n.intersect, s, o);
    },
    x(e, t, n, s) {
      const i = fs(t, e);
      return Fp(e, i, "x", n.intersect, s);
    },
    y(e, t, n, s) {
      const i = fs(t, e);
      return Fp(e, i, "y", n.intersect, s);
    }
  }
};
const ab = [
  "left",
  "top",
  "right",
  "bottom"
];
function ki(e, t) {
  return e.filter((n) => n.pos === t);
}
function jp(e, t) {
  return e.filter((n) => ab.indexOf(n.pos) === -1 && n.box.axis === t);
}
function Ti(e, t) {
  return e.sort((n, s) => {
    const i = t ? s : n, r = t ? n : s;
    return i.weight === r.weight ? i.index - r.index : i.weight - r.weight;
  });
}
function _I(e) {
  const t = [];
  let n, s, i, r, o, a;
  for (n = 0, s = (e || []).length; n < s; ++n)
    i = e[n], { position: r, options: { stack: o, stackWeight: a = 1 } } = i, t.push({
      index: n,
      box: i,
      pos: r,
      horizontal: i.isHorizontal(),
      weight: i.weight,
      stack: o && r + o,
      stackWeight: a
    });
  return t;
}
function ZI(e) {
  const t = {};
  for (const n of e) {
    const { stack: s, pos: i, stackWeight: r } = n;
    if (!s || !ab.includes(i))
      continue;
    const o = t[s] || (t[s] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    o.count++, o.weight += r;
  }
  return t;
}
function HI(e, t) {
  const n = ZI(e), { vBoxMaxWidth: s, hBoxMaxHeight: i } = t;
  let r, o, a;
  for (r = 0, o = e.length; r < o; ++r) {
    a = e[r];
    const { fullSize: l } = a.box, c = n[a.stack], u = c && a.stackWeight / c.weight;
    a.horizontal ? (a.width = u ? u * s : l && t.availableWidth, a.height = i) : (a.width = s, a.height = u ? u * i : l && t.availableHeight);
  }
  return n;
}
function JI(e) {
  const t = _I(e), n = Ti(t.filter((c) => c.box.fullSize), !0), s = Ti(ki(t, "left"), !0), i = Ti(ki(t, "right")), r = Ti(ki(t, "top"), !0), o = Ti(ki(t, "bottom")), a = jp(t, "x"), l = jp(t, "y");
  return {
    fullSize: n,
    leftAndTop: s.concat(r),
    rightAndBottom: i.concat(l).concat(o).concat(a),
    chartArea: ki(t, "chartArea"),
    vertical: s.concat(i).concat(l),
    horizontal: r.concat(o).concat(a)
  };
}
function Vp(e, t, n, s) {
  return Math.max(e[n], t[n]) + Math.max(e[s], t[s]);
}
function lb(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function XI(e, t, n, s) {
  const { pos: i, box: r } = n, o = e.maxPadding;
  if (!it(i)) {
    n.size && (e[i] -= n.size);
    const d = s[n.stack] || {
      size: 0,
      count: 1
    };
    d.size = Math.max(d.size, n.horizontal ? r.height : r.width), n.size = d.size / d.count, e[i] += n.size;
  }
  r.getPadding && lb(o, r.getPadding());
  const a = Math.max(0, t.outerWidth - Vp(o, e, "left", "right")), l = Math.max(0, t.outerHeight - Vp(o, e, "top", "bottom")), c = a !== e.w, u = l !== e.h;
  return e.w = a, e.h = l, n.horizontal ? {
    same: c,
    other: u
  } : {
    same: u,
    other: c
  };
}
function $I(e) {
  const t = e.maxPadding;
  function n(s) {
    const i = Math.max(t[s] - e[s], 0);
    return e[s] += i, i;
  }
  e.y += n("top"), e.x += n("left"), n("right"), n("bottom");
}
function tP(e, t) {
  const n = t.maxPadding;
  function s(i) {
    const r = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return i.forEach((o) => {
      r[o] = Math.max(t[o], n[o]);
    }), r;
  }
  return s(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Vi(e, t, n, s) {
  const i = [];
  let r, o, a, l, c, u;
  for (r = 0, o = e.length, c = 0; r < o; ++r) {
    a = e[r], l = a.box, l.update(a.width || t.w, a.height || t.h, tP(a.horizontal, t));
    const { same: d, other: h } = XI(t, n, a, s);
    c |= d && i.length, u = u || h, l.fullSize || i.push(a);
  }
  return c && Vi(i, t, n, s) || u;
}
function po(e, t, n, s, i) {
  e.top = n, e.left = t, e.right = t + s, e.bottom = n + i, e.width = s, e.height = i;
}
function Up(e, t, n, s) {
  const i = n.padding;
  let { x: r, y: o } = t;
  for (const a of e) {
    const l = a.box, c = s[a.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    }, u = a.stackWeight / c.weight || 1;
    if (a.horizontal) {
      const d = t.w * u, h = c.size || l.height;
      vr(c.start) && (o = c.start), l.fullSize ? po(l, i.left, o, n.outerWidth - i.right - i.left, h) : po(l, t.left + c.placed, o, d, h), c.start = o, c.placed += d, o = l.bottom;
    } else {
      const d = t.h * u, h = c.size || l.width;
      vr(c.start) && (r = c.start), l.fullSize ? po(l, r, i.top, h, n.outerHeight - i.bottom - i.top) : po(l, r, t.top + c.placed, h, d), c.start = r, c.placed += d, r = l.right;
    }
  }
  t.x = r, t.y = o;
}
var Ht = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            t.draw(n);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const n = e.boxes ? e.boxes.indexOf(t) : -1;
    n !== -1 && e.boxes.splice(n, 1);
  },
  configure(e, t, n) {
    t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight;
  },
  update(e, t, n, s) {
    if (!e)
      return;
    const i = $t(e.options.layout.padding), r = Math.max(t - i.width, 0), o = Math.max(n - i.height, 0), a = JI(e.boxes), l = a.vertical, c = a.horizontal;
    dt(e.boxes, (g) => {
      typeof g.beforeLayout == "function" && g.beforeLayout();
    });
    const u = l.reduce((g, m) => m.box.options && m.box.options.display === !1 ? g : g + 1, 0) || 1, d = Object.freeze({
      outerWidth: t,
      outerHeight: n,
      padding: i,
      availableWidth: r,
      availableHeight: o,
      vBoxMaxWidth: r / 2 / u,
      hBoxMaxHeight: o / 2
    }), h = Object.assign({}, i);
    lb(h, $t(s));
    const f = Object.assign({
      maxPadding: h,
      w: r,
      h: o,
      x: i.left,
      y: i.top
    }, i), p = HI(l.concat(c), d);
    Vi(a.fullSize, f, d, p), Vi(l, f, d, p), Vi(c, f, d, p) && Vi(l, f, d, p), $I(f), Up(a.leftAndTop, f, d, p), f.x += f.w, f.y += f.h, Up(a.rightAndBottom, f, d, p), e.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, dt(a.chartArea, (g) => {
      const m = g.box;
      Object.assign(m, e.chartArea), m.update(f.w, f.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class cb {
  acquireContext(t, n) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, n, s) {
  }
  removeEventListener(t, n, s) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, n, s, i) {
    return n = Math.max(0, n || t.width), s = s || t.height, {
      width: n,
      height: Math.max(0, i ? Math.floor(n / i) : s)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class eP extends cb {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const Lo = "$chartjs", nP = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Yp = (e) => e === null || e === "";
function sP(e, t) {
  const n = e.style, s = e.getAttribute("height"), i = e.getAttribute("width");
  if (e[Lo] = {
    initial: {
      height: s,
      width: i,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", Yp(i)) {
    const r = Sp(e, "width");
    r !== void 0 && (e.width = r);
  }
  if (Yp(s))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const r = Sp(e, "height");
      r !== void 0 && (e.height = r);
    }
  return e;
}
const ub = rI ? {
  passive: !0
} : !1;
function iP(e, t, n) {
  e && e.addEventListener(t, n, ub);
}
function rP(e, t, n) {
  e && e.canvas && e.canvas.removeEventListener(t, n, ub);
}
function oP(e, t) {
  const n = nP[e.type] || e.type, { x: s, y: i } = fs(e, t);
  return {
    type: n,
    chart: t,
    native: e,
    x: s !== void 0 ? s : null,
    y: i !== void 0 ? i : null
  };
}
function Aa(e, t) {
  for (const n of e)
    if (n === t || n.contains(t))
      return !0;
}
function aP(e, t, n) {
  const s = e.canvas, i = new MutationObserver((r) => {
    let o = !1;
    for (const a of r)
      o = o || Aa(a.addedNodes, s), o = o && !Aa(a.removedNodes, s);
    o && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
function lP(e, t, n) {
  const s = e.canvas, i = new MutationObserver((r) => {
    let o = !1;
    for (const a of r)
      o = o || Aa(a.removedNodes, s), o = o && !Aa(a.addedNodes, s);
    o && n();
  });
  return i.observe(document, {
    childList: !0,
    subtree: !0
  }), i;
}
const Mr = /* @__PURE__ */ new Map();
let Wp = 0;
function db() {
  const e = window.devicePixelRatio;
  e !== Wp && (Wp = e, Mr.forEach((t, n) => {
    n.currentDevicePixelRatio !== e && t();
  }));
}
function cP(e, t) {
  Mr.size || window.addEventListener("resize", db), Mr.set(e, t);
}
function uP(e) {
  Mr.delete(e), Mr.size || window.removeEventListener("resize", db);
}
function dP(e, t, n) {
  const s = e.canvas, i = s && Wd(s);
  if (!i)
    return;
  const r = Uw((a, l) => {
    const c = i.clientWidth;
    n(a, l), c < i.clientWidth && n();
  }, window), o = new ResizeObserver((a) => {
    const l = a[0], c = l.contentRect.width, u = l.contentRect.height;
    c === 0 && u === 0 || r(c, u);
  });
  return o.observe(i), cP(e, r), o;
}
function Yl(e, t, n) {
  n && n.disconnect(), t === "resize" && uP(e);
}
function hP(e, t, n) {
  const s = e.canvas, i = Uw((r) => {
    e.ctx !== null && n(oP(r, e));
  }, e);
  return iP(s, t, i), i;
}
class fP extends cb {
  acquireContext(t, n) {
    const s = t && t.getContext && t.getContext("2d");
    return s && s.canvas === t ? (sP(t, n), s) : null;
  }
  releaseContext(t) {
    const n = t.canvas;
    if (!n[Lo])
      return !1;
    const s = n[Lo].initial;
    [
      "height",
      "width"
    ].forEach((r) => {
      const o = s[r];
      ot(o) ? n.removeAttribute(r) : n.setAttribute(r, o);
    });
    const i = s.style || {};
    return Object.keys(i).forEach((r) => {
      n.style[r] = i[r];
    }), n.width = n.width, delete n[Lo], !0;
  }
  addEventListener(t, n, s) {
    this.removeEventListener(t, n);
    const i = t.$proxies || (t.$proxies = {}), o = {
      attach: aP,
      detach: lP,
      resize: dP
    }[n] || hP;
    i[n] = o(t, n, s);
  }
  removeEventListener(t, n) {
    const s = t.$proxies || (t.$proxies = {}), i = s[n];
    if (!i)
      return;
    ({
      attach: Yl,
      detach: Yl,
      resize: Yl
    }[n] || rP)(t, n, i), s[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, n, s, i) {
    return iI(t, n, s, i);
  }
  isAttached(t) {
    const n = t && Wd(t);
    return !!(n && n.isConnected);
  }
}
function pP(e) {
  return !Yd() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? eP : fP;
}
var vo;
let vn = (vo = class {
  constructor() {
    L(this, "x");
    L(this, "y");
    L(this, "active", !1);
    L(this, "options");
    L(this, "$animations");
  }
  tooltipPosition(t) {
    const { x: n, y: s } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: s
    };
  }
  hasValue() {
    return ai(this.x) && ai(this.y);
  }
  getProps(t, n) {
    const s = this.$animations;
    if (!n || !s)
      return this;
    const i = {};
    return t.forEach((r) => {
      i[r] = s[r] && s[r].active() ? s[r]._to : this[r];
    }), i;
  }
}, L(vo, "defaults", {}), L(vo, "defaultRoutes"), vo);
function gP(e, t) {
  const n = e.options.ticks, s = mP(e), i = Math.min(n.maxTicksLimit || s, s), r = n.major.enabled ? yP(t) : [], o = r.length, a = r[0], l = r[o - 1], c = [];
  if (o > i)
    return wP(t, c, r, o / i), c;
  const u = AP(r, t, i);
  if (o > 0) {
    let d, h;
    const f = o > 1 ? Math.round((l - a) / (o - 1)) : null;
    for (go(t, c, u, ot(f) ? 0 : a - f, a), d = 0, h = o - 1; d < h; d++)
      go(t, c, u, r[d], r[d + 1]);
    return go(t, c, u, l, ot(f) ? t.length : l + f), c;
  }
  return go(t, c, u), c;
}
function mP(e) {
  const t = e.options.offset, n = e._tickSize(), s = e._length / n + (t ? 0 : 1), i = e._maxLength / n;
  return Math.floor(Math.min(s, i));
}
function AP(e, t, n) {
  const s = bP(e), i = t.length / n;
  if (!s)
    return Math.max(i, 1);
  const r = l2(s);
  for (let o = 0, a = r.length - 1; o < a; o++) {
    const l = r[o];
    if (l > i)
      return l;
  }
  return Math.max(i, 1);
}
function yP(e) {
  const t = [];
  let n, s;
  for (n = 0, s = e.length; n < s; n++)
    e[n].major && t.push(n);
  return t;
}
function wP(e, t, n, s) {
  let i = 0, r = n[0], o;
  for (s = Math.ceil(s), o = 0; o < e.length; o++)
    o === r && (t.push(e[o]), i++, r = n[i * s]);
}
function go(e, t, n, s, i) {
  const r = $(s, 0), o = Math.min($(i, e.length), e.length);
  let a = 0, l, c, u;
  for (n = Math.ceil(n), i && (l = i - s, n = l / Math.floor(l / n)), u = r; u < 0; )
    a++, u = Math.round(r + a * n);
  for (c = Math.max(r, 0); c < o; c++)
    c === u && (t.push(e[c]), a++, u = Math.round(r + a * n));
}
function bP(e) {
  const t = e.length;
  let n, s;
  if (t < 2)
    return !1;
  for (s = e[0], n = 1; n < t; ++n)
    if (e[n] - e[n - 1] !== s)
      return !1;
  return s;
}
const xP = (e) => e === "left" ? "right" : e === "right" ? "left" : e, Qp = (e, t, n) => t === "top" || t === "left" ? e[t] + n : e[t] - n, Gp = (e, t) => Math.min(t || e, e);
function Kp(e, t) {
  const n = [], s = e.length / t, i = e.length;
  let r = 0;
  for (; r < i; r += s)
    n.push(e[Math.floor(r)]);
  return n;
}
function vP(e, t, n) {
  const s = e.ticks.length, i = Math.min(t, s - 1), r = e._startPixel, o = e._endPixel, a = 1e-6;
  let l = e.getPixelForTick(i), c;
  if (!(n && (s === 1 ? c = Math.max(l - r, o - l) : t === 0 ? c = (e.getPixelForTick(1) - l) / 2 : c = (l - e.getPixelForTick(i - 1)) / 2, l += i < t ? c : -c, l < r - a || l > o + a)))
    return l;
}
function CP(e, t) {
  dt(e, (n) => {
    const s = n.gc, i = s.length / 2;
    let r;
    if (i > t) {
      for (r = 0; r < i; ++r)
        delete n.data[s[r]];
      s.splice(0, i);
    }
  });
}
function Di(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function zp(e, t) {
  if (!e.display)
    return 0;
  const n = Ft(e.font, t), s = $t(e.padding);
  return (St(e.text) ? e.text.length : 1) * n.lineHeight + s.height;
}
function SP(e, t) {
  return es(e, {
    scale: t,
    type: "scale"
  });
}
function MP(e, t, n) {
  return es(e, {
    tick: n,
    index: t,
    type: "tick"
  });
}
function EP(e, t, n) {
  let s = Nd(e);
  return (n && t !== "right" || !n && t === "right") && (s = xP(s)), s;
}
function qP(e, t, n, s) {
  const { top: i, left: r, bottom: o, right: a, chart: l } = e, { chartArea: c, scales: u } = l;
  let d = 0, h, f, p;
  const g = o - i, m = a - r;
  if (e.isHorizontal()) {
    if (f = zt(s, r, a), it(n)) {
      const A = Object.keys(n)[0], w = n[A];
      p = u[A].getPixelForValue(w) + g - t;
    } else n === "center" ? p = (c.bottom + c.top) / 2 + g - t : p = Qp(e, n, t);
    h = a - r;
  } else {
    if (it(n)) {
      const A = Object.keys(n)[0], w = n[A];
      f = u[A].getPixelForValue(w) - m + t;
    } else n === "center" ? f = (c.left + c.right) / 2 - m + t : f = Qp(e, n, t);
    p = zt(s, o, i), d = n === "left" ? -It : It;
  }
  return {
    titleX: f,
    titleY: p,
    maxWidth: h,
    rotation: d
  };
}
class Ds extends vn {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, n) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: n, _suggestedMin: s, _suggestedMax: i } = this;
    return t = me(t, Number.POSITIVE_INFINITY), n = me(n, Number.NEGATIVE_INFINITY), s = me(s, Number.POSITIVE_INFINITY), i = me(i, Number.NEGATIVE_INFINITY), {
      min: me(t, s),
      max: me(n, i),
      minDefined: Tt(t),
      maxDefined: Tt(n)
    };
  }
  getMinMax(t) {
    let { min: n, max: s, minDefined: i, maxDefined: r } = this.getUserBounds(), o;
    if (i && r)
      return {
        min: n,
        max: s
      };
    const a = this.getMatchingVisibleMetas();
    for (let l = 0, c = a.length; l < c; ++l)
      o = a[l].controller.getMinMax(this, t), i || (n = Math.min(n, o.min)), r || (s = Math.max(s, o.max));
    return n = r && n > s ? s : n, s = i && n > s ? n : s, {
      min: me(n, me(s, n)),
      max: me(s, me(n, s))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    mt(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, n, s) {
    const { beginAtZero: i, grace: r, ticks: o } = this.options, a = o.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = n, this._margins = s = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = N2(this, r, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = a < this.ticks.length;
    this._convertTicksToLabels(l ? Kp(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = gP(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, n, s;
    this.isHorizontal() ? (n = this.left, s = this.right) : (n = this.top, s = this.bottom, t = !t), this._startPixel = n, this._endPixel = s, this._reversePixels = t, this._length = s - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    mt(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    mt(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    mt(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), mt(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    mt(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const n = this.options.ticks;
    let s, i, r;
    for (s = 0, i = t.length; s < i; s++)
      r = t[s], r.label = mt(n.callback, [
        r.value,
        s,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    mt(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    mt(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, n = t.ticks, s = Gp(this.ticks.length, t.ticks.maxTicksLimit), i = n.minRotation || 0, r = n.maxRotation;
    let o = i, a, l, c;
    if (!this._isVisible() || !n.display || i >= r || s <= 1 || !this.isHorizontal()) {
      this.labelRotation = i;
      return;
    }
    const u = this._getLabelSizes(), d = u.widest.width, h = u.highest.height, f = jt(this.chart.width - d, 0, this.maxWidth);
    a = t.offset ? this.maxWidth / s : f / (s - 1), d + 6 > a && (a = f / (s - (t.offset ? 0.5 : 1)), l = this.maxHeight - Di(t.grid) - n.padding - zp(t.title, this.chart.options.font), c = Math.sqrt(d * d + h * h), o = Pd(Math.min(Math.asin(jt((u.highest.height + 6) / a, -1, 1)), Math.asin(jt(l / c, -1, 1)) - Math.asin(jt(h / c, -1, 1)))), o = Math.max(i, Math.min(r, o))), this.labelRotation = o;
  }
  afterCalculateLabelRotation() {
    mt(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    mt(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: s, title: i, grid: r } } = this, o = this._isVisible(), a = this.isHorizontal();
    if (o) {
      const l = zp(i, n.options.font);
      if (a ? (t.width = this.maxWidth, t.height = Di(r) + l) : (t.height = this.maxHeight, t.width = Di(r) + l), s.display && this.ticks.length) {
        const { first: c, last: u, widest: d, highest: h } = this._getLabelSizes(), f = s.padding * 2, p = Ie(this.labelRotation), g = Math.cos(p), m = Math.sin(p);
        if (a) {
          const A = s.mirror ? 0 : m * d.width + g * h.height;
          t.height = Math.min(this.maxHeight, t.height + A + f);
        } else {
          const A = s.mirror ? 0 : g * d.width + m * h.height;
          t.width = Math.min(this.maxWidth, t.width + A + f);
        }
        this._calculatePadding(c, u, m, g);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, n, s, i) {
    const { ticks: { align: r, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let h = 0, f = 0;
      l ? c ? (h = i * t.width, f = s * n.height) : (h = s * t.height, f = i * n.width) : r === "start" ? f = n.width : r === "end" ? h = t.width : r !== "inner" && (h = t.width / 2, f = n.width / 2), this.paddingLeft = Math.max((h - u + o) * this.width / (this.width - u), 0), this.paddingRight = Math.max((f - d + o) * this.width / (this.width - d), 0);
    } else {
      let u = n.height / 2, d = t.height / 2;
      r === "start" ? (u = 0, d = t.height) : r === "end" && (u = n.height, d = 0), this.paddingTop = u + o, this.paddingBottom = d + o;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    mt(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: n } = this.options;
    return n === "top" || n === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let n, s;
    for (n = 0, s = t.length; n < s; n++)
      ot(t[n].label) && (t.splice(n, 1), s--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const n = this.options.ticks.sampleSize;
      let s = this.ticks;
      n < s.length && (s = Kp(s, n)), this._labelSizes = t = this._computeLabelSizes(s, s.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, n, s) {
    const { ctx: i, _longestTextCache: r } = this, o = [], a = [], l = Math.floor(n / Gp(n, s));
    let c = 0, u = 0, d, h, f, p, g, m, A, w, x, v, C;
    for (d = 0; d < n; d += l) {
      if (p = t[d].label, g = this._resolveTickFontOptions(d), i.font = m = g.string, A = r[m] = r[m] || {
        data: {},
        gc: []
      }, w = g.lineHeight, x = v = 0, !ot(p) && !St(p))
        x = ga(i, A.data, A.gc, x, p), v = w;
      else if (St(p))
        for (h = 0, f = p.length; h < f; ++h)
          C = p[h], !ot(C) && !St(C) && (x = ga(i, A.data, A.gc, x, C), v += w);
      o.push(x), a.push(v), c = Math.max(x, c), u = Math.max(v, u);
    }
    CP(r, n);
    const E = o.indexOf(c), S = a.indexOf(u), M = (q) => ({
      width: o[q] || 0,
      height: a[q] || 0
    });
    return {
      first: M(0),
      last: M(n - 1),
      widest: M(E),
      highest: M(S),
      widths: o,
      heights: a
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, n) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const n = this._startPixel + t * this._length;
    return d2(this._alignToPixels ? ls(this.chart, n, 0) : n);
  }
  getDecimalForPixel(t) {
    const n = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: n } = this;
    return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0;
  }
  getContext(t) {
    const n = this.ticks || [];
    if (t >= 0 && t < n.length) {
      const s = n[t];
      return s.$context || (s.$context = MP(this.getContext(), t, s));
    }
    return this.$context || (this.$context = SP(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, n = Ie(this.labelRotation), s = Math.abs(Math.cos(n)), i = Math.abs(Math.sin(n)), r = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = r ? r.widest.width + o : 0, l = r ? r.highest.height + o : 0;
    return this.isHorizontal() ? l * s > a * i ? a / s : l / i : l * i < a * s ? l / s : a / i;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const n = this.axis, s = this.chart, i = this.options, { grid: r, position: o, border: a } = i, l = r.offset, c = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), h = Di(r), f = [], p = a.setContext(this.getContext()), g = p.display ? p.width : 0, m = g / 2, A = function(U) {
      return ls(s, U, g);
    };
    let w, x, v, C, E, S, M, q, k, R, D, j;
    if (o === "top")
      w = A(this.bottom), S = this.bottom - h, q = w - m, R = A(t.top) + m, j = t.bottom;
    else if (o === "bottom")
      w = A(this.top), R = t.top, j = A(t.bottom) - m, S = w + m, q = this.top + h;
    else if (o === "left")
      w = A(this.right), E = this.right - h, M = w - m, k = A(t.left) + m, D = t.right;
    else if (o === "right")
      w = A(this.left), k = t.left, D = A(t.right) - m, E = w + m, M = this.left + h;
    else if (n === "x") {
      if (o === "center")
        w = A((t.top + t.bottom) / 2 + 0.5);
      else if (it(o)) {
        const U = Object.keys(o)[0], I = o[U];
        w = A(this.chart.scales[U].getPixelForValue(I));
      }
      R = t.top, j = t.bottom, S = w + m, q = S + h;
    } else if (n === "y") {
      if (o === "center")
        w = A((t.left + t.right) / 2);
      else if (it(o)) {
        const U = Object.keys(o)[0], I = o[U];
        w = A(this.chart.scales[U].getPixelForValue(I));
      }
      E = w - m, M = E - h, k = t.left, D = t.right;
    }
    const W = $(i.ticks.maxTicksLimit, d), O = Math.max(1, Math.ceil(d / W));
    for (x = 0; x < d; x += O) {
      const U = this.getContext(x), I = r.setContext(U), F = a.setContext(U), Q = I.lineWidth, J = I.color, lt = F.dash || [], Vt = F.dashOffset, Pt = I.tickWidth, kt = I.tickColor, Ut = I.tickBorderDash || [], gt = I.tickBorderDashOffset;
      v = vP(this, x, l), v !== void 0 && (C = ls(s, v, Q), c ? E = M = k = D = C : S = q = R = j = C, f.push({
        tx1: E,
        ty1: S,
        tx2: M,
        ty2: q,
        x1: k,
        y1: R,
        x2: D,
        y2: j,
        width: Q,
        color: J,
        borderDash: lt,
        borderDashOffset: Vt,
        tickWidth: Pt,
        tickColor: kt,
        tickBorderDash: Ut,
        tickBorderDashOffset: gt
      }));
    }
    return this._ticksLength = d, this._borderValue = w, f;
  }
  _computeLabelItems(t) {
    const n = this.axis, s = this.options, { position: i, ticks: r } = s, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: d } = r, h = Di(s.grid), f = h + u, p = d ? -u : f, g = -Ie(this.labelRotation), m = [];
    let A, w, x, v, C, E, S, M, q, k, R, D, j = "middle";
    if (i === "top")
      E = this.bottom - p, S = this._getXAxisLabelAlignment();
    else if (i === "bottom")
      E = this.top + p, S = this._getXAxisLabelAlignment();
    else if (i === "left") {
      const O = this._getYAxisLabelAlignment(h);
      S = O.textAlign, C = O.x;
    } else if (i === "right") {
      const O = this._getYAxisLabelAlignment(h);
      S = O.textAlign, C = O.x;
    } else if (n === "x") {
      if (i === "center")
        E = (t.top + t.bottom) / 2 + f;
      else if (it(i)) {
        const O = Object.keys(i)[0], U = i[O];
        E = this.chart.scales[O].getPixelForValue(U) + f;
      }
      S = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (i === "center")
        C = (t.left + t.right) / 2 - f;
      else if (it(i)) {
        const O = Object.keys(i)[0], U = i[O];
        C = this.chart.scales[O].getPixelForValue(U);
      }
      S = this._getYAxisLabelAlignment(h).textAlign;
    }
    n === "y" && (l === "start" ? j = "top" : l === "end" && (j = "bottom"));
    const W = this._getLabelSizes();
    for (A = 0, w = a.length; A < w; ++A) {
      x = a[A], v = x.label;
      const O = r.setContext(this.getContext(A));
      M = this.getPixelForTick(A) + r.labelOffset, q = this._resolveTickFontOptions(A), k = q.lineHeight, R = St(v) ? v.length : 1;
      const U = R / 2, I = O.color, F = O.textStrokeColor, Q = O.textStrokeWidth;
      let J = S;
      o ? (C = M, S === "inner" && (A === w - 1 ? J = this.options.reverse ? "left" : "right" : A === 0 ? J = this.options.reverse ? "right" : "left" : J = "center"), i === "top" ? c === "near" || g !== 0 ? D = -R * k + k / 2 : c === "center" ? D = -W.highest.height / 2 - U * k + k : D = -W.highest.height + k / 2 : c === "near" || g !== 0 ? D = k / 2 : c === "center" ? D = W.highest.height / 2 - U * k : D = W.highest.height - R * k, d && (D *= -1), g !== 0 && !O.showLabelBackdrop && (C += k / 2 * Math.sin(g))) : (E = M, D = (1 - R) * k / 2);
      let lt;
      if (O.showLabelBackdrop) {
        const Vt = $t(O.backdropPadding), Pt = W.heights[A], kt = W.widths[A];
        let Ut = D - Vt.top, gt = 0 - Vt.left;
        switch (j) {
          case "middle":
            Ut -= Pt / 2;
            break;
          case "bottom":
            Ut -= Pt;
            break;
        }
        switch (S) {
          case "center":
            gt -= kt / 2;
            break;
          case "right":
            gt -= kt;
            break;
          case "inner":
            A === w - 1 ? gt -= kt : A > 0 && (gt -= kt / 2);
            break;
        }
        lt = {
          left: gt,
          top: Ut,
          width: kt + Vt.width,
          height: Pt + Vt.height,
          color: O.backdropColor
        };
      }
      m.push({
        label: v,
        font: q,
        textOffset: D,
        options: {
          rotation: g,
          color: I,
          strokeColor: F,
          strokeWidth: Q,
          textAlign: J,
          textBaseline: j,
          translation: [
            C,
            E
          ],
          backdrop: lt
        }
      });
    }
    return m;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: n } = this.options;
    if (-Ie(this.labelRotation))
      return t === "top" ? "left" : "right";
    let i = "center";
    return n.align === "start" ? i = "left" : n.align === "end" ? i = "right" : n.align === "inner" && (i = "inner"), i;
  }
  _getYAxisLabelAlignment(t) {
    const { position: n, ticks: { crossAlign: s, mirror: i, padding: r } } = this.options, o = this._getLabelSizes(), a = t + r, l = o.widest.width;
    let c, u;
    return n === "left" ? i ? (u = this.right + r, s === "near" ? c = "left" : s === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, s === "near" ? c = "right" : s === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : n === "right" ? i ? (u = this.left + r, s === "near" ? c = "right" : s === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, s === "near" ? c = "left" : s === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
      textAlign: c,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: n }, left: s, top: i, width: r, height: o } = this;
    n && (t.save(), t.fillStyle = n, t.fillRect(s, i, r, o), t.restore());
  }
  getLineWidthForValue(t) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const i = this.ticks.findIndex((r) => r.value === t);
    return i >= 0 ? n.setContext(this.getContext(i)).lineWidth : 0;
  }
  drawGrid(t) {
    const n = this.options.grid, s = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let r, o;
    const a = (l, c, u) => {
      !u.width || !u.color || (s.save(), s.lineWidth = u.width, s.strokeStyle = u.color, s.setLineDash(u.borderDash || []), s.lineDashOffset = u.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());
    };
    if (n.display)
      for (r = 0, o = i.length; r < o; ++r) {
        const l = i[r];
        n.drawOnChartArea && a({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), n.drawTicks && a({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: n, options: { border: s, grid: i } } = this, r = s.setContext(this.getContext()), o = s.display ? r.width : 0;
    if (!o)
      return;
    const a = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, u, d, h;
    this.isHorizontal() ? (c = ls(t, this.left, o) - o / 2, u = ls(t, this.right, a) + a / 2, d = h = l) : (d = ls(t, this.top, o) - o / 2, h = ls(t, this.bottom, a) + a / 2, c = u = l), n.save(), n.lineWidth = r.width, n.strokeStyle = r.color, n.beginPath(), n.moveTo(c, d), n.lineTo(u, h), n.stroke(), n.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const s = this.ctx, i = this._computeLabelArea();
    i && _a(s, i);
    const r = this.getLabelItems(t);
    for (const o of r) {
      const a = o.options, l = o.font, c = o.label, u = o.textOffset;
      Rs(s, c, 0, u, l, a);
    }
    i && Za(s);
  }
  drawTitle() {
    const { ctx: t, options: { position: n, title: s, reverse: i } } = this;
    if (!s.display)
      return;
    const r = Ft(s.font), o = $t(s.padding), a = s.align;
    let l = r.lineHeight / 2;
    n === "bottom" || n === "center" || it(n) ? (l += o.bottom, St(s.text) && (l += r.lineHeight * (s.text.length - 1))) : l += o.top;
    const { titleX: c, titleY: u, maxWidth: d, rotation: h } = qP(this, l, n, a);
    Rs(t, s.text, 0, 0, r, {
      color: s.color,
      maxWidth: d,
      rotation: h,
      textAlign: EP(a, n, i),
      textBaseline: "middle",
      translation: [
        c,
        u
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, n = t.ticks && t.ticks.z || 0, s = $(t.grid && t.grid.z, -1), i = $(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== Ds.prototype.draw ? [
      {
        z: n,
        draw: (r) => {
          this.draw(r);
        }
      }
    ] : [
      {
        z: s,
        draw: (r) => {
          this.drawBackground(), this.drawGrid(r), this.drawTitle();
        }
      },
      {
        z: i,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (r) => {
          this.drawLabels(r);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const n = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + "AxisID", i = [];
    let r, o;
    for (r = 0, o = n.length; r < o; ++r) {
      const a = n[r];
      a[s] === this.id && (!t || a.type === t) && i.push(a);
    }
    return i;
  }
  _resolveTickFontOptions(t) {
    const n = this.options.ticks.setContext(this.getContext(t));
    return Ft(n.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class mo {
  constructor(t, n, s) {
    this.type = t, this.scope = n, this.override = s, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const n = Object.getPrototypeOf(t);
    let s;
    TP(n) && (s = this.register(n));
    const i = this.items, r = t.id, o = this.scope + "." + r;
    if (!r)
      throw new Error("class does not have id: " + t);
    return r in i || (i[r] = t, RP(t, o, s), this.override && Dt.override(t.id, t.overrides)), o;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const n = this.items, s = t.id, i = this.scope;
    s in n && delete n[s], i && s in Dt[i] && (delete Dt[i][s], this.override && delete qs[s]);
  }
}
function RP(e, t, n) {
  const s = xr(/* @__PURE__ */ Object.create(null), [
    n ? Dt.get(n) : {},
    Dt.get(t),
    e.defaults
  ]);
  Dt.set(t, s), e.defaultRoutes && kP(t, e.defaultRoutes), e.descriptors && Dt.describe(t, e.descriptors);
}
function kP(e, t) {
  Object.keys(t).forEach((n) => {
    const s = n.split("."), i = s.pop(), r = [
      e
    ].concat(s).join("."), o = t[n].split("."), a = o.pop(), l = o.join(".");
    Dt.route(r, i, l, a);
  });
}
function TP(e) {
  return "id" in e && "defaults" in e;
}
class DP {
  constructor() {
    this.controllers = new mo(Oe, "datasets", !0), this.elements = new mo(vn, "elements"), this.plugins = new mo(Object, "plugins"), this.scales = new mo(Ds, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, n, s) {
    [
      ...n
    ].forEach((i) => {
      const r = s || this._getRegistryForType(i);
      s || r.isForType(i) || r === this.plugins && i.id ? this._exec(t, r, i) : dt(i, (o) => {
        const a = s || this._getRegistryForType(o);
        this._exec(t, a, o);
      });
    });
  }
  _exec(t, n, s) {
    const i = Id(t);
    mt(s["before" + i], [], s), n[t](s), mt(s["after" + i], [], s);
  }
  _getRegistryForType(t) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const s = this._typedRegistries[n];
      if (s.isForType(t))
        return s;
    }
    return this.plugins;
  }
  _get(t, n, s) {
    const i = n.get(t);
    if (i === void 0)
      throw new Error('"' + t + '" is not a registered ' + s + ".");
    return i;
  }
}
var We = /* @__PURE__ */ new DP();
class BP {
  constructor() {
    this._init = [];
  }
  notify(t, n, s, i) {
    n === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const r = i ? this._descriptors(t).filter(i) : this._descriptors(t), o = this._notify(r, t, n, s);
    return n === "afterDestroy" && (this._notify(r, t, "stop"), this._notify(this._init, t, "uninstall")), o;
  }
  _notify(t, n, s, i) {
    i = i || {};
    for (const r of t) {
      const o = r.plugin, a = o[s], l = [
        n,
        i,
        r.options
      ];
      if (mt(a, l, o) === !1 && i.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    ot(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), n;
  }
  _createDescriptors(t, n) {
    const s = t && t.config, i = $(s.options && s.options.plugins, {}), r = IP(s);
    return i === !1 && !n ? [] : OP(t, r, i, n);
  }
  _notifyStateChanges(t) {
    const n = this._oldCache || [], s = this._cache, i = (r, o) => r.filter((a) => !o.some((l) => a.plugin.id === l.plugin.id));
    this._notify(i(n, s), t, "stop"), this._notify(i(s, n), t, "start");
  }
}
function IP(e) {
  const t = {}, n = [], s = Object.keys(We.plugins.items);
  for (let r = 0; r < s.length; r++)
    n.push(We.getPlugin(s[r]));
  const i = e.plugins || [];
  for (let r = 0; r < i.length; r++) {
    const o = i[r];
    n.indexOf(o) === -1 && (n.push(o), t[o.id] = !0);
  }
  return {
    plugins: n,
    localIds: t
  };
}
function PP(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function OP(e, { plugins: t, localIds: n }, s, i) {
  const r = [], o = e.getContext();
  for (const a of t) {
    const l = a.id, c = PP(s[l], i);
    c !== null && r.push({
      plugin: a,
      options: NP(e.config, {
        plugin: a,
        local: n[l]
      }, c, o)
    });
  }
  return r;
}
function NP(e, { plugin: t, local: n }, s, i) {
  const r = e.pluginScopeKeys(t), o = e.getOptionScopes(s, r);
  return n && t.defaults && o.push(t.defaults), e.createResolver(o, i, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Vc(e, t) {
  const n = Dt.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x";
}
function LP(e, t) {
  let n = e;
  return e === "_index_" ? n = t : e === "_value_" && (n = t === "x" ? "y" : "x"), n;
}
function FP(e, t) {
  return e === t ? "_index_" : "_value_";
}
function _p(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function jP(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function Uc(e, ...t) {
  if (_p(e))
    return e;
  for (const n of t) {
    const s = n.axis || jP(n.position) || e.length > 1 && _p(e[0].toLowerCase());
    if (s)
      return s;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function Zp(e, t, n) {
  if (n[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function VP(e, t) {
  if (t.data && t.data.datasets) {
    const n = t.data.datasets.filter((s) => s.xAxisID === e || s.yAxisID === e);
    if (n.length)
      return Zp(e, "x", n[0]) || Zp(e, "y", n[0]);
  }
  return {};
}
function UP(e, t) {
  const n = qs[e.type] || {
    scales: {}
  }, s = t.scales || {}, i = Vc(e.type, t), r = /* @__PURE__ */ Object.create(null);
  return Object.keys(s).forEach((o) => {
    const a = s[o];
    if (!it(a))
      return console.error(`Invalid scale configuration for scale: ${o}`);
    if (a._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
    const l = Uc(o, a, VP(o, e), Dt.scales[a.type]), c = FP(l, i), u = n.scales || {};
    r[o] = _i(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      a,
      u[l],
      u[c]
    ]);
  }), e.data.datasets.forEach((o) => {
    const a = o.type || e.type, l = o.indexAxis || Vc(a, t), u = (qs[a] || {}).scales || {};
    Object.keys(u).forEach((d) => {
      const h = LP(d, l), f = o[h + "AxisID"] || h;
      r[f] = r[f] || /* @__PURE__ */ Object.create(null), _i(r[f], [
        {
          axis: h
        },
        s[f],
        u[d]
      ]);
    });
  }), Object.keys(r).forEach((o) => {
    const a = r[o];
    _i(a, [
      Dt.scales[a.type],
      Dt.scale
    ]);
  }), r;
}
function hb(e) {
  const t = e.options || (e.options = {});
  t.plugins = $(t.plugins, {}), t.scales = UP(e, t);
}
function fb(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function YP(e) {
  return e = e || {}, e.data = fb(e.data), hb(e), e;
}
const Hp = /* @__PURE__ */ new Map(), pb = /* @__PURE__ */ new Set();
function Ao(e, t) {
  let n = Hp.get(e);
  return n || (n = t(), Hp.set(e, n), pb.add(n)), n;
}
const Bi = (e, t, n) => {
  const s = Hn(t, n);
  s !== void 0 && e.add(s);
};
class WP {
  constructor(t) {
    this._config = YP(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = fb(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), hb(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return Ao(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, n) {
    return Ao(`${t}.transition.${n}`, () => [
      [
        `datasets.${t}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, n) {
    return Ao(`${t}-${n}`, () => [
      [
        `datasets.${t}.elements.${n}`,
        `datasets.${t}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const n = t.id, s = this.type;
    return Ao(`${s}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, n) {
    const s = this._scopeCache;
    let i = s.get(t);
    return (!i || n) && (i = /* @__PURE__ */ new Map(), s.set(t, i)), i;
  }
  getOptionScopes(t, n, s) {
    const { options: i, type: r } = this, o = this._cachedScopes(t, s), a = o.get(n);
    if (a)
      return a;
    const l = /* @__PURE__ */ new Set();
    n.forEach((u) => {
      t && (l.add(t), u.forEach((d) => Bi(l, t, d))), u.forEach((d) => Bi(l, i, d)), u.forEach((d) => Bi(l, qs[r] || {}, d)), u.forEach((d) => Bi(l, Dt, d)), u.forEach((d) => Bi(l, Lc, d));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), pb.has(n) && o.set(n, c), c;
  }
  chartOptionScopes() {
    const { options: t, type: n } = this;
    return [
      t,
      qs[n] || {},
      Dt.datasets[n] || {},
      {
        type: n
      },
      Dt,
      Lc
    ];
  }
  resolveNamedOptions(t, n, s, i = [
    ""
  ]) {
    const r = {
      $shared: !0
    }, { resolver: o, subPrefixes: a } = Jp(this._resolverCache, t, i);
    let l = o;
    if (GP(o, n)) {
      r.$shared = !1, s = Jn(s) ? s() : s;
      const c = this.createResolver(t, s, a);
      l = li(o, s, c);
    }
    for (const c of n)
      r[c] = l[c];
    return r;
  }
  createResolver(t, n, s = [
    ""
  ], i) {
    const { resolver: r } = Jp(this._resolverCache, t, s);
    return it(n) ? li(r, n, void 0, i) : r;
  }
}
function Jp(e, t, n) {
  let s = e.get(t);
  s || (s = /* @__PURE__ */ new Map(), e.set(t, s));
  const i = n.join();
  let r = s.get(i);
  return r || (r = {
    resolver: jd(t, n),
    subPrefixes: n.filter((a) => !a.toLowerCase().includes("hover"))
  }, s.set(i, r)), r;
}
const QP = (e) => it(e) && Object.getOwnPropertyNames(e).some((t) => Jn(e[t]));
function GP(e, t) {
  const { isScriptable: n, isIndexable: s } = zw(e);
  for (const i of t) {
    const r = n(i), o = s(i), a = (o || r) && e[i];
    if (r && (Jn(a) || QP(a)) || o && St(a))
      return !0;
  }
  return !1;
}
var KP = "4.4.4";
const zP = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Xp(e, t) {
  return e === "top" || e === "bottom" || zP.indexOf(e) === -1 && t === "x";
}
function $p(e, t) {
  return function(n, s) {
    return n[e] === s[e] ? n[t] - s[t] : n[e] - s[e];
  };
}
function tg(e) {
  const t = e.chart, n = t.options.animation;
  t.notifyPlugins("afterRender"), mt(n && n.onComplete, [
    e
  ], t);
}
function _P(e) {
  const t = e.chart, n = t.options.animation;
  mt(n && n.onProgress, [
    e
  ], t);
}
function gb(e) {
  return Yd() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const Fo = {}, eg = (e) => {
  const t = gb(e);
  return Object.values(Fo).filter((n) => n.canvas === t).pop();
};
function ZP(e, t, n) {
  const s = Object.keys(e);
  for (const i of s) {
    const r = +i;
    if (r >= t) {
      const o = e[i];
      delete e[i], (n > 0 || r > t) && (e[r + n] = o);
    }
  }
}
function HP(e, t, n, s) {
  return !n || e.type === "mouseout" ? null : s ? t : e;
}
function yo(e, t, n) {
  return e.options.clip ? e[n] : t[n];
}
function JP(e, t) {
  const { xScale: n, yScale: s } = e;
  return n && s ? {
    left: yo(n, t, "left"),
    right: yo(n, t, "right"),
    top: yo(s, t, "top"),
    bottom: yo(s, t, "bottom")
  } : t;
}
class cn {
  static register(...t) {
    We.add(...t), ng();
  }
  static unregister(...t) {
    We.remove(...t), ng();
  }
  constructor(t, n) {
    const s = this.config = new WP(n), i = gb(t), r = eg(i);
    if (r)
      throw new Error("Canvas is already in use. Chart with ID '" + r.id + "' must be destroyed before the canvas with ID '" + r.canvas.id + "' can be reused.");
    const o = s.createResolver(s.chartOptionScopes(), this.getContext());
    this.platform = new (s.platform || pP(i))(), this.platform.updateConfig(s);
    const a = this.platform.acquireContext(i, o.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width;
    if (this.id = $B(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new BP(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = g2((d) => this.update(d), o.resizeDelay || 0), this._dataChanges = [], Fo[this.id] = this, !a || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    on.listen(this, "complete", tg), on.listen(this, "progress", _P), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: n }, width: s, height: i, _aspectRatio: r } = this;
    return ot(t) ? n && r ? r : i ? s / i : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return We;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Cp(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return bp(this.canvas, this.ctx), this;
  }
  stop() {
    return on.stop(this), this;
  }
  resize(t, n) {
    on.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: n
    } : this._resize(t, n);
  }
  _resize(t, n) {
    const s = this.options, i = this.canvas, r = s.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(i, t, n, r), a = s.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, Cp(this, a, !0) && (this.notifyPlugins("resize", {
      size: o
    }), mt(s.onResize, [
      this,
      o
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    dt(n, (s, i) => {
      s.id = i;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, n = t.scales, s = this.scales, i = Object.keys(s).reduce((o, a) => (o[a] = !1, o), {});
    let r = [];
    n && (r = r.concat(Object.keys(n).map((o) => {
      const a = n[o], l = Uc(o, a), c = l === "r", u = l === "x";
      return {
        options: a,
        dposition: c ? "chartArea" : u ? "bottom" : "left",
        dtype: c ? "radialLinear" : u ? "category" : "linear"
      };
    }))), dt(r, (o) => {
      const a = o.options, l = a.id, c = Uc(l, a), u = $(a.type, o.dtype);
      (a.position === void 0 || Xp(a.position, c) !== Xp(o.dposition)) && (a.position = o.dposition), i[l] = !0;
      let d = null;
      if (l in s && s[l].type === u)
        d = s[l];
      else {
        const h = We.getScale(u);
        d = new h({
          id: l,
          type: u,
          ctx: this.ctx,
          chart: this
        }), s[d.id] = d;
      }
      d.init(a, t);
    }), dt(i, (o, a) => {
      o || delete s[a];
    }), dt(s, (o) => {
      Ht.configure(this, o, o.options), Ht.addBox(this, o);
    });
  }
  _updateMetasets() {
    const t = this._metasets, n = this.data.datasets.length, s = t.length;
    if (t.sort((i, r) => i.index - r.index), s > n) {
      for (let i = n; i < s; ++i)
        this._destroyDatasetMeta(i);
      t.splice(n, s - n);
    }
    this._sortedMetasets = t.slice(0).sort($p("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: n } } = this;
    t.length > n.length && delete this._stacks, t.forEach((s, i) => {
      n.filter((r) => r === s._dataset).length === 0 && this._destroyDatasetMeta(i);
    });
  }
  buildOrUpdateControllers() {
    const t = [], n = this.data.datasets;
    let s, i;
    for (this._removeUnreferencedMetasets(), s = 0, i = n.length; s < i; s++) {
      const r = n[s];
      let o = this.getDatasetMeta(s);
      const a = r.type || this.config.type;
      if (o.type && o.type !== a && (this._destroyDatasetMeta(s), o = this.getDatasetMeta(s)), o.type = a, o.indexAxis = r.indexAxis || Vc(a, this.options), o.order = r.order || 0, o.index = s, o.label = "" + r.label, o.visible = this.isDatasetVisible(s), o.controller)
        o.controller.updateIndex(s), o.controller.linkScales();
      else {
        const l = We.getController(a), { datasetElementType: c, dataElementType: u } = Dt.datasets[a];
        Object.assign(l, {
          dataElementType: We.getElement(u),
          datasetElementType: c && We.getElement(c)
        }), o.controller = new l(this, s), t.push(o.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    dt(this.data.datasets, (t, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const n = this.config;
    n.update();
    const s = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !s.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const r = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let o = 0;
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: d } = this.getDatasetMeta(c), h = !i && r.indexOf(d) === -1;
      d.buildOrUpdateElements(h), o = Math.max(+d.getMaxOverflow(), o);
    }
    o = this._minPadding = s.layout.autoPadding ? o : 0, this._updateLayout(o), i || dt(r, (c) => {
      c.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort($p("z", "_idx"));
    const { _active: a, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();
  }
  _updateScales() {
    dt(this.scales, (t) => {
      Ht.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, n = new Set(Object.keys(this._listeners)), s = new Set(t.events);
    (!dp(n, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, n = this._getUniformDataChanges() || [];
    for (const { method: s, start: i, count: r } of n) {
      const o = s === "_removeElements" ? -r : r;
      ZP(t, i, o);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, s = (r) => new Set(t.filter((o) => o[0] === r).map((o, a) => a + "," + o.splice(1).join(","))), i = s(0);
    for (let r = 1; r < n; r++)
      if (!dp(i, s(r)))
        return;
    return Array.from(i).map((r) => r.split(",")).map((r) => ({
      method: r[1],
      start: +r[2],
      count: +r[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Ht.update(this, this.width, this.height, t);
    const n = this.chartArea, s = n.width <= 0 || n.height <= 0;
    this._layers = [], dt(this.boxes, (i) => {
      s && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers()));
    }, this), this._layers.forEach((i, r) => {
      i._idx = r;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let n = 0, s = this.data.datasets.length; n < s; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, s = this.data.datasets.length; n < s; ++n)
        this._updateDataset(n, Jn(t) ? t({
          datasetIndex: n
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, n) {
    const s = this.getDatasetMeta(t), i = {
      meta: s,
      index: t,
      mode: n,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", i) !== !1 && (s.controller._update(n), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (on.has(this) ? this.attached && !on.running(this) && on.start(this) : (this.draw(), tg({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: s, height: i } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(s, i);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const n = this._layers;
    for (t = 0; t < n.length && n[t].z <= 0; ++t)
      n[t].draw(this.chartArea);
    for (this._drawDatasets(); t < n.length; ++t)
      n[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const n = this._sortedMetasets, s = [];
    let i, r;
    for (i = 0, r = n.length; i < r; ++i) {
      const o = n[i];
      (!t || o.visible) && s.push(o);
    }
    return s;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let n = t.length - 1; n >= 0; --n)
      this._drawDataset(t[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const n = this.ctx, s = t._clip, i = !s.disabled, r = JP(t, this.chartArea), o = {
      meta: t,
      index: t.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (i && _a(n, {
      left: s.left === !1 ? 0 : r.left - s.left,
      right: s.right === !1 ? this.width : r.right + s.right,
      top: s.top === !1 ? 0 : r.top - s.top,
      bottom: s.bottom === !1 ? this.height : r.bottom + s.bottom
    }), t.controller.draw(), i && Za(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o));
  }
  isPointInArea(t) {
    return fn(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, n, s, i) {
    const r = zI.modes[n];
    return typeof r == "function" ? r(this, t, s, i) : [];
  }
  getDatasetMeta(t) {
    const n = this.data.datasets[t], s = this._metasets;
    let i = s.filter((r) => r && r._dataset === n).pop();
    return i || (i = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: t,
      _dataset: n,
      _parsed: [],
      _sorted: !1
    }, s.push(i)), i;
  }
  getContext() {
    return this.$context || (this.$context = es(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const n = this.data.datasets[t];
    if (!n)
      return !1;
    const s = this.getDatasetMeta(t);
    return typeof s.hidden == "boolean" ? !s.hidden : !n.hidden;
  }
  setDatasetVisibility(t, n) {
    const s = this.getDatasetMeta(t);
    s.hidden = !n;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, n, s) {
    const i = s ? "show" : "hide", r = this.getDatasetMeta(t), o = r.controller._resolveAnimations(void 0, i);
    vr(n) ? (r.data[n].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), o.update(r, {
      visible: s
    }), this.update((a) => a.datasetIndex === t ? i : void 0));
  }
  hide(t, n) {
    this._updateVisibility(t, n, !1);
  }
  show(t, n) {
    this._updateVisibility(t, n, !0);
  }
  _destroyDatasetMeta(t) {
    const n = this._metasets[t];
    n && n.controller && n.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, n;
    for (this.stop(), on.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: n } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), bp(t, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Fo[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, n = this.platform, s = (r, o) => {
      n.addEventListener(this, r, o), t[r] = o;
    }, i = (r, o, a) => {
      r.offsetX = o, r.offsetY = a, this._eventHandler(r);
    };
    dt(this.options.events, (r) => s(r, i));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, n = this.platform, s = (l, c) => {
      n.addEventListener(this, l, c), t[l] = c;
    }, i = (l, c) => {
      t[l] && (n.removeEventListener(this, l, c), delete t[l]);
    }, r = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let o;
    const a = () => {
      i("attach", a), this.attached = !0, this.resize(), s("resize", r), s("detach", o);
    };
    o = () => {
      this.attached = !1, i("resize", r), this._stop(), this._resize(0, 0), s("attach", a);
    }, n.isAttached(this.canvas) ? a() : o();
  }
  unbindEvents() {
    dt(this._listeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._listeners = {}, dt(this._responsiveListeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, n, s) {
    const i = s ? "set" : "remove";
    let r, o, a, l;
    for (n === "dataset" && (r = this.getDatasetMeta(t[0].datasetIndex), r.controller["_" + i + "DatasetHoverStyle"]()), a = 0, l = t.length; a < l; ++a) {
      o = t[a];
      const c = o && this.getDatasetMeta(o.datasetIndex).controller;
      c && c[i + "HoverStyle"](o.element, o.datasetIndex, o.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const n = this._active || [], s = t.map(({ datasetIndex: r, index: o }) => {
      const a = this.getDatasetMeta(r);
      if (!a)
        throw new Error("No dataset found at index " + r);
      return {
        datasetIndex: r,
        element: a.data[o],
        index: o
      };
    });
    !ha(s, n) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, n));
  }
  notifyPlugins(t, n, s) {
    return this._plugins.notify(this, t, n, s);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((n) => n.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, n, s) {
    const i = this.options.hover, r = (l, c) => l.filter((u) => !c.some((d) => u.datasetIndex === d.datasetIndex && u.index === d.index)), o = r(n, t), a = s ? t : r(t, n);
    o.length && this.updateHoverStyle(o, i.mode, !1), a.length && i.mode && this.updateHoverStyle(a, i.mode, !0);
  }
  _eventHandler(t, n) {
    const s = {
      event: t,
      replay: n,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, i = (o) => (o.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", s, i) === !1)
      return;
    const r = this._handleEvent(t, n, s.inChartArea);
    return s.cancelable = !1, this.notifyPlugins("afterEvent", s, i), (r || s.changed) && this.render(), this;
  }
  _handleEvent(t, n, s) {
    const { _active: i = [], options: r } = this, o = n, a = this._getActiveElements(t, i, s, o), l = r2(t), c = HP(t, this._lastEvent, s, l);
    s && (this._lastEvent = null, mt(r.onHover, [
      t,
      a,
      this
    ], this), l && mt(r.onClick, [
      t,
      a,
      this
    ], this));
    const u = !ha(a, i);
    return (u || n) && (this._active = a, this._updateHoverStyles(a, i, n)), this._lastEvent = c, u;
  }
  _getActiveElements(t, n, s, i) {
    if (t.type === "mouseout")
      return [];
    if (!s)
      return n;
    const r = this.options.hover;
    return this.getElementsAtEventForMode(t, r.mode, r, i);
  }
}
L(cn, "defaults", Dt), L(cn, "instances", Fo), L(cn, "overrides", qs), L(cn, "registry", We), L(cn, "version", KP), L(cn, "getChart", eg);
function ng() {
  return dt(cn.instances, (e) => e._plugins.invalidate());
}
function XP(e, t, n) {
  const { startAngle: s, pixelMargin: i, x: r, y: o, outerRadius: a, innerRadius: l } = t;
  let c = i / a;
  e.beginPath(), e.arc(r, o, a, s - c, n + c), l > i ? (c = i / l, e.arc(r, o, l, n + c, s - c, !0)) : e.arc(r, o, i, n + It, s - It), e.closePath(), e.clip();
}
function $P(e) {
  return Fd(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function tO(e, t, n, s) {
  const i = $P(e.options.borderRadius), r = (n - t) / 2, o = Math.min(r, s * t / 2), a = (l) => {
    const c = (n - Math.min(r, l)) * s / 2;
    return jt(l, 0, Math.min(r, c));
  };
  return {
    outerStart: a(i.outerStart),
    outerEnd: a(i.outerEnd),
    innerStart: jt(i.innerStart, 0, o),
    innerEnd: jt(i.innerEnd, 0, o)
  };
}
function Ns(e, t, n, s) {
  return {
    x: n + e * Math.cos(t),
    y: s + e * Math.sin(t)
  };
}
function ya(e, t, n, s, i, r) {
  const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: u } = t, d = Math.max(t.outerRadius + s + n - c, 0), h = u > 0 ? u + s + n + c : 0;
  let f = 0;
  const p = i - l;
  if (s) {
    const O = u > 0 ? u - s : 0, U = d > 0 ? d - s : 0, I = (O + U) / 2, F = I !== 0 ? p * I / (I + s) : p;
    f = (p - F) / 2;
  }
  const g = Math.max(1e-3, p * d - n / xt) / d, m = (p - g) / 2, A = l + m + f, w = i - m - f, { outerStart: x, outerEnd: v, innerStart: C, innerEnd: E } = tO(t, h, d, w - A), S = d - x, M = d - v, q = A + x / S, k = w - v / M, R = h + C, D = h + E, j = A + C / R, W = w - E / D;
  if (e.beginPath(), r) {
    const O = (q + k) / 2;
    if (e.arc(o, a, d, q, O), e.arc(o, a, d, O, k), v > 0) {
      const Q = Ns(M, k, o, a);
      e.arc(Q.x, Q.y, v, k, w + It);
    }
    const U = Ns(D, w, o, a);
    if (e.lineTo(U.x, U.y), E > 0) {
      const Q = Ns(D, W, o, a);
      e.arc(Q.x, Q.y, E, w + It, W + Math.PI);
    }
    const I = (w - E / h + (A + C / h)) / 2;
    if (e.arc(o, a, h, w - E / h, I, !0), e.arc(o, a, h, I, A + C / h, !0), C > 0) {
      const Q = Ns(R, j, o, a);
      e.arc(Q.x, Q.y, C, j + Math.PI, A - It);
    }
    const F = Ns(S, A, o, a);
    if (e.lineTo(F.x, F.y), x > 0) {
      const Q = Ns(S, q, o, a);
      e.arc(Q.x, Q.y, x, A - It, q);
    }
  } else {
    e.moveTo(o, a);
    const O = Math.cos(q) * d + o, U = Math.sin(q) * d + a;
    e.lineTo(O, U);
    const I = Math.cos(k) * d + o, F = Math.sin(k) * d + a;
    e.lineTo(I, F);
  }
  e.closePath();
}
function eO(e, t, n, s, i) {
  const { fullCircles: r, startAngle: o, circumference: a } = t;
  let l = t.endAngle;
  if (r) {
    ya(e, t, n, s, l, i);
    for (let c = 0; c < r; ++c)
      e.fill();
    isNaN(a) || (l = o + (a % bt || bt));
  }
  return ya(e, t, n, s, l, i), e.fill(), l;
}
function nO(e, t, n, s, i) {
  const { fullCircles: r, startAngle: o, circumference: a, options: l } = t, { borderWidth: c, borderJoinStyle: u, borderDash: d, borderDashOffset: h } = l, f = l.borderAlign === "inner";
  if (!c)
    return;
  e.setLineDash(d || []), e.lineDashOffset = h, f ? (e.lineWidth = c * 2, e.lineJoin = u || "round") : (e.lineWidth = c, e.lineJoin = u || "bevel");
  let p = t.endAngle;
  if (r) {
    ya(e, t, n, s, p, i);
    for (let g = 0; g < r; ++g)
      e.stroke();
    isNaN(a) || (p = o + (a % bt || bt));
  }
  f && XP(e, t, p), r || (ya(e, t, n, s, p, i), e.stroke());
}
class Ui extends vn {
  constructor(n) {
    super();
    L(this, "circumference");
    L(this, "endAngle");
    L(this, "fullCircles");
    L(this, "innerRadius");
    L(this, "outerRadius");
    L(this, "pixelMargin");
    L(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, n && Object.assign(this, n);
  }
  inRange(n, s, i) {
    const r = this.getProps([
      "x",
      "y"
    ], i), { angle: o, distance: a } = Lw(r, {
      x: n,
      y: s
    }), { startAngle: l, endAngle: c, innerRadius: u, outerRadius: d, circumference: h } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], i), f = (this.options.spacing + this.options.borderWidth) / 2, p = $(h, c - l), g = Cr(o, l, c) && l !== c, m = p >= bt || g, A = dn(a, u + f, d + f);
    return m && A;
  }
  getCenterPoint(n) {
    const { x: s, y: i, startAngle: r, endAngle: o, innerRadius: a, outerRadius: l } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], n), { offset: c, spacing: u } = this.options, d = (r + o) / 2, h = (a + l + u + c) / 2;
    return {
      x: s + Math.cos(d) * h,
      y: i + Math.sin(d) * h
    };
  }
  tooltipPosition(n) {
    return this.getCenterPoint(n);
  }
  draw(n) {
    const { options: s, circumference: i } = this, r = (s.offset || 0) / 4, o = (s.spacing || 0) / 2, a = s.circular;
    if (this.pixelMargin = s.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = i > bt ? Math.floor(i / bt) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    n.save();
    const l = (this.startAngle + this.endAngle) / 2;
    n.translate(Math.cos(l) * r, Math.sin(l) * r);
    const c = 1 - Math.sin(Math.min(xt, i || 0)), u = r * c;
    n.fillStyle = s.backgroundColor, n.strokeStyle = s.borderColor, eO(n, this, u, o, a), nO(n, this, u, o, a), n.restore();
  }
}
L(Ui, "id", "arc"), L(Ui, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), L(Ui, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), L(Ui, "descriptors", {
  _scriptable: !0,
  _indexable: (n) => n !== "borderDash"
});
function mb(e, t, n = t) {
  e.lineCap = $(n.borderCapStyle, t.borderCapStyle), e.setLineDash($(n.borderDash, t.borderDash)), e.lineDashOffset = $(n.borderDashOffset, t.borderDashOffset), e.lineJoin = $(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = $(n.borderWidth, t.borderWidth), e.strokeStyle = $(n.borderColor, t.borderColor);
}
function sO(e, t, n) {
  e.lineTo(n.x, n.y);
}
function iO(e) {
  return e.stepped ? q2 : e.tension || e.cubicInterpolationMode === "monotone" ? R2 : sO;
}
function Ab(e, t, n = {}) {
  const s = e.length, { start: i = 0, end: r = s - 1 } = n, { start: o, end: a } = t, l = Math.max(i, o), c = Math.min(r, a), u = i < o && r < o || i > a && r > a;
  return {
    count: s,
    start: l,
    loop: t.loop,
    ilen: c < l && !u ? s + c - l : c - l
  };
}
function rO(e, t, n, s) {
  const { points: i, options: r } = t, { count: o, start: a, loop: l, ilen: c } = Ab(i, n, s), u = iO(r);
  let { move: d = !0, reverse: h } = s || {}, f, p, g;
  for (f = 0; f <= c; ++f)
    p = i[(a + (h ? c - f : f)) % o], !p.skip && (d ? (e.moveTo(p.x, p.y), d = !1) : u(e, g, p, h, r.stepped), g = p);
  return l && (p = i[(a + (h ? c : 0)) % o], u(e, g, p, h, r.stepped)), !!l;
}
function oO(e, t, n, s) {
  const i = t.points, { count: r, start: o, ilen: a } = Ab(i, n, s), { move: l = !0, reverse: c } = s || {};
  let u = 0, d = 0, h, f, p, g, m, A;
  const w = (v) => (o + (c ? a - v : v)) % r, x = () => {
    g !== m && (e.lineTo(u, m), e.lineTo(u, g), e.lineTo(u, A));
  };
  for (l && (f = i[w(0)], e.moveTo(f.x, f.y)), h = 0; h <= a; ++h) {
    if (f = i[w(h)], f.skip)
      continue;
    const v = f.x, C = f.y, E = v | 0;
    E === p ? (C < g ? g = C : C > m && (m = C), u = (d * u + v) / ++d) : (x(), e.lineTo(v, C), p = E, d = 0, g = m = C), A = C;
  }
  x();
}
function Yc(e) {
  const t = e.options, n = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? oO : rO;
}
function aO(e) {
  return e.stepped ? oI : e.tension || e.cubicInterpolationMode === "monotone" ? aI : ps;
}
function lO(e, t, n, s) {
  let i = t._path;
  i || (i = t._path = new Path2D(), t.path(i, n, s) && i.closePath()), mb(e, t.options), e.stroke(i);
}
function cO(e, t, n, s) {
  const { segments: i, options: r } = t, o = Yc(t);
  for (const a of i)
    mb(e, r, a.style), e.beginPath(), o(e, t, a, {
      start: n,
      end: n + s - 1
    }) && e.closePath(), e.stroke();
}
const uO = typeof Path2D == "function";
function dO(e, t, n, s) {
  uO && !t.options.segment ? lO(e, t, n, s) : cO(e, t, n, s);
}
class Pn extends vn {
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, n) {
    const s = this.options;
    if ((s.tension || s.cubicInterpolationMode === "monotone") && !s.stepped && !this._pointsUpdated) {
      const i = s.spanGaps ? this._loop : this._fullLoop;
      X2(this._points, s, t, i, n), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = fI(this, this.options.segment));
  }
  first() {
    const t = this.segments, n = this.points;
    return t.length && n[t[0].start];
  }
  last() {
    const t = this.segments, n = this.points, s = t.length;
    return s && n[t[s - 1].end];
  }
  interpolate(t, n) {
    const s = this.options, i = t[n], r = this.points, o = sb(this, {
      property: n,
      start: i,
      end: i
    });
    if (!o.length)
      return;
    const a = [], l = aO(s);
    let c, u;
    for (c = 0, u = o.length; c < u; ++c) {
      const { start: d, end: h } = o[c], f = r[d], p = r[h];
      if (f === p) {
        a.push(f);
        continue;
      }
      const g = Math.abs((i - f[n]) / (p[n] - f[n])), m = l(f, p, g, s.stepped);
      m[n] = t[n], a.push(m);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(t, n, s) {
    return Yc(this)(t, this, n, s);
  }
  path(t, n, s) {
    const i = this.segments, r = Yc(this);
    let o = this._loop;
    n = n || 0, s = s || this.points.length - n;
    for (const a of i)
      o &= r(t, this, a, {
        start: n,
        end: n + s - 1
      });
    return !!o;
  }
  draw(t, n, s, i) {
    const r = this.options || {};
    (this.points || []).length && r.borderWidth && (t.save(), dO(t, this, s, i), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
L(Pn, "id", "line"), L(Pn, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), L(Pn, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), L(Pn, "descriptors", {
  _scriptable: !0,
  _indexable: (t) => t !== "borderDash" && t !== "fill"
});
function sg(e, t, n, s) {
  const i = e.options, { [n]: r } = e.getProps([
    n
  ], s);
  return Math.abs(t - r) < i.radius + i.hitRadius;
}
class jo extends vn {
  constructor(n) {
    super();
    L(this, "parsed");
    L(this, "skip");
    L(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, n && Object.assign(this, n);
  }
  inRange(n, s, i) {
    const r = this.options, { x: o, y: a } = this.getProps([
      "x",
      "y"
    ], i);
    return Math.pow(n - o, 2) + Math.pow(s - a, 2) < Math.pow(r.hitRadius + r.radius, 2);
  }
  inXRange(n, s) {
    return sg(this, n, "x", s);
  }
  inYRange(n, s) {
    return sg(this, n, "y", s);
  }
  getCenterPoint(n) {
    const { x: s, y: i } = this.getProps([
      "x",
      "y"
    ], n);
    return {
      x: s,
      y: i
    };
  }
  size(n) {
    n = n || this.options || {};
    let s = n.radius || 0;
    s = Math.max(s, s && n.hoverRadius || 0);
    const i = s && n.borderWidth || 0;
    return (s + i) * 2;
  }
  draw(n, s) {
    const i = this.options;
    this.skip || i.radius < 0.1 || !fn(this, s, this.size(i) / 2) || (n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.fillStyle = i.backgroundColor, Fc(n, i, this.x, this.y));
  }
  getRange() {
    const n = this.options || {};
    return n.radius + n.hitRadius;
  }
}
L(jo, "id", "point"), /**
* @type {any}
*/
L(jo, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
L(jo, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function yb(e, t) {
  const { x: n, y: s, base: i, width: r, height: o } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let a, l, c, u, d;
  return e.horizontal ? (d = o / 2, a = Math.min(n, i), l = Math.max(n, i), c = s - d, u = s + d) : (d = r / 2, a = n - d, l = n + d, c = Math.min(s, i), u = Math.max(s, i)), {
    left: a,
    top: c,
    right: l,
    bottom: u
  };
}
function On(e, t, n, s) {
  return e ? 0 : jt(t, n, s);
}
function hO(e, t, n) {
  const s = e.options.borderWidth, i = e.borderSkipped, r = Kw(s);
  return {
    t: On(i.top, r.top, 0, n),
    r: On(i.right, r.right, 0, t),
    b: On(i.bottom, r.bottom, 0, n),
    l: On(i.left, r.left, 0, t)
  };
}
function fO(e, t, n) {
  const { enableBorderRadius: s } = e.getProps([
    "enableBorderRadius"
  ]), i = e.options.borderRadius, r = bs(i), o = Math.min(t, n), a = e.borderSkipped, l = s || it(i);
  return {
    topLeft: On(!l || a.top || a.left, r.topLeft, 0, o),
    topRight: On(!l || a.top || a.right, r.topRight, 0, o),
    bottomLeft: On(!l || a.bottom || a.left, r.bottomLeft, 0, o),
    bottomRight: On(!l || a.bottom || a.right, r.bottomRight, 0, o)
  };
}
function pO(e) {
  const t = yb(e), n = t.right - t.left, s = t.bottom - t.top, i = hO(e, n / 2, s / 2), r = fO(e, n / 2, s / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: n,
      h: s,
      radius: r
    },
    inner: {
      x: t.left + i.l,
      y: t.top + i.t,
      w: n - i.l - i.r,
      h: s - i.t - i.b,
      radius: {
        topLeft: Math.max(0, r.topLeft - Math.max(i.t, i.l)),
        topRight: Math.max(0, r.topRight - Math.max(i.t, i.r)),
        bottomLeft: Math.max(0, r.bottomLeft - Math.max(i.b, i.l)),
        bottomRight: Math.max(0, r.bottomRight - Math.max(i.b, i.r))
      }
    }
  };
}
function Wl(e, t, n, s) {
  const i = t === null, r = n === null, a = e && !(i && r) && yb(e, s);
  return a && (i || dn(t, a.left, a.right)) && (r || dn(n, a.top, a.bottom));
}
function gO(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function mO(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function Ql(e, t, n = {}) {
  const s = e.x !== n.x ? -t : 0, i = e.y !== n.y ? -t : 0, r = (e.x + e.w !== n.x + n.w ? t : 0) - s, o = (e.y + e.h !== n.y + n.h ? t : 0) - i;
  return {
    x: e.x + s,
    y: e.y + i,
    w: e.w + r,
    h: e.h + o,
    radius: e.radius
  };
}
class Vo extends vn {
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: n, options: { borderColor: s, backgroundColor: i } } = this, { inner: r, outer: o } = pO(this), a = gO(o.radius) ? Sr : mO;
    t.save(), (o.w !== r.w || o.h !== r.h) && (t.beginPath(), a(t, Ql(o, n, r)), t.clip(), a(t, Ql(r, -n, o)), t.fillStyle = s, t.fill("evenodd")), t.beginPath(), a(t, Ql(r, n)), t.fillStyle = i, t.fill(), t.restore();
  }
  inRange(t, n, s) {
    return Wl(this, t, n, s);
  }
  inXRange(t, n) {
    return Wl(this, t, null, n);
  }
  inYRange(t, n) {
    return Wl(this, null, t, n);
  }
  getCenterPoint(t) {
    const { x: n, y: s, base: i, horizontal: r } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: r ? (n + i) / 2 : n,
      y: r ? s : (s + i) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
L(Vo, "id", "bar"), L(Vo, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), L(Vo, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var AO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: Ui,
  BarElement: Vo,
  LineElement: Pn,
  PointElement: jo
});
const Wc = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], ig = /* @__PURE__ */ Wc.map((e) => e.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function wb(e) {
  return Wc[e % Wc.length];
}
function bb(e) {
  return ig[e % ig.length];
}
function yO(e, t) {
  return e.borderColor = wb(t), e.backgroundColor = bb(t), ++t;
}
function wO(e, t) {
  return e.backgroundColor = e.data.map(() => wb(t++)), t;
}
function bO(e, t) {
  return e.backgroundColor = e.data.map(() => bb(t++)), t;
}
function xO(e) {
  let t = 0;
  return (n, s) => {
    const i = e.getDatasetMeta(s).controller;
    i instanceof ms ? t = wO(n, t) : i instanceof Xi ? t = bO(n, t) : i && (t = yO(n, t));
  };
}
function rg(e) {
  let t;
  for (t in e)
    if (e[t].borderColor || e[t].backgroundColor)
      return !0;
  return !1;
}
function vO(e) {
  return e && (e.borderColor || e.backgroundColor);
}
var CO = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(e, t, n) {
    if (!n.enabled)
      return;
    const { data: { datasets: s }, options: i } = e.config, { elements: r } = i;
    if (!n.forceOverride && (rg(s) || vO(i) || r && rg(r)))
      return;
    const o = xO(e);
    s.forEach(o);
  }
};
function SO(e, t, n, s, i) {
  const r = i.samples || s;
  if (r >= n)
    return e.slice(t, t + n);
  const o = [], a = (n - 2) / (r - 2);
  let l = 0;
  const c = t + n - 1;
  let u = t, d, h, f, p, g;
  for (o[l++] = e[u], d = 0; d < r - 2; d++) {
    let m = 0, A = 0, w;
    const x = Math.floor((d + 1) * a) + 1 + t, v = Math.min(Math.floor((d + 2) * a) + 1, n) + t, C = v - x;
    for (w = x; w < v; w++)
      m += e[w].x, A += e[w].y;
    m /= C, A /= C;
    const E = Math.floor(d * a) + 1 + t, S = Math.min(Math.floor((d + 1) * a) + 1, n) + t, { x: M, y: q } = e[u];
    for (f = p = -1, w = E; w < S; w++)
      p = 0.5 * Math.abs((M - m) * (e[w].y - q) - (M - e[w].x) * (A - q)), p > f && (f = p, h = e[w], g = w);
    o[l++] = h, u = g;
  }
  return o[l++] = e[c], o;
}
function MO(e, t, n, s) {
  let i = 0, r = 0, o, a, l, c, u, d, h, f, p, g;
  const m = [], A = t + n - 1, w = e[t].x, v = e[A].x - w;
  for (o = t; o < t + n; ++o) {
    a = e[o], l = (a.x - w) / v * s, c = a.y;
    const C = l | 0;
    if (C === u)
      c < p ? (p = c, d = o) : c > g && (g = c, h = o), i = (r * i + a.x) / ++r;
    else {
      const E = o - 1;
      if (!ot(d) && !ot(h)) {
        const S = Math.min(d, h), M = Math.max(d, h);
        S !== f && S !== E && m.push({
          ...e[S],
          x: i
        }), M !== f && M !== E && m.push({
          ...e[M],
          x: i
        });
      }
      o > 0 && E !== f && m.push(e[E]), m.push(a), u = C, r = 0, p = g = c, d = h = f = o;
    }
  }
  return m;
}
function xb(e) {
  if (e._decimated) {
    const t = e._data;
    delete e._decimated, delete e._data, Object.defineProperty(e, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: t
    });
  }
}
function og(e) {
  e.data.datasets.forEach((t) => {
    xb(t);
  });
}
function EO(e, t) {
  const n = t.length;
  let s = 0, i;
  const { iScale: r } = e, { min: o, max: a, minDefined: l, maxDefined: c } = r.getUserBounds();
  return l && (s = jt(hn(t, r.axis, o).lo, 0, n - 1)), c ? i = jt(hn(t, r.axis, a).hi + 1, s, n) - s : i = n - s, {
    start: s,
    count: i
  };
}
var qO = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (e, t, n) => {
    if (!n.enabled) {
      og(e);
      return;
    }
    const s = e.width;
    e.data.datasets.forEach((i, r) => {
      const { _data: o, indexAxis: a } = i, l = e.getDatasetMeta(r), c = o || i.data;
      if (ji([
        a,
        e.options.indexAxis
      ]) === "y" || !l.controller.supportsDecimation)
        return;
      const u = e.scales[l.xAxisID];
      if (u.type !== "linear" && u.type !== "time" || e.options.parsing)
        return;
      let { start: d, count: h } = EO(l, c);
      const f = n.threshold || 4 * s;
      if (h <= f) {
        xb(i);
        return;
      }
      ot(o) && (i._data = c, delete i.data, Object.defineProperty(i, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(g) {
          this._data = g;
        }
      }));
      let p;
      switch (n.algorithm) {
        case "lttb":
          p = SO(c, d, h, s, n);
          break;
        case "min-max":
          p = MO(c, d, h, s);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`);
      }
      i._decimated = p;
    });
  },
  destroy(e) {
    og(e);
  }
};
function RO(e, t, n) {
  const s = e.segments, i = e.points, r = t.points, o = [];
  for (const a of s) {
    let { start: l, end: c } = a;
    c = Gd(l, c, i);
    const u = Qc(n, i[l], i[c], a.loop);
    if (!t.segments) {
      o.push({
        source: a,
        target: u,
        start: i[l],
        end: i[c]
      });
      continue;
    }
    const d = sb(t, u);
    for (const h of d) {
      const f = Qc(n, r[h.start], r[h.end], h.loop), p = nb(a, i, f);
      for (const g of p)
        o.push({
          source: g,
          target: h,
          start: {
            [n]: ag(u, f, "start", Math.max)
          },
          end: {
            [n]: ag(u, f, "end", Math.min)
          }
        });
    }
  }
  return o;
}
function Qc(e, t, n, s) {
  if (s)
    return;
  let i = t[e], r = n[e];
  return e === "angle" && (i = Ae(i), r = Ae(r)), {
    property: e,
    start: i,
    end: r
  };
}
function kO(e, t) {
  const { x: n = null, y: s = null } = e || {}, i = t.points, r = [];
  return t.segments.forEach(({ start: o, end: a }) => {
    a = Gd(o, a, i);
    const l = i[o], c = i[a];
    s !== null ? (r.push({
      x: l.x,
      y: s
    }), r.push({
      x: c.x,
      y: s
    })) : n !== null && (r.push({
      x: n,
      y: l.y
    }), r.push({
      x: n,
      y: c.y
    }));
  }), r;
}
function Gd(e, t, n) {
  for (; t > e; t--) {
    const s = n[t];
    if (!isNaN(s.x) && !isNaN(s.y))
      break;
  }
  return t;
}
function ag(e, t, n, s) {
  return e && t ? s(e[n], t[n]) : e ? e[n] : t ? t[n] : 0;
}
function vb(e, t) {
  let n = [], s = !1;
  return St(e) ? (s = !0, n = e) : n = kO(e, t), n.length ? new Pn({
    points: n,
    options: {
      tension: 0
    },
    _loop: s,
    _fullLoop: s
  }) : null;
}
function lg(e) {
  return e && e.fill !== !1;
}
function TO(e, t, n) {
  let i = e[t].fill;
  const r = [
    t
  ];
  let o;
  if (!n)
    return i;
  for (; i !== !1 && r.indexOf(i) === -1; ) {
    if (!Tt(i))
      return i;
    if (o = e[i], !o)
      return !1;
    if (o.visible)
      return i;
    r.push(i), i = o.fill;
  }
  return !1;
}
function DO(e, t, n) {
  const s = OO(e);
  if (it(s))
    return isNaN(s.value) ? !1 : s;
  let i = parseFloat(s);
  return Tt(i) && Math.floor(i) === i ? BO(s[0], t, i, n) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(s) >= 0 && s;
}
function BO(e, t, n, s) {
  return (e === "-" || e === "+") && (n = t + n), n === t || n < 0 || n >= s ? !1 : n;
}
function IO(e, t) {
  let n = null;
  return e === "start" ? n = t.bottom : e === "end" ? n = t.top : it(e) ? n = t.getPixelForValue(e.value) : t.getBasePixel && (n = t.getBasePixel()), n;
}
function PO(e, t, n) {
  let s;
  return e === "start" ? s = n : e === "end" ? s = t.options.reverse ? t.min : t.max : it(e) ? s = e.value : s = t.getBaseValue(), s;
}
function OO(e) {
  const t = e.options, n = t.fill;
  let s = $(n && n.target, n);
  return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? "origin" : s;
}
function NO(e) {
  const { scale: t, index: n, line: s } = e, i = [], r = s.segments, o = s.points, a = LO(t, n);
  a.push(vb({
    x: null,
    y: t.bottom
  }, s));
  for (let l = 0; l < r.length; l++) {
    const c = r[l];
    for (let u = c.start; u <= c.end; u++)
      FO(i, o[u], a);
  }
  return new Pn({
    points: i,
    options: {}
  });
}
function LO(e, t) {
  const n = [], s = e.getMatchingVisibleMetas("line");
  for (let i = 0; i < s.length; i++) {
    const r = s[i];
    if (r.index === t)
      break;
    r.hidden || n.unshift(r.dataset);
  }
  return n;
}
function FO(e, t, n) {
  const s = [];
  for (let i = 0; i < n.length; i++) {
    const r = n[i], { first: o, last: a, point: l } = jO(r, t, "x");
    if (!(!l || o && a)) {
      if (o)
        s.unshift(l);
      else if (e.push(l), !a)
        break;
    }
  }
  e.push(...s);
}
function jO(e, t, n) {
  const s = e.interpolate(t, n);
  if (!s)
    return {};
  const i = s[n], r = e.segments, o = e.points;
  let a = !1, l = !1;
  for (let c = 0; c < r.length; c++) {
    const u = r[c], d = o[u.start][n], h = o[u.end][n];
    if (dn(i, d, h)) {
      a = i === d, l = i === h;
      break;
    }
  }
  return {
    first: a,
    last: l,
    point: s
  };
}
class Cb {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, n, s) {
    const { x: i, y: r, radius: o } = this;
    return n = n || {
      start: 0,
      end: bt
    }, t.arc(i, r, o, n.end, n.start, !0), !s.bounds;
  }
  interpolate(t) {
    const { x: n, y: s, radius: i } = this, r = t.angle;
    return {
      x: n + Math.cos(r) * i,
      y: s + Math.sin(r) * i,
      angle: r
    };
  }
}
function VO(e) {
  const { chart: t, fill: n, line: s } = e;
  if (Tt(n))
    return UO(t, n);
  if (n === "stack")
    return NO(e);
  if (n === "shape")
    return !0;
  const i = YO(e);
  return i instanceof Cb ? i : vb(i, s);
}
function UO(e, t) {
  const n = e.getDatasetMeta(t);
  return n && e.isDatasetVisible(t) ? n.dataset : null;
}
function YO(e) {
  return (e.scale || {}).getPointPositionForValue ? QO(e) : WO(e);
}
function WO(e) {
  const { scale: t = {}, fill: n } = e, s = IO(n, t);
  if (Tt(s)) {
    const i = t.isHorizontal();
    return {
      x: i ? s : null,
      y: i ? null : s
    };
  }
  return null;
}
function QO(e) {
  const { scale: t, fill: n } = e, s = t.options, i = t.getLabels().length, r = s.reverse ? t.max : t.min, o = PO(n, t, r), a = [];
  if (s.grid.circular) {
    const l = t.getPointPositionForValue(0, r);
    return new Cb({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(o)
    });
  }
  for (let l = 0; l < i; ++l)
    a.push(t.getPointPositionForValue(l, o));
  return a;
}
function Gl(e, t, n) {
  const s = VO(t), { line: i, scale: r, axis: o } = t, a = i.options, l = a.fill, c = a.backgroundColor, { above: u = c, below: d = c } = l || {};
  s && i.points.length && (_a(e, n), GO(e, {
    line: i,
    target: s,
    above: u,
    below: d,
    area: n,
    scale: r,
    axis: o
  }), Za(e));
}
function GO(e, t) {
  const { line: n, target: s, above: i, below: r, area: o, scale: a } = t, l = n._loop ? "angle" : t.axis;
  e.save(), l === "x" && r !== i && (cg(e, s, o.top), ug(e, {
    line: n,
    target: s,
    color: i,
    scale: a,
    property: l
  }), e.restore(), e.save(), cg(e, s, o.bottom)), ug(e, {
    line: n,
    target: s,
    color: r,
    scale: a,
    property: l
  }), e.restore();
}
function cg(e, t, n) {
  const { segments: s, points: i } = t;
  let r = !0, o = !1;
  e.beginPath();
  for (const a of s) {
    const { start: l, end: c } = a, u = i[l], d = i[Gd(l, c, i)];
    r ? (e.moveTo(u.x, u.y), r = !1) : (e.lineTo(u.x, n), e.lineTo(u.x, u.y)), o = !!t.pathSegment(e, a, {
      move: o
    }), o ? e.closePath() : e.lineTo(d.x, n);
  }
  e.lineTo(t.first().x, n), e.closePath(), e.clip();
}
function ug(e, t) {
  const { line: n, target: s, property: i, color: r, scale: o } = t, a = RO(n, s, i);
  for (const { source: l, target: c, start: u, end: d } of a) {
    const { style: { backgroundColor: h = r } = {} } = l, f = s !== !0;
    e.save(), e.fillStyle = h, KO(e, o, f && Qc(i, u, d)), e.beginPath();
    const p = !!n.pathSegment(e, l);
    let g;
    if (f) {
      p ? e.closePath() : dg(e, s, d, i);
      const m = !!s.pathSegment(e, c, {
        move: p,
        reverse: !0
      });
      g = p && m, g || dg(e, s, u, i);
    }
    e.closePath(), e.fill(g ? "evenodd" : "nonzero"), e.restore();
  }
}
function KO(e, t, n) {
  const { top: s, bottom: i } = t.chart.chartArea, { property: r, start: o, end: a } = n || {};
  r === "x" && (e.beginPath(), e.rect(o, s, a - o, i - s), e.clip());
}
function dg(e, t, n, s) {
  const i = t.interpolate(n, s);
  i && e.lineTo(i.x, i.y);
}
var zO = {
  id: "filler",
  afterDatasetsUpdate(e, t, n) {
    const s = (e.data.datasets || []).length, i = [];
    let r, o, a, l;
    for (o = 0; o < s; ++o)
      r = e.getDatasetMeta(o), a = r.dataset, l = null, a && a.options && a instanceof Pn && (l = {
        visible: e.isDatasetVisible(o),
        index: o,
        fill: DO(a, o, s),
        chart: e,
        axis: r.controller.options.indexAxis,
        scale: r.vScale,
        line: a
      }), r.$filler = l, i.push(l);
    for (o = 0; o < s; ++o)
      l = i[o], !(!l || l.fill === !1) && (l.fill = TO(i, o, n.propagate));
  },
  beforeDraw(e, t, n) {
    const s = n.drawTime === "beforeDraw", i = e.getSortedVisibleDatasetMetas(), r = e.chartArea;
    for (let o = i.length - 1; o >= 0; --o) {
      const a = i[o].$filler;
      a && (a.line.updateControlPoints(r, a.axis), s && a.fill && Gl(e.ctx, a, r));
    }
  },
  beforeDatasetsDraw(e, t, n) {
    if (n.drawTime !== "beforeDatasetsDraw")
      return;
    const s = e.getSortedVisibleDatasetMetas();
    for (let i = s.length - 1; i >= 0; --i) {
      const r = s[i].$filler;
      lg(r) && Gl(e.ctx, r, e.chartArea);
    }
  },
  beforeDatasetDraw(e, t, n) {
    const s = t.meta.$filler;
    !lg(s) || n.drawTime !== "beforeDatasetDraw" || Gl(e.ctx, s, e.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const hg = (e, t) => {
  let { boxHeight: n = t, boxWidth: s = t } = e;
  return e.usePointStyle && (n = Math.min(n, t), s = e.pointStyleWidth || Math.min(s, t)), {
    boxWidth: s,
    boxHeight: n,
    itemHeight: Math.max(t, n)
  };
}, _O = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class fg extends vn {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, n, s) {
    this.maxWidth = t, this.maxHeight = n, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let n = mt(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (n = n.filter((s) => t.filter(s, this.chart.data))), t.sort && (n = n.sort((s, i) => t.sort(s, i, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n;
  }
  fit() {
    const { options: t, ctx: n } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const s = t.labels, i = Ft(s.font), r = i.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = hg(s, r);
    let c, u;
    n.font = i.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(o, r, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(o, i, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(u, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, n, s, i) {
    const { ctx: r, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
      0
    ], u = i + a;
    let d = t;
    r.textAlign = "left", r.textBaseline = "middle";
    let h = -1, f = -u;
    return this.legendItems.forEach((p, g) => {
      const m = s + n / 2 + r.measureText(p.text).width;
      (g === 0 || c[c.length - 1] + m + 2 * a > o) && (d += u, c[c.length - (g > 0 ? 0 : 1)] = 0, f += u, h++), l[g] = {
        left: 0,
        top: f,
        row: h,
        width: m,
        height: i
      }, c[c.length - 1] += m + a;
    }), d;
  }
  _fitCols(t, n, s, i) {
    const { ctx: r, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = o - t;
    let d = a, h = 0, f = 0, p = 0, g = 0;
    return this.legendItems.forEach((m, A) => {
      const { itemWidth: w, itemHeight: x } = ZO(s, n, r, m, i);
      A > 0 && f + x + 2 * a > u && (d += h + a, c.push({
        width: h,
        height: f
      }), p += h + a, g++, h = f = 0), l[A] = {
        left: p,
        top: f,
        col: g,
        width: w,
        height: x
      }, h = Math.max(h, w), f += x + a;
    }), d += h, c.push({
      width: h,
      height: f
    }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: s, labels: { padding: i }, rtl: r } } = this, o = Hs(r, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, l = zt(s, this.left + i, this.right - this.lineWidths[a]);
      for (const c of n)
        a !== c.row && (a = c.row, l = zt(s, this.left + i, this.right - this.lineWidths[a])), c.top += this.top + t + i, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + i;
    } else {
      let a = 0, l = zt(s, this.top + t + i, this.bottom - this.columnSizes[a].height);
      for (const c of n)
        c.col !== a && (a = c.col, l = zt(s, this.top + t + i, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + i, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + i;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      _a(t, this), this._draw(), Za(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: n, lineWidths: s, ctx: i } = this, { align: r, labels: o } = t, a = Dt.color, l = Hs(t.rtl, this.left, this.width), c = Ft(o.font), { padding: u } = o, d = c.size, h = d / 2;
    let f;
    this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = 0.5, i.font = c.string;
    const { boxWidth: p, boxHeight: g, itemHeight: m } = hg(o, d), A = function(E, S, M) {
      if (isNaN(p) || p <= 0 || isNaN(g) || g < 0)
        return;
      i.save();
      const q = $(M.lineWidth, 1);
      if (i.fillStyle = $(M.fillStyle, a), i.lineCap = $(M.lineCap, "butt"), i.lineDashOffset = $(M.lineDashOffset, 0), i.lineJoin = $(M.lineJoin, "miter"), i.lineWidth = q, i.strokeStyle = $(M.strokeStyle, a), i.setLineDash($(M.lineDash, [])), o.usePointStyle) {
        const k = {
          radius: g * Math.SQRT2 / 2,
          pointStyle: M.pointStyle,
          rotation: M.rotation,
          borderWidth: q
        }, R = l.xPlus(E, p / 2), D = S + h;
        Gw(i, k, R, D, o.pointStyleWidth && p);
      } else {
        const k = S + Math.max((d - g) / 2, 0), R = l.leftForLtr(E, p), D = bs(M.borderRadius);
        i.beginPath(), Object.values(D).some((j) => j !== 0) ? Sr(i, {
          x: R,
          y: k,
          w: p,
          h: g,
          radius: D
        }) : i.rect(R, k, p, g), i.fill(), q !== 0 && i.stroke();
      }
      i.restore();
    }, w = function(E, S, M) {
      Rs(i, M.text, E, S + m / 2, c, {
        strikethrough: M.hidden,
        textAlign: l.textAlign(M.textAlign)
      });
    }, x = this.isHorizontal(), v = this._computeTitleHeight();
    x ? f = {
      x: zt(r, this.left + u, this.right - s[0]),
      y: this.top + u + v,
      line: 0
    } : f = {
      x: this.left + u,
      y: zt(r, this.top + v + u, this.bottom - n[0].height),
      line: 0
    }, $w(this.ctx, t.textDirection);
    const C = m + u;
    this.legendItems.forEach((E, S) => {
      i.strokeStyle = E.fontColor, i.fillStyle = E.fontColor;
      const M = i.measureText(E.text).width, q = l.textAlign(E.textAlign || (E.textAlign = o.textAlign)), k = p + h + M;
      let R = f.x, D = f.y;
      l.setWidth(this.width), x ? S > 0 && R + k + u > this.right && (D = f.y += C, f.line++, R = f.x = zt(r, this.left + u, this.right - s[f.line])) : S > 0 && D + C > this.bottom && (R = f.x = R + n[f.line].width + u, f.line++, D = f.y = zt(r, this.top + v + u, this.bottom - n[f.line].height));
      const j = l.x(R);
      if (A(j, D, E), R = m2(q, R + p + h, x ? R + k : this.right, t.rtl), w(l.x(R), D, E), x)
        f.x += k + u;
      else if (typeof E.text != "string") {
        const W = c.lineHeight;
        f.y += Sb(E, W) + u;
      } else
        f.y += C;
    }), tb(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, n = t.title, s = Ft(n.font), i = $t(n.padding);
    if (!n.display)
      return;
    const r = Hs(t.rtl, this.left, this.width), o = this.ctx, a = n.position, l = s.size / 2, c = i.top + l;
    let u, d = this.left, h = this.width;
    if (this.isHorizontal())
      h = Math.max(...this.lineWidths), u = this.top + c, d = zt(t.align, d, this.right - h);
    else {
      const p = this.columnSizes.reduce((g, m) => Math.max(g, m.height), 0);
      u = c + zt(t.align, this.top, this.bottom - p - t.labels.padding - this._computeTitleHeight());
    }
    const f = zt(a, d, d + h);
    o.textAlign = r.textAlign(Nd(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = s.string, Rs(o, n.text, f, u, s);
  }
  _computeTitleHeight() {
    const t = this.options.title, n = Ft(t.font), s = $t(t.padding);
    return t.display ? n.lineHeight + s.height : 0;
  }
  _getLegendItemAt(t, n) {
    let s, i, r;
    if (dn(t, this.left, this.right) && dn(n, this.top, this.bottom)) {
      for (r = this.legendHitBoxes, s = 0; s < r.length; ++s)
        if (i = r[s], dn(t, i.left, i.left + i.width) && dn(n, i.top, i.top + i.height))
          return this.legendItems[s];
    }
    return null;
  }
  handleEvent(t) {
    const n = this.options;
    if (!XO(t.type, n))
      return;
    const s = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const i = this._hoveredItem, r = _O(i, s);
      i && !r && mt(n.onLeave, [
        t,
        i,
        this
      ], this), this._hoveredItem = s, s && !r && mt(n.onHover, [
        t,
        s,
        this
      ], this);
    } else s && mt(n.onClick, [
      t,
      s,
      this
    ], this);
  }
}
function ZO(e, t, n, s, i) {
  const r = HO(s, e, t, n), o = JO(i, s, t.lineHeight);
  return {
    itemWidth: r,
    itemHeight: o
  };
}
function HO(e, t, n, s) {
  let i = e.text;
  return i && typeof i != "string" && (i = i.reduce((r, o) => r.length > o.length ? r : o)), t + n.size / 2 + s.measureText(i).width;
}
function JO(e, t, n) {
  let s = e;
  return typeof t.text != "string" && (s = Sb(t, n)), s;
}
function Sb(e, t) {
  const n = e.text ? e.text.length : 0;
  return t * n;
}
function XO(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var $O = {
  id: "legend",
  _element: fg,
  start(e, t, n) {
    const s = e.legend = new fg({
      ctx: e.ctx,
      options: n,
      chart: e
    });
    Ht.configure(e, s, n), Ht.addBox(e, s);
  },
  stop(e) {
    Ht.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, n) {
    const s = e.legend;
    Ht.configure(e, s, n), s.options = n;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, n) {
      const s = t.datasetIndex, i = n.chart;
      i.isDatasetVisible(s) ? (i.hide(s), t.hidden = !0) : (i.show(s), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: n, pointStyle: s, textAlign: i, color: r, useBorderRadius: o, borderRadius: a } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(n ? 0 : void 0), u = $t(c.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: r,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: s || c.pointStyle,
            rotation: c.rotation,
            textAlign: i || c.textAlign,
            borderRadius: o && (a || c.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
class Kd extends vn {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, n) {
    const s = this.options;
    if (this.left = 0, this.top = 0, !s.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = n;
    const i = St(s.text) ? s.text.length : 1;
    this._padding = $t(s.padding);
    const r = i * Ft(s.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = r : this.width = r;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: n, left: s, bottom: i, right: r, options: o } = this, a = o.align;
    let l = 0, c, u, d;
    return this.isHorizontal() ? (u = zt(a, s, r), d = n + t, c = r - s) : (o.position === "left" ? (u = s + t, d = zt(a, i, n), l = xt * -0.5) : (u = r - t, d = zt(a, n, i), l = xt * 0.5), c = i - n), {
      titleX: u,
      titleY: d,
      maxWidth: c,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, n = this.options;
    if (!n.display)
      return;
    const s = Ft(n.font), r = s.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(r);
    Rs(t, n.text, 0, 0, s, {
      color: n.color,
      maxWidth: l,
      rotation: c,
      textAlign: Nd(n.align),
      textBaseline: "middle",
      translation: [
        o,
        a
      ]
    });
  }
}
function tN(e, t) {
  const n = new Kd({
    ctx: e.ctx,
    options: t,
    chart: e
  });
  Ht.configure(e, n, t), Ht.addBox(e, n), e.titleBlock = n;
}
var eN = {
  id: "title",
  _element: Kd,
  start(e, t, n) {
    tN(e, n);
  },
  stop(e) {
    const t = e.titleBlock;
    Ht.removeBox(e, t), delete e.titleBlock;
  },
  beforeUpdate(e, t, n) {
    const s = e.titleBlock;
    Ht.configure(e, s, n), s.options = n;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const wo = /* @__PURE__ */ new WeakMap();
var nN = {
  id: "subtitle",
  start(e, t, n) {
    const s = new Kd({
      ctx: e.ctx,
      options: n,
      chart: e
    });
    Ht.configure(e, s, n), Ht.addBox(e, s), wo.set(e, s);
  },
  stop(e) {
    Ht.removeBox(e, wo.get(e)), wo.delete(e);
  },
  beforeUpdate(e, t, n) {
    const s = wo.get(e);
    Ht.configure(e, s, n), s.options = n;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Yi = {
  average(e) {
    if (!e.length)
      return !1;
    let t, n, s = /* @__PURE__ */ new Set(), i = 0, r = 0;
    for (t = 0, n = e.length; t < n; ++t) {
      const a = e[t].element;
      if (a && a.hasValue()) {
        const l = a.tooltipPosition();
        s.add(l.x), i += l.y, ++r;
      }
    }
    return r === 0 || s.size === 0 ? !1 : {
      x: [
        ...s
      ].reduce((a, l) => a + l) / s.size,
      y: i / r
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let n = t.x, s = t.y, i = Number.POSITIVE_INFINITY, r, o, a;
    for (r = 0, o = e.length; r < o; ++r) {
      const l = e[r].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), u = Nc(t, c);
        u < i && (i = u, a = l);
      }
    }
    if (a) {
      const l = a.tooltipPosition();
      n = l.x, s = l.y;
    }
    return {
      x: n,
      y: s
    };
  }
};
function Ye(e, t) {
  return t && (St(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function an(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function sN(e, t) {
  const { element: n, datasetIndex: s, index: i } = t, r = e.getDatasetMeta(s).controller, { label: o, value: a } = r.getLabelAndValue(i);
  return {
    chart: e,
    label: o,
    parsed: r.getParsed(i),
    raw: e.data.datasets[s].data[i],
    formattedValue: a,
    dataset: r.getDataset(),
    dataIndex: i,
    datasetIndex: s,
    element: n
  };
}
function pg(e, t) {
  const n = e.chart.ctx, { body: s, footer: i, title: r } = e, { boxWidth: o, boxHeight: a } = t, l = Ft(t.bodyFont), c = Ft(t.titleFont), u = Ft(t.footerFont), d = r.length, h = i.length, f = s.length, p = $t(t.padding);
  let g = p.height, m = 0, A = s.reduce((v, C) => v + C.before.length + C.lines.length + C.after.length, 0);
  if (A += e.beforeBody.length + e.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), A) {
    const v = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
    g += f * v + (A - f) * l.lineHeight + (A - 1) * t.bodySpacing;
  }
  h && (g += t.footerMarginTop + h * u.lineHeight + (h - 1) * t.footerSpacing);
  let w = 0;
  const x = function(v) {
    m = Math.max(m, n.measureText(v).width + w);
  };
  return n.save(), n.font = c.string, dt(e.title, x), n.font = l.string, dt(e.beforeBody.concat(e.afterBody), x), w = t.displayColors ? o + 2 + t.boxPadding : 0, dt(s, (v) => {
    dt(v.before, x), dt(v.lines, x), dt(v.after, x);
  }), w = 0, n.font = u.string, dt(e.footer, x), n.restore(), m += p.width, {
    width: m,
    height: g
  };
}
function iN(e, t) {
  const { y: n, height: s } = t;
  return n < s / 2 ? "top" : n > e.height - s / 2 ? "bottom" : "center";
}
function rN(e, t, n, s) {
  const { x: i, width: r } = s, o = n.caretSize + n.caretPadding;
  if (e === "left" && i + r + o > t.width || e === "right" && i - r - o < 0)
    return !0;
}
function oN(e, t, n, s) {
  const { x: i, width: r } = n, { width: o, chartArea: { left: a, right: l } } = e;
  let c = "center";
  return s === "center" ? c = i <= (a + l) / 2 ? "left" : "right" : i <= r / 2 ? c = "left" : i >= o - r / 2 && (c = "right"), rN(c, e, t, n) && (c = "center"), c;
}
function gg(e, t, n) {
  const s = n.yAlign || t.yAlign || iN(e, n);
  return {
    xAlign: n.xAlign || t.xAlign || oN(e, t, n, s),
    yAlign: s
  };
}
function aN(e, t) {
  let { x: n, width: s } = e;
  return t === "right" ? n -= s : t === "center" && (n -= s / 2), n;
}
function lN(e, t, n) {
  let { y: s, height: i } = e;
  return t === "top" ? s += n : t === "bottom" ? s -= i + n : s -= i / 2, s;
}
function mg(e, t, n, s) {
  const { caretSize: i, caretPadding: r, cornerRadius: o } = e, { xAlign: a, yAlign: l } = n, c = i + r, { topLeft: u, topRight: d, bottomLeft: h, bottomRight: f } = bs(o);
  let p = aN(t, a);
  const g = lN(t, l, c);
  return l === "center" ? a === "left" ? p += c : a === "right" && (p -= c) : a === "left" ? p -= Math.max(u, h) + i : a === "right" && (p += Math.max(d, f) + i), {
    x: jt(p, 0, s.width - t.width),
    y: jt(g, 0, s.height - t.height)
  };
}
function bo(e, t, n) {
  const s = $t(n.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - s.right : e.x + s.left;
}
function Ag(e) {
  return Ye([], an(e));
}
function cN(e, t, n) {
  return es(e, {
    tooltip: t,
    tooltipItems: n,
    type: "tooltip"
  });
}
function yg(e, t) {
  const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return n ? e.override(n) : e;
}
const Mb = {
  beforeTitle: sn,
  title(e) {
    if (e.length > 0) {
      const t = e[0], n = t.chart.data.labels, s = n ? n.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (s > 0 && t.dataIndex < s)
        return n[t.dataIndex];
    }
    return "";
  },
  afterTitle: sn,
  beforeBody: sn,
  beforeLabel: sn,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const n = e.formattedValue;
    return ot(n) || (t += n), t;
  },
  labelColor(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: n.pointStyle,
      rotation: n.rotation
    };
  },
  afterLabel: sn,
  afterBody: sn,
  beforeFooter: sn,
  footer: sn,
  afterFooter: sn
};
function le(e, t, n, s) {
  const i = e[t].call(n, s);
  return typeof i > "u" ? Mb[t].call(n, s) : i;
}
class Gc extends vn {
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const n = this.chart, s = this.options.setContext(this.getContext()), i = s.enabled && n.options.animation && s.animations, r = new ib(this.chart, i);
    return i._cacheable && (this._cachedAnimations = Object.freeze(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = cN(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, n) {
    const { callbacks: s } = n, i = le(s, "beforeTitle", this, t), r = le(s, "title", this, t), o = le(s, "afterTitle", this, t);
    let a = [];
    return a = Ye(a, an(i)), a = Ye(a, an(r)), a = Ye(a, an(o)), a;
  }
  getBeforeBody(t, n) {
    return Ag(le(n.callbacks, "beforeBody", this, t));
  }
  getBody(t, n) {
    const { callbacks: s } = n, i = [];
    return dt(t, (r) => {
      const o = {
        before: [],
        lines: [],
        after: []
      }, a = yg(s, r);
      Ye(o.before, an(le(a, "beforeLabel", this, r))), Ye(o.lines, le(a, "label", this, r)), Ye(o.after, an(le(a, "afterLabel", this, r))), i.push(o);
    }), i;
  }
  getAfterBody(t, n) {
    return Ag(le(n.callbacks, "afterBody", this, t));
  }
  getFooter(t, n) {
    const { callbacks: s } = n, i = le(s, "beforeFooter", this, t), r = le(s, "footer", this, t), o = le(s, "afterFooter", this, t);
    let a = [];
    return a = Ye(a, an(i)), a = Ye(a, an(r)), a = Ye(a, an(o)), a;
  }
  _createItems(t) {
    const n = this._active, s = this.chart.data, i = [], r = [], o = [];
    let a = [], l, c;
    for (l = 0, c = n.length; l < c; ++l)
      a.push(sN(this.chart, n[l]));
    return t.filter && (a = a.filter((u, d, h) => t.filter(u, d, h, s))), t.itemSort && (a = a.sort((u, d) => t.itemSort(u, d, s))), dt(a, (u) => {
      const d = yg(t.callbacks, u);
      i.push(le(d, "labelColor", this, u)), r.push(le(d, "labelPointStyle", this, u)), o.push(le(d, "labelTextColor", this, u));
    }), this.labelColors = i, this.labelPointStyles = r, this.labelTextColors = o, this.dataPoints = a, a;
  }
  update(t, n) {
    const s = this.options.setContext(this.getContext()), i = this._active;
    let r, o = [];
    if (!i.length)
      this.opacity !== 0 && (r = {
        opacity: 0
      });
    else {
      const a = Yi[s.position].call(this, i, this._eventPosition);
      o = this._createItems(s), this.title = this.getTitle(o, s), this.beforeBody = this.getBeforeBody(o, s), this.body = this.getBody(o, s), this.afterBody = this.getAfterBody(o, s), this.footer = this.getFooter(o, s);
      const l = this._size = pg(this, s), c = Object.assign({}, a, l), u = gg(this.chart, s, c), d = mg(s, c, u, this.chart);
      this.xAlign = u.xAlign, this.yAlign = u.yAlign, r = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = o, this.$context = void 0, r && this._resolveAnimations().update(this, r), t && s.external && s.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: n
    });
  }
  drawCaret(t, n, s, i) {
    const r = this.getCaretPosition(t, s, i);
    n.lineTo(r.x1, r.y1), n.lineTo(r.x2, r.y2), n.lineTo(r.x3, r.y3);
  }
  getCaretPosition(t, n, s) {
    const { xAlign: i, yAlign: r } = this, { caretSize: o, cornerRadius: a } = s, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: d } = bs(a), { x: h, y: f } = t, { width: p, height: g } = n;
    let m, A, w, x, v, C;
    return r === "center" ? (v = f + g / 2, i === "left" ? (m = h, A = m - o, x = v + o, C = v - o) : (m = h + p, A = m + o, x = v - o, C = v + o), w = m) : (i === "left" ? A = h + Math.max(l, u) + o : i === "right" ? A = h + p - Math.max(c, d) - o : A = this.caretX, r === "top" ? (x = f, v = x - o, m = A - o, w = A + o) : (x = f + g, v = x + o, m = A + o, w = A - o), C = x), {
      x1: m,
      x2: A,
      x3: w,
      y1: x,
      y2: v,
      y3: C
    };
  }
  drawTitle(t, n, s) {
    const i = this.title, r = i.length;
    let o, a, l;
    if (r) {
      const c = Hs(s.rtl, this.x, this.width);
      for (t.x = bo(this, s.titleAlign, s), n.textAlign = c.textAlign(s.titleAlign), n.textBaseline = "middle", o = Ft(s.titleFont), a = s.titleSpacing, n.fillStyle = s.titleColor, n.font = o.string, l = 0; l < r; ++l)
        n.fillText(i[l], c.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, l + 1 === r && (t.y += s.titleMarginBottom - a);
    }
  }
  _drawColorBox(t, n, s, i, r) {
    const o = this.labelColors[s], a = this.labelPointStyles[s], { boxHeight: l, boxWidth: c } = r, u = Ft(r.bodyFont), d = bo(this, "left", r), h = i.x(d), f = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, p = n.y + f;
    if (r.usePointStyle) {
      const g = {
        radius: Math.min(c, l) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, m = i.leftForLtr(h, c) + c / 2, A = p + l / 2;
      t.strokeStyle = r.multiKeyBackground, t.fillStyle = r.multiKeyBackground, Fc(t, g, m, A), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, Fc(t, g, m, A);
    } else {
      t.lineWidth = it(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, t.strokeStyle = o.borderColor, t.setLineDash(o.borderDash || []), t.lineDashOffset = o.borderDashOffset || 0;
      const g = i.leftForLtr(h, c), m = i.leftForLtr(i.xPlus(h, 1), c - 2), A = bs(o.borderRadius);
      Object.values(A).some((w) => w !== 0) ? (t.beginPath(), t.fillStyle = r.multiKeyBackground, Sr(t, {
        x: g,
        y: p,
        w: c,
        h: l,
        radius: A
      }), t.fill(), t.stroke(), t.fillStyle = o.backgroundColor, t.beginPath(), Sr(t, {
        x: m,
        y: p + 1,
        w: c - 2,
        h: l - 2,
        radius: A
      }), t.fill()) : (t.fillStyle = r.multiKeyBackground, t.fillRect(g, p, c, l), t.strokeRect(g, p, c, l), t.fillStyle = o.backgroundColor, t.fillRect(m, p + 1, c - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[s];
  }
  drawBody(t, n, s) {
    const { body: i } = this, { bodySpacing: r, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u } = s, d = Ft(s.bodyFont);
    let h = d.lineHeight, f = 0;
    const p = Hs(s.rtl, this.x, this.width), g = function(M) {
      n.fillText(M, p.x(t.x + f), t.y + h / 2), t.y += h + r;
    }, m = p.textAlign(o);
    let A, w, x, v, C, E, S;
    for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, t.x = bo(this, m, s), n.fillStyle = s.bodyColor, dt(this.beforeBody, g), f = a && m !== "right" ? o === "center" ? c / 2 + u : c + 2 + u : 0, v = 0, E = i.length; v < E; ++v) {
      for (A = i[v], w = this.labelTextColors[v], n.fillStyle = w, dt(A.before, g), x = A.lines, a && x.length && (this._drawColorBox(n, t, v, p, s), h = Math.max(d.lineHeight, l)), C = 0, S = x.length; C < S; ++C)
        g(x[C]), h = d.lineHeight;
      dt(A.after, g);
    }
    f = 0, h = d.lineHeight, dt(this.afterBody, g), t.y -= r;
  }
  drawFooter(t, n, s) {
    const i = this.footer, r = i.length;
    let o, a;
    if (r) {
      const l = Hs(s.rtl, this.x, this.width);
      for (t.x = bo(this, s.footerAlign, s), t.y += s.footerMarginTop, n.textAlign = l.textAlign(s.footerAlign), n.textBaseline = "middle", o = Ft(s.footerFont), n.fillStyle = s.footerColor, n.font = o.string, a = 0; a < r; ++a)
        n.fillText(i[a], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + s.footerSpacing;
    }
  }
  drawBackground(t, n, s, i) {
    const { xAlign: r, yAlign: o } = this, { x: a, y: l } = t, { width: c, height: u } = s, { topLeft: d, topRight: h, bottomLeft: f, bottomRight: p } = bs(i.cornerRadius);
    n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, n.lineWidth = i.borderWidth, n.beginPath(), n.moveTo(a + d, l), o === "top" && this.drawCaret(t, n, s, i), n.lineTo(a + c - h, l), n.quadraticCurveTo(a + c, l, a + c, l + h), o === "center" && r === "right" && this.drawCaret(t, n, s, i), n.lineTo(a + c, l + u - p), n.quadraticCurveTo(a + c, l + u, a + c - p, l + u), o === "bottom" && this.drawCaret(t, n, s, i), n.lineTo(a + f, l + u), n.quadraticCurveTo(a, l + u, a, l + u - f), o === "center" && r === "left" && this.drawCaret(t, n, s, i), n.lineTo(a, l + d), n.quadraticCurveTo(a, l, a + d, l), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke();
  }
  _updateAnimationTarget(t) {
    const n = this.chart, s = this.$animations, i = s && s.x, r = s && s.y;
    if (i || r) {
      const o = Yi[t.position].call(this, this._active, this._eventPosition);
      if (!o)
        return;
      const a = this._size = pg(this, t), l = Object.assign({}, o, this._size), c = gg(n, t, l), u = mg(t, l, c, n);
      (i._to !== u.x || r._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, u));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const n = this.options.setContext(this.getContext());
    let s = this.opacity;
    if (!s)
      return;
    this._updateAnimationTarget(n);
    const i = {
      width: this.width,
      height: this.height
    }, r = {
      x: this.x,
      y: this.y
    };
    s = Math.abs(s) < 1e-3 ? 0 : s;
    const o = $t(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(r, t, i, n), $w(t, n.textDirection), r.y += o.top, this.drawTitle(r, t, n), this.drawBody(r, t, n), this.drawFooter(r, t, n), tb(t, n.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, n) {
    const s = this._active, i = t.map(({ datasetIndex: a, index: l }) => {
      const c = this.chart.getDatasetMeta(a);
      if (!c)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: c.data[l],
        index: l
      };
    }), r = !ha(s, i), o = this._positionChanged(i, n);
    (r || o) && (this._active = i, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, n, s = !0) {
    if (n && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const i = this.options, r = this._active || [], o = this._getActiveElements(t, r, n, s), a = this._positionChanged(o, t), l = n || !ha(o, r) || a;
    return l && (this._active = o, (i.enabled || i.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, n))), l;
  }
  _getActiveElements(t, n, s, i) {
    const r = this.options;
    if (t.type === "mouseout")
      return [];
    if (!i)
      return n.filter((a) => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
    const o = this.chart.getElementsAtEventForMode(t, r.mode, r, s);
    return r.reverse && o.reverse(), o;
  }
  _positionChanged(t, n) {
    const { caretX: s, caretY: i, options: r } = this, o = Yi[r.position].call(this, t, n);
    return o !== !1 && (s !== o.x || i !== o.y);
  }
}
L(Gc, "positioners", Yi);
var uN = {
  id: "tooltip",
  _element: Gc,
  positioners: Yi,
  afterInit(e, t, n) {
    n && (e.tooltip = new Gc({
      chart: e,
      options: n
    }));
  },
  beforeUpdate(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  reset(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const n = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...n,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", n);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const n = t.replay;
      e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: Mb
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, dN = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: CO,
  Decimation: qO,
  Filler: zO,
  Legend: $O,
  SubTitle: nN,
  Title: eN,
  Tooltip: uN
});
const hN = (e, t, n, s) => (typeof t == "string" ? (n = e.push(t) - 1, s.unshift({
  index: n,
  label: t
})) : isNaN(t) && (n = null), n);
function fN(e, t, n, s) {
  const i = e.indexOf(t);
  if (i === -1)
    return hN(e, t, n, s);
  const r = e.lastIndexOf(t);
  return i !== r ? n : i;
}
const pN = (e, t) => e === null ? null : jt(Math.round(e), 0, t);
function wg(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class Kc extends Ds {
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const n = this._addedLabels;
    if (n.length) {
      const s = this.getLabels();
      for (const { index: i, label: r } of n)
        s[i] === r && s.splice(i, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, n) {
    if (ot(t))
      return null;
    const s = this.getLabels();
    return n = isFinite(n) && s[n] === t ? n : fN(s, t, $(n, t), this._addedLabels), pN(n, s.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds();
    let { min: s, max: i } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (s = 0), n || (i = this.getLabels().length - 1)), this.min = s, this.max = i;
  }
  buildTicks() {
    const t = this.min, n = this.max, s = this.options.offset, i = [];
    let r = this.getLabels();
    r = t === 0 && n === r.length - 1 ? r : r.slice(t, n + 1), this._valueRange = Math.max(r.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);
    for (let o = t; o <= n; o++)
      i.push({
        value: o
      });
    return i;
  }
  getLabelForValue(t) {
    return wg.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
L(Kc, "id", "category"), L(Kc, "defaults", {
  ticks: {
    callback: wg
  }
});
function gN(e, t) {
  const n = [], { bounds: i, step: r, min: o, max: a, precision: l, count: c, maxTicks: u, maxDigits: d, includeBounds: h } = e, f = r || 1, p = u - 1, { min: g, max: m } = t, A = !ot(o), w = !ot(a), x = !ot(c), v = (m - g) / (d + 1);
  let C = fp((m - g) / p / f) * f, E, S, M, q;
  if (C < 1e-14 && !A && !w)
    return [
      {
        value: g
      },
      {
        value: m
      }
    ];
  q = Math.ceil(m / C) - Math.floor(g / C), q > p && (C = fp(q * C / p / f) * f), ot(l) || (E = Math.pow(10, l), C = Math.ceil(C * E) / E), i === "ticks" ? (S = Math.floor(g / C) * C, M = Math.ceil(m / C) * C) : (S = g, M = m), A && w && r && c2((a - o) / r, C / 1e3) ? (q = Math.round(Math.min((a - o) / C, u)), C = (a - o) / q, S = o, M = a) : x ? (S = A ? o : S, M = w ? a : M, q = c - 1, C = (M - S) / q) : (q = (M - S) / C, Zi(q, Math.round(q), C / 1e3) ? q = Math.round(q) : q = Math.ceil(q));
  const k = Math.max(pp(C), pp(S));
  E = Math.pow(10, ot(l) ? k : l), S = Math.round(S * E) / E, M = Math.round(M * E) / E;
  let R = 0;
  for (A && (h && S !== o ? (n.push({
    value: o
  }), S < o && R++, Zi(Math.round((S + R * C) * E) / E, o, bg(o, v, e)) && R++) : S < o && R++); R < q; ++R) {
    const D = Math.round((S + R * C) * E) / E;
    if (w && D > a)
      break;
    n.push({
      value: D
    });
  }
  return w && h && M !== a ? n.length && Zi(n[n.length - 1].value, a, bg(a, v, e)) ? n[n.length - 1].value = a : n.push({
    value: a
  }) : (!w || M === a) && n.push({
    value: M
  }), n;
}
function bg(e, t, { horizontal: n, minRotation: s }) {
  const i = Ie(s), r = (n ? Math.sin(i) : Math.cos(i)) || 1e-3, o = 0.75 * t * ("" + e).length;
  return Math.min(t / r, o);
}
class wa extends Ds {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, n) {
    return ot(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: n, maxDefined: s } = this.getUserBounds();
    let { min: i, max: r } = this;
    const o = (l) => i = n ? i : l, a = (l) => r = s ? r : l;
    if (t) {
      const l = Ze(i), c = Ze(r);
      l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0);
    }
    if (i === r) {
      let l = r === 0 ? 1 : Math.abs(r * 0.05);
      a(r + l), t || o(i - l);
    }
    this.min = i, this.max = r;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: n, stepSize: s } = t, i;
    return s ? (i = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, n = t.ticks;
    let s = this.getTickLimit();
    s = Math.max(2, s);
    const i = {
      maxTicks: s,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== !1
    }, r = this._range || this, o = gN(i, r);
    return t.bounds === "ticks" && Nw(o, this, "value"), t.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
  }
  configure() {
    const t = this.ticks;
    let n = this.min, s = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const i = (s - n) / Math.max(t.length - 1, 1) / 2;
      n -= i, s += i;
    }
    this._startValue = n, this._endValue = s, this._valueRange = s - n;
  }
  getLabelForValue(t) {
    return Fr(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class zc extends wa {
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0);
    this.min = Tt(t) ? t : 0, this.max = Tt(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), n = t ? this.width : this.height, s = Ie(this.options.ticks.minRotation), i = (t ? Math.sin(s) : Math.cos(s)) || 1e-3, r = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, r.lineHeight / i));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
L(zc, "id", "linear"), L(zc, "defaults", {
  ticks: {
    callback: za.formatters.numeric
  }
});
const Er = (e) => Math.floor(In(e)), us = (e, t) => Math.pow(10, Er(e) + t);
function xg(e) {
  return e / Math.pow(10, Er(e)) === 1;
}
function vg(e, t, n) {
  const s = Math.pow(10, n), i = Math.floor(e / s);
  return Math.ceil(t / s) - i;
}
function mN(e, t) {
  const n = t - e;
  let s = Er(n);
  for (; vg(e, t, s) > 10; )
    s++;
  for (; vg(e, t, s) < 10; )
    s--;
  return Math.min(s, Er(e));
}
function AN(e, { min: t, max: n }) {
  t = me(e.min, t);
  const s = [], i = Er(t);
  let r = mN(t, n), o = r < 0 ? Math.pow(10, Math.abs(r)) : 1;
  const a = Math.pow(10, r), l = i > r ? Math.pow(10, i) : 0, c = Math.round((t - l) * o) / o, u = Math.floor((t - l) / a / 10) * a * 10;
  let d = Math.floor((c - u) / Math.pow(10, r)), h = me(e.min, Math.round((l + u + d * Math.pow(10, r)) * o) / o);
  for (; h < n; )
    s.push({
      value: h,
      major: xg(h),
      significand: d
    }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (r++, d = 2, o = r >= 0 ? 1 : o), h = Math.round((l + u + d * Math.pow(10, r)) * o) / o;
  const f = me(e.max, h);
  return s.push({
    value: f,
    major: xg(f),
    significand: d
  }), s;
}
class _c extends Ds {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(t, n) {
    const s = wa.prototype.parse.apply(this, [
      t,
      n
    ]);
    if (s === 0) {
      this._zero = !0;
      return;
    }
    return Tt(s) && s > 0 ? s : null;
  }
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0);
    this.min = Tt(t) ? Math.max(0, t) : null, this.max = Tt(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Tt(this._userMin) && (this.min = t === us(this.min, 0) ? us(this.min, -1) : us(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds();
    let s = this.min, i = this.max;
    const r = (a) => s = t ? s : a, o = (a) => i = n ? i : a;
    s === i && (s <= 0 ? (r(1), o(10)) : (r(us(s, -1)), o(us(i, 1)))), s <= 0 && r(us(i, -1)), i <= 0 && o(us(s, 1)), this.min = s, this.max = i;
  }
  buildTicks() {
    const t = this.options, n = {
      min: this._userMin,
      max: this._userMax
    }, s = AN(n, this);
    return t.bounds === "ticks" && Nw(s, this, "value"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
  }
  getLabelForValue(t) {
    return t === void 0 ? "0" : Fr(t, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const t = this.min;
    super.configure(), this._startValue = In(t), this._valueRange = In(this.max) - In(t);
  }
  getPixelForValue(t) {
    return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (In(t) - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    const n = this.getDecimalForPixel(t);
    return Math.pow(10, this._startValue + n * this._valueRange);
  }
}
L(_c, "id", "logarithmic"), L(_c, "defaults", {
  ticks: {
    callback: za.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function Zc(e) {
  const t = e.ticks;
  if (t.display && e.display) {
    const n = $t(t.backdropPadding);
    return $(t.font && t.font.size, Dt.font.size) + n.height;
  }
  return 0;
}
function yN(e, t, n) {
  return n = St(n) ? n : [
    n
  ], {
    w: E2(e, t.string, n),
    h: n.length * t.lineHeight
  };
}
function Cg(e, t, n, s, i) {
  return e === s || e === i ? {
    start: t - n / 2,
    end: t + n / 2
  } : e < s || e > i ? {
    start: t - n,
    end: t
  } : {
    start: t,
    end: t + n
  };
}
function wN(e) {
  const t = {
    l: e.left + e._padding.left,
    r: e.right - e._padding.right,
    t: e.top + e._padding.top,
    b: e.bottom - e._padding.bottom
  }, n = Object.assign({}, t), s = [], i = [], r = e._pointLabels.length, o = e.options.pointLabels, a = o.centerPointLabels ? xt / r : 0;
  for (let l = 0; l < r; l++) {
    const c = o.setContext(e.getPointLabelContext(l));
    i[l] = c.padding;
    const u = e.getPointPosition(l, e.drawingArea + i[l], a), d = Ft(c.font), h = yN(e.ctx, d, e._pointLabels[l]);
    s[l] = h;
    const f = Ae(e.getIndexAngle(l) + a), p = Math.round(Pd(f)), g = Cg(p, u.x, h.w, 0, 180), m = Cg(p, u.y, h.h, 90, 270);
    bN(n, t, f, g, m);
  }
  e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b), e._pointLabelItems = CN(e, s, i);
}
function bN(e, t, n, s, i) {
  const r = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n));
  let a = 0, l = 0;
  s.start < t.l ? (a = (t.l - s.start) / r, e.l = Math.min(e.l, t.l - a)) : s.end > t.r && (a = (s.end - t.r) / r, e.r = Math.max(e.r, t.r + a)), i.start < t.t ? (l = (t.t - i.start) / o, e.t = Math.min(e.t, t.t - l)) : i.end > t.b && (l = (i.end - t.b) / o, e.b = Math.max(e.b, t.b + l));
}
function xN(e, t, n) {
  const s = e.drawingArea, { extra: i, additionalAngle: r, padding: o, size: a } = n, l = e.getPointPosition(t, s + i + o, r), c = Math.round(Pd(Ae(l.angle + It))), u = EN(l.y, a.h, c), d = SN(c), h = MN(l.x, a.w, d);
  return {
    visible: !0,
    x: l.x,
    y: u,
    textAlign: d,
    left: h,
    top: u,
    right: h + a.w,
    bottom: u + a.h
  };
}
function vN(e, t) {
  if (!t)
    return !0;
  const { left: n, top: s, right: i, bottom: r } = e;
  return !(fn({
    x: n,
    y: s
  }, t) || fn({
    x: n,
    y: r
  }, t) || fn({
    x: i,
    y: s
  }, t) || fn({
    x: i,
    y: r
  }, t));
}
function CN(e, t, n) {
  const s = [], i = e._pointLabels.length, r = e.options, { centerPointLabels: o, display: a } = r.pointLabels, l = {
    extra: Zc(r) / 2,
    additionalAngle: o ? xt / i : 0
  };
  let c;
  for (let u = 0; u < i; u++) {
    l.padding = n[u], l.size = t[u];
    const d = xN(e, u, l);
    s.push(d), a === "auto" && (d.visible = vN(d, c), d.visible && (c = d));
  }
  return s;
}
function SN(e) {
  return e === 0 || e === 180 ? "center" : e < 180 ? "left" : "right";
}
function MN(e, t, n) {
  return n === "right" ? e -= t : n === "center" && (e -= t / 2), e;
}
function EN(e, t, n) {
  return n === 90 || n === 270 ? e -= t / 2 : (n > 270 || n < 90) && (e -= t), e;
}
function qN(e, t, n) {
  const { left: s, top: i, right: r, bottom: o } = n, { backdropColor: a } = t;
  if (!ot(a)) {
    const l = bs(t.borderRadius), c = $t(t.backdropPadding);
    e.fillStyle = a;
    const u = s - c.left, d = i - c.top, h = r - s + c.width, f = o - i + c.height;
    Object.values(l).some((p) => p !== 0) ? (e.beginPath(), Sr(e, {
      x: u,
      y: d,
      w: h,
      h: f,
      radius: l
    }), e.fill()) : e.fillRect(u, d, h, f);
  }
}
function RN(e, t) {
  const { ctx: n, options: { pointLabels: s } } = e;
  for (let i = t - 1; i >= 0; i--) {
    const r = e._pointLabelItems[i];
    if (!r.visible)
      continue;
    const o = s.setContext(e.getPointLabelContext(i));
    qN(n, o, r);
    const a = Ft(o.font), { x: l, y: c, textAlign: u } = r;
    Rs(n, e._pointLabels[i], l, c + a.lineHeight / 2, a, {
      color: o.color,
      textAlign: u,
      textBaseline: "middle"
    });
  }
}
function Eb(e, t, n, s) {
  const { ctx: i } = e;
  if (n)
    i.arc(e.xCenter, e.yCenter, t, 0, bt);
  else {
    let r = e.getPointPosition(0, t);
    i.moveTo(r.x, r.y);
    for (let o = 1; o < s; o++)
      r = e.getPointPosition(o, t), i.lineTo(r.x, r.y);
  }
}
function kN(e, t, n, s, i) {
  const r = e.ctx, o = t.circular, { color: a, lineWidth: l } = t;
  !o && !s || !a || !l || n < 0 || (r.save(), r.strokeStyle = a, r.lineWidth = l, r.setLineDash(i.dash), r.lineDashOffset = i.dashOffset, r.beginPath(), Eb(e, n, o, s), r.closePath(), r.stroke(), r.restore());
}
function TN(e, t, n) {
  return es(e, {
    label: n,
    index: t,
    type: "pointLabel"
  });
}
class Wi extends wa {
  constructor(t) {
    super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const t = this._padding = $t(Zc(this.options) / 2), n = this.width = this.maxWidth - t.width, s = this.height = this.maxHeight - t.height;
    this.xCenter = Math.floor(this.left + n / 2 + t.left), this.yCenter = Math.floor(this.top + s / 2 + t.top), this.drawingArea = Math.floor(Math.min(n, s) / 2);
  }
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!1);
    this.min = Tt(t) && !isNaN(t) ? t : 0, this.max = Tt(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / Zc(this.options));
  }
  generateTickLabels(t) {
    wa.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((n, s) => {
      const i = mt(this.options.pointLabels.callback, [
        n,
        s
      ], this);
      return i || i === 0 ? i : "";
    }).filter((n, s) => this.chart.getDataVisibility(s));
  }
  fit() {
    const t = this.options;
    t.display && t.pointLabels.display ? wN(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(t, n, s, i) {
    this.xCenter += Math.floor((t - n) / 2), this.yCenter += Math.floor((s - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, n, s, i));
  }
  getIndexAngle(t) {
    const n = bt / (this._pointLabels.length || 1), s = this.options.startAngle || 0;
    return Ae(t * n + Ie(s));
  }
  getDistanceFromCenterForValue(t) {
    if (ot(t))
      return NaN;
    const n = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - t) * n : (t - this.min) * n;
  }
  getValueForDistanceFromCenter(t) {
    if (ot(t))
      return NaN;
    const n = t / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - n : this.min + n;
  }
  getPointLabelContext(t) {
    const n = this._pointLabels || [];
    if (t >= 0 && t < n.length) {
      const s = n[t];
      return TN(this.getContext(), t, s);
    }
  }
  getPointPosition(t, n, s = 0) {
    const i = this.getIndexAngle(t) - It + s;
    return {
      x: Math.cos(i) * n + this.xCenter,
      y: Math.sin(i) * n + this.yCenter,
      angle: i
    };
  }
  getPointPositionForValue(t, n) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(n));
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue());
  }
  getPointLabelPosition(t) {
    const { left: n, top: s, right: i, bottom: r } = this._pointLabelItems[t];
    return {
      left: n,
      top: s,
      right: i,
      bottom: r
    };
  }
  drawBackground() {
    const { backgroundColor: t, grid: { circular: n } } = this.options;
    if (t) {
      const s = this.ctx;
      s.save(), s.beginPath(), Eb(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), s.closePath(), s.fillStyle = t, s.fill(), s.restore();
    }
  }
  drawGrid() {
    const t = this.ctx, n = this.options, { angleLines: s, grid: i, border: r } = n, o = this._pointLabels.length;
    let a, l, c;
    if (n.pointLabels.display && RN(this, o), i.display && this.ticks.forEach((u, d) => {
      if (d !== 0 || d === 0 && this.min < 0) {
        l = this.getDistanceFromCenterForValue(u.value);
        const h = this.getContext(d), f = i.setContext(h), p = r.setContext(h);
        kN(this, f, l, o, p);
      }
    }), s.display) {
      for (t.save(), a = o - 1; a >= 0; a--) {
        const u = s.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: h } = u;
        !h || !d || (t.lineWidth = h, t.strokeStyle = d, t.setLineDash(u.borderDash), t.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(n.reverse ? this.min : this.max), c = this.getPointPosition(a, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(c.x, c.y), t.stroke());
      }
      t.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const t = this.ctx, n = this.options, s = n.ticks;
    if (!s.display)
      return;
    const i = this.getIndexAngle(0);
    let r, o;
    t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(i), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((a, l) => {
      if (l === 0 && this.min >= 0 && !n.reverse)
        return;
      const c = s.setContext(this.getContext(l)), u = Ft(c.font);
      if (r = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
        t.font = u.string, o = t.measureText(a.label).width, t.fillStyle = c.backdropColor;
        const d = $t(c.backdropPadding);
        t.fillRect(-o / 2 - d.left, -r - u.size / 2 - d.top, o + d.width, u.size + d.height);
      }
      Rs(t, a.label, 0, -r, u, {
        color: c.color,
        strokeColor: c.textStrokeColor,
        strokeWidth: c.textStrokeWidth
      });
    }), t.restore();
  }
  drawTitle() {
  }
}
L(Wi, "id", "radialLinear"), L(Wi, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: za.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(t) {
      return t;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), L(Wi, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), L(Wi, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const Ja = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, ue = /* @__PURE__ */ Object.keys(Ja);
function Sg(e, t) {
  return e - t;
}
function Mg(e, t) {
  if (ot(t))
    return null;
  const n = e._adapter, { parser: s, round: i, isoWeekday: r } = e._parseOpts;
  let o = t;
  return typeof s == "function" && (o = s(o)), Tt(o) || (o = typeof s == "string" ? n.parse(o, s) : n.parse(o)), o === null ? null : (i && (o = i === "week" && (ai(r) || r === !0) ? n.startOf(o, "isoWeek", r) : n.startOf(o, i)), +o);
}
function Eg(e, t, n, s) {
  const i = ue.length;
  for (let r = ue.indexOf(e); r < i - 1; ++r) {
    const o = Ja[ue[r]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
    if (o.common && Math.ceil((n - t) / (a * o.size)) <= s)
      return ue[r];
  }
  return ue[i - 1];
}
function DN(e, t, n, s, i) {
  for (let r = ue.length - 1; r >= ue.indexOf(n); r--) {
    const o = ue[r];
    if (Ja[o].common && e._adapter.diff(i, s, o) >= t - 1)
      return o;
  }
  return ue[n ? ue.indexOf(n) : 0];
}
function BN(e) {
  for (let t = ue.indexOf(e) + 1, n = ue.length; t < n; ++t)
    if (Ja[ue[t]].common)
      return ue[t];
}
function qg(e, t, n) {
  if (!n)
    e[t] = !0;
  else if (n.length) {
    const { lo: s, hi: i } = Od(n, t), r = n[s] >= t ? n[s] : n[i];
    e[r] = !0;
  }
}
function IN(e, t, n, s) {
  const i = e._adapter, r = +i.startOf(t[0].value, s), o = t[t.length - 1].value;
  let a, l;
  for (a = r; a <= o; a = +i.add(a, 1, s))
    l = n[a], l >= 0 && (t[l].major = !0);
  return t;
}
function Rg(e, t, n) {
  const s = [], i = {}, r = t.length;
  let o, a;
  for (o = 0; o < r; ++o)
    a = t[o], i[a] = o, s.push({
      value: a,
      major: !1
    });
  return r === 0 || !n ? s : IN(e, s, i, n);
}
class qr extends Ds {
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, n = {}) {
    const s = t.time || (t.time = {}), i = this._adapter = new YI._date(t.adapters.date);
    i.init(n), _i(s.displayFormats, i.formats()), this._parseOpts = {
      parser: s.parser,
      round: s.round,
      isoWeekday: s.isoWeekday
    }, super.init(t), this._normalized = n.normalized;
  }
  parse(t, n) {
    return t === void 0 ? null : Mg(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, n = this._adapter, s = t.time.unit || "day";
    let { min: i, max: r, minDefined: o, maxDefined: a } = this.getUserBounds();
    function l(c) {
      !o && !isNaN(c.min) && (i = Math.min(i, c.min)), !a && !isNaN(c.max) && (r = Math.max(r, c.max));
    }
    (!o || !a) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), i = Tt(i) && !isNaN(i) ? i : +n.startOf(Date.now(), s), r = Tt(r) && !isNaN(r) ? r : +n.endOf(Date.now(), s) + 1, this.min = Math.min(i, r - 1), this.max = Math.max(i + 1, r);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    return t.length && (n = t[0], s = t[t.length - 1]), {
      min: n,
      max: s
    };
  }
  buildTicks() {
    const t = this.options, n = t.time, s = t.ticks, i = s.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]);
    const r = this.min, o = this.max, a = f2(i, r, o);
    return this._unit = n.unit || (s.autoSkip ? Eg(n.minUnit, this.min, this.max, this._getLabelCapacity(r)) : DN(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === "year" ? void 0 : BN(this._unit), this.initOffsets(i), t.reverse && a.reverse(), Rg(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let n = 0, s = 0, i, r;
    this.options.offset && t.length && (i = this.getDecimalForValue(t[0]), t.length === 1 ? n = 1 - i : n = (this.getDecimalForValue(t[1]) - i) / 2, r = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = r : s = (r - this.getDecimalForValue(t[t.length - 2])) / 2);
    const o = t.length < 3 ? 0.5 : 0.25;
    n = jt(n, 0, o), s = jt(s, 0, o), this._offsets = {
      start: n,
      end: s,
      factor: 1 / (n + 1 + s)
    };
  }
  _generate() {
    const t = this._adapter, n = this.min, s = this.max, i = this.options, r = i.time, o = r.unit || Eg(r.minUnit, n, s, this._getLabelCapacity(n)), a = $(i.ticks.stepSize, 1), l = o === "week" ? r.isoWeekday : !1, c = ai(l) || l === !0, u = {};
    let d = n, h, f;
    if (c && (d = +t.startOf(d, "isoWeek", l)), d = +t.startOf(d, c ? "day" : o), t.diff(s, n, o) > 1e5 * a)
      throw new Error(n + " and " + s + " are too far apart with stepSize of " + a + " " + o);
    const p = i.ticks.source === "data" && this.getDataTimestamps();
    for (h = d, f = 0; h < s; h = +t.add(h, a, o), f++)
      qg(u, h, p);
    return (h === s || i.bounds === "ticks" || f === 1) && qg(u, h, p), Object.keys(u).sort(Sg).map((g) => +g);
  }
  getLabelForValue(t) {
    const n = this._adapter, s = this.options.time;
    return s.tooltipFormat ? n.format(t, s.tooltipFormat) : n.format(t, s.displayFormats.datetime);
  }
  format(t, n) {
    const i = this.options.time.displayFormats, r = this._unit, o = n || i[r];
    return this._adapter.format(t, o);
  }
  _tickFormatFunction(t, n, s, i) {
    const r = this.options, o = r.ticks.callback;
    if (o)
      return mt(o, [
        t,
        n,
        s
      ], this);
    const a = r.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && a[l], d = c && a[c], h = s[n], f = c && d && h && h.major;
    return this._adapter.format(t, i || (f ? d : u));
  }
  generateTickLabels(t) {
    let n, s, i;
    for (n = 0, s = t.length; n < s; ++n)
      i = t[n], i.label = this._tickFormatFunction(i.value, n, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const n = this._offsets, s = this.getDecimalForValue(t);
    return this.getPixelForDecimal((n.start + s) * n.factor);
  }
  getValueForPixel(t) {
    const n = this._offsets, s = this.getDecimalForPixel(t) / n.factor - n.end;
    return this.min + s * (this.max - this.min);
  }
  _getLabelSize(t) {
    const n = this.options.ticks, s = this.ctx.measureText(t).width, i = Ie(this.isHorizontal() ? n.maxRotation : n.minRotation), r = Math.cos(i), o = Math.sin(i), a = this._resolveTickFontOptions(0).size;
    return {
      w: s * r + a * o,
      h: s * o + a * r
    };
  }
  _getLabelCapacity(t) {
    const n = this.options.time, s = n.displayFormats, i = s[n.unit] || s.millisecond, r = this._tickFormatFunction(t, 0, Rg(this, [
      t
    ], this._majorUnit), i), o = this._getLabelSize(r), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], n, s;
    if (t.length)
      return t;
    const i = this.getMatchingVisibleMetas();
    if (this._normalized && i.length)
      return this._cache.data = i[0].controller.getAllParsedValues(this);
    for (n = 0, s = i.length; n < s; ++n)
      t = t.concat(i[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let n, s;
    if (t.length)
      return t;
    const i = this.getLabels();
    for (n = 0, s = i.length; n < s; ++n)
      t.push(Mg(this, i[n]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return jw(t.sort(Sg));
  }
}
L(qr, "id", "time"), L(qr, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function xo(e, t, n) {
  let s = 0, i = e.length - 1, r, o, a, l;
  n ? (t >= e[s].pos && t <= e[i].pos && ({ lo: s, hi: i } = hn(e, "pos", t)), { pos: r, time: a } = e[s], { pos: o, time: l } = e[i]) : (t >= e[s].time && t <= e[i].time && ({ lo: s, hi: i } = hn(e, "time", t)), { time: r, pos: a } = e[s], { time: o, pos: l } = e[i]);
  const c = o - r;
  return c ? a + (l - a) * (t - r) / c : a;
}
class Hc extends qr {
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(t);
    this._minPos = xo(n, this.min), this._tableRange = xo(n, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: n, max: s } = this, i = [], r = [];
    let o, a, l, c, u;
    for (o = 0, a = t.length; o < a; ++o)
      c = t[o], c >= n && c <= s && i.push(c);
    if (i.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: s,
          pos: 1
        }
      ];
    for (o = 0, a = i.length; o < a; ++o)
      u = i[o + 1], l = i[o - 1], c = i[o], Math.round((u + l) / 2) !== c && r.push({
        time: c,
        pos: o / (a - 1)
      });
    return r;
  }
  _generate() {
    const t = this.min, n = this.max;
    let s = super.getDataTimestamps();
    return (!s.includes(t) || !s.length) && s.splice(0, 0, t), (!s.includes(n) || s.length === 1) && s.push(n), s.sort((i, r) => i - r);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const n = this.getDataTimestamps(), s = this.getLabelTimestamps();
    return n.length && s.length ? t = this.normalize(n.concat(s)) : t = n.length ? n : s, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (xo(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const n = this._offsets, s = this.getDecimalForPixel(t) / n.factor - n.end;
    return xo(this._table, s * this._tableRange + this._minPos, !0);
  }
}
L(Hc, "id", "timeseries"), L(Hc, "defaults", qr.defaults);
var PN = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: Kc,
  LinearScale: zc,
  LogarithmicScale: _c,
  RadialLinearScale: Wi,
  TimeScale: qr,
  TimeSeriesScale: Hc
});
const ON = [
  UI,
  AO,
  dN,
  PN
];
cn.register(...ON);
const kg = {
  profit: [0],
  wins: 0,
  losses: 0,
  history: []
}, Xa = Ta((e) => ({
  ...kg,
  updateProfitData: (t, n) => e((s) => {
    const r = s.profit[s.profit.length - 1] + t;
    return {
      profit: [...s.profit, r],
      wins: n ? s.wins + 1 : s.wins,
      losses: n ? s.losses : s.losses + 1,
      history: [...s.history, t]
    };
  }),
  resetProfitData: () => e(kg)
})), qb = () => {
  const { selectedCurrency: e } = ze();
  return ce((n) => new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: e.currencyCode,
    minimumFractionDigits: e.fractionalDigits,
    maximumFractionDigits: e.fractionalDigits
  }).format(n), [e]);
}, Tg = "rgb(74, 222, 128)", Dg = "rgb(248, 113, 113)";
function NN() {
  const { profit: e, wins: t, losses: n } = Xa(), s = qb(), i = e.length > 0 ? e[e.length - 1] : 0;
  return /* @__PURE__ */ y.jsxs("div", { className: "flex rounded-md bg-slate-900 p-4 text-sm", children: [
    /* @__PURE__ */ y.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ y.jsx("p", { className: "font-medium text-slate-400", children: "Profit" }),
      /* @__PURE__ */ y.jsx(
        "p",
        {
          className: `font-semibold tabular-nums ${i >= 0 ? "text-green-400" : "text-red-400"}`,
          children: s(i)
        }
      )
    ] }),
    /* @__PURE__ */ y.jsx("div", { className: "mx-4 w-0.5 bg-slate-600", "aria-hidden": !0 }),
    /* @__PURE__ */ y.jsxs("div", { className: "flex-1 space-y-2", children: [
      /* @__PURE__ */ y.jsxs("div", { children: [
        /* @__PURE__ */ y.jsx("p", { className: "font-medium text-slate-400", children: "Wins" }),
        /* @__PURE__ */ y.jsx("p", { className: "font-semibold tabular-nums text-green-400", children: t })
      ] }),
      /* @__PURE__ */ y.jsxs("div", { children: [
        /* @__PURE__ */ y.jsx("p", { className: "font-medium text-slate-400", children: "Losses" }),
        /* @__PURE__ */ y.jsx("p", { className: "font-semibold tabular-nums text-red-400", children: n })
      ] })
    ] })
  ] });
}
function LN() {
  const e = fe(null), t = fe(null), [n, s] = ie(null), { profit: i } = Xa(), r = qb();
  return Lt(() => {
    if (e.current) {
      const o = e.current.getContext("2d");
      o && (t.current && t.current.destroy(), t.current = new cn(o, {
        type: "line",
        data: {
          labels: i,
          datasets: [
            {
              label: "Profit",
              data: i,
              fill: {
                target: "origin",
                above: "rgba(74, 222, 128, 0.3)",
                below: "rgba(248, 113, 113, 0.3)"
              },
              segment: {
                borderColor: (a) => {
                  const l = a.p0.parsed.y, c = a.p1.parsed.y;
                  return c === 0 ? l < 0 ? Dg : Tg : c < 0 ? Dg : Tg;
                }
              },
              tension: 0.1,
              pointRadius: 0,
              pointHoverRadius: 6,
              pointHoverBackgroundColor: "white",
              pointHoverBorderColor: "white",
              pointHoverBorderWidth: 3
            }
          ]
        },
        options: {
          responsive: !0,
          bezierCurve: !0,
          maintainAspectRatio: !1,
          animations: {
            y: {
              duration: 0
            }
          },
          plugins: {
            legend: { display: !1 },
            tooltip: { enabled: !1 }
          },
          scales: {
            x: {
              border: { display: !1 },
              grid: { display: !1 },
              ticks: { display: !1 }
            },
            y: {
              border: { display: !1 },
              grid: { display: !1 },
              ticks: { display: !1 },
              grace: "1%"
            }
          },
          onHover: (a, l) => {
            if (l.length) {
              const c = l[0].index;
              s(i[c]);
            }
          },
          interaction: {
            intersect: !1,
            mode: "index"
          }
        }
      }));
    }
    return () => {
      t.current && t.current.destroy();
    };
  }, [i]), /* @__PURE__ */ y.jsxs("div", { className: "relative mt-4 rounded-md bg-slate-900 p-4 text-sm", children: [
    /* @__PURE__ */ y.jsx("p", { className: "font-medium text-slate-400", children: "Profit History" }),
    n !== null && /* @__PURE__ */ y.jsx(
      "p",
      {
        className: `absolute top-4 right-4 font-semibold tabular-nums ${n >= 0 ? "text-green-400" : "text-red-400"}`,
        children: r(n)
      }
    ),
    /* @__PURE__ */ y.jsx("div", { className: "mt-6 h-44 w-64", children: /* @__PURE__ */ y.jsx("canvas", { ref: e }) }),
    /* @__PURE__ */ y.jsx("div", { id: "chartjs-tooltip", className: "hidden" })
  ] });
}
function FN({
  isLiveStatsOpen: e,
  setLiveStatsOpen: t
}) {
  const { resetProfitData: n } = Xa();
  return /* @__PURE__ */ y.jsx(y.Fragment, { children: e && /* @__PURE__ */ y.jsxs("div", { className: "absolute z-20 bottom-16 right-4 w-80 rounded-lg bg-gray-800 shadow-lg", children: [
    /* @__PURE__ */ y.jsxs("div", { className: "flex items-center justify-between p-4 text-white", children: [
      /* @__PURE__ */ y.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ y.jsx(m0, { className: "mr-2 h-5 w-5" }),
        /* @__PURE__ */ y.jsx("h2", { className: "text-sm font-medium", children: "Live Stats" })
      ] }),
      /* @__PURE__ */ y.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ y.jsx(RB, { children: /* @__PURE__ */ y.jsxs(kB, { children: [
          /* @__PURE__ */ y.jsx(TB, { asChild: !0, children: /* @__PURE__ */ y.jsx(
            se,
            {
              variant: "ghost",
              size: "icon",
              onClick: n,
              className: "mr-2 text-gray-400 hover:bg-gray-700 hover:text-white",
              children: /* @__PURE__ */ y.jsx(zq, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ y.jsx(Tw, { children: /* @__PURE__ */ y.jsx("p", { children: "Reset Live Stats" }) })
        ] }) }),
        /* @__PURE__ */ y.jsx(
          se,
          {
            variant: "ghost",
            size: "icon",
            onClick: () => t(!1),
            className: "text-gray-400 hover:bg-gray-700 hover:text-white",
            children: /* @__PURE__ */ y.jsx(Jq, { className: "h-4 w-4" })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ y.jsxs("div", { className: "p-4", children: [
      /* @__PURE__ */ y.jsx(NN, {}),
      /* @__PURE__ */ y.jsx(LN, {})
    ] })
  ] }) });
}
const jN = () => {
  const e = Math.floor(Math.random() * 4), t = Math.random() * window.innerWidth;
  switch (e) {
    case 0:
      return { x: t, y: 0, angle: 45 };
    case 1:
      return { x: window.innerWidth, y: t, angle: 135 };
    case 2:
      return { x: t, y: window.innerHeight, angle: 225 };
    case 3:
      return { x: 0, y: t, angle: 315 };
    default:
      return { x: 0, y: 0, angle: 45 };
  }
}, VN = ({
  minSpeed: e = 10,
  maxSpeed: t = 30,
  minDelay: n = 1200,
  maxDelay: s = 4200,
  starColor: i = "#9E00FF",
  trailColor: r = "#2EB9DF",
  starWidth: o = 10,
  starHeight: a = 1,
  className: l
}) => {
  const [c, u] = ie(null), d = fe(null);
  return Lt(() => {
    const h = () => {
      const { x: f, y: p, angle: g } = jN(), m = {
        id: Date.now(),
        x: f,
        y: p,
        angle: g,
        scale: 1,
        speed: Math.random() * (t - e) + e,
        distance: 0
      };
      u(m);
      const A = Math.random() * (s - n) + n;
      setTimeout(h, A);
    };
    return h(), () => {
    };
  }, [e, t, n, s]), Lt(() => {
    const f = requestAnimationFrame(() => {
      c && u((p) => {
        if (!p) return null;
        const g = p.x + p.speed * Math.cos(p.angle * Math.PI / 180), m = p.y + p.speed * Math.sin(p.angle * Math.PI / 180), A = p.distance + p.speed, w = 1 + A / 100;
        return g < -20 || g > window.innerWidth + 20 || m < -20 || m > window.innerHeight + 20 ? null : {
          ...p,
          x: g,
          y: m,
          distance: A,
          scale: w
        };
      });
    });
    return () => cancelAnimationFrame(f);
  }, [c]), /* @__PURE__ */ y.jsxs(
    "svg",
    {
      ref: d,
      className: At("w-full h-full absolute inset-0", l),
      children: [
        c && /* @__PURE__ */ y.jsx(
          "rect",
          {
            x: c.x,
            y: c.y,
            width: o * c.scale,
            height: a,
            fill: "url(#gradient)",
            transform: `rotate(${c.angle}, ${c.x + o * c.scale / 2}, ${c.y + a / 2})`
          },
          c.id
        ),
        /* @__PURE__ */ y.jsx("defs", { children: /* @__PURE__ */ y.jsxs("linearGradient", { id: "gradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
          /* @__PURE__ */ y.jsx("stop", { offset: "0%", style: { stopColor: r, stopOpacity: 0 } }),
          /* @__PURE__ */ y.jsx(
            "stop",
            {
              offset: "100%",
              style: { stopColor: i, stopOpacity: 1 }
            }
          )
        ] }) })
      ]
    }
  );
}, UN = ({
  starDensity: e = 15e-5,
  allStarsTwinkle: t = !0,
  twinkleProbability: n = 0.7,
  minTwinkleSpeed: s = 0.5,
  maxTwinkleSpeed: i = 1,
  className: r
}) => {
  const [o, a] = ie([]), l = fe(null), c = ce(
    (u, d) => {
      const h = u * d, f = Math.floor(h * e);
      return Array.from({ length: f }, () => {
        const p = t || Math.random() < n;
        return {
          x: Math.random() * u,
          y: Math.random() * d,
          radius: Math.random() * 0.05 + 0.5,
          opacity: Math.random() * 0.5 + 0.5,
          twinkleSpeed: p ? s + Math.random() * (i - s) : null
        };
      });
    },
    [
      e,
      t,
      n,
      s,
      i
    ]
  );
  return Lt(() => {
    const u = () => {
      if (l.current) {
        const h = l.current;
        if (!h.getContext("2d")) return;
        const { width: p, height: g } = h.getBoundingClientRect();
        h.width = p, h.height = g, a(c(p, g));
      }
    };
    u();
    const d = new ResizeObserver(u);
    return l.current && d.observe(l.current), () => {
      l.current && d.unobserve(l.current);
    };
  }, [
    e,
    t,
    n,
    s,
    i,
    c
  ]), Lt(() => {
    const u = l.current;
    if (!u) return;
    const d = u.getContext("2d");
    if (!d) return;
    let h;
    const f = () => {
      d.clearRect(0, 0, u.width, u.height), o.forEach((p) => {
        d.beginPath(), d.arc(p.x, p.y, p.radius, 0, Math.PI * 2), d.fillStyle = `rgba(255, 255, 255, ${p.opacity})`, d.fill(), p.twinkleSpeed !== null && (p.opacity = 0.5 + Math.abs(Math.sin(Date.now() * 1e-3 / p.twinkleSpeed) * 0.5));
      }), h = requestAnimationFrame(f);
    };
    return f(), () => {
      cancelAnimationFrame(h);
    };
  }, [o]), /* @__PURE__ */ y.jsx(
    "canvas",
    {
      ref: l,
      className: At("h-full w-full absolute inset-0", r)
    }
  );
};
function Rb(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: YN } = Object.prototype, { getPrototypeOf: zd } = Object, $a = /* @__PURE__ */ ((e) => (t) => {
  const n = YN.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ve = (e) => (e = e.toLowerCase(), (t) => $a(t) === e), tl = (e) => (t) => typeof t === e, { isArray: yi } = Array, Rr = tl("undefined");
function WN(e) {
  return e !== null && !Rr(e) && e.constructor !== null && !Rr(e.constructor) && ve(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const kb = Ve("ArrayBuffer");
function QN(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && kb(e.buffer), t;
}
const GN = tl("string"), ve = tl("function"), Tb = tl("number"), el = (e) => e !== null && typeof e == "object", KN = (e) => e === !0 || e === !1, Uo = (e) => {
  if ($a(e) !== "object")
    return !1;
  const t = zd(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, zN = Ve("Date"), _N = Ve("File"), ZN = Ve("Blob"), HN = Ve("FileList"), JN = (e) => el(e) && ve(e.pipe), XN = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || ve(e.append) && ((t = $a(e)) === "formdata" || // detect form-data instance
  t === "object" && ve(e.toString) && e.toString() === "[object FormData]"));
}, $N = Ve("URLSearchParams"), [tL, eL, nL, sL] = ["ReadableStream", "Request", "Response", "Headers"].map(Ve), iL = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Vr(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let s, i;
  if (typeof e != "object" && (e = [e]), yi(e))
    for (s = 0, i = e.length; s < i; s++)
      t.call(null, e[s], s, e);
  else {
    const r = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = r.length;
    let a;
    for (s = 0; s < o; s++)
      a = r[s], t.call(null, e[a], a, e);
  }
}
function Db(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let s = n.length, i;
  for (; s-- > 0; )
    if (i = n[s], t === i.toLowerCase())
      return i;
  return null;
}
const As = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Bb = (e) => !Rr(e) && e !== As;
function Jc() {
  const { caseless: e } = Bb(this) && this || {}, t = {}, n = (s, i) => {
    const r = e && Db(t, i) || i;
    Uo(t[r]) && Uo(s) ? t[r] = Jc(t[r], s) : Uo(s) ? t[r] = Jc({}, s) : yi(s) ? t[r] = s.slice() : t[r] = s;
  };
  for (let s = 0, i = arguments.length; s < i; s++)
    arguments[s] && Vr(arguments[s], n);
  return t;
}
const rL = (e, t, n, { allOwnKeys: s } = {}) => (Vr(t, (i, r) => {
  n && ve(i) ? e[r] = Rb(i, n) : e[r] = i;
}, { allOwnKeys: s }), e), oL = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), aL = (e, t, n, s) => {
  e.prototype = Object.create(t.prototype, s), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, lL = (e, t, n, s) => {
  let i, r, o;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), r = i.length; r-- > 0; )
      o = i[r], (!s || s(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = n !== !1 && zd(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, cL = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const s = e.indexOf(t, n);
  return s !== -1 && s === n;
}, uL = (e) => {
  if (!e) return null;
  if (yi(e)) return e;
  let t = e.length;
  if (!Tb(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, dL = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && zd(Uint8Array)), hL = (e, t) => {
  const s = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = s.next()) && !i.done; ) {
    const r = i.value;
    t.call(e, r[0], r[1]);
  }
}, fL = (e, t) => {
  let n;
  const s = [];
  for (; (n = e.exec(t)) !== null; )
    s.push(n);
  return s;
}, pL = Ve("HTMLFormElement"), gL = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, s, i) {
    return s.toUpperCase() + i;
  }
), Bg = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), mL = Ve("RegExp"), Ib = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), s = {};
  Vr(n, (i, r) => {
    let o;
    (o = t(i, r, e)) !== !1 && (s[r] = o || i);
  }), Object.defineProperties(e, s);
}, AL = (e) => {
  Ib(e, (t, n) => {
    if (ve(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const s = e[n];
    if (ve(s)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, yL = (e, t) => {
  const n = {}, s = (i) => {
    i.forEach((r) => {
      n[r] = !0;
    });
  };
  return yi(e) ? s(e) : s(String(e).split(t)), n;
}, wL = () => {
}, bL = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, Kl = "abcdefghijklmnopqrstuvwxyz", Ig = "0123456789", Pb = {
  DIGIT: Ig,
  ALPHA: Kl,
  ALPHA_DIGIT: Kl + Kl.toUpperCase() + Ig
}, xL = (e = 16, t = Pb.ALPHA_DIGIT) => {
  let n = "";
  const { length: s } = t;
  for (; e--; )
    n += t[Math.random() * s | 0];
  return n;
};
function vL(e) {
  return !!(e && ve(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const CL = (e) => {
  const t = new Array(10), n = (s, i) => {
    if (el(s)) {
      if (t.indexOf(s) >= 0)
        return;
      if (!("toJSON" in s)) {
        t[i] = s;
        const r = yi(s) ? [] : {};
        return Vr(s, (o, a) => {
          const l = n(o, i + 1);
          !Rr(l) && (r[a] = l);
        }), t[i] = void 0, r;
      }
    }
    return s;
  };
  return n(e, 0);
}, SL = Ve("AsyncFunction"), ML = (e) => e && (el(e) || ve(e)) && ve(e.then) && ve(e.catch), Ob = ((e, t) => e ? setImmediate : t ? ((n, s) => (As.addEventListener("message", ({ source: i, data: r }) => {
  i === As && r === n && s.length && s.shift()();
}, !1), (i) => {
  s.push(i), As.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  ve(As.postMessage)
), EL = typeof queueMicrotask < "u" ? queueMicrotask.bind(As) : typeof process < "u" && process.nextTick || Ob, T = {
  isArray: yi,
  isArrayBuffer: kb,
  isBuffer: WN,
  isFormData: XN,
  isArrayBufferView: QN,
  isString: GN,
  isNumber: Tb,
  isBoolean: KN,
  isObject: el,
  isPlainObject: Uo,
  isReadableStream: tL,
  isRequest: eL,
  isResponse: nL,
  isHeaders: sL,
  isUndefined: Rr,
  isDate: zN,
  isFile: _N,
  isBlob: ZN,
  isRegExp: mL,
  isFunction: ve,
  isStream: JN,
  isURLSearchParams: $N,
  isTypedArray: dL,
  isFileList: HN,
  forEach: Vr,
  merge: Jc,
  extend: rL,
  trim: iL,
  stripBOM: oL,
  inherits: aL,
  toFlatObject: lL,
  kindOf: $a,
  kindOfTest: Ve,
  endsWith: cL,
  toArray: uL,
  forEachEntry: hL,
  matchAll: fL,
  isHTMLForm: pL,
  hasOwnProperty: Bg,
  hasOwnProp: Bg,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Ib,
  freezeMethods: AL,
  toObjectSet: yL,
  toCamelCase: gL,
  noop: wL,
  toFiniteNumber: bL,
  findKey: Db,
  global: As,
  isContextDefined: Bb,
  ALPHABET: Pb,
  generateString: xL,
  isSpecCompliantForm: vL,
  toJSONObject: CL,
  isAsyncFn: SL,
  isThenable: ML,
  setImmediate: Ob,
  asap: EL
};
function X(e, t, n, s, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), s && (this.request = s), i && (this.response = i, this.status = i.status ? i.status : null);
}
T.inherits(X, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: T.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Nb = X.prototype, Lb = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  Lb[e] = { value: e };
});
Object.defineProperties(X, Lb);
Object.defineProperty(Nb, "isAxiosError", { value: !0 });
X.from = (e, t, n, s, i, r) => {
  const o = Object.create(Nb);
  return T.toFlatObject(e, o, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), X.call(o, e.message, t, n, s, i), o.cause = e, o.name = e.name, r && Object.assign(o, r), o;
};
const qL = null;
function Xc(e) {
  return T.isPlainObject(e) || T.isArray(e);
}
function Fb(e) {
  return T.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Pg(e, t, n) {
  return e ? e.concat(t).map(function(i, r) {
    return i = Fb(i), !n && r ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function RL(e) {
  return T.isArray(e) && !e.some(Xc);
}
const kL = T.toFlatObject(T, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function nl(e, t, n) {
  if (!T.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = T.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, m) {
    return !T.isUndefined(m[g]);
  });
  const s = n.metaTokens, i = n.visitor || u, r = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && T.isSpecCompliantForm(t);
  if (!T.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(p) {
    if (p === null) return "";
    if (T.isDate(p))
      return p.toISOString();
    if (!l && T.isBlob(p))
      throw new X("Blob is not supported. Use a Buffer instead.");
    return T.isArrayBuffer(p) || T.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function u(p, g, m) {
    let A = p;
    if (p && !m && typeof p == "object") {
      if (T.endsWith(g, "{}"))
        g = s ? g : g.slice(0, -2), p = JSON.stringify(p);
      else if (T.isArray(p) && RL(p) || (T.isFileList(p) || T.endsWith(g, "[]")) && (A = T.toArray(p)))
        return g = Fb(g), A.forEach(function(x, v) {
          !(T.isUndefined(x) || x === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Pg([g], v, r) : o === null ? g : g + "[]",
            c(x)
          );
        }), !1;
    }
    return Xc(p) ? !0 : (t.append(Pg(m, g, r), c(p)), !1);
  }
  const d = [], h = Object.assign(kL, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: Xc
  });
  function f(p, g) {
    if (!T.isUndefined(p)) {
      if (d.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      d.push(p), T.forEach(p, function(A, w) {
        (!(T.isUndefined(A) || A === null) && i.call(
          t,
          A,
          T.isString(w) ? w.trim() : w,
          g,
          h
        )) === !0 && f(A, g ? g.concat(w) : [w]);
      }), d.pop();
    }
  }
  if (!T.isObject(e))
    throw new TypeError("data must be an object");
  return f(e), t;
}
function Og(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(s) {
    return t[s];
  });
}
function _d(e, t) {
  this._pairs = [], e && nl(e, this, t);
}
const jb = _d.prototype;
jb.append = function(t, n) {
  this._pairs.push([t, n]);
};
jb.toString = function(t) {
  const n = t ? function(s) {
    return t.call(this, s, Og);
  } : Og;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function TL(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Vb(e, t, n) {
  if (!t)
    return e;
  const s = n && n.encode || TL, i = n && n.serialize;
  let r;
  if (i ? r = i(t, n) : r = T.isURLSearchParams(t) ? t.toString() : new _d(t, n).toString(s), r) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + r;
  }
  return e;
}
class Ng {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, s) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: s ? s.synchronous : !1,
      runWhen: s ? s.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    T.forEach(this.handlers, function(s) {
      s !== null && t(s);
    });
  }
}
const Ub = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, DL = typeof URLSearchParams < "u" ? URLSearchParams : _d, BL = typeof FormData < "u" ? FormData : null, IL = typeof Blob < "u" ? Blob : null, PL = {
  isBrowser: !0,
  classes: {
    URLSearchParams: DL,
    FormData: BL,
    Blob: IL
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Zd = typeof window < "u" && typeof document < "u", $c = typeof navigator == "object" && navigator || void 0, OL = Zd && (!$c || ["ReactNative", "NativeScript", "NS"].indexOf($c.product) < 0), NL = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", LL = Zd && window.location.href || "http://localhost", FL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Zd,
  hasStandardBrowserEnv: OL,
  hasStandardBrowserWebWorkerEnv: NL,
  navigator: $c,
  origin: LL
}, Symbol.toStringTag, { value: "Module" })), de = {
  ...FL,
  ...PL
};
function jL(e, t) {
  return nl(e, new de.classes.URLSearchParams(), Object.assign({
    visitor: function(n, s, i, r) {
      return de.isNode && T.isBuffer(n) ? (this.append(s, n.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function VL(e) {
  return T.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function UL(e) {
  const t = {}, n = Object.keys(e);
  let s;
  const i = n.length;
  let r;
  for (s = 0; s < i; s++)
    r = n[s], t[r] = e[r];
  return t;
}
function Yb(e) {
  function t(n, s, i, r) {
    let o = n[r++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), l = r >= n.length;
    return o = !o && T.isArray(i) ? i.length : o, l ? (T.hasOwnProp(i, o) ? i[o] = [i[o], s] : i[o] = s, !a) : ((!i[o] || !T.isObject(i[o])) && (i[o] = []), t(n, s, i[o], r) && T.isArray(i[o]) && (i[o] = UL(i[o])), !a);
  }
  if (T.isFormData(e) && T.isFunction(e.entries)) {
    const n = {};
    return T.forEachEntry(e, (s, i) => {
      t(VL(s), i, n, 0);
    }), n;
  }
  return null;
}
function YL(e, t, n) {
  if (T.isString(e))
    try {
      return (t || JSON.parse)(e), T.trim(e);
    } catch (s) {
      if (s.name !== "SyntaxError")
        throw s;
    }
  return (0, JSON.stringify)(e);
}
const Ur = {
  transitional: Ub,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const s = n.getContentType() || "", i = s.indexOf("application/json") > -1, r = T.isObject(t);
    if (r && T.isHTMLForm(t) && (t = new FormData(t)), T.isFormData(t))
      return i ? JSON.stringify(Yb(t)) : t;
    if (T.isArrayBuffer(t) || T.isBuffer(t) || T.isStream(t) || T.isFile(t) || T.isBlob(t) || T.isReadableStream(t))
      return t;
    if (T.isArrayBufferView(t))
      return t.buffer;
    if (T.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (r) {
      if (s.indexOf("application/x-www-form-urlencoded") > -1)
        return jL(t, this.formSerializer).toString();
      if ((a = T.isFileList(t)) || s.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return nl(
          a ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return r || i ? (n.setContentType("application/json", !1), YL(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Ur.transitional, s = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (T.isResponse(t) || T.isReadableStream(t))
      return t;
    if (t && T.isString(t) && (s && !this.responseType || i)) {
      const o = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? X.from(a, X.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: de.classes.FormData,
    Blob: de.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
T.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Ur.headers[e] = {};
});
const WL = T.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), QL = (e) => {
  const t = {};
  let n, s, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), s = o.substring(i + 1).trim(), !(!n || t[n] && WL[n]) && (n === "set-cookie" ? t[n] ? t[n].push(s) : t[n] = [s] : t[n] = t[n] ? t[n] + ", " + s : s);
  }), t;
}, Lg = Symbol("internals");
function Ii(e) {
  return e && String(e).trim().toLowerCase();
}
function Yo(e) {
  return e === !1 || e == null ? e : T.isArray(e) ? e.map(Yo) : String(e);
}
function GL(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let s;
  for (; s = n.exec(e); )
    t[s[1]] = s[2];
  return t;
}
const KL = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function zl(e, t, n, s, i) {
  if (T.isFunction(s))
    return s.call(this, t, n);
  if (i && (t = n), !!T.isString(t)) {
    if (T.isString(s))
      return t.indexOf(s) !== -1;
    if (T.isRegExp(s))
      return s.test(t);
  }
}
function zL(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, s) => n.toUpperCase() + s);
}
function _L(e, t) {
  const n = T.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((s) => {
    Object.defineProperty(e, s + n, {
      value: function(i, r, o) {
        return this[s].call(this, t, i, r, o);
      },
      configurable: !0
    });
  });
}
class he {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, s) {
    const i = this;
    function r(a, l, c) {
      const u = Ii(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = T.findKey(i, u);
      (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = Yo(a));
    }
    const o = (a, l) => T.forEach(a, (c, u) => r(c, u, l));
    if (T.isPlainObject(t) || t instanceof this.constructor)
      o(t, n);
    else if (T.isString(t) && (t = t.trim()) && !KL(t))
      o(QL(t), n);
    else if (T.isHeaders(t))
      for (const [a, l] of t.entries())
        r(l, a, s);
    else
      t != null && r(n, t, s);
    return this;
  }
  get(t, n) {
    if (t = Ii(t), t) {
      const s = T.findKey(this, t);
      if (s) {
        const i = this[s];
        if (!n)
          return i;
        if (n === !0)
          return GL(i);
        if (T.isFunction(n))
          return n.call(this, i, s);
        if (T.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Ii(t), t) {
      const s = T.findKey(this, t);
      return !!(s && this[s] !== void 0 && (!n || zl(this, this[s], s, n)));
    }
    return !1;
  }
  delete(t, n) {
    const s = this;
    let i = !1;
    function r(o) {
      if (o = Ii(o), o) {
        const a = T.findKey(s, o);
        a && (!n || zl(s, s[a], a, n)) && (delete s[a], i = !0);
      }
    }
    return T.isArray(t) ? t.forEach(r) : r(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let s = n.length, i = !1;
    for (; s--; ) {
      const r = n[s];
      (!t || zl(this, this[r], r, t, !0)) && (delete this[r], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, s = {};
    return T.forEach(this, (i, r) => {
      const o = T.findKey(s, r);
      if (o) {
        n[o] = Yo(i), delete n[r];
        return;
      }
      const a = t ? zL(r) : String(r).trim();
      a !== r && delete n[r], n[a] = Yo(i), s[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return T.forEach(this, (s, i) => {
      s != null && s !== !1 && (n[i] = t && T.isArray(s) ? s.join(", ") : s);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const s = new this(t);
    return n.forEach((i) => s.set(i)), s;
  }
  static accessor(t) {
    const s = (this[Lg] = this[Lg] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function r(o) {
      const a = Ii(o);
      s[a] || (_L(i, o), s[a] = !0);
    }
    return T.isArray(t) ? t.forEach(r) : r(t), this;
  }
}
he.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
T.reduceDescriptors(he.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(s) {
      this[n] = s;
    }
  };
});
T.freezeMethods(he);
function _l(e, t) {
  const n = this || Ur, s = t || n, i = he.from(s.headers);
  let r = s.data;
  return T.forEach(e, function(a) {
    r = a.call(n, r, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), r;
}
function Wb(e) {
  return !!(e && e.__CANCEL__);
}
function wi(e, t, n) {
  X.call(this, e ?? "canceled", X.ERR_CANCELED, t, n), this.name = "CanceledError";
}
T.inherits(wi, X, {
  __CANCEL__: !0
});
function Qb(e, t, n) {
  const s = n.config.validateStatus;
  !n.status || !s || s(n.status) ? e(n) : t(new X(
    "Request failed with status code " + n.status,
    [X.ERR_BAD_REQUEST, X.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function ZL(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function HL(e, t) {
  e = e || 10;
  const n = new Array(e), s = new Array(e);
  let i = 0, r = 0, o;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = s[r];
    o || (o = c), n[i] = l, s[i] = c;
    let d = r, h = 0;
    for (; d !== i; )
      h += n[d++], d = d % e;
    if (i = (i + 1) % e, i === r && (r = (r + 1) % e), c - o < t)
      return;
    const f = u && c - u;
    return f ? Math.round(h * 1e3 / f) : void 0;
  };
}
function JL(e, t) {
  let n = 0, s = 1e3 / t, i, r;
  const o = (c, u = Date.now()) => {
    n = u, i = null, r && (clearTimeout(r), r = null), e.apply(null, c);
  };
  return [(...c) => {
    const u = Date.now(), d = u - n;
    d >= s ? o(c, u) : (i = c, r || (r = setTimeout(() => {
      r = null, o(i);
    }, s - d)));
  }, () => i && o(i)];
}
const ba = (e, t, n = 3) => {
  let s = 0;
  const i = HL(50, 250);
  return JL((r) => {
    const o = r.loaded, a = r.lengthComputable ? r.total : void 0, l = o - s, c = i(l), u = o <= a;
    s = o;
    const d = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && a && u ? (a - o) / c : void 0,
      event: r,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(d);
  }, n);
}, Fg = (e, t) => {
  const n = e != null;
  return [(s) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: s
  }), t[1]];
}, jg = (e) => (...t) => T.asap(() => e(...t)), XL = de.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = de.navigator && /(msie|trident)/i.test(de.navigator.userAgent), n = document.createElement("a");
    let s;
    function i(r) {
      let o = r;
      return t && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return s = i(window.location.href), function(o) {
      const a = T.isString(o) ? i(o) : o;
      return a.protocol === s.protocol && a.host === s.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), $L = de.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, s, i, r) {
      const o = [e + "=" + encodeURIComponent(t)];
      T.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), T.isString(s) && o.push("path=" + s), T.isString(i) && o.push("domain=" + i), r === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function tF(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function eF(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function Gb(e, t) {
  return e && !tF(t) ? eF(e, t) : t;
}
const Vg = (e) => e instanceof he ? { ...e } : e;
function ks(e, t) {
  t = t || {};
  const n = {};
  function s(c, u, d) {
    return T.isPlainObject(c) && T.isPlainObject(u) ? T.merge.call({ caseless: d }, c, u) : T.isPlainObject(u) ? T.merge({}, u) : T.isArray(u) ? u.slice() : u;
  }
  function i(c, u, d) {
    if (T.isUndefined(u)) {
      if (!T.isUndefined(c))
        return s(void 0, c, d);
    } else return s(c, u, d);
  }
  function r(c, u) {
    if (!T.isUndefined(u))
      return s(void 0, u);
  }
  function o(c, u) {
    if (T.isUndefined(u)) {
      if (!T.isUndefined(c))
        return s(void 0, c);
    } else return s(void 0, u);
  }
  function a(c, u, d) {
    if (d in t)
      return s(c, u);
    if (d in e)
      return s(void 0, c);
  }
  const l = {
    url: r,
    method: r,
    data: r,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, u) => i(Vg(c), Vg(u), !0)
  };
  return T.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const d = l[u] || i, h = d(e[u], t[u], u);
    T.isUndefined(h) && d !== a || (n[u] = h);
  }), n;
}
const Kb = (e) => {
  const t = ks({}, e);
  let { data: n, withXSRFToken: s, xsrfHeaderName: i, xsrfCookieName: r, headers: o, auth: a } = t;
  t.headers = o = he.from(o), t.url = Vb(Gb(t.baseURL, t.url), e.params, e.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let l;
  if (T.isFormData(n)) {
    if (de.hasStandardBrowserEnv || de.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((l = o.getContentType()) !== !1) {
      const [c, ...u] = l ? l.split(";").map((d) => d.trim()).filter(Boolean) : [];
      o.setContentType([c || "multipart/form-data", ...u].join("; "));
    }
  }
  if (de.hasStandardBrowserEnv && (s && T.isFunction(s) && (s = s(t)), s || s !== !1 && XL(t.url))) {
    const c = i && r && $L.read(r);
    c && o.set(i, c);
  }
  return t;
}, nF = typeof XMLHttpRequest < "u", sF = nF && function(e) {
  return new Promise(function(n, s) {
    const i = Kb(e);
    let r = i.data;
    const o = he.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = i, u, d, h, f, p;
    function g() {
      f && f(), p && p(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u);
    }
    let m = new XMLHttpRequest();
    m.open(i.method.toUpperCase(), i.url, !0), m.timeout = i.timeout;
    function A() {
      if (!m)
        return;
      const x = he.from(
        "getAllResponseHeaders" in m && m.getAllResponseHeaders()
      ), C = {
        data: !a || a === "text" || a === "json" ? m.responseText : m.response,
        status: m.status,
        statusText: m.statusText,
        headers: x,
        config: e,
        request: m
      };
      Qb(function(S) {
        n(S), g();
      }, function(S) {
        s(S), g();
      }, C), m = null;
    }
    "onloadend" in m ? m.onloadend = A : m.onreadystatechange = function() {
      !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(A);
    }, m.onabort = function() {
      m && (s(new X("Request aborted", X.ECONNABORTED, e, m)), m = null);
    }, m.onerror = function() {
      s(new X("Network Error", X.ERR_NETWORK, e, m)), m = null;
    }, m.ontimeout = function() {
      let v = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const C = i.transitional || Ub;
      i.timeoutErrorMessage && (v = i.timeoutErrorMessage), s(new X(
        v,
        C.clarifyTimeoutError ? X.ETIMEDOUT : X.ECONNABORTED,
        e,
        m
      )), m = null;
    }, r === void 0 && o.setContentType(null), "setRequestHeader" in m && T.forEach(o.toJSON(), function(v, C) {
      m.setRequestHeader(C, v);
    }), T.isUndefined(i.withCredentials) || (m.withCredentials = !!i.withCredentials), a && a !== "json" && (m.responseType = i.responseType), c && ([h, p] = ba(c, !0), m.addEventListener("progress", h)), l && m.upload && ([d, f] = ba(l), m.upload.addEventListener("progress", d), m.upload.addEventListener("loadend", f)), (i.cancelToken || i.signal) && (u = (x) => {
      m && (s(!x || x.type ? new wi(null, e, m) : x), m.abort(), m = null);
    }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u)));
    const w = ZL(i.url);
    if (w && de.protocols.indexOf(w) === -1) {
      s(new X("Unsupported protocol " + w + ":", X.ERR_BAD_REQUEST, e));
      return;
    }
    m.send(r || null);
  });
}, iF = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let s = new AbortController(), i;
    const r = function(c) {
      if (!i) {
        i = !0, a();
        const u = c instanceof Error ? c : this.reason;
        s.abort(u instanceof X ? u : new wi(u instanceof Error ? u.message : u));
      }
    };
    let o = t && setTimeout(() => {
      o = null, r(new X(`timeout ${t} of ms exceeded`, X.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (o && clearTimeout(o), o = null, e.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(r) : c.removeEventListener("abort", r);
      }), e = null);
    };
    e.forEach((c) => c.addEventListener("abort", r));
    const { signal: l } = s;
    return l.unsubscribe = () => T.asap(a), l;
  }
}, rF = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let s = 0, i;
  for (; s < n; )
    i = s + t, yield e.slice(s, i), s = i;
}, oF = async function* (e, t) {
  for await (const n of aF(e))
    yield* rF(n, t);
}, aF = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: s } = await t.read();
      if (n)
        break;
      yield s;
    }
  } finally {
    await t.cancel();
  }
}, Ug = (e, t, n, s) => {
  const i = oF(e, t);
  let r = 0, o, a = (l) => {
    o || (o = !0, s && s(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: u } = await i.next();
        if (c) {
          a(), l.close();
          return;
        }
        let d = u.byteLength;
        if (n) {
          let h = r += d;
          n(h);
        }
        l.enqueue(new Uint8Array(u));
      } catch (c) {
        throw a(c), c;
      }
    },
    cancel(l) {
      return a(l), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, sl = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", zb = sl && typeof ReadableStream == "function", lF = sl && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), _b = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, cF = zb && _b(() => {
  let e = !1;
  const t = new Request(de.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), Yg = 64 * 1024, tu = zb && _b(() => T.isReadableStream(new Response("").body)), xa = {
  stream: tu && ((e) => e.body)
};
sl && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !xa[t] && (xa[t] = T.isFunction(e[t]) ? (n) => n[t]() : (n, s) => {
      throw new X(`Response type '${t}' is not supported`, X.ERR_NOT_SUPPORT, s);
    });
  });
})(new Response());
const uF = async (e) => {
  if (e == null)
    return 0;
  if (T.isBlob(e))
    return e.size;
  if (T.isSpecCompliantForm(e))
    return (await new Request(de.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (T.isArrayBufferView(e) || T.isArrayBuffer(e))
    return e.byteLength;
  if (T.isURLSearchParams(e) && (e = e + ""), T.isString(e))
    return (await lF(e)).byteLength;
}, dF = async (e, t) => {
  const n = T.toFiniteNumber(e.getContentLength());
  return n ?? uF(t);
}, hF = sl && (async (e) => {
  let {
    url: t,
    method: n,
    data: s,
    signal: i,
    cancelToken: r,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: l,
    responseType: c,
    headers: u,
    withCredentials: d = "same-origin",
    fetchOptions: h
  } = Kb(e);
  c = c ? (c + "").toLowerCase() : "text";
  let f = iF([i, r && r.toAbortSignal()], o), p;
  const g = f && f.unsubscribe && (() => {
    f.unsubscribe();
  });
  let m;
  try {
    if (l && cF && n !== "get" && n !== "head" && (m = await dF(u, s)) !== 0) {
      let C = new Request(t, {
        method: "POST",
        body: s,
        duplex: "half"
      }), E;
      if (T.isFormData(s) && (E = C.headers.get("content-type")) && u.setContentType(E), C.body) {
        const [S, M] = Fg(
          m,
          ba(jg(l))
        );
        s = Ug(C.body, Yg, S, M);
      }
    }
    T.isString(d) || (d = d ? "include" : "omit");
    const A = "credentials" in Request.prototype;
    p = new Request(t, {
      ...h,
      signal: f,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: s,
      duplex: "half",
      credentials: A ? d : void 0
    });
    let w = await fetch(p);
    const x = tu && (c === "stream" || c === "response");
    if (tu && (a || x && g)) {
      const C = {};
      ["status", "statusText", "headers"].forEach((q) => {
        C[q] = w[q];
      });
      const E = T.toFiniteNumber(w.headers.get("content-length")), [S, M] = a && Fg(
        E,
        ba(jg(a), !0)
      ) || [];
      w = new Response(
        Ug(w.body, Yg, S, () => {
          M && M(), g && g();
        }),
        C
      );
    }
    c = c || "text";
    let v = await xa[T.findKey(xa, c) || "text"](w, e);
    return !x && g && g(), await new Promise((C, E) => {
      Qb(C, E, {
        data: v,
        headers: he.from(w.headers),
        status: w.status,
        statusText: w.statusText,
        config: e,
        request: p
      });
    });
  } catch (A) {
    throw g && g(), A && A.name === "TypeError" && /fetch/i.test(A.message) ? Object.assign(
      new X("Network Error", X.ERR_NETWORK, e, p),
      {
        cause: A.cause || A
      }
    ) : X.from(A, A && A.code, e, p);
  }
}), eu = {
  http: qL,
  xhr: sF,
  fetch: hF
};
T.forEach(eu, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Wg = (e) => `- ${e}`, fF = (e) => T.isFunction(e) || e === null || e === !1, Zb = {
  getAdapter: (e) => {
    e = T.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, s;
    const i = {};
    for (let r = 0; r < t; r++) {
      n = e[r];
      let o;
      if (s = n, !fF(n) && (s = eu[(o = String(n)).toLowerCase()], s === void 0))
        throw new X(`Unknown adapter '${o}'`);
      if (s)
        break;
      i[o || "#" + r] = s;
    }
    if (!s) {
      const r = Object.entries(i).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? r.length > 1 ? `since :
` + r.map(Wg).join(`
`) : " " + Wg(r[0]) : "as no adapter specified";
      throw new X(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return s;
  },
  adapters: eu
};
function Zl(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new wi(null, e);
}
function Qg(e) {
  return Zl(e), e.headers = he.from(e.headers), e.data = _l.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Zb.getAdapter(e.adapter || Ur.adapter)(e).then(function(s) {
    return Zl(e), s.data = _l.call(
      e,
      e.transformResponse,
      s
    ), s.headers = he.from(s.headers), s;
  }, function(s) {
    return Wb(s) || (Zl(e), s && s.response && (s.response.data = _l.call(
      e,
      e.transformResponse,
      s.response
    ), s.response.headers = he.from(s.response.headers))), Promise.reject(s);
  });
}
const Hb = "1.7.7", Hd = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Hd[e] = function(s) {
    return typeof s === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const Gg = {};
Hd.transitional = function(t, n, s) {
  function i(r, o) {
    return "[Axios v" + Hb + "] Transitional option '" + r + "'" + o + (s ? ". " + s : "");
  }
  return (r, o, a) => {
    if (t === !1)
      throw new X(
        i(o, " has been removed" + (n ? " in " + n : "")),
        X.ERR_DEPRECATED
      );
    return n && !Gg[o] && (Gg[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(r, o, a) : !0;
  };
};
function pF(e, t, n) {
  if (typeof e != "object")
    throw new X("options must be an object", X.ERR_BAD_OPTION_VALUE);
  const s = Object.keys(e);
  let i = s.length;
  for (; i-- > 0; ) {
    const r = s[i], o = t[r];
    if (o) {
      const a = e[r], l = a === void 0 || o(a, r, e);
      if (l !== !0)
        throw new X("option " + r + " must be " + l, X.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new X("Unknown option " + r, X.ERR_BAD_OPTION);
  }
}
const nu = {
  assertOptions: pF,
  validators: Hd
}, qn = nu.validators;
class vs {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Ng(),
      response: new Ng()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (s) {
      if (s instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const r = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          s.stack ? r && !String(s.stack).endsWith(r.replace(/^.+\n.+\n/, "")) && (s.stack += `
` + r) : s.stack = r;
        } catch {
        }
      }
      throw s;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = ks(this.defaults, n);
    const { transitional: s, paramsSerializer: i, headers: r } = n;
    s !== void 0 && nu.assertOptions(s, {
      silentJSONParsing: qn.transitional(qn.boolean),
      forcedJSONParsing: qn.transitional(qn.boolean),
      clarifyTimeoutError: qn.transitional(qn.boolean)
    }, !1), i != null && (T.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : nu.assertOptions(i, {
      encode: qn.function,
      serialize: qn.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o = r && T.merge(
      r.common,
      r[n.method]
    );
    r && T.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete r[p];
      }
    ), n.headers = he.concat(o, r);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (l = l && g.synchronous, a.unshift(g.fulfilled, g.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(g) {
      c.push(g.fulfilled, g.rejected);
    });
    let u, d = 0, h;
    if (!l) {
      const p = [Qg.bind(this), void 0];
      for (p.unshift.apply(p, a), p.push.apply(p, c), h = p.length, u = Promise.resolve(n); d < h; )
        u = u.then(p[d++], p[d++]);
      return u;
    }
    h = a.length;
    let f = n;
    for (d = 0; d < h; ) {
      const p = a[d++], g = a[d++];
      try {
        f = p(f);
      } catch (m) {
        g.call(this, m);
        break;
      }
    }
    try {
      u = Qg.call(this, f);
    } catch (p) {
      return Promise.reject(p);
    }
    for (d = 0, h = c.length; d < h; )
      u = u.then(c[d++], c[d++]);
    return u;
  }
  getUri(t) {
    t = ks(this.defaults, t);
    const n = Gb(t.baseURL, t.url);
    return Vb(n, t.params, t.paramsSerializer);
  }
}
T.forEach(["delete", "get", "head", "options"], function(t) {
  vs.prototype[t] = function(n, s) {
    return this.request(ks(s || {}, {
      method: t,
      url: n,
      data: (s || {}).data
    }));
  };
});
T.forEach(["post", "put", "patch"], function(t) {
  function n(s) {
    return function(r, o, a) {
      return this.request(ks(a || {}, {
        method: t,
        headers: s ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: r,
        data: o
      }));
    };
  }
  vs.prototype[t] = n(), vs.prototype[t + "Form"] = n(!0);
});
class Jd {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(r) {
      n = r;
    });
    const s = this;
    this.promise.then((i) => {
      if (!s._listeners) return;
      let r = s._listeners.length;
      for (; r-- > 0; )
        s._listeners[r](i);
      s._listeners = null;
    }), this.promise.then = (i) => {
      let r;
      const o = new Promise((a) => {
        s.subscribe(a), r = a;
      }).then(i);
      return o.cancel = function() {
        s.unsubscribe(r);
      }, o;
    }, t(function(r, o, a) {
      s.reason || (s.reason = new wi(r, o, a), n(s.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (s) => {
      t.abort(s);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Jd(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
function gF(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function mF(e) {
  return T.isObject(e) && e.isAxiosError === !0;
}
const su = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(su).forEach(([e, t]) => {
  su[t] = e;
});
function Jb(e) {
  const t = new vs(e), n = Rb(vs.prototype.request, t);
  return T.extend(n, vs.prototype, t, { allOwnKeys: !0 }), T.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return Jb(ks(e, i));
  }, n;
}
const Rt = Jb(Ur);
Rt.Axios = vs;
Rt.CanceledError = wi;
Rt.CancelToken = Jd;
Rt.isCancel = Wb;
Rt.VERSION = Hb;
Rt.toFormData = nl;
Rt.AxiosError = X;
Rt.Cancel = Rt.CanceledError;
Rt.all = function(t) {
  return Promise.all(t);
};
Rt.spread = gF;
Rt.isAxiosError = mF;
Rt.mergeConfig = ks;
Rt.AxiosHeaders = he;
Rt.formToJSON = (e) => Yb(T.isHTMLForm(e) ? new FormData(e) : e);
Rt.getAdapter = Zb.getAdapter;
Rt.HttpStatusCode = su;
Rt.default = Rt;
let ui, Hl;
async function AF() {
  const t = new URL(document.URL).origin + "/";
  return Hl || (Hl = Rt.get(t + "config/config.json").then((n) => {
    ui = n.data.apiEndpoint;
  }).catch((n) => {
    throw console.error("Failed to load config:", n), new Error("Failed to load config");
  })), Hl;
}
async function il() {
  await AF();
}
async function Yr() {
  return typeof window < "u" ? sessionStorage.getItem("gameToken") : null;
}
async function yF(e) {
  typeof window < "u" && sessionStorage.setItem("gameToken", e);
}
async function wF() {
  typeof window < "u" && sessionStorage.removeItem("gameToken");
}
async function Kg(e, t) {
  await il();
  const n = await Yr();
  if (!n) throw new Error("No authentication token found");
  try {
    return (await Rt.post(
      `${ui}/api/game/${e}/bet`,
      t,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": n
        }
      }
    )).data;
  } catch (s) {
    const i = s.response ? s.response.data : s.message;
    throw console.error("API Error:", i), new Error(`Failed to place bet: ${s.message}`);
  }
}
async function bF(e, t) {
  await il();
  const n = await Yr();
  if (!n) throw new Error("No authentication token found");
  try {
    return (await Rt.post(
      `${ui}/api/game/${e}/play`,
      t,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": n
        }
      }
    )).data;
  } catch (s) {
    const i = s.response ? s.response.data : s.message;
    throw console.error("API Error:", i), new Error(`Failed to perform game action: ${s.message}`);
  }
}
async function xF(e, t) {
  await il();
  const n = await Yr();
  if (!n) throw new Error("No authentication token found");
  try {
    return (await Rt.post(
      `${ui}/api/game/${e}/play`,
      {
        gameRoundId: t,
        custom: { cashout: !0 }
      },
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": n
        }
      }
    )).data;
  } catch (s) {
    const i = s.response ? s.response.data : s.message;
    throw console.error("API Error:", i), new Error(`Failed to cashout game: ${s.message}`);
  }
}
const Xb = Ts(void 0), $b = ({ children: e }) => {
  const [t, n] = ie(null), [s, i] = ie(!1), r = ce(async (a) => {
    await yF(a), n(a);
  }, []), o = ce(async () => {
    await wF(), n(null);
  }, []);
  return Lt(() => {
    (async () => {
      const l = await Yr();
      if (l)
        n(l);
      else if (typeof window < "u") {
        const u = new URLSearchParams(window.location.search).get("token");
        u && (await r(u), window.history.replaceState({}, document.title, window.location.pathname));
      }
      i(!0);
    })();
  }, [r]), /* @__PURE__ */ y.jsx(Xb.Provider, { value: { token: t, setToken: r, clearToken: o, isInitialized: s }, children: e });
}, tx = () => {
  const e = Wt(Xb);
  if (e === void 0)
    throw new Error("useAuth must be used within an AuthProvider");
  return e;
}, vF = ({ currency: e, lang: t, theme: n }) => {
  const [s, i] = ie(!1), { token: r } = tx(), o = Da(), a = fe(null), { betAmount: l, minesCount: c, mode: u, numberOfBets: d } = Vu(), {
    isGameActive: h,
    setIsGameActive: f,
    selectedCurrency: p,
    setCurrency: g,
    setInitializing: m,
    setBalance: A,
    balance: w,
    setTheme: x,
    setIsAutoPlaying: v,
    setCurrentAutoBet: C,
    setBetRanges: E
  } = ze(), {
    initializeGame: S,
    revealCell: M,
    setMultiplier: q,
    setRevealedCells: k,
    revealedCells: R,
    gameRoundId: D,
    endGame: j,
    resetGame: W,
    toggleSelectedCell: O,
    clearSelectedCells: U,
    selectedCells: I,
    updateBoard: F,
    board: Q
  } = ju(), { updateProfitData: J } = Xa(), [lt, Vt] = ie(!1), Pt = ce(async () => {
    if (r) {
      await il();
      try {
        m(!0);
        const N = await fetch(`${ui}/api/game/mines/config`, {
          method: "GET",
          headers: {
            "x-token": r,
            "Content-Type": "application/json"
          }
        });
        if (!N.ok)
          throw new Error("Failed to fetch game config");
        const nt = await N.json();
        g(nt.currencyDefinition), E({
          minBet: nt.allowedBets[0],
          maxBet: nt.allowedBets[1]
        }), A(nt.balance);
      } catch (N) {
        console.error("Error fetching game data:", N);
      } finally {
        m(!1), Vt(!0);
      }
    }
  }, [r, g, A, m]), kt = ce(async (N) => {
    if (r)
      try {
        m(!0);
        const nt = await fetch(`${ui}/api/player/currency-change`, {
          method: "POST",
          headers: {
            "x-token": r,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ currency: N })
        });
        if (!nt.ok)
          throw new Error("Failed to change currency");
        const vt = await nt.json();
        g(vt.currencyDefinition), E({
          minBet: vt.allowedBets[0],
          maxBet: vt.allowedBets[1]
        }), A(vt.balance);
      } catch (nt) {
        console.error("Error changing currency:", nt);
      } finally {
        m(!1);
      }
  }, [r, g, A, m]);
  Lt(() => {
    u1(), x(n), (async () => {
      if (await Yr())
        await Pt();
      else
        throw m(!1), new Error("No token found.");
    })();
  }, [Pt, x, n]), Lt(() => {
    lt && p.currencyCode !== e && kt(e);
  }, [lt, p, e, kt]);
  const Ut = async () => {
    f(!0), W();
    try {
      const N = {
        amount: l.toString(),
        currency: p.currencyCode,
        custom: {
          mines: c
        }
      }, nt = await Kg("mines", N);
      S(nt.roundId), A(nt.balance), f(nt.active);
    } catch (N) {
      console.error("Error starting game:", N), f(!1);
    }
  }, gt = ce((N) => {
    A(N.balance);
    const nt = Q.map((vt, Kt) => N.custom.mines.includes(Kt) ? "mine" : "diamond");
    F(nt), k(N.custom.selected), N.win ? (Tn("win"), J((N.winAmount ?? 0) - l, !0), q(N.multiplier ?? 0)) : (Tn("bomb"), J(-l, !1)), j(N.winAmount ?? 0);
  }, [A, F, k, J, l, Tn, I]), G = fe(null), Gt = ce(async () => {
    const N = (vt) => new Promise((Kt, Te) => {
      var pe;
      const ss = setTimeout(() => {
        Kt();
      }, vt);
      (pe = G.current) == null || pe.signal.addEventListener("abort", () => {
        clearTimeout(ss), Te(new Error("Auto-play aborted"));
      });
    }), nt = async () => {
      const vt = ze.getState();
      if (!vt.isAutoPlaying || d !== "∞" && vt.currentAutoBet > d) {
        v(!1);
        return;
      }
      try {
        G.current = new AbortController(), await N(1e3);
        const Kt = {
          amount: l.toString(),
          currency: p.currencyCode,
          custom: {
            mines: c,
            selected: I
          }
        }, Te = await Kg("mines", Kt);
        gt(Te), await N(1e3), W(), C((ss) => ss + 1), nt();
      } catch (Kt) {
        Kt.message === "Auto-play aborted" ? console.log("Auto-play was stopped by the user") : console.error("Error in auto-play:", Kt), v(!1);
      }
    };
    nt();
  }, [l, p, c, I, C, v, gt, W, d]), ae = ce(async () => {
    h || !r || (u === "auto" && I.length > 0 ? (v(!0), C(1), Gt()) : await Ut());
  }, [h, r, u, I, v, C, Gt, Ut]), Cn = ce(async (N) => {
    if (!(!h || R.includes(N) || !D))
      try {
        const nt = {
          gameRoundId: D.toString(),
          custom: { selected: [N] }
        }, vt = await bF("mines", nt);
        ke(vt, !1);
      } catch (nt) {
        console.error("Error revealing cell:", nt);
      }
  }, [h, R, D]), ke = ce((N, nt) => {
    if (k(N.custom.selected), q(N.multiplier), N.custom.selected.forEach((vt) => {
      M(vt, N.custom.mines.includes(vt) ? "mine" : "diamond");
    }), N.active && !nt)
      Tn("diamond");
    else {
      const vt = Q.map((Kt, Te) => N.custom.mines.includes(Te) ? "mine" : "diamond");
      F(vt), j(N.winAmount), J(-l, N.win), f(!1), Tn(N.win ? "win" : "bomb");
    }
  }, [l, j, M, f, q, k, J]), ns = ce(async () => {
    if (ze.getState().isAutoPlaying) {
      v(!1), a.current && clearTimeout(a.current);
      return;
    }
    if (!(!h || !D))
      try {
        const nt = await xF("mines", D.toString());
        q(nt.multiplier), j(nt.winAmount);
        const vt = Q.map((Kt, Te) => nt.custom.mines.includes(Te) ? "mine" : "diamond");
        F(vt), A(w + nt.winAmount), J(nt.winAmount - l, nt.win), f(!1), Tn("win");
      } catch (nt) {
        console.error("Error cashing out:", nt);
      }
  }, [h, D, q, j, M, A, w, J, f, v]);
  return Lt(() => {
    W(), u === "manual" && U();
  }, [u, U]), Lt(() => () => {
    a.current && clearTimeout(a.current);
  }, []), console.log("Mines component rendering"), /* @__PURE__ */ y.jsxs($b, { children: [
    /* @__PURE__ */ y.jsxs("div", { className: "flex flex-col lg:flex-row h-auto lg:h-[600px] ", children: [
      /* @__PURE__ */ y.jsx(
        Wq,
        {
          handleStartGame: ae,
          handleCashout: ns
        }
      ),
      /* @__PURE__ */ y.jsxs("div", { className: "relative flex-grow lg:p-6 flex items-center justify-center order-1 lg:order-2 ", children: [
        /* @__PURE__ */ y.jsx("div", { className: "relative z-10 bg-black p-3 lg:p-2 rounded-md w-full lg:max-w-[480px] aspect-square", children: /* @__PURE__ */ y.jsx(
          f1,
          {
            handleRevealCell: Cn,
            handleAutoSelection: O
          }
        ) }),
        !o && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(
            VN,
            {
              starHeight: 5,
              starWidth: 20,
              minSpeed: 5,
              maxSpeed: 20,
              trailColor: n === "betpanda" ? "#0c2d30" : "#dc016c",
              starColor: n === "betpanda" ? "#1fe88a" : "#dc016c"
            }
          ),
          /* @__PURE__ */ y.jsx(UN, { starDensity: 2e-3 })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ y.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ y.jsx(
        FN,
        {
          isLiveStatsOpen: s,
          setLiveStatsOpen: i
        }
      ),
      /* @__PURE__ */ y.jsx(
        YT,
        {
          setLiveStatsOpen: i
        }
      )
    ] })
  ] });
}, CF = '*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:Nunito Sans,sans-serif;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}:root{--background: 0 0% 100%;--foreground: 222.2 84% 4.9%;--card: 0 0% 100%;--card-foreground: 222.2 84% 4.9%;--popover: 0 0% 100%;--popover-foreground: 222.2 84% 4.9%;--primary: 222.2 47.4% 11.2%;--primary-foreground: 210 40% 98%;--secondary: 210 40% 96.1%;--secondary-foreground: 222.2 47.4% 11.2%;--muted: 210 40% 96.1%;--muted-foreground: 215.4 16.3% 46.9%;--accent: 210 40% 96.1%;--accent-foreground: 222.2 47.4% 11.2%;--destructive: 0 84.2% 60.2%;--destructive-foreground: 210 40% 98%;--border: 214.3 31.8% 91.4%;--input: 214.3 31.8% 91.4%;--ring: 222.2 84% 4.9%;--radius: .5rem;--chart-1: 12 76% 61%;--chart-2: 173 58% 39%;--chart-3: 197 37% 24%;--chart-4: 43 74% 66%;--chart-5: 27 87% 67%}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.no-scrollbar::-webkit-scrollbar{display:none}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{top:0;right:0;bottom:0;left:0}.inset-x-0{left:0;right:0}.-top-2{top:-.5rem}.bottom-0{bottom:0}.bottom-16{bottom:4rem}.left-1\\/2{left:50%}.left-2{left:.5rem}.left-3{left:.75rem}.left-\\[50\\%\\]{left:50%}.right-0{right:0}.right-3{right:.75rem}.right-4{right:1rem}.top-0{top:0}.top-4{top:1rem}.top-\\[50\\%\\]{top:50%}.top-full{top:100%}.z-10{z-index:10}.z-20{z-index:20}.z-50{z-index:50}.order-1{order:1}.order-2{order:2}.order-first{order:-9999}.order-last{order:9999}.-mx-1{margin-left:-.25rem;margin-right:-.25rem}.mx-4{margin-left:1rem;margin-right:1rem}.mx-auto{margin-left:auto;margin-right:auto}.my-1{margin-top:.25rem;margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.ml-2{margin-left:.5rem}.ml-auto{margin-left:auto}.mr-1{margin-right:.25rem}.mr-2{margin-right:.5rem}.mt-2{margin-top:.5rem}.mt-24{margin-top:6rem}.mt-4{margin-top:1rem}.mt-6{margin-top:1.5rem}.mt-auto{margin-top:auto}.block{display:block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.h-0{height:0px}.h-10{height:2.5rem}.h-11{height:2.75rem}.h-2{height:.5rem}.h-2\\.5{height:.625rem}.h-3\\.5{height:.875rem}.h-4{height:1rem}.h-44{height:11rem}.h-5{height:1.25rem}.h-8{height:2rem}.h-9{height:2.25rem}.h-\\[55px\\]{height:55px}.h-auto{height:auto}.h-full{height:100%}.h-px{height:1px}.max-h-\\[90\\%\\]{max-height:90%}.min-h-screen{min-height:100vh}.w-0{width:0px}.w-0\\.5{width:.125rem}.w-1\\/2{width:50%}.w-10{width:2.5rem}.w-16{width:4rem}.w-2{width:.5rem}.w-2\\.5{width:.625rem}.w-20{width:5rem}.w-3\\.5{width:.875rem}.w-4{width:1rem}.w-40{width:10rem}.w-5{width:1.25rem}.w-64{width:16rem}.w-72{width:18rem}.w-80{width:20rem}.w-\\[100px\\]{width:100px}.w-\\[110px\\]{width:110px}.w-\\[30\\%\\]{width:30%}.w-\\[70\\%\\]{width:70%}.w-full{width:100%}.min-w-\\[2rem\\]{min-width:2rem}.min-w-\\[8rem\\]{min-width:8rem}.max-w-lg{max-width:32rem}.flex-1{flex:1 1 0%}.shrink-0{flex-shrink:0}.flex-grow,.grow{flex-grow:1}.-translate-x-1\\/2,.translate-x-\\[-50\\%\\]{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.translate-y-\\[-50\\%\\]{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.cursor-default{cursor:default}.cursor-pointer{cursor:pointer}.touch-none{touch-action:none}.select-none{-webkit-user-select:none;user-select:none}.resize{resize:both}.list-disc{list-style-type:disc}.grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1\\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-x-1>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.25rem * var(--tw-space-x-reverse));margin-left:calc(.25rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-3>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.75rem * var(--tw-space-x-reverse));margin-left:calc(.75rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-1\\.5>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.375rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.375rem * var(--tw-space-y-reverse))}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.whitespace-nowrap{white-space:nowrap}.rounded{border-radius:.25rem}.rounded-\\[inherit\\]{border-radius:inherit}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-t-\\[10px\\]{border-top-left-radius:10px;border-top-right-radius:10px}.border{border-width:1px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-b-8{border-bottom-width:8px}.border-l{border-left-width:1px}.border-l-8{border-left-width:8px}.border-r-8{border-right-width:8px}.border-t{border-top-width:1px}.border-none{border-style:none}.border-brand{--tw-border-opacity: 1;border-color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-border-opacity)))}.border-gray-700{--tw-border-opacity: 1;border-color:rgb(55 65 81 / var(--tw-border-opacity))}.border-green-500{--tw-border-opacity: 1;border-color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-border-opacity)))}.border-input{border-color:hsl(var(--input))}.border-transparent{border-color:transparent}.border-b-white{--tw-border-opacity: 1;border-bottom-color:rgb(255 255 255 / var(--tw-border-opacity))}.border-l-transparent{border-left-color:transparent}.border-t-transparent{border-top-color:transparent}.border-opacity-0{--tw-border-opacity: 0}.bg-\\[\\#07182c\\]{--tw-bg-opacity: 1;background-color:rgb(7 24 44 / var(--tw-bg-opacity))}.bg-\\[\\#152538\\]{--tw-bg-opacity: 1;background-color:rgb(21 37 56 / var(--tw-bg-opacity))}.bg-background{background-color:hsl(var(--background))}.bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.bg-black\\/80{background-color:#000c}.bg-border{background-color:hsl(var(--border))}.bg-brand{--tw-bg-opacity: 1;background-color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-bg-opacity)))}.bg-destructive{background-color:hsl(var(--destructive))}.bg-gray-300{--tw-bg-opacity: 1;background-color:rgb(209 213 219 / var(--tw-bg-opacity))}.bg-gray-700{--tw-bg-opacity: 1;background-color:rgb(55 65 81 / var(--tw-bg-opacity))}.bg-gray-800{--tw-bg-opacity: 1;background-color:rgb(31 41 55 / var(--tw-bg-opacity))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity))}.bg-gray-950{--tw-bg-opacity: 1;background-color:rgb(3 7 18 / var(--tw-bg-opacity))}.bg-green-500\\/30{background-color:hsl(var(--twc-green-500) / .3)}.bg-muted{background-color:hsl(var(--muted))}.bg-pills{--tw-bg-opacity: 1;background-color:hsl(var(--twc-pills) / var(--twc-pills-opacity, var(--tw-bg-opacity)))}.bg-popover{background-color:hsl(var(--popover))}.bg-primary{--tw-bg-opacity: 1;background-color:hsl(var(--twc-primary) / var(--twc-primary-opacity, var(--tw-bg-opacity)))}.bg-red-400{--tw-bg-opacity: 1;background-color:rgb(248 113 113 / var(--tw-bg-opacity))}.bg-secondary{--tw-bg-opacity: 1;background-color:hsl(var(--twc-secondary) / var(--twc-secondary-opacity, var(--tw-bg-opacity)))}.bg-slate-600{--tw-bg-opacity: 1;background-color:rgb(71 85 105 / var(--tw-bg-opacity))}.bg-slate-900{--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}.bg-transparent{background-color:transparent}.bg-violet-700{--tw-bg-opacity: 1;background-color:rgb(109 40 217 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.fill-current{fill:currentColor}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-\\[1px\\]{padding:1px}.px-1{padding-left:.25rem;padding-right:.25rem}.px-1\\.5{padding-left:.375rem;padding-right:.375rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-2\\.5{padding-left:.625rem;padding-right:.625rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-0\\.5{padding-top:.125rem;padding-bottom:.125rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pb-4{padding-bottom:1rem}.pb-5{padding-bottom:1.25rem}.pl-5{padding-left:1.25rem}.pl-8{padding-left:2rem}.pr-2{padding-right:.5rem}.pr-8{padding-right:2rem}.pt-0{padding-top:0}.text-center{text-align:center}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-black{font-weight:900}.font-bold{font-weight:700}.font-extrabold{font-weight:800}.font-medium{font-weight:500}.font-semibold{font-weight:600}.uppercase{text-transform:uppercase}.lowercase{text-transform:lowercase}.tabular-nums{--tw-numeric-spacing: tabular-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.leading-none{line-height:1}.tracking-tight{letter-spacing:-.025em}.tracking-widest{letter-spacing:.1em}.text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.text-destructive-foreground{color:hsl(var(--destructive-foreground))}.text-foreground{color:hsl(var(--foreground))}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.text-green-400{--tw-text-opacity: 1;color:rgb(74 222 128 / var(--tw-text-opacity))}.text-green-500{--tw-text-opacity: 1;color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-text-opacity)))}.text-muted-foreground{color:hsl(var(--muted-foreground))}.text-popover-foreground{color:hsl(var(--popover-foreground))}.text-primary{--tw-text-opacity: 1;color:hsl(var(--twc-primary) / var(--twc-primary-opacity, var(--tw-text-opacity)))}.text-red-400{--tw-text-opacity: 1;color:rgb(248 113 113 / var(--tw-text-opacity))}.text-red-500{--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}.text-slate-400{--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline-offset-4{text-underline-offset:4px}.opacity-0{opacity:0}.opacity-100{opacity:1}.opacity-20{opacity:.2}.opacity-50{opacity:.5}.opacity-60{opacity:.6}.opacity-70{opacity:.7}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-2xl{--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / .25);--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-lg{--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-md{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.ring-1{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.ring-brand{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-ring-opacity)))}.ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.duration-200{transition-duration:.2s}.duration-300{transition-duration:.3s}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.will-change-auto{will-change:auto}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.animate-in{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.fade-in-0{--tw-enter-opacity: 0}.zoom-in-95{--tw-enter-scale: .95}.duration-200{animation-duration:.2s}.duration-300{animation-duration:.3s}.ease-in-out{animation-timing-function:cubic-bezier(.4,0,.2,1)}.betpanda,[data-theme=betpanda]{--twc-brand: 152.39999999999998 76.1% 44.3%;--twc-pills: 210.5 60% 18.6%;--twc-primary: 212.39999999999998 72.5% 10%;--twc-secondary: 212.60000000000002 45.5% 15.1%;--twc-green-500: 120.30000000000001 100% 45.3%}.betplay,[data-theme=betplay]{--twc-brand: 330.29999999999995 100% 43.1%;--twc-pills: 210.5 60% 18.6%;--twc-primary: 212.39999999999998 72.5% 10%;--twc-secondary: 212.60000000000002 45.5% 15.1%;--twc-border: 330.29999999999995 100% 43.1%;--twc-border-opacity: .64}.theme2,[data-theme=theme2]{--twc-brand: 120 100% 25.1%;--twc-primary: 0 0% 100%;--twc-secondary: 0 0% 94.1%}.\\[border\\:calc\\(var\\(--border-width\\)\\*1px\\)_solid_transparent\\]{border:calc(var(--border-width) * 1px) solid transparent}.\\!\\[mask-clip\\:padding-box\\,border-box\\]{-webkit-mask-clip:padding-box,border-box!important;mask-clip:padding-box,border-box!important}.\\!\\[mask-composite\\:intersect\\]{-webkit-mask-composite:source-in,xor!important;mask-composite:intersect!important}.\\[mask\\:linear-gradient\\(transparent\\,transparent\\)\\,linear-gradient\\(white\\,white\\)\\]{-webkit-mask:linear-gradient(transparent,transparent),linear-gradient(white,white);mask:linear-gradient(transparent,transparent),linear-gradient(white,white)}.file\\:border-0::file-selector-button{border-width:0px}.file\\:bg-transparent::file-selector-button{background-color:transparent}.file\\:text-sm::file-selector-button{font-size:.875rem;line-height:1.25rem}.file\\:font-medium::file-selector-button{font-weight:500}.file\\:text-foreground::file-selector-button{color:hsl(var(--foreground))}.placeholder\\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.after\\:absolute:after{content:var(--tw-content);position:absolute}.after\\:aspect-square:after{content:var(--tw-content);aspect-ratio:1 / 1}.after\\:w-\\[calc\\(var\\(--size\\)\\*1px\\)\\]:after{content:var(--tw-content);width:calc(var(--size) * 1px)}@keyframes border-beam{to{content:var(--tw-content);offset-distance:100%}}.after\\:animate-border-beam:after{content:var(--tw-content);animation:border-beam calc(var(--duration)*1s) infinite linear}.after\\:\\[animation-delay\\:var\\(--delay\\)\\]:after{content:var(--tw-content);animation-delay:var(--delay)}.after\\:\\[background\\:linear-gradient\\(to_left\\,var\\(--color-from\\)\\,var\\(--color-to\\)\\,transparent\\)\\]:after{content:var(--tw-content);background:linear-gradient(to left,var(--color-from),var(--color-to),transparent)}.after\\:\\[offset-anchor\\:calc\\(var\\(--anchor\\)\\*1\\%\\)_50\\%\\]:after{content:var(--tw-content);offset-anchor:calc(var(--anchor) * 1%) 50%}.after\\:\\[offset-path\\:rect\\(0_auto_auto_0_round_calc\\(var\\(--size\\)\\*1px\\)\\)\\]:after{content:var(--tw-content);offset-path:rect(0 auto auto 0 round calc(var(--size) * 1px))}@media (hover: hover) and (pointer: fine){.hover\\:bg-accent:hover{background-color:hsl(var(--accent))}.hover\\:bg-brand\\/80:hover{background-color:hsl(var(--twc-brand) / .8)}.hover\\:bg-destructive\\/80:hover{background-color:hsl(var(--destructive) / .8)}.hover\\:bg-destructive\\/90:hover{background-color:hsl(var(--destructive) / .9)}.hover\\:bg-gray-700:hover{--tw-bg-opacity: 1;background-color:rgb(55 65 81 / var(--tw-bg-opacity))}.hover\\:bg-primary\\/80:hover{background-color:hsl(var(--twc-primary) / .8)}.hover\\:bg-primary\\/90:hover{background-color:hsl(var(--twc-primary) / .9)}.hover\\:bg-secondary\\/80:hover{background-color:hsl(var(--twc-secondary) / .8)}.hover\\:bg-transparent:hover{background-color:transparent}.hover\\:bg-opacity-80:hover{--tw-bg-opacity: .8}.hover\\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.hover\\:text-white:hover{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}}.focus\\:bg-accent:focus{background-color:hsl(var(--accent))}.focus\\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-0:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-1:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-brand:focus{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-ring-opacity)))}.focus\\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.focus\\:ring-offset-0:focus{--tw-ring-offset-width: 0px}.focus\\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\\:ring-0:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.focus-visible\\:ring-offset-0:focus-visible{--tw-ring-offset-width: 0px}.focus-visible\\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-100:disabled{opacity:1}.disabled\\:opacity-50:disabled{opacity:.5}.disabled\\:opacity-80:disabled{opacity:.8}@media (hover: hover) and (pointer: fine){.group:hover .group-hover\\:text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}}.peer:disabled~.peer-disabled\\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\\:opacity-70{opacity:.7}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}@keyframes accordion-up{0%{height:var(--radix-accordion-content-height)}to{height:0}}.data-\\[state\\=closed\\]\\:animate-accordion-up[data-state=closed]{animation:accordion-up .2s ease-out}@keyframes accordion-down{0%{height:0}to{height:var(--radix-accordion-content-height)}}.data-\\[state\\=open\\]\\:animate-accordion-down[data-state=open]{animation:accordion-down .2s ease-out}.data-\\[state\\=open\\]\\:bg-accent[data-state=open]{background-color:hsl(var(--accent))}.data-\\[state\\=open\\]\\:text-muted-foreground[data-state=open]{color:hsl(var(--muted-foreground))}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.data-\\[state\\=closed\\]\\:slide-out-to-left-1\\/2[data-state=closed]{--tw-exit-translate-x: -50%}.data-\\[state\\=closed\\]\\:slide-out-to-top-\\[48\\%\\][data-state=closed]{--tw-exit-translate-y: -48%}.data-\\[state\\=open\\]\\:slide-in-from-left-1\\/2[data-state=open]{--tw-enter-translate-x: -50%}.data-\\[state\\=open\\]\\:slide-in-from-top-\\[48\\%\\][data-state=open]{--tw-enter-translate-y: -48%}@media (min-width: 640px){.sm\\:max-w-\\[425px\\]{max-width:425px}.sm\\:flex-row{flex-direction:row}.sm\\:justify-end{justify-content:flex-end}.sm\\:space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.sm\\:rounded-lg{border-radius:var(--radius)}.sm\\:p-6{padding:1.5rem}.sm\\:text-left{text-align:left}}@media (min-width: 768px){.md\\:flex{display:flex}.md\\:hidden{display:none}.md\\:max-w-\\[600px\\]{max-width:600px}}@media (min-width: 1024px){.lg\\:sticky{position:sticky}.lg\\:bottom-0{bottom:0}.lg\\:order-1{order:1}.lg\\:order-2{order:2}.lg\\:order-first{order:-9999}.lg\\:order-last{order:9999}.lg\\:mb-4{margin-bottom:1rem}.lg\\:mt-0{margin-top:0}.lg\\:h-\\[600px\\]{height:600px}.lg\\:w-1\\/3{width:33.333333%}.lg\\:max-w-\\[1200px\\]{max-width:1200px}.lg\\:max-w-\\[480px\\]{max-width:480px}.lg\\:flex-row{flex-direction:row}.lg\\:p-2{padding:.5rem}.lg\\:p-6{padding:1.5rem}}.\\[\\&\\>\\.sliderThumb\\]\\:h-4>.sliderThumb{height:1rem}.\\[\\&\\>\\.sliderThumb\\]\\:w-2>.sliderThumb{width:.5rem}.\\[\\&\\>\\.sliderTrack\\]\\:h-1>.sliderTrack{height:.25rem}.\\[\\&\\>\\.sliderTrack\\]\\:bg-red-500>.sliderTrack{--tw-bg-opacity: 1;background-color:rgb(239 68 68 / var(--tw-bg-opacity))}.\\[\\&\\[data-state\\=open\\]\\>svg\\]\\:rotate-180[data-state=open]>svg{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}', SF = ({ currency: e, lang: t, token: n, theme: s }) => {
  const { setToken: i, isInitialized: r } = tx();
  return Lt(() => {
    n && r && i(n);
  }, [n, r, i]), /* @__PURE__ */ y.jsx(vF, { currency: e, lang: t, theme: s });
}, MF = (e) => {
  const t = fe(null), [n, s] = ie(!1);
  return Lt(() => {
    const i = () => {
      if (t.current) {
        const r = t.current.getRootNode();
        if (r instanceof ShadowRoot && !r.querySelector('style[data-injected="true"]')) {
          const a = document.createElement("style");
          a.textContent = CF, a.setAttribute("data-injected", "true"), r.appendChild(a);
        }
      }
      s(!0);
    };
    if (i(), !n) {
      const r = setTimeout(i, 0);
      return () => clearTimeout(r);
    }
  }, [n]), /* @__PURE__ */ y.jsx("div", { ref: t, "data-theme": e.theme, className: e.styling, children: /* @__PURE__ */ y.jsx($b, { children: /* @__PURE__ */ y.jsx(SF, { ...e }) }) });
}, jF = Lx(MF, {
  props: {
    currency: "string",
    lang: "string",
    theme: "string",
    token: "string",
    styling: "string"
  },
  shadow: "closed"
});
export {
  jF as default
};
