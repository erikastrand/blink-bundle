/* Built at: 2024-11-04T04:56:29.795Z */
var n2 = Object.defineProperty;
var r2 = (t, e, n) => e in t ? n2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var K = (t, e, n) => r2(t, typeof e != "symbol" ? e + "" : e, n);
import * as E from "react";
import z, { createContext as oi, useState as Ge, useCallback as Je, useEffect as _e, useContext as Ht, useId as Pg, Component as s2, useLayoutEffect as Ig, useRef as Et, useInsertionEffect as VS, useMemo as Pr, forwardRef as ai, Fragment as US, createElement as Mn, Children as i2, isValidElement as o2, version as WS } from "react";
import * as Dg from "react-dom";
import pf from "react-dom";
function a2(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function c2(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var zS = { exports: {} }, Du = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function() {
  var t = z, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p = Symbol.iterator, m = "@@iterator";
  function y(I) {
    if (I === null || typeof I != "object")
      return null;
    var U = p && I[p] || I[m];
    return typeof U == "function" ? U : null;
  }
  var b = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function v(I) {
    {
      for (var U = arguments.length, X = new Array(U > 1 ? U - 1 : 0), pe = 1; pe < U; pe++)
        X[pe - 1] = arguments[pe];
      w("error", I, X);
    }
  }
  function w(I, U, X) {
    {
      var pe = b.ReactDebugCurrentFrame, $e = pe.getStackAddendum();
      $e !== "" && (U += "%s", X = X.concat([$e]));
      var ot = X.map(function(qe) {
        return String(qe);
      });
      ot.unshift("Warning: " + U), Function.prototype.apply.call(console[I], console, ot);
    }
  }
  var x = !1, A = !1, C = !1, S = !1, _ = !1, T;
  T = Symbol.for("react.module.reference");
  function k(I) {
    return !!(typeof I == "string" || typeof I == "function" || I === r || I === i || _ || I === s || I === l || I === u || S || I === h || x || A || C || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === d || I.$$typeof === o || I.$$typeof === a || I.$$typeof === c || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    I.$$typeof === T || I.getModuleId !== void 0));
  }
  function R(I, U, X) {
    var pe = I.displayName;
    if (pe)
      return pe;
    var $e = U.displayName || U.name || "";
    return $e !== "" ? X + "(" + $e + ")" : X;
  }
  function P(I) {
    return I.displayName || "Context";
  }
  function M(I) {
    if (I == null)
      return null;
    if (typeof I.tag == "number" && v("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof I == "function")
      return I.displayName || I.name || null;
    if (typeof I == "string")
      return I;
    switch (I) {
      case r:
        return "Fragment";
      case n:
        return "Portal";
      case i:
        return "Profiler";
      case s:
        return "StrictMode";
      case l:
        return "Suspense";
      case u:
        return "SuspenseList";
    }
    if (typeof I == "object")
      switch (I.$$typeof) {
        case a:
          var U = I;
          return P(U) + ".Consumer";
        case o:
          var X = I;
          return P(X._context) + ".Provider";
        case c:
          return R(I, I.render, "ForwardRef");
        case d:
          var pe = I.displayName || null;
          return pe !== null ? pe : M(I.type) || "Memo";
        case f: {
          var $e = I, ot = $e._payload, qe = $e._init;
          try {
            return M(qe(ot));
          } catch {
            return null;
          }
        }
      }
    return null;
  }
  var D = Object.assign, O = 0, q, L, N, j, V, Z, G;
  function $() {
  }
  $.__reactDisabledLog = !0;
  function fe() {
    {
      if (O === 0) {
        q = console.log, L = console.info, N = console.warn, j = console.error, V = console.group, Z = console.groupCollapsed, G = console.groupEnd;
        var I = {
          configurable: !0,
          enumerable: !0,
          value: $,
          writable: !0
        };
        Object.defineProperties(console, {
          info: I,
          log: I,
          warn: I,
          error: I,
          group: I,
          groupCollapsed: I,
          groupEnd: I
        });
      }
      O++;
    }
  }
  function he() {
    {
      if (O--, O === 0) {
        var I = {
          configurable: !0,
          enumerable: !0,
          writable: !0
        };
        Object.defineProperties(console, {
          log: D({}, I, {
            value: q
          }),
          info: D({}, I, {
            value: L
          }),
          warn: D({}, I, {
            value: N
          }),
          error: D({}, I, {
            value: j
          }),
          group: D({}, I, {
            value: V
          }),
          groupCollapsed: D({}, I, {
            value: Z
          }),
          groupEnd: D({}, I, {
            value: G
          })
        });
      }
      O < 0 && v("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
  }
  var be = b.ReactCurrentDispatcher, He;
  function at(I, U, X) {
    {
      if (He === void 0)
        try {
          throw Error();
        } catch ($e) {
          var pe = $e.stack.trim().match(/\n( *(at )?)/);
          He = pe && pe[1] || "";
        }
      return `
` + He + I;
    }
  }
  var xt = !1, tt;
  {
    var wt = typeof WeakMap == "function" ? WeakMap : Map;
    tt = new wt();
  }
  function F(I, U) {
    if (!I || xt)
      return "";
    {
      var X = tt.get(I);
      if (X !== void 0)
        return X;
    }
    var pe;
    xt = !0;
    var $e = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    var ot;
    ot = be.current, be.current = null, fe();
    try {
      if (U) {
        var qe = function() {
          throw Error();
        };
        if (Object.defineProperty(qe.prototype, "props", {
          set: function() {
            throw Error();
          }
        }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(qe, []);
          } catch (An) {
            pe = An;
          }
          Reflect.construct(I, [], qe);
        } else {
          try {
            qe.call();
          } catch (An) {
            pe = An;
          }
          I.call(qe.prototype);
        }
      } else {
        try {
          throw Error();
        } catch (An) {
          pe = An;
        }
        I();
      }
    } catch (An) {
      if (An && pe && typeof An.stack == "string") {
        for (var Me = An.stack.split(`
`), fn = pe.stack.split(`
`), Mt = Me.length - 1, Ot = fn.length - 1; Mt >= 1 && Ot >= 0 && Me[Mt] !== fn[Ot]; )
          Ot--;
        for (; Mt >= 1 && Ot >= 0; Mt--, Ot--)
          if (Me[Mt] !== fn[Ot]) {
            if (Mt !== 1 || Ot !== 1)
              do
                if (Mt--, Ot--, Ot < 0 || Me[Mt] !== fn[Ot]) {
                  var Gn = `
` + Me[Mt].replace(" at new ", " at ");
                  return I.displayName && Gn.includes("<anonymous>") && (Gn = Gn.replace("<anonymous>", I.displayName)), typeof I == "function" && tt.set(I, Gn), Gn;
                }
              while (Mt >= 1 && Ot >= 0);
            break;
          }
      }
    } finally {
      xt = !1, be.current = ot, he(), Error.prepareStackTrace = $e;
    }
    var lo = I ? I.displayName || I.name : "", mi = lo ? at(lo) : "";
    return typeof I == "function" && tt.set(I, mi), mi;
  }
  function ee(I, U, X) {
    return F(I, !1);
  }
  function re(I) {
    var U = I.prototype;
    return !!(U && U.isReactComponent);
  }
  function nt(I, U, X) {
    if (I == null)
      return "";
    if (typeof I == "function")
      return F(I, re(I));
    if (typeof I == "string")
      return at(I);
    switch (I) {
      case l:
        return at("Suspense");
      case u:
        return at("SuspenseList");
    }
    if (typeof I == "object")
      switch (I.$$typeof) {
        case c:
          return ee(I.render);
        case d:
          return nt(I.type, U, X);
        case f: {
          var pe = I, $e = pe._payload, ot = pe._init;
          try {
            return nt(ot($e), U, X);
          } catch {
          }
        }
      }
    return "";
  }
  var kt = Object.prototype.hasOwnProperty, Yn = {}, Pn = b.ReactDebugCurrentFrame;
  function Rt(I) {
    if (I) {
      var U = I._owner, X = nt(I.type, I._source, U ? U.type : null);
      Pn.setExtraStackFrame(X);
    } else
      Pn.setExtraStackFrame(null);
  }
  function Y(I, U, X, pe, $e) {
    {
      var ot = Function.call.bind(kt);
      for (var qe in I)
        if (ot(I, qe)) {
          var Me = void 0;
          try {
            if (typeof I[qe] != "function") {
              var fn = Error((pe || "React class") + ": " + X + " type `" + qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof I[qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
              throw fn.name = "Invariant Violation", fn;
            }
            Me = I[qe](U, qe, pe, X, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
          } catch (Mt) {
            Me = Mt;
          }
          Me && !(Me instanceof Error) && (Rt($e), v("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", pe || "React class", X, qe, typeof Me), Rt(null)), Me instanceof Error && !(Me.message in Yn) && (Yn[Me.message] = !0, Rt($e), v("Failed %s type: %s", X, Me.message), Rt(null));
        }
    }
  }
  var ye = Array.isArray;
  function te(I) {
    return ye(I);
  }
  function ve(I) {
    {
      var U = typeof Symbol == "function" && Symbol.toStringTag, X = U && I[Symbol.toStringTag] || I.constructor.name || "Object";
      return X;
    }
  }
  function Ee(I) {
    try {
      return xn(I), !1;
    } catch {
      return !0;
    }
  }
  function xn(I) {
    return "" + I;
  }
  function ao(I) {
    if (Ee(I))
      return v("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ve(I)), xn(I);
  }
  var mr = b.ReactCurrentOwner, wh = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  }, Ba, Ll, Fr;
  Fr = {};
  function jl(I) {
    if (kt.call(I, "ref")) {
      var U = Object.getOwnPropertyDescriptor(I, "ref").get;
      if (U && U.isReactWarning)
        return !1;
    }
    return I.ref !== void 0;
  }
  function Ah(I) {
    if (kt.call(I, "key")) {
      var U = Object.getOwnPropertyDescriptor(I, "key").get;
      if (U && U.isReactWarning)
        return !1;
    }
    return I.key !== void 0;
  }
  function Sh(I, U) {
    if (typeof I.ref == "string" && mr.current && U && mr.current.stateNode !== U) {
      var X = M(mr.current.type);
      Fr[X] || (v('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', M(mr.current.type), I.ref), Fr[X] = !0);
    }
  }
  function Eh(I, U) {
    {
      var X = function() {
        Ba || (Ba = !0, v("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", U));
      };
      X.isReactWarning = !0, Object.defineProperty(I, "key", {
        get: X,
        configurable: !0
      });
    }
  }
  function Ch(I, U) {
    {
      var X = function() {
        Ll || (Ll = !0, v("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", U));
      };
      X.isReactWarning = !0, Object.defineProperty(I, "ref", {
        get: X,
        configurable: !0
      });
    }
  }
  var _h = function(I, U, X, pe, $e, ot, qe) {
    var Me = {
      // This tag allows us to uniquely identify this as a React Element
      $$typeof: e,
      // Built-in properties that belong on the element
      type: I,
      key: U,
      ref: X,
      props: qe,
      // Record the component responsible for creating this element.
      _owner: ot
    };
    return Me._store = {}, Object.defineProperty(Me._store, "validated", {
      configurable: !1,
      enumerable: !1,
      writable: !0,
      value: !1
    }), Object.defineProperty(Me, "_self", {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: pe
    }), Object.defineProperty(Me, "_source", {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: $e
    }), Object.freeze && (Object.freeze(Me.props), Object.freeze(Me)), Me;
  };
  function ce(I, U, X, pe, $e) {
    {
      var ot, qe = {}, Me = null, fn = null;
      X !== void 0 && (ao(X), Me = "" + X), Ah(U) && (ao(U.key), Me = "" + U.key), jl(U) && (fn = U.ref, Sh(U, $e));
      for (ot in U)
        kt.call(U, ot) && !wh.hasOwnProperty(ot) && (qe[ot] = U[ot]);
      if (I && I.defaultProps) {
        var Mt = I.defaultProps;
        for (ot in Mt)
          qe[ot] === void 0 && (qe[ot] = Mt[ot]);
      }
      if (Me || fn) {
        var Ot = typeof I == "function" ? I.displayName || I.name || "Unknown" : I;
        Me && Eh(qe, Ot), fn && Ch(qe, Ot);
      }
      return _h(I, Me, fn, $e, pe, mr.current, qe);
    }
  }
  var Ve = b.ReactCurrentOwner, rt = b.ReactDebugCurrentFrame;
  function Ye(I) {
    if (I) {
      var U = I._owner, X = nt(I.type, I._source, U ? U.type : null);
      rt.setExtraStackFrame(X);
    } else
      rt.setExtraStackFrame(null);
  }
  var Ue;
  Ue = !1;
  function tn(I) {
    return typeof I == "object" && I !== null && I.$$typeof === e;
  }
  function Wt() {
    {
      if (Ve.current) {
        var I = M(Ve.current.type);
        if (I)
          return `

Check the render method of \`` + I + "`.";
      }
      return "";
    }
  }
  function dn(I) {
    return "";
  }
  var wn = {};
  function Vr(I) {
    {
      var U = Wt();
      if (!U) {
        var X = typeof I == "string" ? I : I.displayName || I.name;
        X && (U = `

Check the top-level render call using <` + X + ">.");
      }
      return U;
    }
  }
  function tr(I, U) {
    {
      if (!I._store || I._store.validated || I.key != null)
        return;
      I._store.validated = !0;
      var X = Vr(U);
      if (wn[X])
        return;
      wn[X] = !0;
      var pe = "";
      I && I._owner && I._owner !== Ve.current && (pe = " It was passed a child from " + M(I._owner.type) + "."), Ye(I), v('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', X, pe), Ye(null);
    }
  }
  function In(I, U) {
    {
      if (typeof I != "object")
        return;
      if (te(I))
        for (var X = 0; X < I.length; X++) {
          var pe = I[X];
          tn(pe) && tr(pe, U);
        }
      else if (tn(I))
        I._store && (I._store.validated = !0);
      else if (I) {
        var $e = y(I);
        if (typeof $e == "function" && $e !== I.entries)
          for (var ot = $e.call(I), qe; !(qe = ot.next()).done; )
            tn(qe.value) && tr(qe.value, U);
      }
    }
  }
  function co(I) {
    {
      var U = I.type;
      if (U == null || typeof U == "string")
        return;
      var X;
      if (typeof U == "function")
        X = U.propTypes;
      else if (typeof U == "object" && (U.$$typeof === c || // Note: Memo only checks outer props here.
      // Inner props are checked in the reconciler.
      U.$$typeof === d))
        X = U.propTypes;
      else
        return;
      if (X) {
        var pe = M(U);
        Y(X, I.props, "prop", pe, I);
      } else if (U.PropTypes !== void 0 && !Ue) {
        Ue = !0;
        var $e = M(U);
        v("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", $e || "Unknown");
      }
      typeof U.getDefaultProps == "function" && !U.getDefaultProps.isReactClassApproved && v("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Bl(I) {
    {
      for (var U = Object.keys(I.props), X = 0; X < U.length; X++) {
        var pe = U[X];
        if (pe !== "children" && pe !== "key") {
          Ye(I), v("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", pe), Ye(null);
          break;
        }
      }
      I.ref !== null && (Ye(I), v("Invalid attribute `ref` supplied to `React.Fragment`."), Ye(null));
    }
  }
  var c0 = {};
  function l0(I, U, X, pe, $e, ot) {
    {
      var qe = k(I);
      if (!qe) {
        var Me = "";
        (I === void 0 || typeof I == "object" && I !== null && Object.keys(I).length === 0) && (Me += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
        var fn = dn();
        fn ? Me += fn : Me += Wt();
        var Mt;
        I === null ? Mt = "null" : te(I) ? Mt = "array" : I !== void 0 && I.$$typeof === e ? (Mt = "<" + (M(I.type) || "Unknown") + " />", Me = " Did you accidentally export a JSX literal instead of a component?") : Mt = typeof I, v("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Mt, Me);
      }
      var Ot = ce(I, U, X, $e, ot);
      if (Ot == null)
        return Ot;
      if (qe) {
        var Gn = U.children;
        if (Gn !== void 0)
          if (pe)
            if (te(Gn)) {
              for (var lo = 0; lo < Gn.length; lo++)
                In(Gn[lo], I);
              Object.freeze && Object.freeze(Gn);
            } else
              v("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
          else
            In(Gn, I);
      }
      if (kt.call(U, "key")) {
        var mi = M(I), An = Object.keys(U).filter(function(t2) {
          return t2 !== "key";
        }), Th = An.length > 0 ? "{key: someKey, " + An.join(": ..., ") + ": ...}" : "{key: someKey}";
        if (!c0[mi + Th]) {
          var e2 = An.length > 0 ? "{" + An.join(": ..., ") + ": ...}" : "{}";
          v(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Th, mi, e2, mi), c0[mi + Th] = !0;
        }
      }
      return I === r ? Bl(Ot) : co(Ot), Ot;
    }
  }
  function ZP(I, U, X) {
    return l0(I, U, X, !0);
  }
  function QP(I, U, X) {
    return l0(I, U, X, !1);
  }
  var XP = QP, JP = ZP;
  Du.Fragment = r, Du.jsx = XP, Du.jsxs = JP;
})();
zS.exports = Du;
var g = zS.exports, l2 = Object.defineProperty, u2 = (t, e, n) => e in t ? l2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Fa = (t, e, n) => (u2(t, typeof e != "symbol" ? e + "" : e, n), n), HS, u0 = pf;
{
  var d0 = u0.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  HS = function(t, e) {
    d0.usingClientEntryPoint = !0;
    try {
      return u0.createRoot(t, e);
    } finally {
      d0.usingClientEntryPoint = !1;
    }
  };
}
const d2 = {
  stringify: (t) => t,
  parse: (t) => t
}, f2 = {
  stringify: (t) => `${t}`,
  parse: (t) => parseFloat(t)
}, h2 = {
  stringify: (t) => t ? "true" : "false",
  parse: (t) => /^[ty1-9]/i.test(t)
}, p2 = {
  stringify: (t) => t.name,
  parse: (t, e) => {
    const n = (() => {
      if (typeof window < "u" && t in window)
        return window[t];
      if (typeof global < "u" && t in global)
        return global[t];
    })();
    return typeof n == "function" ? n.bind(e) : void 0;
  }
}, m2 = {
  stringify: (t) => JSON.stringify(t),
  parse: (t) => typeof t == "string" ? JSON.parse(t) : t
}, g2 = {
  string: d2,
  number: f2,
  boolean: h2,
  function: p2,
  json: m2
}, y2 = "__reactProps";
function b2(t, e, n) {
  e.props || (e.props = t.propTypes ? Object.keys(t.propTypes) : []);
  const r = (Array.isArray(e.props) ? e.props.slice() : Object.keys(e.props)).filter((a) => a !== "container"), s = {}, i = {};
  for (const a of r) {
    s[a] = Array.isArray(e.props) ? "string" : e.props[a];
    const c = v2(a);
    i[a] = c;
  }
  class o extends HTMLElement {
    constructor() {
      super(), Fa(this, "connected", !1), Fa(this, "context"), Fa(this, "_props", {}), Fa(this, "container"), Fa(this, "observer"), this.observer = new MutationObserver(
        (c) => this.attributesChanged(c)
      ), this.observer.observe(this, { attributes: !0 }), e.shadow ? this.container = this.attachShadow({
        mode: e.shadow
      }) : this.container = this, this._props.container = this.container;
    }
    set props(c) {
      this._props = {
        ...this._props,
        ...c
      }, this.update();
    }
    get props() {
      return this._props;
    }
    connectedCallback() {
      this.connected = !0;
      for (const c of r)
        this.setProps(c);
      this.mount();
    }
    disconnectedCallback() {
      this.connected = !1, this.observer.disconnect(), this.unmount();
    }
    attributesChanged(c) {
      c.forEach(({ attributeName: l }) => {
        this.setProps(l);
      }), this.update();
    }
    setProps(c) {
      const l = Object.keys(this).find((m) => m.includes(y2)), u = l ? this[l] : {}, d = i[c], f = u[c] ?? this.getAttribute(d), h = s[c], p = g2[h];
      c in u ? this._props[c] = f : f && p != null && p.parse && (this._props[c] = p.parse(f, this));
    }
    update() {
      this.connected && this.context && n.update(this.context, this.props);
    }
    mount() {
      if (!this.connected)
        throw new Error(`${t} is not in a DOM`);
      if (this.context)
        throw new Error(`${t} is already mounted`);
      this.context = n.mount(this.container, t, this.props);
    }
    unmount() {
      this.context && n.unmount(this.context);
    }
  }
  return o;
}
function v2(t = "") {
  return t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
const x2 = (t, e, n) => {
  const r = HS(t), s = z.createElement(e, n);
  return r.render(s), {
    root: r,
    ReactComponent: e
  };
}, w2 = ({ root: t, ReactComponent: e }, n) => {
  const r = z.createElement(e, n);
  t.render(r);
}, A2 = ({ root: t }) => {
  t.unmount();
}, S2 = (t, e = {}) => b2(t, e, { mount: x2, update: w2, unmount: A2 }), YS = oi(void 0);
async function E2() {
  return typeof window < "u" ? sessionStorage.getItem("gameToken") : null;
}
async function C2(t) {
  typeof window < "u" && sessionStorage.setItem("gameToken", t);
}
async function _2() {
  typeof window < "u" && sessionStorage.removeItem("gameToken");
}
const T2 = ({ children: t }) => {
  const [e, n] = Ge(sessionStorage.getItem("gameToken") || null), [r, s] = Ge(!1), i = Je(async (a) => {
    await C2(a), n(a);
  }, []), o = Je(async () => {
    await _2(), n(null);
  }, []);
  return _e(() => {
    (async () => {
      const c = await E2();
      if (c)
        n(c);
      else if (typeof window < "u") {
        const u = new URLSearchParams(window.location.search).get("token");
        u && (await i(u), window.history.replaceState({}, document.title, window.location.pathname));
      }
      s(!0);
    })();
  }, [i]), /* @__PURE__ */ g.jsx(YS.Provider, { value: { authToken: e, setAuthToken: i, clearAuthToken: o, isInitialized: r }, children: t });
}, ma = () => {
  const t = Ht(YS);
  if (t === void 0)
    throw new Error("useAuth must be used within an AuthProvider");
  return t;
}, k2 = {
  type: "logger",
  log(t) {
    this.output("log", t);
  },
  warn(t) {
    this.output("warn", t);
  },
  error(t) {
    this.output("error", t);
  },
  output(t, e) {
    console && console[t] && console[t].apply(console, e);
  }
};
class dd {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, n);
  }
  init(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = n.prefix || "i18next:", this.logger = e || k2, this.options = n, this.debug = n.debug;
  }
  log() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    return this.forward(n, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    return this.forward(n, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    return this.forward(n, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    return this.forward(n, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, n, r, s) {
    return s && !this.debug ? null : (typeof e[0] == "string" && (e[0] = `${r}${this.prefix} ${e[0]}`), this.logger[n](e));
  }
  create(e) {
    return new dd(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new dd(this.logger, e);
  }
}
var Sr = new dd();
class mf {
  constructor() {
    this.observers = {};
  }
  on(e, n) {
    return e.split(" ").forEach((r) => {
      this.observers[r] || (this.observers[r] = /* @__PURE__ */ new Map());
      const s = this.observers[r].get(n) || 0;
      this.observers[r].set(n, s + 1);
    }), this;
  }
  off(e, n) {
    if (this.observers[e]) {
      if (!n) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(n);
    }
  }
  emit(e) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      r[s - 1] = arguments[s];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((o) => {
      let [a, c] = o;
      for (let l = 0; l < c; l++)
        a(...r);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((o) => {
      let [a, c] = o;
      for (let l = 0; l < c; l++)
        a.apply(a, [e, ...r]);
    });
  }
}
const Va = () => {
  let t, e;
  const n = new Promise((r, s) => {
    t = r, e = s;
  });
  return n.resolve = t, n.reject = e, n;
}, f0 = (t) => t == null ? "" : "" + t, R2 = (t, e, n) => {
  t.forEach((r) => {
    e[r] && (n[r] = e[r]);
  });
}, M2 = /###/g, h0 = (t) => t && t.indexOf("###") > -1 ? t.replace(M2, ".") : t, p0 = (t) => !t || typeof t == "string", fc = (t, e, n) => {
  const r = typeof e != "string" ? e : e.split(".");
  let s = 0;
  for (; s < r.length - 1; ) {
    if (p0(t)) return {};
    const i = h0(r[s]);
    !t[i] && n && (t[i] = new n()), Object.prototype.hasOwnProperty.call(t, i) ? t = t[i] : t = {}, ++s;
  }
  return p0(t) ? {} : {
    obj: t,
    k: h0(r[s])
  };
}, m0 = (t, e, n) => {
  const {
    obj: r,
    k: s
  } = fc(t, e, Object);
  if (r !== void 0 || e.length === 1) {
    r[s] = n;
    return;
  }
  let i = e[e.length - 1], o = e.slice(0, e.length - 1), a = fc(t, o, Object);
  for (; a.obj === void 0 && o.length; )
    i = `${o[o.length - 1]}.${i}`, o = o.slice(0, o.length - 1), a = fc(t, o, Object), a && a.obj && typeof a.obj[`${a.k}.${i}`] < "u" && (a.obj = void 0);
  a.obj[`${a.k}.${i}`] = n;
}, P2 = (t, e, n, r) => {
  const {
    obj: s,
    k: i
  } = fc(t, e, Object);
  s[i] = s[i] || [], s[i].push(n);
}, fd = (t, e) => {
  const {
    obj: n,
    k: r
  } = fc(t, e);
  if (n)
    return n[r];
}, I2 = (t, e, n) => {
  const r = fd(t, n);
  return r !== void 0 ? r : fd(e, n);
}, GS = (t, e, n) => {
  for (const r in e)
    r !== "__proto__" && r !== "constructor" && (r in t ? typeof t[r] == "string" || t[r] instanceof String || typeof e[r] == "string" || e[r] instanceof String ? n && (t[r] = e[r]) : GS(t[r], e[r], n) : t[r] = e[r]);
  return t;
}, uo = (t) => t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var D2 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const O2 = (t) => typeof t == "string" ? t.replace(/[&<>"'\/]/g, (e) => D2[e]) : t;
class q2 {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const n = this.regExpMap.get(e);
    if (n !== void 0)
      return n;
    const r = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, r), this.regExpQueue.push(e), r;
  }
}
const N2 = [" ", ",", "?", "!", ";"], L2 = new q2(20), j2 = (t, e, n) => {
  e = e || "", n = n || "";
  const r = N2.filter((o) => e.indexOf(o) < 0 && n.indexOf(o) < 0);
  if (r.length === 0) return !0;
  const s = L2.getRegExp(`(${r.map((o) => o === "?" ? "\\?" : o).join("|")})`);
  let i = !s.test(t);
  if (!i) {
    const o = t.indexOf(n);
    o > 0 && !s.test(t.substring(0, o)) && (i = !0);
  }
  return i;
}, Fp = function(t, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!t) return;
  if (t[e]) return t[e];
  const r = e.split(n);
  let s = t;
  for (let i = 0; i < r.length; ) {
    if (!s || typeof s != "object")
      return;
    let o, a = "";
    for (let c = i; c < r.length; ++c)
      if (c !== i && (a += n), a += r[c], o = s[a], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && c < r.length - 1)
          continue;
        i += c - i + 1;
        break;
      }
    s = o;
  }
  return s;
}, hd = (t) => t && t.indexOf("_") > 0 ? t.replace("_", "-") : t;
class g0 extends mf {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const n = this.options.ns.indexOf(e);
    n > -1 && this.options.ns.splice(n, 1);
  }
  getResource(e, n, r) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const i = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator, o = s.ignoreJSONStructure !== void 0 ? s.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let a;
    e.indexOf(".") > -1 ? a = e.split(".") : (a = [e, n], r && (Array.isArray(r) ? a.push(...r) : typeof r == "string" && i ? a.push(...r.split(i)) : a.push(r)));
    const c = fd(this.data, a);
    return !c && !n && !r && e.indexOf(".") > -1 && (e = a[0], n = a[1], r = a.slice(2).join(".")), c || !o || typeof r != "string" ? c : Fp(this.data && this.data[e] && this.data[e][n], r, i);
  }
  addResource(e, n, r, s) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator;
    let a = [e, n];
    r && (a = a.concat(o ? r.split(o) : r)), e.indexOf(".") > -1 && (a = e.split("."), s = n, n = a[1]), this.addNamespaces(n), m0(this.data, a, s), i.silent || this.emit("added", e, n, r, s);
  }
  addResources(e, n, r) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const i in r)
      (typeof r[i] == "string" || Array.isArray(r[i])) && this.addResource(e, n, i, r[i], {
        silent: !0
      });
    s.silent || this.emit("added", e, n, r);
  }
  addResourceBundle(e, n, r, s, i) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, a = [e, n];
    e.indexOf(".") > -1 && (a = e.split("."), s = r, r = n, n = a[1]), this.addNamespaces(n);
    let c = fd(this.data, a) || {};
    o.skipCopy || (r = JSON.parse(JSON.stringify(r))), s ? GS(c, r, i) : c = {
      ...c,
      ...r
    }, m0(this.data, a, c), o.silent || this.emit("added", e, n, r);
  }
  removeResourceBundle(e, n) {
    this.hasResourceBundle(e, n) && delete this.data[e][n], this.removeNamespaces(n), this.emit("removed", e, n);
  }
  hasResourceBundle(e, n) {
    return this.getResource(e, n) !== void 0;
  }
  getResourceBundle(e, n) {
    return n || (n = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(e, n)
    } : this.getResource(e, n);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const n = this.getDataByLanguage(e);
    return !!(n && Object.keys(n) || []).find((s) => n[s] && Object.keys(n[s]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var KS = {
  processors: {},
  addPostProcessor(t) {
    this.processors[t.name] = t;
  },
  handle(t, e, n, r, s) {
    return t.forEach((i) => {
      this.processors[i] && (e = this.processors[i].process(e, n, r, s));
    }), e;
  }
};
const y0 = {};
class pd extends mf {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), R2(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Sr.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const r = this.resolve(e, n);
    return r && r.res !== void 0;
  }
  extractFromKey(e, n) {
    let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
    r === void 0 && (r = ":");
    const s = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
    let i = n.ns || this.options.defaultNS || [];
    const o = r && e.indexOf(r) > -1, a = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !j2(e, r, s);
    if (o && !a) {
      const c = e.match(this.interpolator.nestingRegexp);
      if (c && c.length > 0)
        return {
          key: e,
          namespaces: i
        };
      const l = e.split(r);
      (r !== s || r === s && this.options.ns.indexOf(l[0]) > -1) && (i = l.shift()), e = l.join(s);
    }
    return typeof i == "string" && (i = [i]), {
      key: e,
      namespaces: i
    };
  }
  translate(e, n, r) {
    if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == "object" && (n = {
      ...n
    }), n || (n = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const s = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails, i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator, {
      key: o,
      namespaces: a
    } = this.extractFromKey(e[e.length - 1], n), c = a[a.length - 1], l = n.lng || this.language, u = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (l && l.toLowerCase() === "cimode") {
      if (u) {
        const x = n.nsSeparator || this.options.nsSeparator;
        return s ? {
          res: `${c}${x}${o}`,
          usedKey: o,
          exactUsedKey: o,
          usedLng: l,
          usedNS: c,
          usedParams: this.getUsedParamsDetails(n)
        } : `${c}${x}${o}`;
      }
      return s ? {
        res: o,
        usedKey: o,
        exactUsedKey: o,
        usedLng: l,
        usedNS: c,
        usedParams: this.getUsedParamsDetails(n)
      } : o;
    }
    const d = this.resolve(e, n);
    let f = d && d.res;
    const h = d && d.usedKey || o, p = d && d.exactUsedKey || o, m = Object.prototype.toString.apply(f), y = ["[object Number]", "[object Function]", "[object RegExp]"], b = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays, v = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (v && f && (typeof f != "string" && typeof f != "boolean" && typeof f != "number") && y.indexOf(m) < 0 && !(typeof b == "string" && Array.isArray(f))) {
      if (!n.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const x = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, f, {
          ...n,
          ns: a
        }) : `key '${o} (${this.language})' returned an object instead of string.`;
        return s ? (d.res = x, d.usedParams = this.getUsedParamsDetails(n), d) : x;
      }
      if (i) {
        const x = Array.isArray(f), A = x ? [] : {}, C = x ? p : h;
        for (const S in f)
          if (Object.prototype.hasOwnProperty.call(f, S)) {
            const _ = `${C}${i}${S}`;
            A[S] = this.translate(_, {
              ...n,
              joinArrays: !1,
              ns: a
            }), A[S] === _ && (A[S] = f[S]);
          }
        f = A;
      }
    } else if (v && typeof b == "string" && Array.isArray(f))
      f = f.join(b), f && (f = this.extendTranslation(f, e, n, r));
    else {
      let x = !1, A = !1;
      const C = n.count !== void 0 && typeof n.count != "string", S = pd.hasDefaultValue(n), _ = C ? this.pluralResolver.getSuffix(l, n.count, n) : "", T = n.ordinal && C ? this.pluralResolver.getSuffix(l, n.count, {
        ordinal: !1
      }) : "", k = C && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), R = k && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${_}`] || n[`defaultValue${T}`] || n.defaultValue;
      !this.isValidLookup(f) && S && (x = !0, f = R), this.isValidLookup(f) || (A = !0, f = o);
      const M = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && A ? void 0 : f, D = S && R !== f && this.options.updateMissing;
      if (A || x || D) {
        if (this.logger.log(D ? "updateKey" : "missingKey", l, c, o, D ? R : f), i) {
          const N = this.resolve(o, {
            ...n,
            keySeparator: !1
          });
          N && N.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let O = [];
        const q = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && q && q[0])
          for (let N = 0; N < q.length; N++)
            O.push(q[N]);
        else this.options.saveMissingTo === "all" ? O = this.languageUtils.toResolveHierarchy(n.lng || this.language) : O.push(n.lng || this.language);
        const L = (N, j, V) => {
          const Z = S && V !== f ? V : M;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(N, c, j, Z, D, n) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(N, c, j, Z, D, n), this.emit("missingKey", N, c, j, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && C ? O.forEach((N) => {
          const j = this.pluralResolver.getSuffixes(N, n);
          k && n[`defaultValue${this.options.pluralSeparator}zero`] && j.indexOf(`${this.options.pluralSeparator}zero`) < 0 && j.push(`${this.options.pluralSeparator}zero`), j.forEach((V) => {
            L([N], o + V, n[`defaultValue${V}`] || R);
          });
        }) : L(O, o, R));
      }
      f = this.extendTranslation(f, e, n, d, r), A && f === o && this.options.appendNamespaceToMissingKey && (f = `${c}:${o}`), (A || x) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${c}:${o}` : o, x ? f : void 0) : f = this.options.parseMissingKeyHandler(f));
    }
    return s ? (d.res = f, d.usedParams = this.getUsedParamsDetails(n), d) : f;
  }
  extendTranslation(e, n, r, s, i) {
    var o = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...r
      }, r.lng || this.language || s.usedLng, s.usedNS, s.usedKey, {
        resolved: s
      });
    else if (!r.skipInterpolation) {
      r.interpolation && this.interpolator.init({
        ...r,
        interpolation: {
          ...this.options.interpolation,
          ...r.interpolation
        }
      });
      const l = typeof e == "string" && (r && r.interpolation && r.interpolation.skipOnVariables !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let u;
      if (l) {
        const f = e.match(this.interpolator.nestingRegexp);
        u = f && f.length;
      }
      let d = r.replace && typeof r.replace != "string" ? r.replace : r;
      if (this.options.interpolation.defaultVariables && (d = {
        ...this.options.interpolation.defaultVariables,
        ...d
      }), e = this.interpolator.interpolate(e, d, r.lng || this.language || s.usedLng, r), l) {
        const f = e.match(this.interpolator.nestingRegexp), h = f && f.length;
        u < h && (r.nest = !1);
      }
      !r.lng && this.options.compatibilityAPI !== "v1" && s && s.res && (r.lng = this.language || s.usedLng), r.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var f = arguments.length, h = new Array(f), p = 0; p < f; p++)
          h[p] = arguments[p];
        return i && i[0] === h[0] && !r.context ? (o.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${n[0]}`), null) : o.translate(...h, n);
      }, r)), r.interpolation && this.interpolator.reset();
    }
    const a = r.postProcess || this.options.postProcess, c = typeof a == "string" ? [a] : a;
    return e != null && c && c.length && r.applyPostProcessor !== !1 && (e = KS.handle(c, e, n, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...s,
        usedParams: this.getUsedParamsDetails(r)
      },
      ...r
    } : r, this)), e;
  }
  resolve(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r, s, i, o, a;
    return typeof e == "string" && (e = [e]), e.forEach((c) => {
      if (this.isValidLookup(r)) return;
      const l = this.extractFromKey(c, n), u = l.key;
      s = u;
      let d = l.namespaces;
      this.options.fallbackNS && (d = d.concat(this.options.fallbackNS));
      const f = n.count !== void 0 && typeof n.count != "string", h = f && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(), p = n.context !== void 0 && (typeof n.context == "string" || typeof n.context == "number") && n.context !== "", m = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
      d.forEach((y) => {
        this.isValidLookup(r) || (a = y, !y0[`${m[0]}-${y}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(a) && (y0[`${m[0]}-${y}`] = !0, this.logger.warn(`key "${s}" for languages "${m.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), m.forEach((b) => {
          if (this.isValidLookup(r)) return;
          o = b;
          const v = [u];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(v, u, b, y, n);
          else {
            let x;
            f && (x = this.pluralResolver.getSuffix(b, n.count, n));
            const A = `${this.options.pluralSeparator}zero`, C = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (f && (v.push(u + x), n.ordinal && x.indexOf(C) === 0 && v.push(u + x.replace(C, this.options.pluralSeparator)), h && v.push(u + A)), p) {
              const S = `${u}${this.options.contextSeparator}${n.context}`;
              v.push(S), f && (v.push(S + x), n.ordinal && x.indexOf(C) === 0 && v.push(S + x.replace(C, this.options.pluralSeparator)), h && v.push(S + A));
            }
          }
          let w;
          for (; w = v.pop(); )
            this.isValidLookup(r) || (i = w, r = this.getResource(b, y, w, n));
        }));
      });
    }), {
      res: r,
      usedKey: s,
      exactUsedKey: i,
      usedLng: o,
      usedNS: a
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, n, r) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, n, r, s) : this.resourceStore.getResource(e, n, r, s);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], r = e.replace && typeof e.replace != "string";
    let s = r ? e.replace : e;
    if (r && typeof e.count < "u" && (s.count = e.count), this.options.interpolation.defaultVariables && (s = {
      ...this.options.interpolation.defaultVariables,
      ...s
    }), !r) {
      s = {
        ...s
      };
      for (const i of n)
        delete s[i];
    }
    return s;
  }
  static hasDefaultValue(e) {
    const n = "defaultValue";
    for (const r in e)
      if (Object.prototype.hasOwnProperty.call(e, r) && n === r.substring(0, n.length) && e[r] !== void 0)
        return !0;
    return !1;
  }
}
const kh = (t) => t.charAt(0).toUpperCase() + t.slice(1);
class b0 {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Sr.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = hd(e), !e || e.indexOf("-") < 0) return null;
    const n = e.split("-");
    return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = hd(e), !e || e.indexOf("-") < 0) return e;
    const n = e.split("-");
    return this.formatLanguageCode(n[0]);
  }
  formatLanguageCode(e) {
    if (typeof e == "string" && e.indexOf("-") > -1) {
      const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let r = e.split("-");
      return this.options.lowerCaseLng ? r = r.map((s) => s.toLowerCase()) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = kh(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = kh(r[1].toLowerCase())), n.indexOf(r[2].toLowerCase()) > -1 && (r[2] = kh(r[2].toLowerCase()))), r.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let n;
    return e.forEach((r) => {
      if (n) return;
      const s = this.formatLanguageCode(r);
      (!this.options.supportedLngs || this.isSupportedCode(s)) && (n = s);
    }), !n && this.options.supportedLngs && e.forEach((r) => {
      if (n) return;
      const s = this.getLanguagePartFromCode(r);
      if (this.isSupportedCode(s)) return n = s;
      n = this.options.supportedLngs.find((i) => {
        if (i === s) return i;
        if (!(i.indexOf("-") < 0 && s.indexOf("-") < 0) && (i.indexOf("-") > 0 && s.indexOf("-") < 0 && i.substring(0, i.indexOf("-")) === s || i.indexOf(s) === 0 && s.length > 1))
          return i;
      });
    }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n;
  }
  getFallbackCodes(e, n) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(n)), typeof e == "string" && (e = [e]), Array.isArray(e)) return e;
    if (!n) return e.default || [];
    let r = e[n];
    return r || (r = e[this.getScriptPartFromCode(n)]), r || (r = e[this.formatLanguageCode(n)]), r || (r = e[this.getLanguagePartFromCode(n)]), r || (r = e.default), r || [];
  }
  toResolveHierarchy(e, n) {
    const r = this.getFallbackCodes(n || this.options.fallbackLng || [], e), s = [], i = (o) => {
      o && (this.isSupportedCode(o) ? s.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`));
    };
    return typeof e == "string" && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && i(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && i(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && i(this.getLanguagePartFromCode(e))) : typeof e == "string" && i(this.formatLanguageCode(e)), r.forEach((o) => {
      s.indexOf(o) < 0 && i(this.formatLanguageCode(o));
    }), s;
  }
}
let B2 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], F2 = {
  1: (t) => +(t > 1),
  2: (t) => +(t != 1),
  3: (t) => 0,
  4: (t) => t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2,
  5: (t) => t == 0 ? 0 : t == 1 ? 1 : t == 2 ? 2 : t % 100 >= 3 && t % 100 <= 10 ? 3 : t % 100 >= 11 ? 4 : 5,
  6: (t) => t == 1 ? 0 : t >= 2 && t <= 4 ? 1 : 2,
  7: (t) => t == 1 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2,
  8: (t) => t == 1 ? 0 : t == 2 ? 1 : t != 8 && t != 11 ? 2 : 3,
  9: (t) => +(t >= 2),
  10: (t) => t == 1 ? 0 : t == 2 ? 1 : t < 7 ? 2 : t < 11 ? 3 : 4,
  11: (t) => t == 1 || t == 11 ? 0 : t == 2 || t == 12 ? 1 : t > 2 && t < 20 ? 2 : 3,
  12: (t) => +(t % 10 != 1 || t % 100 == 11),
  13: (t) => +(t !== 0),
  14: (t) => t == 1 ? 0 : t == 2 ? 1 : t == 3 ? 2 : 3,
  15: (t) => t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2,
  16: (t) => t % 10 == 1 && t % 100 != 11 ? 0 : t !== 0 ? 1 : 2,
  17: (t) => t == 1 || t % 10 == 1 && t % 100 != 11 ? 0 : 1,
  18: (t) => t == 0 ? 0 : t == 1 ? 1 : 2,
  19: (t) => t == 1 ? 0 : t == 0 || t % 100 > 1 && t % 100 < 11 ? 1 : t % 100 > 10 && t % 100 < 20 ? 2 : 3,
  20: (t) => t == 1 ? 0 : t == 0 || t % 100 > 0 && t % 100 < 20 ? 1 : 2,
  21: (t) => t % 100 == 1 ? 1 : t % 100 == 2 ? 2 : t % 100 == 3 || t % 100 == 4 ? 3 : 0,
  22: (t) => t == 1 ? 0 : t == 2 ? 1 : (t < 0 || t > 10) && t % 10 == 0 ? 2 : 3
};
const V2 = ["v1", "v2", "v3"], U2 = ["v4"], v0 = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, W2 = () => {
  const t = {};
  return B2.forEach((e) => {
    e.lngs.forEach((n) => {
      t[n] = {
        numbers: e.nr,
        plurals: F2[e.fc]
      };
    });
  }), t;
};
class z2 {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = n, this.logger = Sr.create("pluralResolver"), (!this.options.compatibilityJSON || U2.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = W2(), this.pluralRulesCache = {};
  }
  addRule(e, n) {
    this.rules[e] = n;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        const r = hd(e === "dev" ? "en" : e), s = n.ordinal ? "ordinal" : "cardinal", i = JSON.stringify({
          cleanedCode: r,
          type: s
        });
        if (i in this.pluralRulesCache)
          return this.pluralRulesCache[i];
        const o = new Intl.PluralRules(r, {
          type: s
        });
        return this.pluralRulesCache[i] = o, o;
      } catch {
        return;
      }
    return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)];
  }
  needsPlural(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(e, n);
    return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1;
  }
  getPluralFormsOfKey(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, r).map((s) => `${n}${s}`);
  }
  getSuffixes(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(e, n);
    return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort((s, i) => v0[s] - v0[i]).map((s) => `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${s}`) : r.numbers.map((s) => this.getSuffix(e, s, n)) : [];
  }
  getSuffix(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const s = this.getRule(e, r);
    return s ? this.shouldUseIntlApi() ? `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${s.select(n)}` : this.getSuffixRetroCompatible(s, n) : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, n) {
    const r = e.noAbs ? e.plurals(n) : e.plurals(Math.abs(n));
    let s = e.numbers[r];
    this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (s === 2 ? s = "plural" : s === 1 && (s = ""));
    const i = () => this.options.prepend && s.toString() ? this.options.prepend + s.toString() : s.toString();
    return this.options.compatibilityJSON === "v1" ? s === 1 ? "" : typeof s == "number" ? `_plural_${s.toString()}` : i() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? i() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString();
  }
  shouldUseIntlApi() {
    return !V2.includes(this.options.compatibilityJSON);
  }
}
const x0 = function(t, e, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, i = I2(t, e, n);
  return !i && s && typeof n == "string" && (i = Fp(t, n, r), i === void 0 && (i = Fp(e, n, r))), i;
}, Rh = (t) => t.replace(/\$/g, "$$$$");
class H2 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Sr.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || ((n) => n), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: n,
      escapeValue: r,
      useRawValueToEscape: s,
      prefix: i,
      prefixEscaped: o,
      suffix: a,
      suffixEscaped: c,
      formatSeparator: l,
      unescapeSuffix: u,
      unescapePrefix: d,
      nestingPrefix: f,
      nestingPrefixEscaped: h,
      nestingSuffix: p,
      nestingSuffixEscaped: m,
      nestingOptionsSeparator: y,
      maxReplaces: b,
      alwaysFormat: v
    } = e.interpolation;
    this.escape = n !== void 0 ? n : O2, this.escapeValue = r !== void 0 ? r : !0, this.useRawValueToEscape = s !== void 0 ? s : !1, this.prefix = i ? uo(i) : o || "{{", this.suffix = a ? uo(a) : c || "}}", this.formatSeparator = l || ",", this.unescapePrefix = u ? "" : d || "-", this.unescapeSuffix = this.unescapePrefix ? "" : u || "", this.nestingPrefix = f ? uo(f) : h || uo("$t("), this.nestingSuffix = p ? uo(p) : m || uo(")"), this.nestingOptionsSeparator = y || ",", this.maxReplaces = b || 1e3, this.alwaysFormat = v !== void 0 ? v : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (n, r) => n && n.source === r ? (n.lastIndex = 0, n) : new RegExp(r, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, n, r, s) {
    let i, o, a;
    const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, l = (h) => {
      if (h.indexOf(this.formatSeparator) < 0) {
        const b = x0(n, c, h, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(b, void 0, r, {
          ...s,
          ...n,
          interpolationkey: h
        }) : b;
      }
      const p = h.split(this.formatSeparator), m = p.shift().trim(), y = p.join(this.formatSeparator).trim();
      return this.format(x0(n, c, m, this.options.keySeparator, this.options.ignoreJSONStructure), y, r, {
        ...s,
        ...n,
        interpolationkey: m
      });
    };
    this.resetRegExp();
    const u = s && s.missingInterpolationHandler || this.options.missingInterpolationHandler, d = s && s.interpolation && s.interpolation.skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (h) => Rh(h)
    }, {
      regex: this.regexp,
      safeValue: (h) => this.escapeValue ? Rh(this.escape(h)) : Rh(h)
    }].forEach((h) => {
      for (a = 0; i = h.regex.exec(e); ) {
        const p = i[1].trim();
        if (o = l(p), o === void 0)
          if (typeof u == "function") {
            const y = u(e, i, s);
            o = typeof y == "string" ? y : "";
          } else if (s && Object.prototype.hasOwnProperty.call(s, p))
            o = "";
          else if (d) {
            o = i[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${p} for interpolating ${e}`), o = "";
        else typeof o != "string" && !this.useRawValueToEscape && (o = f0(o));
        const m = h.safeValue(o);
        if (e = e.replace(i[0], m), d ? (h.regex.lastIndex += o.length, h.regex.lastIndex -= i[0].length) : h.regex.lastIndex = 0, a++, a >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s, i, o;
    const a = (c, l) => {
      const u = this.nestingOptionsSeparator;
      if (c.indexOf(u) < 0) return c;
      const d = c.split(new RegExp(`${u}[ ]*{`));
      let f = `{${d[1]}`;
      c = d[0], f = this.interpolate(f, o);
      const h = f.match(/'/g), p = f.match(/"/g);
      (h && h.length % 2 === 0 && !p || p.length % 2 !== 0) && (f = f.replace(/'/g, '"'));
      try {
        o = JSON.parse(f), l && (o = {
          ...l,
          ...o
        });
      } catch (m) {
        return this.logger.warn(`failed parsing options string in nesting for key ${c}`, m), `${c}${u}${f}`;
      }
      return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, c;
    };
    for (; s = this.nestingRegexp.exec(e); ) {
      let c = [];
      o = {
        ...r
      }, o = o.replace && typeof o.replace != "string" ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      let l = !1;
      if (s[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(s[1])) {
        const u = s[1].split(this.formatSeparator).map((d) => d.trim());
        s[1] = u.shift(), c = u, l = !0;
      }
      if (i = n(a.call(this, s[1].trim(), o), o), i && s[0] === e && typeof i != "string") return i;
      typeof i != "string" && (i = f0(i)), i || (this.logger.warn(`missed to resolve ${s[1]} for nesting ${e}`), i = ""), l && (i = c.reduce((u, d) => this.format(u, d, r.lng, {
        ...r,
        interpolationkey: s[1].trim()
      }), i.trim())), e = e.replace(s[0], i), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
const Y2 = (t) => {
  let e = t.toLowerCase().trim();
  const n = {};
  if (t.indexOf("(") > -1) {
    const r = t.split("(");
    e = r[0].toLowerCase().trim();
    const s = r[1].substring(0, r[1].length - 1);
    e === "currency" && s.indexOf(":") < 0 ? n.currency || (n.currency = s.trim()) : e === "relativetime" && s.indexOf(":") < 0 ? n.range || (n.range = s.trim()) : s.split(";").forEach((o) => {
      if (o) {
        const [a, ...c] = o.split(":"), l = c.join(":").trim().replace(/^'+|'+$/g, ""), u = a.trim();
        n[u] || (n[u] = l), l === "false" && (n[u] = !1), l === "true" && (n[u] = !0), isNaN(l) || (n[u] = parseInt(l, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: n
  };
}, fo = (t) => {
  const e = {};
  return (n, r, s) => {
    let i = s;
    s && s.interpolationkey && s.formatParams && s.formatParams[s.interpolationkey] && s[s.interpolationkey] && (i = {
      ...i,
      [s.interpolationkey]: void 0
    });
    const o = r + JSON.stringify(i);
    let a = e[o];
    return a || (a = t(hd(r), s), e[o] = a), a(n);
  };
};
class G2 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Sr.create("formatter"), this.options = e, this.formats = {
      number: fo((n, r) => {
        const s = new Intl.NumberFormat(n, {
          ...r
        });
        return (i) => s.format(i);
      }),
      currency: fo((n, r) => {
        const s = new Intl.NumberFormat(n, {
          ...r,
          style: "currency"
        });
        return (i) => s.format(i);
      }),
      datetime: fo((n, r) => {
        const s = new Intl.DateTimeFormat(n, {
          ...r
        });
        return (i) => s.format(i);
      }),
      relativetime: fo((n, r) => {
        const s = new Intl.RelativeTimeFormat(n, {
          ...r
        });
        return (i) => s.format(i, r.range || "day");
      }),
      list: fo((n, r) => {
        const s = new Intl.ListFormat(n, {
          ...r
        });
        return (i) => s.format(i);
      })
    }, this.init(e);
  }
  init(e) {
    const r = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",";
  }
  add(e, n) {
    this.formats[e.toLowerCase().trim()] = n;
  }
  addCached(e, n) {
    this.formats[e.toLowerCase().trim()] = fo(n);
  }
  format(e, n, r) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const i = n.split(this.formatSeparator);
    if (i.length > 1 && i[0].indexOf("(") > 1 && i[0].indexOf(")") < 0 && i.find((a) => a.indexOf(")") > -1)) {
      const a = i.findIndex((c) => c.indexOf(")") > -1);
      i[0] = [i[0], ...i.splice(1, a)].join(this.formatSeparator);
    }
    return i.reduce((a, c) => {
      const {
        formatName: l,
        formatOptions: u
      } = Y2(c);
      if (this.formats[l]) {
        let d = a;
        try {
          const f = s && s.formatParams && s.formatParams[s.interpolationkey] || {}, h = f.locale || f.lng || s.locale || s.lng || r;
          d = this.formats[l](a, h, {
            ...u,
            ...s,
            ...f
          });
        } catch (f) {
          this.logger.warn(f);
        }
        return d;
      } else
        this.logger.warn(`there was no format function for ${l}`);
      return a;
    }, e);
  }
}
const K2 = (t, e) => {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--);
};
class $2 extends mf {
  constructor(e, n, r) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = n, this.services = r, this.languageUtils = r.languageUtils, this.options = s, this.logger = Sr.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = s.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = s.maxRetries >= 0 ? s.maxRetries : 5, this.retryTimeout = s.retryTimeout >= 1 ? s.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(r, s.backend, s);
  }
  queueLoad(e, n, r, s) {
    const i = {}, o = {}, a = {}, c = {};
    return e.forEach((l) => {
      let u = !0;
      n.forEach((d) => {
        const f = `${l}|${d}`;
        !r.reload && this.store.hasResourceBundle(l, d) ? this.state[f] = 2 : this.state[f] < 0 || (this.state[f] === 1 ? o[f] === void 0 && (o[f] = !0) : (this.state[f] = 1, u = !1, o[f] === void 0 && (o[f] = !0), i[f] === void 0 && (i[f] = !0), c[d] === void 0 && (c[d] = !0)));
      }), u || (a[l] = !0);
    }), (Object.keys(i).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: s
    }), {
      toLoad: Object.keys(i),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(a),
      toLoadNamespaces: Object.keys(c)
    };
  }
  loaded(e, n, r) {
    const s = e.split("|"), i = s[0], o = s[1];
    n && this.emit("failedLoading", i, o, n), !n && r && this.store.addResourceBundle(i, o, r, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = n ? -1 : 2, n && r && (this.state[e] = 0);
    const a = {};
    this.queue.forEach((c) => {
      P2(c.loaded, [i], o), K2(c, e), n && c.errors.push(n), c.pendingCount === 0 && !c.done && (Object.keys(c.loaded).forEach((l) => {
        a[l] || (a[l] = {});
        const u = c.loaded[l];
        u.length && u.forEach((d) => {
          a[l][d] === void 0 && (a[l][d] = !0);
        });
      }), c.done = !0, c.errors.length ? c.callback(c.errors) : c.callback());
    }), this.emit("loaded", a), this.queue = this.queue.filter((c) => !c.done);
  }
  read(e, n, r) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, o = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: n,
        fcName: r,
        tried: s,
        wait: i,
        callback: o
      });
      return;
    }
    this.readingCalls++;
    const a = (l, u) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const d = this.waitingReads.shift();
        this.read(d.lng, d.ns, d.fcName, d.tried, d.wait, d.callback);
      }
      if (l && u && s < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, n, r, s + 1, i * 2, o);
        }, i);
        return;
      }
      o(l, u);
    }, c = this.backend[r].bind(this.backend);
    if (c.length === 2) {
      try {
        const l = c(e, n);
        l && typeof l.then == "function" ? l.then((u) => a(null, u)).catch(a) : a(null, l);
      } catch (l) {
        a(l);
      }
      return;
    }
    return c(e, n, a);
  }
  prepareLoading(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), s && s();
    typeof e == "string" && (e = this.languageUtils.toResolveHierarchy(e)), typeof n == "string" && (n = [n]);
    const i = this.queueLoad(e, n, r, s);
    if (!i.toLoad.length)
      return i.pending.length || s(), null;
    i.toLoad.forEach((o) => {
      this.loadOne(o);
    });
  }
  load(e, n, r) {
    this.prepareLoading(e, n, {}, r);
  }
  reload(e, n, r) {
    this.prepareLoading(e, n, {
      reload: !0
    }, r);
  }
  loadOne(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const r = e.split("|"), s = r[0], i = r[1];
    this.read(s, i, "read", void 0, void 0, (o, a) => {
      o && this.logger.warn(`${n}loading namespace ${i} for language ${s} failed`, o), !o && a && this.logger.log(`${n}loaded namespace ${i} for language ${s}`, a), this.loaded(e, o, a);
    });
  }
  saveMissing(e, n, r, s, i) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(n)) {
      this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(r == null || r === "")) {
      if (this.backend && this.backend.create) {
        const c = {
          ...o,
          isUpdate: i
        }, l = this.backend.create.bind(this.backend);
        if (l.length < 6)
          try {
            let u;
            l.length === 5 ? u = l(e, n, r, s, c) : u = l(e, n, r, s), u && typeof u.then == "function" ? u.then((d) => a(null, d)).catch(a) : a(null, u);
          } catch (u) {
            a(u);
          }
        else
          l(e, n, r, s, a, c);
      }
      !e || !e[0] || this.store.addResource(e[0], n, r, s);
    }
  }
}
const w0 = () => ({
  debug: !1,
  initImmediate: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (t) => {
    let e = {};
    if (typeof t[1] == "object" && (e = t[1]), typeof t[1] == "string" && (e.defaultValue = t[1]), typeof t[2] == "string" && (e.tDescription = t[2]), typeof t[2] == "object" || typeof t[3] == "object") {
      const n = t[3] || t[2];
      Object.keys(n).forEach((r) => {
        e[r] = n[r];
      });
    }
    return e;
  },
  interpolation: {
    escapeValue: !0,
    format: (t) => t,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), A0 = (t) => (typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t), Fl = () => {
}, Z2 = (t) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach((n) => {
    typeof t[n] == "function" && (t[n] = t[n].bind(t));
  });
};
class kc extends mf {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = A0(e), this.services = {}, this.logger = Sr, this.modules = {
      external: []
    }, Z2(this), n && !this.isInitialized && !e.isClone) {
      if (!this.options.initImmediate)
        return this.init(e, n), this;
      setTimeout(() => {
        this.init(e, n);
      }, 0);
    }
  }
  init() {
    var e = this;
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof n == "function" && (r = n, n = {}), !n.defaultNS && n.defaultNS !== !1 && n.ns && (typeof n.ns == "string" ? n.defaultNS = n.ns : n.ns.indexOf("translation") < 0 && (n.defaultNS = n.ns[0]));
    const s = w0();
    this.options = {
      ...s,
      ...this.options,
      ...A0(n)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...s.interpolation,
      ...this.options.interpolation
    }), n.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = n.keySeparator), n.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = n.nsSeparator);
    const i = (u) => u ? typeof u == "function" ? new u() : u : null;
    if (!this.options.isClone) {
      this.modules.logger ? Sr.init(i(this.modules.logger), this.options) : Sr.init(null, this.options);
      let u;
      this.modules.formatter ? u = this.modules.formatter : typeof Intl < "u" && (u = G2);
      const d = new b0(this.options);
      this.store = new g0(this.options.resources, this.options);
      const f = this.services;
      f.logger = Sr, f.resourceStore = this.store, f.languageUtils = d, f.pluralResolver = new z2(d, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), u && (!this.options.interpolation.format || this.options.interpolation.format === s.interpolation.format) && (f.formatter = i(u), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new H2(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new $2(i(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(h) {
        for (var p = arguments.length, m = new Array(p > 1 ? p - 1 : 0), y = 1; y < p; y++)
          m[y - 1] = arguments[y];
        e.emit(h, ...m);
      }), this.modules.languageDetector && (f.languageDetector = i(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = i(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new pd(this.services, this.options), this.translator.on("*", function(h) {
        for (var p = arguments.length, m = new Array(p > 1 ? p - 1 : 0), y = 1; y < p; y++)
          m[y - 1] = arguments[y];
        e.emit(h, ...m);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, r || (r = Fl), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((u) => {
      this[u] = function() {
        return e.store[u](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((u) => {
      this[u] = function() {
        return e.store[u](...arguments), e;
      };
    });
    const c = Va(), l = () => {
      const u = (d, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), c.resolve(f), r(d, f);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return u(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, u);
    };
    return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0), c;
  }
  loadResources(e) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Fl;
    const s = typeof e == "string" ? e : this.language;
    if (typeof e == "function" && (r = e), !this.options.resources || this.options.partialBundledLanguages) {
      if (s && s.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return r();
      const i = [], o = (a) => {
        if (!a || a === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(a).forEach((l) => {
          l !== "cimode" && i.indexOf(l) < 0 && i.push(l);
        });
      };
      s ? o(s) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((c) => o(c)), this.options.preload && this.options.preload.forEach((a) => o(a)), this.services.backendConnector.load(i, this.options.ns, (a) => {
        !a && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), r(a);
      });
    } else
      r(null);
  }
  reloadResources(e, n, r) {
    const s = Va();
    return typeof e == "function" && (r = e, e = void 0), typeof n == "function" && (r = n, n = void 0), e || (e = this.languages), n || (n = this.options.ns), r || (r = Fl), this.services.backendConnector.reload(e, n, (i) => {
      s.resolve(), r(i);
    }), s;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && KS.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let n = 0; n < this.languages.length; n++) {
        const r = this.languages[n];
        if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) {
          this.resolvedLanguage = r;
          break;
        }
      }
  }
  changeLanguage(e, n) {
    var r = this;
    this.isLanguageChangingTo = e;
    const s = Va();
    this.emit("languageChanging", e);
    const i = (c) => {
      this.language = c, this.languages = this.services.languageUtils.toResolveHierarchy(c), this.resolvedLanguage = void 0, this.setResolvedLanguage(c);
    }, o = (c, l) => {
      l ? (i(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l), this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0, s.resolve(function() {
        return r.t(...arguments);
      }), n && n(c, function() {
        return r.t(...arguments);
      });
    }, a = (c) => {
      !e && !c && this.services.languageDetector && (c = []);
      const l = typeof c == "string" ? c : this.services.languageUtils.getBestMatchFromCodes(c);
      l && (this.language || i(l), this.translator.language || this.translator.changeLanguage(l), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(l)), this.loadResources(l, (u) => {
        o(u, l);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(e), s;
  }
  getFixedT(e, n, r) {
    var s = this;
    const i = function(o, a) {
      let c;
      if (typeof a != "object") {
        for (var l = arguments.length, u = new Array(l > 2 ? l - 2 : 0), d = 2; d < l; d++)
          u[d - 2] = arguments[d];
        c = s.options.overloadTranslationOptionHandler([o, a].concat(u));
      } else
        c = {
          ...a
        };
      c.lng = c.lng || i.lng, c.lngs = c.lngs || i.lngs, c.ns = c.ns || i.ns, c.keyPrefix !== "" && (c.keyPrefix = c.keyPrefix || r || i.keyPrefix);
      const f = s.options.keySeparator || ".";
      let h;
      return c.keyPrefix && Array.isArray(o) ? h = o.map((p) => `${c.keyPrefix}${f}${p}`) : h = c.keyPrefix ? `${c.keyPrefix}${f}${o}` : o, s.t(h, c);
    };
    return typeof e == "string" ? i.lng = e : i.lngs = e, i.ns = n, i.keyPrefix = r, i;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const r = n.lng || this.resolvedLanguage || this.languages[0], s = this.options ? this.options.fallbackLng : !1, i = this.languages[this.languages.length - 1];
    if (r.toLowerCase() === "cimode") return !0;
    const o = (a, c) => {
      const l = this.services.backendConnector.state[`${a}|${c}`];
      return l === -1 || l === 0 || l === 2;
    };
    if (n.precheck) {
      const a = n.precheck(this, o);
      if (a !== void 0) return a;
    }
    return !!(this.hasResourceBundle(r, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(r, e) && (!s || o(i, e)));
  }
  loadNamespaces(e, n) {
    const r = Va();
    return this.options.ns ? (typeof e == "string" && (e = [e]), e.forEach((s) => {
      this.options.ns.indexOf(s) < 0 && this.options.ns.push(s);
    }), this.loadResources((s) => {
      r.resolve(), n && n(s);
    }), r) : (n && n(), Promise.resolve());
  }
  loadLanguages(e, n) {
    const r = Va();
    typeof e == "string" && (e = [e]);
    const s = this.options.preload || [], i = e.filter((o) => s.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o));
    return i.length ? (this.options.preload = s.concat(i), this.loadResources((o) => {
      r.resolve(), n && n(o);
    }), r) : (n && n(), Promise.resolve());
  }
  dir(e) {
    if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], r = this.services && this.services.languageUtils || new b0(w0());
    return n.indexOf(r.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    return new kc(e, n);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Fl;
    const r = e.forkResourceStore;
    r && delete e.forkResourceStore;
    const s = {
      ...this.options,
      ...e,
      isClone: !0
    }, i = new kc(s);
    return (e.debug !== void 0 || e.prefix !== void 0) && (i.logger = i.logger.clone(e)), ["store", "services", "language"].forEach((a) => {
      i[a] = this[a];
    }), i.services = {
      ...this.services
    }, i.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, r && (i.store = new g0(this.store.data, s), i.services.resourceStore = i.store), i.translator = new pd(i.services, s), i.translator.on("*", function(a) {
      for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), u = 1; u < c; u++)
        l[u - 1] = arguments[u];
      i.emit(a, ...l);
    }), i.init(s, n), i.translator.options = s, i.translator.backendConnector.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, i;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const un = kc.createInstance();
un.createInstance = kc.createInstance;
un.createInstance;
un.dir;
un.init;
un.loadResources;
un.reloadResources;
un.use;
un.changeLanguage;
un.getFixedT;
const Nt = un.t;
un.exists;
un.setDefaultNamespace;
un.hasLoadedNamespace;
un.loadNamespaces;
un.loadLanguages;
function Q2(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function Fi(t) {
  "@babel/helpers - typeof";
  return Fi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Fi(t);
}
function X2(t, e) {
  if (Fi(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e);
    if (Fi(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function $S(t) {
  var e = X2(t, "string");
  return Fi(e) == "symbol" ? e : e + "";
}
function J2(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, $S(r.key), r);
  }
}
function eI(t, e, n) {
  return e && J2(t.prototype, e), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function tI(t, e, n) {
  return (e = $S(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
var ZS = [], nI = ZS.forEach, rI = ZS.slice;
function sI(t) {
  return nI.call(rI.call(arguments, 1), function(e) {
    if (e)
      for (var n in e)
        t[n] === void 0 && (t[n] = e[n]);
  }), t;
}
function S0(t, e) {
  if (e && Fi(e) === "object") {
    var n = "", r = encodeURIComponent;
    for (var s in e)
      n += "&" + r(s) + "=" + r(e[s]);
    if (!n)
      return t;
    t = t + (t.indexOf("?") !== -1 ? "&" : "?") + n.slice(1);
  }
  return t;
}
function iI(t, e, n, r, s) {
  r && Fi(r) === "object" && (s || (r._t = /* @__PURE__ */ new Date()), r = S0("", r).slice(1)), e.queryStringParams && (t = S0(t, e.queryStringParams));
  try {
    var i;
    XMLHttpRequest ? i = new XMLHttpRequest() : i = new ActiveXObject("MSXML2.XMLHTTP.3.0"), i.open(r ? "POST" : "GET", t, 1), e.crossDomain || i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), i.withCredentials = !!e.withCredentials, r && i.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), i.overrideMimeType && i.overrideMimeType("application/json");
    var o = e.customHeaders;
    if (o = typeof o == "function" ? o() : o, o)
      for (var a in o)
        i.setRequestHeader(a, o[a]);
    i.onreadystatechange = function() {
      i.readyState > 3 && n && n(i.responseText, i);
    }, i.send(r);
  } catch (c) {
    console && console.log(c);
  }
}
function oI() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: !1,
    parse: JSON.parse,
    parsePayload: function(e, n, r) {
      return tI({}, n, r || "");
    },
    crossDomain: !1,
    ajax: iI
  };
}
var QS = /* @__PURE__ */ function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Q2(this, t), this.init(e, n), this.type = "backend";
  }
  return eI(t, [{
    key: "init",
    value: function(n) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.services = n, this.options = sI(r, this.options || {}, oI());
    }
  }, {
    key: "readMulti",
    value: function(n, r, s) {
      var i = this.options.loadPath;
      typeof this.options.loadPath == "function" && (i = this.options.loadPath(n, r));
      var o = this.services.interpolator.interpolate(i, {
        lng: n.join("+"),
        ns: r.join("+")
      });
      this.loadUrl(o, s);
    }
  }, {
    key: "read",
    value: function(n, r, s) {
      var i = this.options.loadPath;
      typeof this.options.loadPath == "function" && (i = this.options.loadPath([n], [r]));
      var o = this.services.interpolator.interpolate(i, {
        lng: n,
        ns: r
      });
      this.loadUrl(o, s);
    }
  }, {
    key: "loadUrl",
    value: function(n, r) {
      var s = this;
      this.options.ajax(n, this.options, function(i, o) {
        if (o.status >= 500 && o.status < 600) return r(
          "failed loading " + n,
          !0
          /* retry */
        );
        if (o.status >= 400 && o.status < 500) return r(
          "failed loading " + n,
          !1
          /* no retry */
        );
        var a, c;
        try {
          a = s.options.parse(i, n);
        } catch {
          c = "failed parsing " + n + " to json";
        }
        if (c) return r(c, !1);
        r(null, a);
      });
    }
  }, {
    key: "create",
    value: function(n, r, s, i) {
      var o = this;
      typeof n == "string" && (n = [n]);
      var a = this.options.parsePayload(r, s, i);
      n.forEach(function(c) {
        var l = o.services.interpolator.interpolate(o.options.addPath, {
          lng: c,
          ns: r
        });
        o.options.ajax(l, o.options, function(u, d) {
        }, a);
      });
    }
  }]), t;
}();
QS.type = "backend";
async function aI(t) {
  var n;
  new URL(document.URL).origin + "";
  try {
    await un.use(QS).init({
      debug: !1,
      lng: t,
      fallbackLng: "en",
      backend: {
        crossDomain: !0,
        loadPath: "https://nano-public.s3.eu-west-1.amazonaws.com/blink/translations/{{lng}}.json"
      }
    });
  } catch (r) {
    console.error("Unable to initialize i18n", r), (n = document.location) == null || n.reload();
  }
}
const E0 = (t) => {
  let e;
  const n = /* @__PURE__ */ new Set(), r = (l, u) => {
    const d = typeof l == "function" ? l(e) : l;
    if (!Object.is(d, e)) {
      const f = e;
      e = u ?? (typeof d != "object" || d === null) ? d : Object.assign({}, e, d), n.forEach((h) => h(e, f));
    }
  }, s = () => e, a = { setState: r, getState: s, getInitialState: () => c, subscribe: (l) => (n.add(l), () => n.delete(l)) }, c = e = t(r, s, a);
  return a;
}, cI = (t) => t ? E0(t) : E0, lI = (t) => t;
function uI(t, e = lI) {
  const n = z.useSyncExternalStore(
    t.subscribe,
    () => e(t.getState()),
    () => e(t.getInitialState())
  );
  return z.useDebugValue(n), n;
}
const C0 = (t) => {
  const e = cI(t), n = (r) => uI(e, r);
  return Object.assign(n, e), n;
}, ga = (t) => t ? C0(t) : C0, _0 = {
  result: null,
  totalProfit: 0,
  multiplier: 0
}, XS = ga((t) => ({
  // Initial state
  ..._0,
  // Actions
  setResult: (e) => t({ result: e }),
  setTotalProfit: (e) => t({ totalProfit: e }),
  setMultiplier: (e) => t({ multiplier: e }),
  resetGame: () => t({ ..._0 })
})), dI = { BASE_URL: "/", DEV: !1, IS_WEB_COMPONENT: !0, MODE: "web-component-prod", PROD: !0, SSR: !1, VITE_DEV_API_BASE_URL: "http://localhost:3000", VITE_DEV_BASE_URL: "/", VITE_PROD_API_BASE_URL: "https://eu.blink.run", VITE_PROD_BASE_URL: "/games/blink-games/", VITE_STAGING_API_BASE_URL: "http://localhost:3000", VITE_STAGING_BASE_URL: "/games/blink-games/", VITE_WC_API_BASE_URL: "https://eu.blink.run", VITE_WC_BASE_URL: "/", VITE_WC_BUILD_TYPE: "web-component", VITE_WC_PROD_API_BASE_URL: "https://eu.blink.run", VITE_WC_PROD_BASE_URL: "/", VITE_WC_PROD_BUILD_TYPE: "web-component" };
function fr() {
  const [t, e] = Ge(!1);
  return _e(() => {
    function n() {
      e(window.innerWidth < 1024);
    }
    return window.addEventListener("resize", n), n(), () => window.removeEventListener("resize", n);
  }, []), t;
}
function fI(t) {
  const n = `VITE_PROD_${t}`;
  return dI[n] || "";
}
const hI = (t, e) => e / t, pI = (t, e) => {
  const r = 25 - t;
  if (t < 0 || t >= 25 || e < 0 || e > r)
    throw new Error("Invalid input: 'minesCount' should be between 0 and 24, 'turn' should be between 0 and (25 - minesCount).");
  let s = 0.99;
  for (let i = 0; i < e; i++) {
    const o = 25 - i, a = r - i, c = hI(o, a);
    s *= 1 / c;
  }
  return parseFloat(s.toFixed(2));
};
function JS(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = JS(t[e])) && (r && (r += " "), r += n);
  } else for (n in t) t[n] && (r && (r += " "), r += n);
  return r;
}
function mI() {
  for (var t, e, n = 0, r = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = JS(t)) && (r && (r += " "), r += e);
  return r;
}
const Og = "-", gI = (t) => {
  const e = bI(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = t;
  return {
    getClassGroupId: (o) => {
      const a = o.split(Og);
      return a[0] === "" && a.length !== 1 && a.shift(), e1(a, e) || yI(o);
    },
    getConflictingClassGroupIds: (o, a) => {
      const c = n[o] || [];
      return a && r[o] ? [...c, ...r[o]] : c;
    }
  };
}, e1 = (t, e) => {
  var o;
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], r = e.nextPart.get(n), s = r ? e1(t.slice(1), r) : void 0;
  if (s)
    return s;
  if (e.validators.length === 0)
    return;
  const i = t.join(Og);
  return (o = e.validators.find(({
    validator: a
  }) => a(i))) == null ? void 0 : o.classGroupId;
}, T0 = /^\[(.+)\]$/, yI = (t) => {
  if (T0.test(t)) {
    const e = T0.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, bI = (t) => {
  const {
    theme: e,
    prefix: n
  } = t, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return xI(Object.entries(t.classGroups), n).forEach(([i, o]) => {
    Vp(o, r, i, e);
  }), r;
}, Vp = (t, e, n, r) => {
  t.forEach((s) => {
    if (typeof s == "string") {
      const i = s === "" ? e : k0(e, s);
      i.classGroupId = n;
      return;
    }
    if (typeof s == "function") {
      if (vI(s)) {
        Vp(s(r), e, n, r);
        return;
      }
      e.validators.push({
        validator: s,
        classGroupId: n
      });
      return;
    }
    Object.entries(s).forEach(([i, o]) => {
      Vp(o, k0(e, i), n, r);
    });
  });
}, k0 = (t, e) => {
  let n = t;
  return e.split(Og).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, vI = (t) => t.isThemeGetter, xI = (t, e) => e ? t.map(([n, r]) => {
  const s = r.map((i) => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, a]) => [e + o, a])) : i);
  return [n, s];
}) : t, wI = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const s = (i, o) => {
    n.set(i, o), e++, e > t && (e = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let o = n.get(i);
      if (o !== void 0)
        return o;
      if ((o = r.get(i)) !== void 0)
        return s(i, o), o;
    },
    set(i, o) {
      n.has(i) ? n.set(i, o) : s(i, o);
    }
  };
}, t1 = "!", AI = (t) => {
  const {
    separator: e,
    experimentalParseClassName: n
  } = t, r = e.length === 1, s = e[0], i = e.length, o = (a) => {
    const c = [];
    let l = 0, u = 0, d;
    for (let y = 0; y < a.length; y++) {
      let b = a[y];
      if (l === 0) {
        if (b === s && (r || a.slice(y, y + i) === e)) {
          c.push(a.slice(u, y)), u = y + i;
          continue;
        }
        if (b === "/") {
          d = y;
          continue;
        }
      }
      b === "[" ? l++ : b === "]" && l--;
    }
    const f = c.length === 0 ? a : a.substring(u), h = f.startsWith(t1), p = h ? f.substring(1) : f, m = d && d > u ? d - u : void 0;
    return {
      modifiers: c,
      hasImportantModifier: h,
      baseClassName: p,
      maybePostfixModifierPosition: m
    };
  };
  return n ? (a) => n({
    className: a,
    parseClassName: o
  }) : o;
}, SI = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let n = [];
  return t.forEach((r) => {
    r[0] === "[" ? (e.push(...n.sort(), r), n = []) : n.push(r);
  }), e.push(...n.sort()), e;
}, EI = (t) => ({
  cache: wI(t.cacheSize),
  parseClassName: AI(t),
  ...gI(t)
}), CI = /\s+/, _I = (t, e) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: s
  } = e, i = [], o = t.trim().split(CI);
  let a = "";
  for (let c = o.length - 1; c >= 0; c -= 1) {
    const l = o[c], {
      modifiers: u,
      hasImportantModifier: d,
      baseClassName: f,
      maybePostfixModifierPosition: h
    } = n(l);
    let p = !!h, m = r(p ? f.substring(0, h) : f);
    if (!m) {
      if (!p) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (m = r(f), !m) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      p = !1;
    }
    const y = SI(u).join(":"), b = d ? y + t1 : y, v = b + m;
    if (i.includes(v))
      continue;
    i.push(v);
    const w = s(m, p);
    for (let x = 0; x < w.length; ++x) {
      const A = w[x];
      i.push(b + A);
    }
    a = l + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function TI() {
  let t = 0, e, n, r = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = n1(e)) && (r && (r += " "), r += n);
  return r;
}
const n1 = (t) => {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let r = 0; r < t.length; r++)
    t[r] && (e = n1(t[r])) && (n && (n += " "), n += e);
  return n;
};
function kI(t, ...e) {
  let n, r, s, i = o;
  function o(c) {
    const l = e.reduce((u, d) => d(u), t());
    return n = EI(l), r = n.cache.get, s = n.cache.set, i = a, a(c);
  }
  function a(c) {
    const l = r(c);
    if (l)
      return l;
    const u = _I(c, n);
    return s(c, u), u;
  }
  return function() {
    return i(TI.apply(null, arguments));
  };
}
const dt = (t) => {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}, r1 = /^\[(?:([a-z-]+):)?(.+)\]$/i, RI = /^\d+\/\d+$/, MI = /* @__PURE__ */ new Set(["px", "full", "screen"]), PI = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, II = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, DI = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, OI = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, qI = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Ur = (t) => qo(t) || MI.has(t) || RI.test(t), Ss = (t) => ya(t, "length", WI), qo = (t) => !!t && !Number.isNaN(Number(t)), Mh = (t) => ya(t, "number", qo), Ua = (t) => !!t && Number.isInteger(Number(t)), NI = (t) => t.endsWith("%") && qo(t.slice(0, -1)), Ce = (t) => r1.test(t), Es = (t) => PI.test(t), LI = /* @__PURE__ */ new Set(["length", "size", "percentage"]), jI = (t) => ya(t, LI, s1), BI = (t) => ya(t, "position", s1), FI = /* @__PURE__ */ new Set(["image", "url"]), VI = (t) => ya(t, FI, HI), UI = (t) => ya(t, "", zI), Wa = () => !0, ya = (t, e, n) => {
  const r = r1.exec(t);
  return r ? r[1] ? typeof e == "string" ? r[1] === e : e.has(r[1]) : n(r[2]) : !1;
}, WI = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  II.test(t) && !DI.test(t)
), s1 = () => !1, zI = (t) => OI.test(t), HI = (t) => qI.test(t), YI = () => {
  const t = dt("colors"), e = dt("spacing"), n = dt("blur"), r = dt("brightness"), s = dt("borderColor"), i = dt("borderRadius"), o = dt("borderSpacing"), a = dt("borderWidth"), c = dt("contrast"), l = dt("grayscale"), u = dt("hueRotate"), d = dt("invert"), f = dt("gap"), h = dt("gradientColorStops"), p = dt("gradientColorStopPositions"), m = dt("inset"), y = dt("margin"), b = dt("opacity"), v = dt("padding"), w = dt("saturate"), x = dt("scale"), A = dt("sepia"), C = dt("skew"), S = dt("space"), _ = dt("translate"), T = () => ["auto", "contain", "none"], k = () => ["auto", "hidden", "clip", "visible", "scroll"], R = () => ["auto", Ce, e], P = () => [Ce, e], M = () => ["", Ur, Ss], D = () => ["auto", qo, Ce], O = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], q = () => ["solid", "dashed", "dotted", "double", "none"], L = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], N = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], j = () => ["", "0", Ce], V = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Z = () => [qo, Ce];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Wa],
      spacing: [Ur, Ss],
      blur: ["none", "", Es, Ce],
      brightness: Z(),
      borderColor: [t],
      borderRadius: ["none", "", "full", Es, Ce],
      borderSpacing: P(),
      borderWidth: M(),
      contrast: Z(),
      grayscale: j(),
      hueRotate: Z(),
      invert: j(),
      gap: P(),
      gradientColorStops: [t],
      gradientColorStopPositions: [NI, Ss],
      inset: R(),
      margin: R(),
      opacity: Z(),
      padding: P(),
      saturate: Z(),
      scale: Z(),
      sepia: j(),
      skew: Z(),
      space: P(),
      translate: P()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ce]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Es]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": V()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": V()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...O(), Ce]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: k()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": k()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": k()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: T()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": T()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": T()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [m]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [m]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [m]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [m]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [m]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [m]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [m]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [m]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [m]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Ua, Ce]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: R()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ce]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: j()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: j()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Ua, Ce]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Wa]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Ua, Ce]
        }, Ce]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": D()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": D()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Wa]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Ua, Ce]
        }, Ce]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": D()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": D()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ce]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ce]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...N()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...N(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...N(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [v]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [v]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [v]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [v]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [v]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [v]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [v]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [v]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [v]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [y]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [y]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [y]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [y]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [y]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [y]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [y]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [y]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [y]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [S]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [S]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ce, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ce, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ce, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [Es]
        }, Es]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ce, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ce, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ce, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ce, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Es, Ss]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Mh]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Wa]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ce]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", qo, Mh]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Ur, Ce]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ce]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ce]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [b]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [b]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...q(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Ur, Ss]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Ur, Ce]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: P()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ce]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ce]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [b]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...O(), BI]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", jI]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, VI]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [b]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...q(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [b]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: q()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [s]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [s]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [s]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [s]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [s]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [s]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [s]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [s]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...q()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ur, Ce]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Ur, Ss]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: M()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [b]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Ur, Ss]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Es, UI]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Wa]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [b]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...L(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": L()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [c]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Es, Ce]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [l]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [w]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [A]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [c]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [l]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [b]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [w]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [A]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ce]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Z()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ce]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Z()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ce]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [x]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [x]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [x]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Ua, Ce]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [_]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [_]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [C]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [C]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ce]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ce]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": P()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": P()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": P()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": P()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": P()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": P()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": P()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": P()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": P()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": P()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": P()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": P()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": P()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": P()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": P()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": P()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": P()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": P()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ce]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ur, Ss, Mh]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, GI = /* @__PURE__ */ kI(YI);
function de(...t) {
  return GI(mI(t));
}
const i1 = ({
  className: t,
  size: e = 200,
  duration: n = 15,
  anchor: r = 90,
  borderWidth: s = 1.5,
  colorFrom: i = "#ffaa40",
  colorTo: o = "#9c40ff",
  delay: a = 0
}) => /* @__PURE__ */ g.jsx(
  "div",
  {
    style: {
      "--size": e,
      "--duration": n,
      "--anchor": r,
      "--border-width": s,
      "--color-from": i,
      "--color-to": o,
      "--delay": `-${a}s`
    },
    className: de(
      "pointer-events-none absolute inset-0 rounded-[inherit] [border:calc(var(--border-width)*1px)_solid_transparent]",
      // mask styles
      "![mask-clip:padding-box,border-box] ![mask-composite:intersect] [mask:linear-gradient(transparent,transparent),linear-gradient(white,white)]",
      // pseudo styles
      "after:absolute after:aspect-square after:w-[calc(var(--size)*1px)] after:animate-border-beam after:[animation-delay:var(--delay)] after:[background:linear-gradient(to_left,var(--color-from),var(--color-to),transparent)] after:[offset-anchor:calc(var(--anchor)*1%)_50%] after:[offset-path:rect(0_auto_auto_0_round_calc(var(--size)*1px))]",
      t
    )
  }
);
function o1(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: KI } = Object.prototype, { getPrototypeOf: qg } = Object, gf = /* @__PURE__ */ ((t) => (e) => {
  const n = KI.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), hr = (t) => (t = t.toLowerCase(), (e) => gf(e) === t), yf = (t) => (e) => typeof e === t, { isArray: ba } = Array, Rc = yf("undefined");
function $I(t) {
  return t !== null && !Rc(t) && t.constructor !== null && !Rc(t.constructor) && Fn(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const a1 = hr("ArrayBuffer");
function ZI(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && a1(t.buffer), e;
}
const QI = yf("string"), Fn = yf("function"), c1 = yf("number"), bf = (t) => t !== null && typeof t == "object", XI = (t) => t === !0 || t === !1, Ou = (t) => {
  if (gf(t) !== "object")
    return !1;
  const e = qg(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, JI = hr("Date"), eD = hr("File"), tD = hr("Blob"), nD = hr("FileList"), rD = (t) => bf(t) && Fn(t.pipe), sD = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Fn(t.append) && ((e = gf(t)) === "formdata" || // detect form-data instance
  e === "object" && Fn(t.toString) && t.toString() === "[object FormData]"));
}, iD = hr("URLSearchParams"), [oD, aD, cD, lD] = ["ReadableStream", "Request", "Response", "Headers"].map(hr), uD = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function hl(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let r, s;
  if (typeof t != "object" && (t = [t]), ba(t))
    for (r = 0, s = t.length; r < s; r++)
      e.call(null, t[r], r, t);
  else {
    const i = n ? Object.getOwnPropertyNames(t) : Object.keys(t), o = i.length;
    let a;
    for (r = 0; r < o; r++)
      a = i[r], e.call(null, t[a], a, t);
  }
}
function l1(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let r = n.length, s;
  for (; r-- > 0; )
    if (s = n[r], e === s.toLowerCase())
      return s;
  return null;
}
const _i = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, u1 = (t) => !Rc(t) && t !== _i;
function Up() {
  const { caseless: t } = u1(this) && this || {}, e = {}, n = (r, s) => {
    const i = t && l1(e, s) || s;
    Ou(e[i]) && Ou(r) ? e[i] = Up(e[i], r) : Ou(r) ? e[i] = Up({}, r) : ba(r) ? e[i] = r.slice() : e[i] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && hl(arguments[r], n);
  return e;
}
const dD = (t, e, n, { allOwnKeys: r } = {}) => (hl(e, (s, i) => {
  n && Fn(s) ? t[i] = o1(s, n) : t[i] = s;
}, { allOwnKeys: r }), t), fD = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), hD = (t, e, n, r) => {
  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, pD = (t, e, n, r) => {
  let s, i, o;
  const a = {};
  if (e = e || {}, t == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(t), i = s.length; i-- > 0; )
      o = s[i], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
    t = n !== !1 && qg(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, mD = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const r = t.indexOf(e, n);
  return r !== -1 && r === n;
}, gD = (t) => {
  if (!t) return null;
  if (ba(t)) return t;
  let e = t.length;
  if (!c1(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, yD = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && qg(Uint8Array)), bD = (t, e) => {
  const r = (t && t[Symbol.iterator]).call(t);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const i = s.value;
    e.call(t, i[0], i[1]);
  }
}, vD = (t, e) => {
  let n;
  const r = [];
  for (; (n = t.exec(e)) !== null; )
    r.push(n);
  return r;
}, xD = hr("HTMLFormElement"), wD = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, s) {
    return r.toUpperCase() + s;
  }
), R0 = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), AD = hr("RegExp"), d1 = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), r = {};
  hl(n, (s, i) => {
    let o;
    (o = e(s, i, t)) !== !1 && (r[i] = o || s);
  }), Object.defineProperties(t, r);
}, SD = (t) => {
  d1(t, (e, n) => {
    if (Fn(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = t[n];
    if (Fn(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, ED = (t, e) => {
  const n = {}, r = (s) => {
    s.forEach((i) => {
      n[i] = !0;
    });
  };
  return ba(t) ? r(t) : r(String(t).split(e)), n;
}, CD = () => {
}, _D = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, Ph = "abcdefghijklmnopqrstuvwxyz", M0 = "0123456789", f1 = {
  DIGIT: M0,
  ALPHA: Ph,
  ALPHA_DIGIT: Ph + Ph.toUpperCase() + M0
}, TD = (t = 16, e = f1.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = e;
  for (; t--; )
    n += e[Math.random() * r | 0];
  return n;
};
function kD(t) {
  return !!(t && Fn(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const RD = (t) => {
  const e = new Array(10), n = (r, s) => {
    if (bf(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const i = ba(r) ? [] : {};
        return hl(r, (o, a) => {
          const c = n(o, s + 1);
          !Rc(c) && (i[a] = c);
        }), e[s] = void 0, i;
      }
    }
    return r;
  };
  return n(t, 0);
}, MD = hr("AsyncFunction"), PD = (t) => t && (bf(t) || Fn(t)) && Fn(t.then) && Fn(t.catch), h1 = ((t, e) => t ? setImmediate : e ? ((n, r) => (_i.addEventListener("message", ({ source: s, data: i }) => {
  s === _i && i === n && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), _i.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Fn(_i.postMessage)
), ID = typeof queueMicrotask < "u" ? queueMicrotask.bind(_i) : typeof process < "u" && process.nextTick || h1, B = {
  isArray: ba,
  isArrayBuffer: a1,
  isBuffer: $I,
  isFormData: sD,
  isArrayBufferView: ZI,
  isString: QI,
  isNumber: c1,
  isBoolean: XI,
  isObject: bf,
  isPlainObject: Ou,
  isReadableStream: oD,
  isRequest: aD,
  isResponse: cD,
  isHeaders: lD,
  isUndefined: Rc,
  isDate: JI,
  isFile: eD,
  isBlob: tD,
  isRegExp: AD,
  isFunction: Fn,
  isStream: rD,
  isURLSearchParams: iD,
  isTypedArray: yD,
  isFileList: nD,
  forEach: hl,
  merge: Up,
  extend: dD,
  trim: uD,
  stripBOM: fD,
  inherits: hD,
  toFlatObject: pD,
  kindOf: gf,
  kindOfTest: hr,
  endsWith: mD,
  toArray: gD,
  forEachEntry: bD,
  matchAll: vD,
  isHTMLForm: xD,
  hasOwnProperty: R0,
  hasOwnProp: R0,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: d1,
  freezeMethods: SD,
  toObjectSet: ED,
  toCamelCase: wD,
  noop: CD,
  toFiniteNumber: _D,
  findKey: l1,
  global: _i,
  isContextDefined: u1,
  ALPHABET: f1,
  generateString: TD,
  isSpecCompliantForm: kD,
  toJSONObject: RD,
  isAsyncFn: MD,
  isThenable: PD,
  setImmediate: h1,
  asap: ID
};
function we(t, e, n, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null);
}
B.inherits(we, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: B.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const p1 = we.prototype, m1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  m1[t] = { value: t };
});
Object.defineProperties(we, m1);
Object.defineProperty(p1, "isAxiosError", { value: !0 });
we.from = (t, e, n, r, s, i) => {
  const o = Object.create(p1);
  return B.toFlatObject(t, o, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), we.call(o, t.message, e, n, r, s), o.cause = t, o.name = t.name, i && Object.assign(o, i), o;
};
const DD = null;
function Wp(t) {
  return B.isPlainObject(t) || B.isArray(t);
}
function g1(t) {
  return B.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function P0(t, e, n) {
  return t ? t.concat(e).map(function(s, i) {
    return s = g1(s), !n && i ? "[" + s + "]" : s;
  }).join(n ? "." : "") : e;
}
function OD(t) {
  return B.isArray(t) && !t.some(Wp);
}
const qD = B.toFlatObject(B, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function vf(t, e, n) {
  if (!B.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = B.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, y) {
    return !B.isUndefined(y[m]);
  });
  const r = n.metaTokens, s = n.visitor || u, i = n.dots, o = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && B.isSpecCompliantForm(e);
  if (!B.isFunction(s))
    throw new TypeError("visitor must be a function");
  function l(p) {
    if (p === null) return "";
    if (B.isDate(p))
      return p.toISOString();
    if (!c && B.isBlob(p))
      throw new we("Blob is not supported. Use a Buffer instead.");
    return B.isArrayBuffer(p) || B.isTypedArray(p) ? c && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function u(p, m, y) {
    let b = p;
    if (p && !y && typeof p == "object") {
      if (B.endsWith(m, "{}"))
        m = r ? m : m.slice(0, -2), p = JSON.stringify(p);
      else if (B.isArray(p) && OD(p) || (B.isFileList(p) || B.endsWith(m, "[]")) && (b = B.toArray(p)))
        return m = g1(m), b.forEach(function(w, x) {
          !(B.isUndefined(w) || w === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? P0([m], x, i) : o === null ? m : m + "[]",
            l(w)
          );
        }), !1;
    }
    return Wp(p) ? !0 : (e.append(P0(y, m, i), l(p)), !1);
  }
  const d = [], f = Object.assign(qD, {
    defaultVisitor: u,
    convertValue: l,
    isVisitable: Wp
  });
  function h(p, m) {
    if (!B.isUndefined(p)) {
      if (d.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      d.push(p), B.forEach(p, function(b, v) {
        (!(B.isUndefined(b) || b === null) && s.call(
          e,
          b,
          B.isString(v) ? v.trim() : v,
          m,
          f
        )) === !0 && h(b, m ? m.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!B.isObject(t))
    throw new TypeError("data must be an object");
  return h(t), e;
}
function I0(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function Ng(t, e) {
  this._pairs = [], t && vf(t, this, e);
}
const y1 = Ng.prototype;
y1.append = function(e, n) {
  this._pairs.push([e, n]);
};
y1.toString = function(e) {
  const n = e ? function(r) {
    return e.call(this, r, I0);
  } : I0;
  return this._pairs.map(function(s) {
    return n(s[0]) + "=" + n(s[1]);
  }, "").join("&");
};
function ND(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function b1(t, e, n) {
  if (!e)
    return t;
  const r = n && n.encode || ND, s = n && n.serialize;
  let i;
  if (s ? i = s(e, n) : i = B.isURLSearchParams(e) ? e.toString() : new Ng(e, n).toString(r), i) {
    const o = t.indexOf("#");
    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return t;
}
class D0 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    B.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const v1 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, LD = typeof URLSearchParams < "u" ? URLSearchParams : Ng, jD = typeof FormData < "u" ? FormData : null, BD = typeof Blob < "u" ? Blob : null, FD = {
  isBrowser: !0,
  classes: {
    URLSearchParams: LD,
    FormData: jD,
    Blob: BD
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Lg = typeof window < "u" && typeof document < "u", zp = typeof navigator == "object" && navigator || void 0, VD = Lg && (!zp || ["ReactNative", "NativeScript", "NS"].indexOf(zp.product) < 0), UD = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", WD = Lg && window.location.href || "http://localhost", zD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Lg,
  hasStandardBrowserEnv: VD,
  hasStandardBrowserWebWorkerEnv: UD,
  navigator: zp,
  origin: WD
}, Symbol.toStringTag, { value: "Module" })), Tn = {
  ...zD,
  ...FD
};
function HD(t, e) {
  return vf(t, new Tn.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, s, i) {
      return Tn.isNode && B.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function YD(t) {
  return B.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function GD(t) {
  const e = {}, n = Object.keys(t);
  let r;
  const s = n.length;
  let i;
  for (r = 0; r < s; r++)
    i = n[r], e[i] = t[i];
  return e;
}
function x1(t) {
  function e(n, r, s, i) {
    let o = n[i++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), c = i >= n.length;
    return o = !o && B.isArray(s) ? s.length : o, c ? (B.hasOwnProp(s, o) ? s[o] = [s[o], r] : s[o] = r, !a) : ((!s[o] || !B.isObject(s[o])) && (s[o] = []), e(n, r, s[o], i) && B.isArray(s[o]) && (s[o] = GD(s[o])), !a);
  }
  if (B.isFormData(t) && B.isFunction(t.entries)) {
    const n = {};
    return B.forEachEntry(t, (r, s) => {
      e(YD(r), s, n, 0);
    }), n;
  }
  return null;
}
function KD(t, e, n) {
  if (B.isString(t))
    try {
      return (e || JSON.parse)(t), B.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (0, JSON.stringify)(t);
}
const pl = {
  transitional: v1,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const r = n.getContentType() || "", s = r.indexOf("application/json") > -1, i = B.isObject(e);
    if (i && B.isHTMLForm(e) && (e = new FormData(e)), B.isFormData(e))
      return s ? JSON.stringify(x1(e)) : e;
    if (B.isArrayBuffer(e) || B.isBuffer(e) || B.isStream(e) || B.isFile(e) || B.isBlob(e) || B.isReadableStream(e))
      return e;
    if (B.isArrayBufferView(e))
      return e.buffer;
    if (B.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (i) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return HD(e, this.formSerializer).toString();
      if ((a = B.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return vf(
          a ? { "files[]": e } : e,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return i || s ? (n.setContentType("application/json", !1), KD(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || pl.transitional, r = n && n.forcedJSONParsing, s = this.responseType === "json";
    if (B.isResponse(e) || B.isReadableStream(e))
      return e;
    if (e && B.isString(e) && (r && !this.responseType || s)) {
      const o = !(n && n.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? we.from(a, we.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Tn.classes.FormData,
    Blob: Tn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
B.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  pl.headers[t] = {};
});
const $D = B.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), ZD = (t) => {
  const e = {};
  let n, r, s;
  return t && t.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), n = o.substring(0, s).trim().toLowerCase(), r = o.substring(s + 1).trim(), !(!n || e[n] && $D[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r);
  }), e;
}, O0 = Symbol("internals");
function za(t) {
  return t && String(t).trim().toLowerCase();
}
function qu(t) {
  return t === !1 || t == null ? t : B.isArray(t) ? t.map(qu) : String(t);
}
function QD(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(t); )
    e[r[1]] = r[2];
  return e;
}
const XD = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Ih(t, e, n, r, s) {
  if (B.isFunction(r))
    return r.call(this, e, n);
  if (s && (e = n), !!B.isString(e)) {
    if (B.isString(r))
      return e.indexOf(r) !== -1;
    if (B.isRegExp(r))
      return r.test(e);
  }
}
function JD(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
}
function eO(t, e) {
  const n = B.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(t, r + n, {
      value: function(s, i, o) {
        return this[r].call(this, e, s, i, o);
      },
      configurable: !0
    });
  });
}
class kn {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, r) {
    const s = this;
    function i(a, c, l) {
      const u = za(c);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = B.findKey(s, u);
      (!d || s[d] === void 0 || l === !0 || l === void 0 && s[d] !== !1) && (s[d || c] = qu(a));
    }
    const o = (a, c) => B.forEach(a, (l, u) => i(l, u, c));
    if (B.isPlainObject(e) || e instanceof this.constructor)
      o(e, n);
    else if (B.isString(e) && (e = e.trim()) && !XD(e))
      o(ZD(e), n);
    else if (B.isHeaders(e))
      for (const [a, c] of e.entries())
        i(c, a, r);
    else
      e != null && i(n, e, r);
    return this;
  }
  get(e, n) {
    if (e = za(e), e) {
      const r = B.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!n)
          return s;
        if (n === !0)
          return QD(s);
        if (B.isFunction(n))
          return n.call(this, s, r);
        if (B.isRegExp(n))
          return n.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = za(e), e) {
      const r = B.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!n || Ih(this, this[r], r, n)));
    }
    return !1;
  }
  delete(e, n) {
    const r = this;
    let s = !1;
    function i(o) {
      if (o = za(o), o) {
        const a = B.findKey(r, o);
        a && (!n || Ih(r, r[a], a, n)) && (delete r[a], s = !0);
      }
    }
    return B.isArray(e) ? e.forEach(i) : i(e), s;
  }
  clear(e) {
    const n = Object.keys(this);
    let r = n.length, s = !1;
    for (; r--; ) {
      const i = n[r];
      (!e || Ih(this, this[i], i, e, !0)) && (delete this[i], s = !0);
    }
    return s;
  }
  normalize(e) {
    const n = this, r = {};
    return B.forEach(this, (s, i) => {
      const o = B.findKey(r, i);
      if (o) {
        n[o] = qu(s), delete n[i];
        return;
      }
      const a = e ? JD(i) : String(i).trim();
      a !== i && delete n[i], n[a] = qu(s), r[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return B.forEach(this, (r, s) => {
      r != null && r !== !1 && (n[s] = e && B.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const r = new this(e);
    return n.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[O0] = this[O0] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function i(o) {
      const a = za(o);
      r[a] || (eO(s, o), r[a] = !0);
    }
    return B.isArray(e) ? e.forEach(i) : i(e), this;
  }
}
kn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
B.reduceDescriptors(kn.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[n] = r;
    }
  };
});
B.freezeMethods(kn);
function Dh(t, e) {
  const n = this || pl, r = e || n, s = kn.from(r.headers);
  let i = r.data;
  return B.forEach(t, function(a) {
    i = a.call(n, i, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), i;
}
function w1(t) {
  return !!(t && t.__CANCEL__);
}
function va(t, e, n) {
  we.call(this, t ?? "canceled", we.ERR_CANCELED, e, n), this.name = "CanceledError";
}
B.inherits(va, we, {
  __CANCEL__: !0
});
function A1(t, e, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? t(n) : e(new we(
    "Request failed with status code " + n.status,
    [we.ERR_BAD_REQUEST, we.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function tO(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function nO(t, e) {
  t = t || 10;
  const n = new Array(t), r = new Array(t);
  let s = 0, i = 0, o;
  return e = e !== void 0 ? e : 1e3, function(c) {
    const l = Date.now(), u = r[i];
    o || (o = l), n[s] = c, r[s] = l;
    let d = i, f = 0;
    for (; d !== s; )
      f += n[d++], d = d % t;
    if (s = (s + 1) % t, s === i && (i = (i + 1) % t), l - o < e)
      return;
    const h = u && l - u;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function rO(t, e) {
  let n = 0, r = 1e3 / e, s, i;
  const o = (l, u = Date.now()) => {
    n = u, s = null, i && (clearTimeout(i), i = null), t.apply(null, l);
  };
  return [(...l) => {
    const u = Date.now(), d = u - n;
    d >= r ? o(l, u) : (s = l, i || (i = setTimeout(() => {
      i = null, o(s);
    }, r - d)));
  }, () => s && o(s)];
}
const md = (t, e, n = 3) => {
  let r = 0;
  const s = nO(50, 250);
  return rO((i) => {
    const o = i.loaded, a = i.lengthComputable ? i.total : void 0, c = o - r, l = s(c), u = o <= a;
    r = o;
    const d = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: c,
      rate: l || void 0,
      estimated: l && a && u ? (a - o) / l : void 0,
      event: i,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    t(d);
  }, n);
}, q0 = (t, e) => {
  const n = t != null;
  return [(r) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: r
  }), e[1]];
}, N0 = (t) => (...e) => B.asap(() => t(...e)), sO = Tn.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = Tn.navigator && /(msie|trident)/i.test(Tn.navigator.userAgent), n = document.createElement("a");
    let r;
    function s(i) {
      let o = i;
      return e && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = s(window.location.href), function(o) {
      const a = B.isString(o) ? s(o) : o;
      return a.protocol === r.protocol && a.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), iO = Tn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, r, s, i) {
      const o = [t + "=" + encodeURIComponent(e)];
      B.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), B.isString(r) && o.push("path=" + r), B.isString(s) && o.push("domain=" + s), i === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function oO(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function aO(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function S1(t, e) {
  return t && !oO(e) ? aO(t, e) : e;
}
const L0 = (t) => t instanceof kn ? { ...t } : t;
function Vi(t, e) {
  e = e || {};
  const n = {};
  function r(l, u, d) {
    return B.isPlainObject(l) && B.isPlainObject(u) ? B.merge.call({ caseless: d }, l, u) : B.isPlainObject(u) ? B.merge({}, u) : B.isArray(u) ? u.slice() : u;
  }
  function s(l, u, d) {
    if (B.isUndefined(u)) {
      if (!B.isUndefined(l))
        return r(void 0, l, d);
    } else return r(l, u, d);
  }
  function i(l, u) {
    if (!B.isUndefined(u))
      return r(void 0, u);
  }
  function o(l, u) {
    if (B.isUndefined(u)) {
      if (!B.isUndefined(l))
        return r(void 0, l);
    } else return r(void 0, u);
  }
  function a(l, u, d) {
    if (d in e)
      return r(l, u);
    if (d in t)
      return r(void 0, l);
  }
  const c = {
    url: i,
    method: i,
    data: i,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (l, u) => s(L0(l), L0(u), !0)
  };
  return B.forEach(Object.keys(Object.assign({}, t, e)), function(u) {
    const d = c[u] || s, f = d(t[u], e[u], u);
    B.isUndefined(f) && d !== a || (n[u] = f);
  }), n;
}
const E1 = (t) => {
  const e = Vi({}, t);
  let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: i, headers: o, auth: a } = e;
  e.headers = o = kn.from(o), e.url = b1(S1(e.baseURL, e.url), t.params, t.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (B.isFormData(n)) {
    if (Tn.hasStandardBrowserEnv || Tn.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((c = o.getContentType()) !== !1) {
      const [l, ...u] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      o.setContentType([l || "multipart/form-data", ...u].join("; "));
    }
  }
  if (Tn.hasStandardBrowserEnv && (r && B.isFunction(r) && (r = r(e)), r || r !== !1 && sO(e.url))) {
    const l = s && i && iO.read(i);
    l && o.set(s, l);
  }
  return e;
}, cO = typeof XMLHttpRequest < "u", lO = cO && function(t) {
  return new Promise(function(n, r) {
    const s = E1(t);
    let i = s.data;
    const o = kn.from(s.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: l } = s, u, d, f, h, p;
    function m() {
      h && h(), p && p(), s.cancelToken && s.cancelToken.unsubscribe(u), s.signal && s.signal.removeEventListener("abort", u);
    }
    let y = new XMLHttpRequest();
    y.open(s.method.toUpperCase(), s.url, !0), y.timeout = s.timeout;
    function b() {
      if (!y)
        return;
      const w = kn.from(
        "getAllResponseHeaders" in y && y.getAllResponseHeaders()
      ), A = {
        data: !a || a === "text" || a === "json" ? y.responseText : y.response,
        status: y.status,
        statusText: y.statusText,
        headers: w,
        config: t,
        request: y
      };
      A1(function(S) {
        n(S), m();
      }, function(S) {
        r(S), m();
      }, A), y = null;
    }
    "onloadend" in y ? y.onloadend = b : y.onreadystatechange = function() {
      !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, y.onabort = function() {
      y && (r(new we("Request aborted", we.ECONNABORTED, t, y)), y = null);
    }, y.onerror = function() {
      r(new we("Network Error", we.ERR_NETWORK, t, y)), y = null;
    }, y.ontimeout = function() {
      let x = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const A = s.transitional || v1;
      s.timeoutErrorMessage && (x = s.timeoutErrorMessage), r(new we(
        x,
        A.clarifyTimeoutError ? we.ETIMEDOUT : we.ECONNABORTED,
        t,
        y
      )), y = null;
    }, i === void 0 && o.setContentType(null), "setRequestHeader" in y && B.forEach(o.toJSON(), function(x, A) {
      y.setRequestHeader(A, x);
    }), B.isUndefined(s.withCredentials) || (y.withCredentials = !!s.withCredentials), a && a !== "json" && (y.responseType = s.responseType), l && ([f, p] = md(l, !0), y.addEventListener("progress", f)), c && y.upload && ([d, h] = md(c), y.upload.addEventListener("progress", d), y.upload.addEventListener("loadend", h)), (s.cancelToken || s.signal) && (u = (w) => {
      y && (r(!w || w.type ? new va(null, t, y) : w), y.abort(), y = null);
    }, s.cancelToken && s.cancelToken.subscribe(u), s.signal && (s.signal.aborted ? u() : s.signal.addEventListener("abort", u)));
    const v = tO(s.url);
    if (v && Tn.protocols.indexOf(v) === -1) {
      r(new we("Unsupported protocol " + v + ":", we.ERR_BAD_REQUEST, t));
      return;
    }
    y.send(i || null);
  });
}, uO = (t, e) => {
  const { length: n } = t = t ? t.filter(Boolean) : [];
  if (e || n) {
    let r = new AbortController(), s;
    const i = function(l) {
      if (!s) {
        s = !0, a();
        const u = l instanceof Error ? l : this.reason;
        r.abort(u instanceof we ? u : new va(u instanceof Error ? u.message : u));
      }
    };
    let o = e && setTimeout(() => {
      o = null, i(new we(`timeout ${e} of ms exceeded`, we.ETIMEDOUT));
    }, e);
    const a = () => {
      t && (o && clearTimeout(o), o = null, t.forEach((l) => {
        l.unsubscribe ? l.unsubscribe(i) : l.removeEventListener("abort", i);
      }), t = null);
    };
    t.forEach((l) => l.addEventListener("abort", i));
    const { signal: c } = r;
    return c.unsubscribe = () => B.asap(a), c;
  }
}, dO = function* (t, e) {
  let n = t.byteLength;
  if (n < e) {
    yield t;
    return;
  }
  let r = 0, s;
  for (; r < n; )
    s = r + e, yield t.slice(r, s), r = s;
}, fO = async function* (t, e) {
  for await (const n of hO(t))
    yield* dO(n, e);
}, hO = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await e.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, j0 = (t, e, n, r) => {
  const s = fO(t, e);
  let i = 0, o, a = (c) => {
    o || (o = !0, r && r(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: l, value: u } = await s.next();
        if (l) {
          a(), c.close();
          return;
        }
        let d = u.byteLength;
        if (n) {
          let f = i += d;
          n(f);
        }
        c.enqueue(new Uint8Array(u));
      } catch (l) {
        throw a(l), l;
      }
    },
    cancel(c) {
      return a(c), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, xf = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", C1 = xf && typeof ReadableStream == "function", pO = xf && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), _1 = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, mO = C1 && _1(() => {
  let t = !1;
  const e = new Request(Tn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), B0 = 64 * 1024, Hp = C1 && _1(() => B.isReadableStream(new Response("").body)), gd = {
  stream: Hp && ((t) => t.body)
};
xf && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !gd[e] && (gd[e] = B.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
      throw new we(`Response type '${e}' is not supported`, we.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const gO = async (t) => {
  if (t == null)
    return 0;
  if (B.isBlob(t))
    return t.size;
  if (B.isSpecCompliantForm(t))
    return (await new Request(Tn.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (B.isArrayBufferView(t) || B.isArrayBuffer(t))
    return t.byteLength;
  if (B.isURLSearchParams(t) && (t = t + ""), B.isString(t))
    return (await pO(t)).byteLength;
}, yO = async (t, e) => {
  const n = B.toFiniteNumber(t.getContentLength());
  return n ?? gO(e);
}, bO = xf && (async (t) => {
  let {
    url: e,
    method: n,
    data: r,
    signal: s,
    cancelToken: i,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: l,
    headers: u,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = E1(t);
  l = l ? (l + "").toLowerCase() : "text";
  let h = uO([s, i && i.toAbortSignal()], o), p;
  const m = h && h.unsubscribe && (() => {
    h.unsubscribe();
  });
  let y;
  try {
    if (c && mO && n !== "get" && n !== "head" && (y = await yO(u, r)) !== 0) {
      let A = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), C;
      if (B.isFormData(r) && (C = A.headers.get("content-type")) && u.setContentType(C), A.body) {
        const [S, _] = q0(
          y,
          md(N0(c))
        );
        r = j0(A.body, B0, S, _);
      }
    }
    B.isString(d) || (d = d ? "include" : "omit");
    const b = "credentials" in Request.prototype;
    p = new Request(e, {
      ...f,
      signal: h,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: b ? d : void 0
    });
    let v = await fetch(p);
    const w = Hp && (l === "stream" || l === "response");
    if (Hp && (a || w && m)) {
      const A = {};
      ["status", "statusText", "headers"].forEach((T) => {
        A[T] = v[T];
      });
      const C = B.toFiniteNumber(v.headers.get("content-length")), [S, _] = a && q0(
        C,
        md(N0(a), !0)
      ) || [];
      v = new Response(
        j0(v.body, B0, S, () => {
          _ && _(), m && m();
        }),
        A
      );
    }
    l = l || "text";
    let x = await gd[B.findKey(gd, l) || "text"](v, t);
    return !w && m && m(), await new Promise((A, C) => {
      A1(A, C, {
        data: x,
        headers: kn.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: t,
        request: p
      });
    });
  } catch (b) {
    throw m && m(), b && b.name === "TypeError" && /fetch/i.test(b.message) ? Object.assign(
      new we("Network Error", we.ERR_NETWORK, t, p),
      {
        cause: b.cause || b
      }
    ) : we.from(b, b && b.code, t, p);
  }
}), Yp = {
  http: DD,
  xhr: lO,
  fetch: bO
};
B.forEach(Yp, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const F0 = (t) => `- ${t}`, vO = (t) => B.isFunction(t) || t === null || t === !1, T1 = {
  getAdapter: (t) => {
    t = B.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, r;
    const s = {};
    for (let i = 0; i < e; i++) {
      n = t[i];
      let o;
      if (r = n, !vO(n) && (r = Yp[(o = String(n)).toLowerCase()], r === void 0))
        throw new we(`Unknown adapter '${o}'`);
      if (r)
        break;
      s[o || "#" + i] = r;
    }
    if (!r) {
      const i = Object.entries(s).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? i.length > 1 ? `since :
` + i.map(F0).join(`
`) : " " + F0(i[0]) : "as no adapter specified";
      throw new we(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Yp
};
function Oh(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new va(null, t);
}
function V0(t) {
  return Oh(t), t.headers = kn.from(t.headers), t.data = Dh.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), T1.getAdapter(t.adapter || pl.adapter)(t).then(function(r) {
    return Oh(t), r.data = Dh.call(
      t,
      t.transformResponse,
      r
    ), r.headers = kn.from(r.headers), r;
  }, function(r) {
    return w1(r) || (Oh(t), r && r.response && (r.response.data = Dh.call(
      t,
      t.transformResponse,
      r.response
    ), r.response.headers = kn.from(r.response.headers))), Promise.reject(r);
  });
}
const k1 = "1.7.7", jg = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  jg[t] = function(r) {
    return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const U0 = {};
jg.transitional = function(e, n, r) {
  function s(i, o) {
    return "[Axios v" + k1 + "] Transitional option '" + i + "'" + o + (r ? ". " + r : "");
  }
  return (i, o, a) => {
    if (e === !1)
      throw new we(
        s(o, " has been removed" + (n ? " in " + n : "")),
        we.ERR_DEPRECATED
      );
    return n && !U0[o] && (U0[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(i, o, a) : !0;
  };
};
function xO(t, e, n) {
  if (typeof t != "object")
    throw new we("options must be an object", we.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(t);
  let s = r.length;
  for (; s-- > 0; ) {
    const i = r[s], o = e[i];
    if (o) {
      const a = t[i], c = a === void 0 || o(a, i, t);
      if (c !== !0)
        throw new we("option " + i + " must be " + c, we.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new we("Unknown option " + i, we.ERR_BAD_OPTION);
  }
}
const Gp = {
  assertOptions: xO,
  validators: jg
}, Cs = Gp.validators;
class Pi {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new D0(),
      response: new D0()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (r) {
      if (r instanceof Error) {
        let s;
        Error.captureStackTrace ? Error.captureStackTrace(s = {}) : s = new Error();
        const i = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? i && !String(r.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + i) : r.stack = i;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Vi(this.defaults, n);
    const { transitional: r, paramsSerializer: s, headers: i } = n;
    r !== void 0 && Gp.assertOptions(r, {
      silentJSONParsing: Cs.transitional(Cs.boolean),
      forcedJSONParsing: Cs.transitional(Cs.boolean),
      clarifyTimeoutError: Cs.transitional(Cs.boolean)
    }, !1), s != null && (B.isFunction(s) ? n.paramsSerializer = {
      serialize: s
    } : Gp.assertOptions(s, {
      encode: Cs.function,
      serialize: Cs.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o = i && B.merge(
      i.common,
      i[n.method]
    );
    i && B.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete i[p];
      }
    ), n.headers = kn.concat(o, i);
    const a = [];
    let c = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(n) === !1 || (c = c && m.synchronous, a.unshift(m.fulfilled, m.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(m) {
      l.push(m.fulfilled, m.rejected);
    });
    let u, d = 0, f;
    if (!c) {
      const p = [V0.bind(this), void 0];
      for (p.unshift.apply(p, a), p.push.apply(p, l), f = p.length, u = Promise.resolve(n); d < f; )
        u = u.then(p[d++], p[d++]);
      return u;
    }
    f = a.length;
    let h = n;
    for (d = 0; d < f; ) {
      const p = a[d++], m = a[d++];
      try {
        h = p(h);
      } catch (y) {
        m.call(this, y);
        break;
      }
    }
    try {
      u = V0.call(this, h);
    } catch (p) {
      return Promise.reject(p);
    }
    for (d = 0, f = l.length; d < f; )
      u = u.then(l[d++], l[d++]);
    return u;
  }
  getUri(e) {
    e = Vi(this.defaults, e);
    const n = S1(e.baseURL, e.url);
    return b1(n, e.params, e.paramsSerializer);
  }
}
B.forEach(["delete", "get", "head", "options"], function(e) {
  Pi.prototype[e] = function(n, r) {
    return this.request(Vi(r || {}, {
      method: e,
      url: n,
      data: (r || {}).data
    }));
  };
});
B.forEach(["post", "put", "patch"], function(e) {
  function n(r) {
    return function(i, o, a) {
      return this.request(Vi(a || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: i,
        data: o
      }));
    };
  }
  Pi.prototype[e] = n(), Pi.prototype[e + "Form"] = n(!0);
});
class Bg {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(i) {
      n = i;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners) return;
      let i = r._listeners.length;
      for (; i-- > 0; )
        r._listeners[i](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let i;
      const o = new Promise((a) => {
        r.subscribe(a), i = a;
      }).then(s);
      return o.cancel = function() {
        r.unsubscribe(i);
      }, o;
    }, e(function(i, o, a) {
      r.reason || (r.reason = new va(i, o, a), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), n = (r) => {
      e.abort(r);
    };
    return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new Bg(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
}
function wO(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function AO(t) {
  return B.isObject(t) && t.isAxiosError === !0;
}
const Kp = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Kp).forEach(([t, e]) => {
  Kp[e] = t;
});
function R1(t) {
  const e = new Pi(t), n = o1(Pi.prototype.request, e);
  return B.extend(n, Pi.prototype, e, { allOwnKeys: !0 }), B.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(s) {
    return R1(Vi(t, s));
  }, n;
}
const Ie = R1(pl);
Ie.Axios = Pi;
Ie.CanceledError = va;
Ie.CancelToken = Bg;
Ie.isCancel = w1;
Ie.VERSION = k1;
Ie.toFormData = vf;
Ie.AxiosError = we;
Ie.Cancel = Ie.CanceledError;
Ie.all = function(e) {
  return Promise.all(e);
};
Ie.spread = wO;
Ie.isAxiosError = AO;
Ie.mergeConfig = Vi;
Ie.AxiosHeaders = kn;
Ie.formToJSON = (t) => x1(B.isHTMLForm(t) ? new FormData(t) : t);
Ie.getAdapter = T1.getAdapter;
Ie.HttpStatusCode = Kp;
Ie.default = Ie;
const W0 = /* @__PURE__ */ new Set();
function Fg(t, e, n) {
  t || W0.has(e) || (console.warn(e), W0.add(e));
}
function SO(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), n = (...r) => (Fg(!1, "motion() is deprecated. Use motion.create() instead."), t(...r));
  return new Proxy(n, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, s) => s === "create" ? t : (e.has(s) || e.set(s, t(s)), e.get(s))
  });
}
function Mc(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const $p = (t) => Array.isArray(t);
function M1(t, e) {
  if (!Array.isArray(e))
    return !1;
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function Pc(t) {
  return typeof t == "string" || Array.isArray(t);
}
function z0(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((n, r) => {
    e[0][r] = n.get(), e[1][r] = n.getVelocity();
  }), e;
}
function Vg(t, e, n, r) {
  if (typeof e == "function") {
    const [s, i] = z0(r);
    e = e(n !== void 0 ? n : t.custom, s, i);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [s, i] = z0(r);
    e = e(n !== void 0 ? n : t.custom, s, i);
  }
  return e;
}
function wf(t, e, n) {
  const r = t.getProps();
  return Vg(r, e, n !== void 0 ? n : r.custom, t);
}
const Ug = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Wg = ["initial", ...Ug], ml = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], ci = new Set(ml), Cr = (t) => t * 1e3, rs = (t) => t / 1e3, EO = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, CO = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), _O = {
  type: "keyframes",
  duration: 0.8
}, TO = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, kO = (t, { keyframes: e }) => e.length > 2 ? _O : ci.has(t) ? t.startsWith("scale") ? CO(e[1]) : EO : TO;
function zg(t, e) {
  return t[e] || t.default || t;
}
const RO = {
  skipAnimations: !1,
  useManualTiming: !1
}, MO = (t) => t !== null;
function Af(t, { repeat: e, repeatType: n = "loop" }, r) {
  const s = t.filter(MO), i = e && n !== "loop" && e % 2 === 1 ? 0 : s.length - 1;
  return !i || r === void 0 ? s[i] : r;
}
const Qt = (t) => t;
function PO(t) {
  let e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = !1, s = !1;
  const i = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(l) {
    i.has(l) && (c.schedule(l), t()), l(o);
  }
  const c = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (l, u = !1, d = !1) => {
      const h = d && r ? e : n;
      return u && i.add(l), h.has(l) || h.add(l), l;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (l) => {
      n.delete(l), i.delete(l);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (l) => {
      if (o = l, r) {
        s = !0;
        return;
      }
      r = !0, [e, n] = [n, e], n.clear(), e.forEach(a), r = !1, s && (s = !1, c.process(l));
    }
  };
  return c;
}
const Vl = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], IO = 40;
function P1(t, e) {
  let n = !1, r = !0;
  const s = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, i = () => n = !0, o = Vl.reduce((b, v) => (b[v] = PO(i), b), {}), { read: a, resolveKeyframes: c, update: l, preRender: u, render: d, postRender: f } = o, h = () => {
    const b = performance.now();
    n = !1, s.delta = r ? 1e3 / 60 : Math.max(Math.min(b - s.timestamp, IO), 1), s.timestamp = b, s.isProcessing = !0, a.process(s), c.process(s), l.process(s), u.process(s), d.process(s), f.process(s), s.isProcessing = !1, n && e && (r = !1, t(h));
  }, p = () => {
    n = !0, r = !0, s.isProcessing || t(h);
  };
  return { schedule: Vl.reduce((b, v) => {
    const w = o[v];
    return b[v] = (x, A = !1, C = !1) => (n || p(), w.schedule(x, A, C)), b;
  }, {}), cancel: (b) => {
    for (let v = 0; v < Vl.length; v++)
      o[Vl[v]].cancel(b);
  }, state: s, steps: o };
}
const { schedule: it, cancel: Ys, state: Kt, steps: qh } = P1(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Qt, !0), I1 = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, DO = 1e-7, OO = 12;
function qO(t, e, n, r, s) {
  let i, o, a = 0;
  do
    o = e + (n - e) / 2, i = I1(o, r, s) - t, i > 0 ? n = o : e = o;
  while (Math.abs(i) > DO && ++a < OO);
  return o;
}
function gl(t, e, n, r) {
  if (t === e && n === r)
    return Qt;
  const s = (i) => qO(i, 0, 1, t, n);
  return (i) => i === 0 || i === 1 ? i : I1(s(i), e, r);
}
const D1 = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, O1 = (t) => (e) => 1 - t(1 - e), q1 = /* @__PURE__ */ gl(0.33, 1.53, 0.69, 0.99), Hg = /* @__PURE__ */ O1(q1), N1 = /* @__PURE__ */ D1(Hg), L1 = (t) => (t *= 2) < 1 ? 0.5 * Hg(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Yg = (t) => 1 - Math.sin(Math.acos(t)), j1 = O1(Yg), B1 = D1(Yg), F1 = (t) => /^0[^.\s]+$/u.test(t);
function NO(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || F1(t) : !0;
}
let xa = Qt, ls = Qt;
xa = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, ls = (t, e) => {
  if (!t)
    throw new Error(e);
};
const V1 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), U1 = (t) => (e) => typeof e == "string" && e.startsWith(t), W1 = /* @__PURE__ */ U1("--"), LO = /* @__PURE__ */ U1("var(--"), Gg = (t) => LO(t) ? jO.test(t.split("/*")[0].trim()) : !1, jO = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, BO = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function FO(t) {
  const e = BO.exec(t);
  if (!e)
    return [,];
  const [, n, r, s] = e;
  return [`--${n ?? r}`, s];
}
const VO = 4;
function z1(t, e, n = 1) {
  ls(n <= VO, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [r, s] = FO(t);
  if (!r)
    return;
  const i = window.getComputedStyle(e).getPropertyValue(r);
  if (i) {
    const o = i.trim();
    return V1(o) ? parseFloat(o) : o;
  }
  return Gg(s) ? z1(s, e, n + 1) : s;
}
const Gs = (t, e, n) => n > e ? e : n < t ? t : n, wa = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Ic = {
  ...wa,
  transform: (t) => Gs(0, 1, t)
}, Ul = {
  ...wa,
  default: 1
}, yl = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), ks = /* @__PURE__ */ yl("deg"), _r = /* @__PURE__ */ yl("%"), se = /* @__PURE__ */ yl("px"), UO = /* @__PURE__ */ yl("vh"), WO = /* @__PURE__ */ yl("vw"), H0 = {
  ..._r,
  parse: (t) => _r.parse(t) / 100,
  transform: (t) => _r.transform(t * 100)
}, zO = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), Y0 = (t) => t === wa || t === se, G0 = (t, e) => parseFloat(t.split(", ")[e]), K0 = (t, e) => (n, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const s = r.match(/^matrix3d\((.+)\)$/u);
  if (s)
    return G0(s[1], e);
  {
    const i = r.match(/^matrix\((.+)\)$/u);
    return i ? G0(i[1], t) : 0;
  }
}, HO = /* @__PURE__ */ new Set(["x", "y", "z"]), YO = ml.filter((t) => !HO.has(t));
function GO(t) {
  const e = [];
  return YO.forEach((n) => {
    const r = t.getValue(n);
    r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), e;
}
const zo = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: K0(4, 13),
  y: K0(5, 14)
};
zo.translateX = zo.x;
zo.translateY = zo.y;
const H1 = (t) => (e) => e.test(t), KO = {
  test: (t) => t === "auto",
  parse: (t) => t
}, Y1 = [wa, se, _r, ks, WO, UO, KO], $0 = (t) => Y1.find(H1(t)), Ii = /* @__PURE__ */ new Set();
let Zp = !1, Qp = !1;
function G1() {
  if (Qp) {
    const t = Array.from(Ii).filter((r) => r.needsMeasurement), e = new Set(t.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    e.forEach((r) => {
      const s = GO(r);
      s.length && (n.set(r, s), r.render());
    }), t.forEach((r) => r.measureInitialState()), e.forEach((r) => {
      r.render();
      const s = n.get(r);
      s && s.forEach(([i, o]) => {
        var a;
        (a = r.getValue(i)) === null || a === void 0 || a.set(o);
      });
    }), t.forEach((r) => r.measureEndState()), t.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  Qp = !1, Zp = !1, Ii.forEach((t) => t.complete()), Ii.clear();
}
function K1() {
  Ii.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (Qp = !0);
  });
}
function $O() {
  K1(), G1();
}
class Kg {
  constructor(e, n, r, s, i, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = r, this.motionValue = s, this.element = i, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (Ii.add(this), Zp || (Zp = !0, it.read(K1), it.resolveKeyframes(G1))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: n, element: r, motionValue: s } = this;
    for (let i = 0; i < e.length; i++)
      if (e[i] === null)
        if (i === 0) {
          const o = s == null ? void 0 : s.get(), a = e[e.length - 1];
          if (o !== void 0)
            e[0] = o;
          else if (r && n) {
            const c = r.readValue(n, a);
            c != null && (e[0] = c);
          }
          e[0] === void 0 && (e[0] = a), s && o === void 0 && s.set(e[0]);
        } else
          e[i] = e[i - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Ii.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, Ii.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const hc = (t) => Math.round(t * 1e5) / 1e5, $g = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function ZO(t) {
  return t == null;
}
const QO = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Zg = (t, e) => (n) => !!(typeof n == "string" && QO.test(n) && n.startsWith(t) || e && !ZO(n) && Object.prototype.hasOwnProperty.call(n, e)), $1 = (t, e, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [s, i, o, a] = r.match($g);
  return {
    [t]: parseFloat(s),
    [e]: parseFloat(i),
    [n]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, XO = (t) => Gs(0, 255, t), Nh = {
  ...wa,
  transform: (t) => Math.round(XO(t))
}, Ti = {
  test: /* @__PURE__ */ Zg("rgb", "red"),
  parse: /* @__PURE__ */ $1("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + Nh.transform(t) + ", " + Nh.transform(e) + ", " + Nh.transform(n) + ", " + hc(Ic.transform(r)) + ")"
};
function JO(t) {
  let e = "", n = "", r = "", s = "";
  return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), s = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), s = t.substring(4, 5), e += e, n += n, r += r, s += s), {
    red: parseInt(e, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: s ? parseInt(s, 16) / 255 : 1
  };
}
const Xp = {
  test: /* @__PURE__ */ Zg("#"),
  parse: JO,
  transform: Ti.transform
}, Eo = {
  test: /* @__PURE__ */ Zg("hsl", "hue"),
  parse: /* @__PURE__ */ $1("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + _r.transform(hc(e)) + ", " + _r.transform(hc(n)) + ", " + hc(Ic.transform(r)) + ")"
}, sn = {
  test: (t) => Ti.test(t) || Xp.test(t) || Eo.test(t),
  parse: (t) => Ti.test(t) ? Ti.parse(t) : Eo.test(t) ? Eo.parse(t) : Xp.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? Ti.transform(t) : Eo.transform(t)
}, eq = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function tq(t) {
  var e, n;
  return isNaN(t) && typeof t == "string" && (((e = t.match($g)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(eq)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const Z1 = "number", Q1 = "color", nq = "var", rq = "var(", Z0 = "${}", sq = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Dc(t) {
  const e = t.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, s = [];
  let i = 0;
  const a = e.replace(sq, (c) => (sn.test(c) ? (r.color.push(i), s.push(Q1), n.push(sn.parse(c))) : c.startsWith(rq) ? (r.var.push(i), s.push(nq), n.push(c)) : (r.number.push(i), s.push(Z1), n.push(parseFloat(c))), ++i, Z0)).split(Z0);
  return { values: n, split: a, indexes: r, types: s };
}
function X1(t) {
  return Dc(t).values;
}
function J1(t) {
  const { split: e, types: n } = Dc(t), r = e.length;
  return (s) => {
    let i = "";
    for (let o = 0; o < r; o++)
      if (i += e[o], s[o] !== void 0) {
        const a = n[o];
        a === Z1 ? i += hc(s[o]) : a === Q1 ? i += sn.transform(s[o]) : i += s[o];
      }
    return i;
  };
}
const iq = (t) => typeof t == "number" ? 0 : t;
function oq(t) {
  const e = X1(t);
  return J1(t)(e.map(iq));
}
const Ks = {
  test: tq,
  parse: X1,
  createTransformer: J1,
  getAnimatableNone: oq
}, aq = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function cq(t) {
  const [e, n] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [r] = n.match($g) || [];
  if (!r)
    return t;
  const s = n.replace(r, "");
  let i = aq.has(e) ? 1 : 0;
  return r !== n && (i *= 100), e + "(" + i + s + ")";
}
const lq = /\b([a-z-]*)\(.*?\)/gu, Jp = {
  ...Ks,
  getAnimatableNone: (t) => {
    const e = t.match(lq);
    return e ? e.map(cq).join(" ") : t;
  }
}, uq = {
  // Border props
  borderWidth: se,
  borderTopWidth: se,
  borderRightWidth: se,
  borderBottomWidth: se,
  borderLeftWidth: se,
  borderRadius: se,
  radius: se,
  borderTopLeftRadius: se,
  borderTopRightRadius: se,
  borderBottomRightRadius: se,
  borderBottomLeftRadius: se,
  // Positioning props
  width: se,
  maxWidth: se,
  height: se,
  maxHeight: se,
  top: se,
  right: se,
  bottom: se,
  left: se,
  // Spacing props
  padding: se,
  paddingTop: se,
  paddingRight: se,
  paddingBottom: se,
  paddingLeft: se,
  margin: se,
  marginTop: se,
  marginRight: se,
  marginBottom: se,
  marginLeft: se,
  // Misc
  backgroundPositionX: se,
  backgroundPositionY: se
}, dq = {
  rotate: ks,
  rotateX: ks,
  rotateY: ks,
  rotateZ: ks,
  scale: Ul,
  scaleX: Ul,
  scaleY: Ul,
  scaleZ: Ul,
  skew: ks,
  skewX: ks,
  skewY: ks,
  distance: se,
  translateX: se,
  translateY: se,
  translateZ: se,
  x: se,
  y: se,
  z: se,
  perspective: se,
  transformPerspective: se,
  opacity: Ic,
  originX: H0,
  originY: H0,
  originZ: se
}, Q0 = {
  ...wa,
  transform: Math.round
}, Qg = {
  ...uq,
  ...dq,
  zIndex: Q0,
  size: se,
  // SVG
  fillOpacity: Ic,
  strokeOpacity: Ic,
  numOctaves: Q0
}, fq = {
  ...Qg,
  // Color props
  color: sn,
  backgroundColor: sn,
  outlineColor: sn,
  fill: sn,
  stroke: sn,
  // Border props
  borderColor: sn,
  borderTopColor: sn,
  borderRightColor: sn,
  borderBottomColor: sn,
  borderLeftColor: sn,
  filter: Jp,
  WebkitFilter: Jp
}, Xg = (t) => fq[t];
function eE(t, e) {
  let n = Xg(t);
  return n !== Jp && (n = Ks), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;
}
const hq = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function pq(t, e, n) {
  let r = 0, s;
  for (; r < t.length && !s; ) {
    const i = t[r];
    typeof i == "string" && !hq.has(i) && Dc(i).values.length && (s = t[r]), r++;
  }
  if (s && n)
    for (const i of e)
      t[i] = eE(n, s);
}
class tE extends Kg {
  constructor(e, n, r, s, i) {
    super(e, n, r, s, i, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let c = 0; c < e.length; c++) {
      let l = e[c];
      if (typeof l == "string" && (l = l.trim(), Gg(l))) {
        const u = z1(l, n.current);
        u !== void 0 && (e[c] = u), c === e.length - 1 && (this.finalKeyframe = l);
      }
    }
    if (this.resolveNoneKeyframes(), !zO.has(r) || e.length !== 2)
      return;
    const [s, i] = e, o = $0(s), a = $0(i);
    if (o !== a)
      if (Y0(o) && Y0(a))
        for (let c = 0; c < e.length; c++) {
          const l = e[c];
          typeof l == "string" && (e[c] = parseFloat(l));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: n } = this, r = [];
    for (let s = 0; s < e.length; s++)
      NO(e[s]) && r.push(s);
    r.length && pq(e, r, n);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: n, name: r } = this;
    if (!e || !e.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = zo[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin;
    const s = n[n.length - 1];
    s !== void 0 && e.getValue(r, s).jump(s, !1);
  }
  measureEndState() {
    var e;
    const { element: n, name: r, unresolvedKeyframes: s } = this;
    if (!n || !n.current)
      return;
    const i = n.getValue(r);
    i && i.jump(this.measuredOrigin, !1);
    const o = s.length - 1, a = s[o];
    s[o] = zo[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([c, l]) => {
      n.getValue(c).set(l);
    }), this.resolveNoneKeyframes();
  }
}
function Jg(t) {
  return typeof t == "function";
}
let Nu;
function mq() {
  Nu = void 0;
}
const Tr = {
  now: () => (Nu === void 0 && Tr.set(Kt.isProcessing || RO.useManualTiming ? Kt.timestamp : performance.now()), Nu),
  set: (t) => {
    Nu = t, queueMicrotask(mq);
  }
}, X0 = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(Ks.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function gq(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e)
      return !0;
}
function yq(t, e, n, r) {
  const s = t[0];
  if (s === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const i = t[t.length - 1], o = X0(s, e), a = X0(i, e);
  return xa(o === a, `You are trying to animate ${e} from "${s}" to "${i}". ${s} is not an animatable value - to enable this animation set ${s} to a value animatable to ${i} via the \`style\` property.`), !o || !a ? !1 : gq(t) || (n === "spring" || Jg(n)) && r;
}
const bq = 40;
class nE {
  constructor({ autoplay: e = !0, delay: n = 0, type: r = "keyframes", repeat: s = 0, repeatDelay: i = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Tr.now(), this.options = {
      autoplay: e,
      delay: n,
      type: r,
      repeat: s,
      repeatDelay: i,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > bq ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && $O(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, n) {
    this.resolvedAt = Tr.now(), this.hasAttemptedResolve = !0;
    const { name: r, type: s, velocity: i, delay: o, onComplete: a, onUpdate: c, isGenerator: l } = this.options;
    if (!l && !yq(e, r, s, i))
      if (o)
        this.options.duration = 0;
      else {
        c == null || c(Af(e, this.options, n)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const u = this.initPlayback(e, n);
    u !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: n,
      ...u
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, n) {
    return this.currentFinishedPromise.then(e, n);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function rE(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const vq = 5;
function sE(t, e, n) {
  const r = Math.max(e - vq, 0);
  return rE(n - t(r), e - r);
}
const Lh = 1e-3, xq = 0.01, J0 = 10, wq = 0.05, Aq = 1;
function Sq({ duration: t = 800, bounce: e = 0.25, velocity: n = 0, mass: r = 1 }) {
  let s, i;
  xa(t <= Cr(J0), "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = Gs(wq, Aq, o), t = Gs(xq, J0, rs(t)), o < 1 ? (s = (l) => {
    const u = l * o, d = u * t, f = u - n, h = em(l, o), p = Math.exp(-d);
    return Lh - f / h * p;
  }, i = (l) => {
    const d = l * o * t, f = d * n + n, h = Math.pow(o, 2) * Math.pow(l, 2) * t, p = Math.exp(-d), m = em(Math.pow(l, 2), o);
    return (-s(l) + Lh > 0 ? -1 : 1) * ((f - h) * p) / m;
  }) : (s = (l) => {
    const u = Math.exp(-l * t), d = (l - n) * t + 1;
    return -Lh + u * d;
  }, i = (l) => {
    const u = Math.exp(-l * t), d = (n - l) * (t * t);
    return u * d;
  });
  const a = 5 / t, c = Cq(s, i, a);
  if (t = Cr(t), isNaN(c))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const l = Math.pow(c, 2) * r;
    return {
      stiffness: l,
      damping: o * 2 * Math.sqrt(r * l),
      duration: t
    };
  }
}
const Eq = 12;
function Cq(t, e, n) {
  let r = n;
  for (let s = 1; s < Eq; s++)
    r = r - t(r) / e(r);
  return r;
}
function em(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const _q = ["duration", "bounce"], Tq = ["stiffness", "damping", "mass"];
function ev(t, e) {
  return e.some((n) => t[n] !== void 0);
}
function kq(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!ev(t, Tq) && ev(t, _q)) {
    const n = Sq(t);
    e = {
      ...e,
      ...n,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function iE({ keyframes: t, restDelta: e, restSpeed: n, ...r }) {
  const s = t[0], i = t[t.length - 1], o = { done: !1, value: s }, { stiffness: a, damping: c, mass: l, duration: u, velocity: d, isResolvedFromDuration: f } = kq({
    ...r,
    velocity: -rs(r.velocity || 0)
  }), h = d || 0, p = c / (2 * Math.sqrt(a * l)), m = i - s, y = rs(Math.sqrt(a / l)), b = Math.abs(m) < 5;
  n || (n = b ? 0.01 : 2), e || (e = b ? 5e-3 : 0.5);
  let v;
  if (p < 1) {
    const w = em(y, p);
    v = (x) => {
      const A = Math.exp(-p * y * x);
      return i - A * ((h + p * y * m) / w * Math.sin(w * x) + m * Math.cos(w * x));
    };
  } else if (p === 1)
    v = (w) => i - Math.exp(-y * w) * (m + (h + y * m) * w);
  else {
    const w = y * Math.sqrt(p * p - 1);
    v = (x) => {
      const A = Math.exp(-p * y * x), C = Math.min(w * x, 300);
      return i - A * ((h + p * y * m) * Math.sinh(C) + w * m * Math.cosh(C)) / w;
    };
  }
  return {
    calculatedDuration: f && u || null,
    next: (w) => {
      const x = v(w);
      if (f)
        o.done = w >= u;
      else {
        let A = 0;
        p < 1 && (A = w === 0 ? Cr(h) : sE(v, w, x));
        const C = Math.abs(A) <= n, S = Math.abs(i - x) <= e;
        o.done = C && S;
      }
      return o.value = o.done ? i : x, o;
    }
  };
}
function tv({ keyframes: t, velocity: e = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: s = 10, bounceStiffness: i = 500, modifyTarget: o, min: a, max: c, restDelta: l = 0.5, restSpeed: u }) {
  const d = t[0], f = {
    done: !1,
    value: d
  }, h = (_) => a !== void 0 && _ < a || c !== void 0 && _ > c, p = (_) => a === void 0 ? c : c === void 0 || Math.abs(a - _) < Math.abs(c - _) ? a : c;
  let m = n * e;
  const y = d + m, b = o === void 0 ? y : o(y);
  b !== y && (m = b - d);
  const v = (_) => -m * Math.exp(-_ / r), w = (_) => b + v(_), x = (_) => {
    const T = v(_), k = w(_);
    f.done = Math.abs(T) <= l, f.value = f.done ? b : k;
  };
  let A, C;
  const S = (_) => {
    h(f.value) && (A = _, C = iE({
      keyframes: [f.value, p(f.value)],
      velocity: sE(w, _, f.value),
      // TODO: This should be passing * 1000
      damping: s,
      stiffness: i,
      restDelta: l,
      restSpeed: u
    }));
  };
  return S(0), {
    calculatedDuration: null,
    next: (_) => {
      let T = !1;
      return !C && A === void 0 && (T = !0, x(_), S(_)), A !== void 0 && _ >= A ? C.next(_ - A) : (!T && x(_), f);
    }
  };
}
const Rq = /* @__PURE__ */ gl(0.42, 0, 1, 1), Mq = /* @__PURE__ */ gl(0, 0, 0.58, 1), oE = /* @__PURE__ */ gl(0.42, 0, 0.58, 1), Pq = (t) => Array.isArray(t) && typeof t[0] != "number", nv = {
  linear: Qt,
  easeIn: Rq,
  easeInOut: oE,
  easeOut: Mq,
  circIn: Yg,
  circInOut: B1,
  circOut: j1,
  backIn: Hg,
  backInOut: N1,
  backOut: q1,
  anticipate: L1
}, rv = (t) => {
  if (Array.isArray(t)) {
    ls(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, n, r, s] = t;
    return gl(e, n, r, s);
  } else if (typeof t == "string")
    return ls(nv[t] !== void 0, `Invalid easing type '${t}'`), nv[t];
  return t;
}, Iq = (t, e) => (n) => e(t(n)), ss = (...t) => t.reduce(Iq), Ho = (t, e, n) => {
  const r = e - t;
  return r === 0 ? 1 : (n - t) / r;
}, vt = (t, e, n) => t + (e - t) * n;
function jh(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function Dq({ hue: t, saturation: e, lightness: n, alpha: r }) {
  t /= 360, e /= 100, n /= 100;
  let s = 0, i = 0, o = 0;
  if (!e)
    s = i = o = n;
  else {
    const a = n < 0.5 ? n * (1 + e) : n + e - n * e, c = 2 * n - a;
    s = jh(c, a, t + 1 / 3), i = jh(c, a, t), o = jh(c, a, t - 1 / 3);
  }
  return {
    red: Math.round(s * 255),
    green: Math.round(i * 255),
    blue: Math.round(o * 255),
    alpha: r
  };
}
function yd(t, e) {
  return (n) => n > 0 ? e : t;
}
const Bh = (t, e, n) => {
  const r = t * t, s = n * (e * e - r) + r;
  return s < 0 ? 0 : Math.sqrt(s);
}, Oq = [Xp, Ti, Eo], qq = (t) => Oq.find((e) => e.test(t));
function sv(t) {
  const e = qq(t);
  if (xa(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let n = e.parse(t);
  return e === Eo && (n = Dq(n)), n;
}
const iv = (t, e) => {
  const n = sv(t), r = sv(e);
  if (!n || !r)
    return yd(t, e);
  const s = { ...n };
  return (i) => (s.red = Bh(n.red, r.red, i), s.green = Bh(n.green, r.green, i), s.blue = Bh(n.blue, r.blue, i), s.alpha = vt(n.alpha, r.alpha, i), Ti.transform(s));
}, tm = /* @__PURE__ */ new Set(["none", "hidden"]);
function Nq(t, e) {
  return tm.has(t) ? (n) => n <= 0 ? t : e : (n) => n >= 1 ? e : t;
}
function Lq(t, e) {
  return (n) => vt(t, e, n);
}
function ey(t) {
  return typeof t == "number" ? Lq : typeof t == "string" ? Gg(t) ? yd : sn.test(t) ? iv : Fq : Array.isArray(t) ? aE : typeof t == "object" ? sn.test(t) ? iv : jq : yd;
}
function aE(t, e) {
  const n = [...t], r = n.length, s = t.map((i, o) => ey(i)(i, e[o]));
  return (i) => {
    for (let o = 0; o < r; o++)
      n[o] = s[o](i);
    return n;
  };
}
function jq(t, e) {
  const n = { ...t, ...e }, r = {};
  for (const s in n)
    t[s] !== void 0 && e[s] !== void 0 && (r[s] = ey(t[s])(t[s], e[s]));
  return (s) => {
    for (const i in r)
      n[i] = r[i](s);
    return n;
  };
}
function Bq(t, e) {
  var n;
  const r = [], s = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < e.values.length; i++) {
    const o = e.types[i], a = t.indexes[o][s[o]], c = (n = t.values[a]) !== null && n !== void 0 ? n : 0;
    r[i] = c, s[o]++;
  }
  return r;
}
const Fq = (t, e) => {
  const n = Ks.createTransformer(e), r = Dc(t), s = Dc(e);
  return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? tm.has(t) && !s.values.length || tm.has(e) && !r.values.length ? Nq(t, e) : ss(aE(Bq(r, s), s.values), n) : (xa(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), yd(t, e));
};
function cE(t, e, n) {
  return typeof t == "number" && typeof e == "number" && typeof n == "number" ? vt(t, e, n) : ey(t)(t, e);
}
function Vq(t, e, n) {
  const r = [], s = n || cE, i = t.length - 1;
  for (let o = 0; o < i; o++) {
    let a = s(t[o], t[o + 1]);
    if (e) {
      const c = Array.isArray(e) ? e[o] || Qt : e;
      a = ss(c, a);
    }
    r.push(a);
  }
  return r;
}
function Uq(t, e, { clamp: n = !0, ease: r, mixer: s } = {}) {
  const i = t.length;
  if (ls(i === e.length, "Both input and output ranges must be the same length"), i === 1)
    return () => e[0];
  if (i === 2 && t[0] === t[1])
    return () => e[1];
  t[0] > t[i - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const o = Vq(e, r, s), a = o.length, c = (l) => {
    let u = 0;
    if (a > 1)
      for (; u < t.length - 2 && !(l < t[u + 1]); u++)
        ;
    const d = Ho(t[u], t[u + 1], l);
    return o[u](d);
  };
  return n ? (l) => c(Gs(t[0], t[i - 1], l)) : c;
}
function Wq(t, e) {
  const n = t[t.length - 1];
  for (let r = 1; r <= e; r++) {
    const s = Ho(0, e, r);
    t.push(vt(n, 1, s));
  }
}
function zq(t) {
  const e = [0];
  return Wq(e, t.length - 1), e;
}
function Hq(t, e) {
  return t.map((n) => n * e);
}
function Yq(t, e) {
  return t.map(() => e || oE).splice(0, t.length - 1);
}
function bd({ duration: t = 300, keyframes: e, times: n, ease: r = "easeInOut" }) {
  const s = Pq(r) ? r.map(rv) : rv(r), i = {
    done: !1,
    value: e[0]
  }, o = Hq(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === e.length ? n : zq(e),
    t
  ), a = Uq(o, e, {
    ease: Array.isArray(s) ? s : Yq(e, s)
  });
  return {
    calculatedDuration: t,
    next: (c) => (i.value = a(c), i.done = c >= t, i)
  };
}
const ov = 2e4;
function Gq(t) {
  let e = 0;
  const n = 50;
  let r = t.next(e);
  for (; !r.done && e < ov; )
    e += n, r = t.next(e);
  return e >= ov ? 1 / 0 : e;
}
const Kq = (t) => {
  const e = ({ timestamp: n }) => t(n);
  return {
    start: () => it.update(e, !0),
    stop: () => Ys(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Kt.isProcessing ? Kt.timestamp : Tr.now()
  };
}, $q = {
  decay: tv,
  inertia: tv,
  tween: bd,
  keyframes: bd,
  spring: iE
}, Zq = (t) => t / 100;
class ty extends nE {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: c } = this.options;
      c && c();
    };
    const { name: n, motionValue: r, element: s, keyframes: i } = this.options, o = (s == null ? void 0 : s.KeyframeResolver) || Kg, a = (c, l) => this.onKeyframesResolved(c, l);
    this.resolver = new o(i, a, n, r, s), this.resolver.scheduleResolve();
  }
  initPlayback(e) {
    const { type: n = "keyframes", repeat: r = 0, repeatDelay: s = 0, repeatType: i, velocity: o = 0 } = this.options, a = Jg(n) ? n : $q[n] || bd;
    let c, l;
    a !== bd && typeof e[0] != "number" && (ls(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), c = ss(Zq, cE(e[0], e[1])), e = [0, 100]);
    const u = a({ ...this.options, keyframes: e });
    i === "mirror" && (l = a({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -o
    })), u.calculatedDuration === null && (u.calculatedDuration = Gq(u));
    const { calculatedDuration: d } = u, f = d + s, h = f * (r + 1) - s;
    return {
      generator: u,
      mirroredGenerator: l,
      mapPercentToKeyframes: c,
      calculatedDuration: d,
      resolvedDuration: f,
      totalDuration: h
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, n = !1) {
    const { resolved: r } = this;
    if (!r) {
      const { keyframes: _ } = this.options;
      return { done: !0, value: _[_.length - 1] };
    }
    const { finalKeyframe: s, generator: i, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: c, calculatedDuration: l, totalDuration: u, resolvedDuration: d } = r;
    if (this.startTime === null)
      return i.next(0);
    const { delay: f, repeat: h, repeatType: p, repeatDelay: m, onUpdate: y } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - u / this.speed, this.startTime)), n ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const b = this.currentTime - f * (this.speed >= 0 ? 1 : -1), v = this.speed >= 0 ? b < 0 : b > u;
    this.currentTime = Math.max(b, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u);
    let w = this.currentTime, x = i;
    if (h) {
      const _ = Math.min(this.currentTime, u) / d;
      let T = Math.floor(_), k = _ % 1;
      !k && _ >= 1 && (k = 1), k === 1 && T--, T = Math.min(T, h + 1), !!(T % 2) && (p === "reverse" ? (k = 1 - k, m && (k -= m / d)) : p === "mirror" && (x = o)), w = Gs(0, 1, k) * d;
    }
    const A = v ? { done: !1, value: c[0] } : x.next(w);
    a && (A.value = a(A.value));
    let { done: C } = A;
    !v && l !== null && (C = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
    const S = this.holdTime === null && (this.state === "finished" || this.state === "running" && C);
    return S && s !== void 0 && (A.value = Af(c, this.options, s)), y && y(A.value), S && this.finish(), A;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? rs(e.calculatedDuration) : 0;
  }
  get time() {
    return rs(this.currentTime);
  }
  set time(e) {
    e = Cr(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const n = this.playbackSpeed !== e;
    this.playbackSpeed = e, n && (this.time = rs(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = Kq, onPlay: n, startTime: r } = this.options;
    this.driver || (this.driver = e((i) => this.tick(i))), n && n();
    const s = this.driver.now();
    this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = s) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const lE = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), uE = (t) => Array.isArray(t) && typeof t[0] == "number", Qq = 10, Xq = (t, e) => {
  let n = "";
  const r = Math.max(Math.round(e / Qq), 2);
  for (let s = 0; s < r; s++)
    n += t(Ho(0, r - 1, s)) + ", ";
  return `linear(${n.substring(0, n.length - 2)})`;
};
function ny(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const Jq = {
  linearEasing: void 0
};
function eN(t, e) {
  const n = ny(t);
  return () => {
    var r;
    return (r = Jq[e]) !== null && r !== void 0 ? r : n();
  };
}
const vd = /* @__PURE__ */ eN(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function dE(t) {
  return !!(typeof t == "function" && vd() || !t || typeof t == "string" && (t in nm || vd()) || uE(t) || Array.isArray(t) && t.every(dE));
}
const nc = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`, nm = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ nc([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ nc([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ nc([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ nc([0.33, 1.53, 0.69, 0.99])
};
function fE(t, e) {
  if (t)
    return typeof t == "function" && vd() ? Xq(t, e) : uE(t) ? nc(t) : Array.isArray(t) ? t.map((n) => fE(n, e) || nm.easeOut) : nm[t];
}
function tN(t, e, n, { delay: r = 0, duration: s = 300, repeat: i = 0, repeatType: o = "loop", ease: a, times: c } = {}) {
  const l = { [e]: n };
  c && (l.offset = c);
  const u = fE(a, s);
  return Array.isArray(u) && (l.easing = u), t.animate(l, {
    delay: r,
    duration: s,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: i + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
function av(t, e) {
  t.timeline = e, t.onfinish = null;
}
const nN = /* @__PURE__ */ ny(() => Object.hasOwnProperty.call(Element.prototype, "animate")), xd = 10, rN = 2e4;
function sN(t) {
  return Jg(t.type) || t.type === "spring" || !dE(t.ease);
}
function iN(t, e) {
  const n = new ty({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let r = { done: !1, value: t[0] };
  const s = [];
  let i = 0;
  for (; !r.done && i < rN; )
    r = n.sample(i), s.push(r.value), i += xd;
  return {
    times: void 0,
    keyframes: s,
    duration: i - xd,
    ease: "linear"
  };
}
const hE = {
  anticipate: L1,
  backInOut: N1,
  circInOut: B1
};
function oN(t) {
  return t in hE;
}
class cv extends nE {
  constructor(e) {
    super(e);
    const { name: n, motionValue: r, element: s, keyframes: i } = this.options;
    this.resolver = new tE(i, (o, a) => this.onKeyframesResolved(o, a), n, r, s), this.resolver.scheduleResolve();
  }
  initPlayback(e, n) {
    var r;
    let { duration: s = 300, times: i, ease: o, type: a, motionValue: c, name: l, startTime: u } = this.options;
    if (!(!((r = c.owner) === null || r === void 0) && r.current))
      return !1;
    if (typeof o == "string" && vd() && oN(o) && (o = hE[o]), sN(this.options)) {
      const { onComplete: f, onUpdate: h, motionValue: p, element: m, ...y } = this.options, b = iN(e, y);
      e = b.keyframes, e.length === 1 && (e[1] = e[0]), s = b.duration, i = b.times, o = b.ease, a = "keyframes";
    }
    const d = tN(c.owner.current, l, e, { ...this.options, duration: s, times: i, ease: o });
    return d.startTime = u ?? this.calcStartTime(), this.pendingTimeline ? (av(d, this.pendingTimeline), this.pendingTimeline = void 0) : d.onfinish = () => {
      const { onComplete: f } = this.options;
      c.set(Af(e, this.options, n)), f && f(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: d,
      duration: s,
      times: i,
      type: a,
      ease: o,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: n } = e;
    return rs(n);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: n } = e;
    return rs(n.currentTime || 0);
  }
  set time(e) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.currentTime = Cr(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: n } = e;
    return n.playbackRate;
  }
  set speed(e) {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: r } = n;
    r.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: n } = e;
    return n.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: n } = e;
    return n.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: n } = this;
      if (!n)
        return Qt;
      const { animation: r } = n;
      av(r, e);
    }
    return Qt;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n } = e;
    n.playState === "finished" && this.updateFinishedPromise(), n.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n } = e;
    n.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: n, keyframes: r, duration: s, type: i, ease: o, times: a } = e;
    if (n.playState === "idle" || n.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: l, onUpdate: u, onComplete: d, element: f, ...h } = this.options, p = new ty({
        ...h,
        keyframes: r,
        duration: s,
        type: i,
        ease: o,
        times: a,
        isGenerator: !0
      }), m = Cr(this.time);
      l.setWithVelocity(p.sample(m - xd).value, p.sample(m).value, xd);
    }
    const { onStop: c } = this.options;
    c && c(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: n, name: r, repeatDelay: s, repeatType: i, damping: o, type: a } = e;
    return nN() && r && lE.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !n.owner.getProps().onUpdate && !s && i !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const aN = ny(() => window.ScrollTimeline !== void 0);
class cN {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  then(e, n) {
    return Promise.all(this.animations).then(e).catch(n);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][e] = n;
  }
  attachTimeline(e, n) {
    const r = this.animations.map((s) => aN() && s.attachTimeline ? s.attachTimeline(e) : n(s));
    return () => {
      r.forEach((s, i) => {
        s && s(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let n = 0; n < this.animations.length; n++)
      e = Math.max(e, this.animations[n].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((n) => n[e]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function lN({ when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: s, repeat: i, repeatType: o, repeatDelay: a, from: c, elapsed: l, ...u }) {
  return !!Object.keys(u).length;
}
const ry = (t, e, n, r = {}, s, i) => (o) => {
  const a = zg(r, t) || {}, c = a.delay || r.delay || 0;
  let { elapsed: l = 0 } = r;
  l = l - Cr(c);
  let u = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -l,
    onUpdate: (f) => {
      e.set(f), a.onUpdate && a.onUpdate(f);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: i ? void 0 : s
  };
  lN(a) || (u = {
    ...u,
    ...kO(t, u)
  }), u.duration && (u.duration = Cr(u.duration)), u.repeatDelay && (u.repeatDelay = Cr(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from);
  let d = !1;
  if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0, u.delay === 0 && (d = !0)), d && !i && e.get() !== void 0) {
    const f = Af(u.keyframes, a);
    if (f !== void 0)
      return it.update(() => {
        u.onUpdate(f), u.onComplete();
      }), new cN([]);
  }
  return !i && cv.supports(u) ? new cv(u) : new ty(u);
}, uN = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), dN = (t) => $p(t) ? t[t.length - 1] || 0 : t;
function bl(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function sy(t, e) {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}
class iy {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return bl(this.subscriptions, e), () => sy(this.subscriptions, e);
  }
  notify(e, n, r) {
    const s = this.subscriptions.length;
    if (s)
      if (s === 1)
        this.subscriptions[0](e, n, r);
      else
        for (let i = 0; i < s; i++) {
          const o = this.subscriptions[i];
          o && o(e, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const lv = 30, fN = (t) => !isNaN(parseFloat(t));
class pE {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, n = {}) {
    this.version = "11.9.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, s = !0) => {
      const i = Tr.now();
      this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), s && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Tr.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = fN(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return Fg(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, n) {
    this.events[e] || (this.events[e] = new iy());
    const r = this.events[e].add(n);
    return e === "change" ? () => {
      r(), it.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, n) {
    this.passiveEffect = e, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, n = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Tr.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > lv)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, lv);
    return rE(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Oc(t, e) {
  return new pE(t, e);
}
function hN(t, e, n) {
  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Oc(n));
}
function pN(t, e) {
  const n = wf(t, e);
  let { transitionEnd: r = {}, transition: s = {}, ...i } = n || {};
  i = { ...i, ...r };
  for (const o in i) {
    const a = dN(i[o]);
    hN(t, o, a);
  }
}
const Sf = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), mN = "framerAppearId", mE = "data-" + Sf(mN);
function gE(t) {
  return t.props[mE];
}
function yE(t) {
  if (ci.has(t))
    return "transform";
  if (lE.has(t))
    return Sf(t);
}
class gN extends pE {
  constructor() {
    super(...arguments), this.values = [];
  }
  add(e) {
    const n = yE(e);
    n && (bl(this.values, n), this.update());
  }
  update() {
    this.set(this.values.length ? this.values.join(", ") : "auto");
  }
}
const on = (t) => !!(t && t.getVelocity);
function yN(t) {
  return !!(on(t) && t.add);
}
function rm(t, e) {
  var n;
  if (!t.applyWillChange)
    return;
  let r = t.getValue("willChange");
  if (!r && !(!((n = t.props.style) === null || n === void 0) && n.willChange) && (r = new gN("auto"), t.addValue("willChange", r)), yN(r))
    return r.add(e);
}
function bN({ protectedKeys: t, needsAnimating: e }, n) {
  const r = t.hasOwnProperty(n) && e[n] !== !0;
  return e[n] = !1, r;
}
function bE(t, e, { delay: n = 0, transitionOverride: r, type: s } = {}) {
  var i;
  let { transition: o = t.getDefaultTransition(), transitionEnd: a, ...c } = e;
  r && (o = r);
  const l = [], u = s && t.animationState && t.animationState.getState()[s];
  for (const d in c) {
    const f = t.getValue(d, (i = t.latestValues[d]) !== null && i !== void 0 ? i : null), h = c[d];
    if (h === void 0 || u && bN(u, d))
      continue;
    const p = {
      delay: n,
      ...zg(o || {}, d)
    };
    let m = !1;
    if (window.MotionHandoffAnimation) {
      const b = gE(t);
      if (b) {
        const v = window.MotionHandoffAnimation(b, d, it);
        v !== null && (p.startTime = v, m = !0);
      }
    }
    rm(t, d), f.start(ry(d, f, h, t.shouldReduceMotion && ci.has(d) ? { type: !1 } : p, t, m));
    const y = f.animation;
    y && l.push(y);
  }
  return a && Promise.all(l).then(() => {
    it.update(() => {
      a && pN(t, a);
    });
  }), l;
}
function sm(t, e, n = {}) {
  var r;
  const s = wf(t, e, n.type === "exit" ? (r = t.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
  let { transition: i = t.getDefaultTransition() || {} } = s || {};
  n.transitionOverride && (i = n.transitionOverride);
  const o = s ? () => Promise.all(bE(t, s, n)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (l = 0) => {
    const { delayChildren: u = 0, staggerChildren: d, staggerDirection: f } = i;
    return vN(t, e, u + l, d, f, n);
  } : () => Promise.resolve(), { when: c } = i;
  if (c) {
    const [l, u] = c === "beforeChildren" ? [o, a] : [a, o];
    return l().then(() => u());
  } else
    return Promise.all([o(), a(n.delay)]);
}
function vN(t, e, n = 0, r = 0, s = 1, i) {
  const o = [], a = (t.variantChildren.size - 1) * r, c = s === 1 ? (l = 0) => l * r : (l = 0) => a - l * r;
  return Array.from(t.variantChildren).sort(xN).forEach((l, u) => {
    l.notify("AnimationStart", e), o.push(sm(l, e, {
      ...i,
      delay: n + c(u)
    }).then(() => l.notify("AnimationComplete", e)));
  }), Promise.all(o);
}
function xN(t, e) {
  return t.sortNodePosition(e);
}
function wN(t, e, n = {}) {
  t.notify("AnimationStart", e);
  let r;
  if (Array.isArray(e)) {
    const s = e.map((i) => sm(t, i, n));
    r = Promise.all(s);
  } else if (typeof e == "string")
    r = sm(t, e, n);
  else {
    const s = typeof e == "function" ? wf(t, e, n.custom) : e;
    r = Promise.all(bE(t, s, n));
  }
  return r.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const AN = Wg.length;
function vE(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const n = t.parent ? vE(t.parent) || {} : {};
    return t.props.initial !== void 0 && (n.initial = t.props.initial), n;
  }
  const e = {};
  for (let n = 0; n < AN; n++) {
    const r = Wg[n], s = t.props[r];
    (Pc(s) || s === !1) && (e[r] = s);
  }
  return e;
}
const SN = [...Ug].reverse(), EN = Ug.length;
function CN(t) {
  return (e) => Promise.all(e.map(({ animation: n, options: r }) => wN(t, n, r)));
}
function _N(t) {
  let e = CN(t), n = uv(), r = !0;
  const s = (c) => (l, u) => {
    var d;
    const f = wf(t, u, c === "exit" ? (d = t.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0);
    if (f) {
      const { transition: h, transitionEnd: p, ...m } = f;
      l = { ...l, ...m, ...p };
    }
    return l;
  };
  function i(c) {
    e = c(t);
  }
  function o(c) {
    const { props: l } = t, u = vE(t.parent) || {}, d = [], f = /* @__PURE__ */ new Set();
    let h = {}, p = 1 / 0;
    for (let y = 0; y < EN; y++) {
      const b = SN[y], v = n[b], w = l[b] !== void 0 ? l[b] : u[b], x = Pc(w), A = b === c ? v.isActive : null;
      A === !1 && (p = y);
      let C = w === u[b] && w !== l[b] && x;
      if (C && r && t.manuallyAnimateOnMount && (C = !1), v.protectedKeys = { ...h }, // If it isn't active and hasn't *just* been set as inactive
      !v.isActive && A === null || // If we didn't and don't have any defined prop for this animation type
      !w && !v.prevProp || // Or if the prop doesn't define an animation
      Mc(w) || typeof w == "boolean")
        continue;
      const S = TN(v.prevProp, w);
      let _ = S || // If we're making this variant active, we want to always make it active
      b === c && v.isActive && !C && x || // If we removed a higher-priority variant (i is in reverse order)
      y > p && x, T = !1;
      const k = Array.isArray(w) ? w : [w];
      let R = k.reduce(s(b), {});
      A === !1 && (R = {});
      const { prevResolvedValues: P = {} } = v, M = {
        ...P,
        ...R
      }, D = (L) => {
        _ = !0, f.has(L) && (T = !0, f.delete(L)), v.needsAnimating[L] = !0;
        const N = t.getValue(L);
        N && (N.liveStyle = !1);
      };
      for (const L in M) {
        const N = R[L], j = P[L];
        if (h.hasOwnProperty(L))
          continue;
        let V = !1;
        $p(N) && $p(j) ? V = !M1(N, j) : V = N !== j, V ? N != null ? D(L) : f.add(L) : N !== void 0 && f.has(L) ? D(L) : v.protectedKeys[L] = !0;
      }
      v.prevProp = w, v.prevResolvedValues = R, v.isActive && (h = { ...h, ...R }), r && t.blockInitialAnimation && (_ = !1), _ && (!(C && S) || T) && d.push(...k.map((L) => ({
        animation: L,
        options: { type: b }
      })));
    }
    if (f.size) {
      const y = {};
      f.forEach((b) => {
        const v = t.getBaseTarget(b), w = t.getValue(b);
        w && (w.liveStyle = !0), y[b] = v ?? null;
      }), d.push({ animation: y });
    }
    let m = !!d.length;
    return r && (l.initial === !1 || l.initial === l.animate) && !t.manuallyAnimateOnMount && (m = !1), r = !1, m ? e(d) : Promise.resolve();
  }
  function a(c, l) {
    var u;
    if (n[c].isActive === l)
      return Promise.resolve();
    (u = t.variantChildren) === null || u === void 0 || u.forEach((f) => {
      var h;
      return (h = f.animationState) === null || h === void 0 ? void 0 : h.setActive(c, l);
    }), n[c].isActive = l;
    const d = o(c);
    for (const f in n)
      n[f].protectedKeys = {};
    return d;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: i,
    getState: () => n,
    reset: () => {
      n = uv(), r = !0;
    }
  };
}
function TN(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !M1(e, t) : !1;
}
function gi(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function uv() {
  return {
    animate: gi(!0),
    whileInView: gi(),
    whileHover: gi(),
    whileTap: gi(),
    whileDrag: gi(),
    whileFocus: gi(),
    exit: gi()
  };
}
class li {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class kN extends li {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = _N(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    Mc(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    e !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let RN = 0;
class MN extends li {
  constructor() {
    super(...arguments), this.id = RN++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r)
      return;
    const s = this.node.animationState.setActive("exit", !e);
    n && !e && s.then(() => n(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const PN = {
  animation: {
    Feature: kN
  },
  exit: {
    Feature: MN
  }
}, xE = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function Ef(t, e = "page") {
  return {
    point: {
      x: t[`${e}X`],
      y: t[`${e}Y`]
    }
  };
}
const IN = (t) => (e) => xE(e) && t(e, Ef(e));
function Xr(t, e, n, r = { passive: !0 }) {
  return t.addEventListener(e, n, r), () => t.removeEventListener(e, n);
}
function is(t, e, n, r) {
  return Xr(t, e, IN(n), r);
}
const dv = (t, e) => Math.abs(t - e);
function DN(t, e) {
  const n = dv(t.x, e.x), r = dv(t.y, e.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class wE {
  constructor(e, n, { transformPagePoint: r, contextWindow: s, dragSnapToOrigin: i = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const d = Vh(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, h = DN(d.offset, { x: 0, y: 0 }) >= 3;
      if (!f && !h)
        return;
      const { point: p } = d, { timestamp: m } = Kt;
      this.history.push({ ...p, timestamp: m });
      const { onStart: y, onMove: b } = this.handlers;
      f || (y && y(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), b && b(this.lastMoveEvent, d);
    }, this.handlePointerMove = (d, f) => {
      this.lastMoveEvent = d, this.lastMoveEventInfo = Fh(f, this.transformPagePoint), it.update(this.updatePoint, !0);
    }, this.handlePointerUp = (d, f) => {
      this.end();
      const { onEnd: h, onSessionEnd: p, resumeAnimation: m } = this.handlers;
      if (this.dragSnapToOrigin && m && m(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const y = Vh(d.type === "pointercancel" ? this.lastMoveEventInfo : Fh(f, this.transformPagePoint), this.history);
      this.startEvent && h && h(d, y), p && p(d, y);
    }, !xE(e))
      return;
    this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.contextWindow = s || window;
    const o = Ef(e), a = Fh(o, this.transformPagePoint), { point: c } = a, { timestamp: l } = Kt;
    this.history = [{ ...c, timestamp: l }];
    const { onSessionStart: u } = n;
    u && u(e, Vh(a, this.history)), this.removeListeners = ss(is(this.contextWindow, "pointermove", this.handlePointerMove), is(this.contextWindow, "pointerup", this.handlePointerUp), is(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Ys(this.updatePoint);
  }
}
function Fh(t, e) {
  return e ? { point: e(t.point) } : t;
}
function fv(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Vh({ point: t }, e) {
  return {
    point: t,
    delta: fv(t, AE(e)),
    offset: fv(t, ON(e)),
    velocity: qN(e, 0.1)
  };
}
function ON(t) {
  return t[0];
}
function AE(t) {
  return t[t.length - 1];
}
function qN(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let n = t.length - 1, r = null;
  const s = AE(t);
  for (; n >= 0 && (r = t[n], !(s.timestamp - r.timestamp > Cr(e))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const i = rs(s.timestamp - r.timestamp);
  if (i === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (s.x - r.x) / i,
    y: (s.y - r.y) / i
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function SE(t) {
  let e = null;
  return () => {
    const n = () => {
      e = null;
    };
    return e === null ? (e = t, n) : !1;
  };
}
const hv = SE("dragHorizontal"), pv = SE("dragVertical");
function EE(t) {
  let e = !1;
  if (t === "y")
    e = pv();
  else if (t === "x")
    e = hv();
  else {
    const n = hv(), r = pv();
    n && r ? e = () => {
      n(), r();
    } : (n && n(), r && r());
  }
  return e;
}
function CE() {
  const t = EE(!0);
  return t ? (t(), !1) : !0;
}
function Co(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
const _E = 1e-4, NN = 1 - _E, LN = 1 + _E, TE = 0.01, jN = 0 - TE, BN = 0 + TE;
function Hn(t) {
  return t.max - t.min;
}
function FN(t, e, n) {
  return Math.abs(t - e) <= n;
}
function mv(t, e, n, r = 0.5) {
  t.origin = r, t.originPoint = vt(e.min, e.max, t.origin), t.scale = Hn(n) / Hn(e), t.translate = vt(n.min, n.max, t.origin) - t.originPoint, (t.scale >= NN && t.scale <= LN || isNaN(t.scale)) && (t.scale = 1), (t.translate >= jN && t.translate <= BN || isNaN(t.translate)) && (t.translate = 0);
}
function pc(t, e, n, r) {
  mv(t.x, e.x, n.x, r ? r.originX : void 0), mv(t.y, e.y, n.y, r ? r.originY : void 0);
}
function gv(t, e, n) {
  t.min = n.min + e.min, t.max = t.min + Hn(e);
}
function VN(t, e, n) {
  gv(t.x, e.x, n.x), gv(t.y, e.y, n.y);
}
function yv(t, e, n) {
  t.min = e.min - n.min, t.max = t.min + Hn(e);
}
function mc(t, e, n) {
  yv(t.x, e.x, n.x), yv(t.y, e.y, n.y);
}
function UN(t, { min: e, max: n }, r) {
  return e !== void 0 && t < e ? t = r ? vt(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? vt(n, t, r.max) : Math.min(t, n)), t;
}
function bv(t, e, n) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
  };
}
function WN(t, { top: e, left: n, bottom: r, right: s }) {
  return {
    x: bv(t.x, n, s),
    y: bv(t.y, e, r)
  };
}
function vv(t, e) {
  let n = e.min - t.min, r = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r };
}
function zN(t, e) {
  return {
    x: vv(t.x, e.x),
    y: vv(t.y, e.y)
  };
}
function HN(t, e) {
  let n = 0.5;
  const r = Hn(t), s = Hn(e);
  return s > r ? n = Ho(e.min, e.max - r, t.min) : r > s && (n = Ho(t.min, t.max - s, e.min)), Gs(0, 1, n);
}
function YN(t, e) {
  const n = {};
  return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
}
const im = 0.35;
function GN(t = im) {
  return t === !1 ? t = 0 : t === !0 && (t = im), {
    x: xv(t, "left", "right"),
    y: xv(t, "top", "bottom")
  };
}
function xv(t, e, n) {
  return {
    min: wv(t, e),
    max: wv(t, n)
  };
}
function wv(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const Av = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), _o = () => ({
  x: Av(),
  y: Av()
}), Sv = () => ({ min: 0, max: 0 }), Pt = () => ({
  x: Sv(),
  y: Sv()
});
function Zn(t) {
  return [t("x"), t("y")];
}
function kE({ top: t, left: e, right: n, bottom: r }) {
  return {
    x: { min: e, max: n },
    y: { min: t, max: r }
  };
}
function KN({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function $N(t, e) {
  if (!e)
    return t;
  const n = e({ x: t.left, y: t.top }), r = e({ x: t.right, y: t.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function Uh(t) {
  return t === void 0 || t === 1;
}
function om({ scale: t, scaleX: e, scaleY: n }) {
  return !Uh(t) || !Uh(e) || !Uh(n);
}
function Ai(t) {
  return om(t) || RE(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function RE(t) {
  return Ev(t.x) || Ev(t.y);
}
function Ev(t) {
  return t && t !== "0%";
}
function wd(t, e, n) {
  const r = t - n, s = e * r;
  return n + s;
}
function Cv(t, e, n, r, s) {
  return s !== void 0 && (t = wd(t, s, r)), wd(t, n, r) + e;
}
function am(t, e = 0, n = 1, r, s) {
  t.min = Cv(t.min, e, n, r, s), t.max = Cv(t.max, e, n, r, s);
}
function ME(t, { x: e, y: n }) {
  am(t.x, e.translate, e.scale, e.originPoint), am(t.y, n.translate, n.scale, n.originPoint);
}
const _v = 0.999999999999, Tv = 1.0000000000001;
function ZN(t, e, n, r = !1) {
  const s = n.length;
  if (!s)
    return;
  e.x = e.y = 1;
  let i, o;
  for (let a = 0; a < s; a++) {
    i = n[a], o = i.projectionDelta;
    const { visualElement: c } = i.options;
    c && c.props.style && c.props.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && ko(t, {
      x: -i.scroll.offset.x,
      y: -i.scroll.offset.y
    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, ME(t, o)), r && Ai(i.latestValues) && ko(t, i.latestValues));
  }
  e.x < Tv && e.x > _v && (e.x = 1), e.y < Tv && e.y > _v && (e.y = 1);
}
function To(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function kv(t, e, n, r, s = 0.5) {
  const i = vt(t.min, t.max, s);
  am(t, e, n, i, r);
}
function ko(t, e) {
  kv(t.x, e.x, e.scaleX, e.scale, e.originX), kv(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function PE(t, e) {
  return kE($N(t.getBoundingClientRect(), e));
}
function QN(t, e, n) {
  const r = PE(t, n), { scroll: s } = e;
  return s && (To(r.x, s.offset.x), To(r.y, s.offset.y)), r;
}
const IE = ({ current: t }) => t ? t.ownerDocument.defaultView : null, XN = /* @__PURE__ */ new WeakMap();
class JN {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Pt(), this.visualElement = e;
  }
  start(e, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const s = (u) => {
      const { dragSnapToOrigin: d } = this.getProps();
      d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Ef(u, "page").point);
    }, i = (u, d) => {
      const { drag: f, dragPropagation: h, onDragStart: p } = this.getProps();
      if (f && !h && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = EE(f), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Zn((y) => {
        let b = this.getAxisMotionValue(y).get() || 0;
        if (_r.test(b)) {
          const { projection: v } = this.visualElement;
          if (v && v.layout) {
            const w = v.layout.layoutBox[y];
            w && (b = Hn(w) * (parseFloat(b) / 100));
          }
        }
        this.originPoint[y] = b;
      }), p && it.postRender(() => p(u, d)), rm(this.visualElement, "transform");
      const { animationState: m } = this.visualElement;
      m && m.setActive("whileDrag", !0);
    }, o = (u, d) => {
      const { dragPropagation: f, dragDirectionLock: h, onDirectionLock: p, onDrag: m } = this.getProps();
      if (!f && !this.openGlobalLock)
        return;
      const { offset: y } = d;
      if (h && this.currentDirection === null) {
        this.currentDirection = eL(y), this.currentDirection !== null && p && p(this.currentDirection);
        return;
      }
      this.updateAxis("x", d.point, y), this.updateAxis("y", d.point, y), this.visualElement.render(), m && m(u, d);
    }, a = (u, d) => this.stop(u, d), c = () => Zn((u) => {
      var d;
      return this.getAnimationState(u) === "paused" && ((d = this.getAxisMotionValue(u).animation) === null || d === void 0 ? void 0 : d.play());
    }), { dragSnapToOrigin: l } = this.getProps();
    this.panSession = new wE(e, {
      onSessionStart: s,
      onStart: i,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: c
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: l,
      contextWindow: IE(this.visualElement)
    });
  }
  stop(e, n) {
    const r = this.isDragging;
    if (this.cancel(), !r)
      return;
    const { velocity: s } = n;
    this.startAnimation(s);
    const { onDragEnd: i } = this.getProps();
    i && it.postRender(() => i(e, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: n } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(e, n, r) {
    const { drag: s } = this.getProps();
    if (!r || !Wl(e, s, this.currentDirection))
      return;
    const i = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + r[e];
    this.constraints && this.constraints[e] && (o = UN(o, this.constraints[e], this.elastic[e])), i.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: n, dragElastic: r } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, i = this.constraints;
    n && Co(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && s ? this.constraints = WN(s.layoutBox, n) : this.constraints = !1, this.elastic = GN(r), i !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && Zn((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = YN(s.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps();
    if (!e || !Co(e))
      return !1;
    const r = e.current;
    ls(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: s } = this.visualElement;
    if (!s || !s.layout)
      return !1;
    const i = QN(r, s.root, this.visualElement.getTransformPagePoint());
    let o = zN(s.layout.layoutBox, i);
    if (n) {
      const a = n(KN(o));
      this.hasMutatedConstraints = !!a, a && (o = kE(a));
    }
    return o;
  }
  startAnimation(e) {
    const { drag: n, dragMomentum: r, dragElastic: s, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), c = this.constraints || {}, l = Zn((u) => {
      if (!Wl(u, n, this.currentDirection))
        return;
      let d = c && c[u] || {};
      o && (d = { min: 0, max: 0 });
      const f = s ? 200 : 1e6, h = s ? 40 : 1e7, p = {
        type: "inertia",
        velocity: r ? e[u] : 0,
        bounceStiffness: f,
        bounceDamping: h,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...i,
        ...d
      };
      return this.startAxisValueAnimation(u, p);
    });
    return Promise.all(l).then(a);
  }
  startAxisValueAnimation(e, n) {
    const r = this.getAxisMotionValue(e);
    return rm(this.visualElement, e), r.start(ry(e, r, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    Zn((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Zn((e) => {
      var n;
      return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(e) {
    var n;
    return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const n = `_drag${e.toUpperCase()}`, r = this.visualElement.getProps(), s = r[n];
    return s || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    Zn((n) => {
      const { drag: r } = this.getProps();
      if (!Wl(n, r, this.currentDirection))
        return;
      const { projection: s } = this.visualElement, i = this.getAxisMotionValue(n);
      if (s && s.layout) {
        const { min: o, max: a } = s.layout.layoutBox[n];
        i.set(e[n] - vt(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!Co(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const s = { x: 0, y: 0 };
    Zn((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const c = a.get();
        s[o] = HN({ min: c, max: c }, this.constraints[o]);
      }
    });
    const { transformTemplate: i } = this.visualElement.getProps();
    this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Zn((o) => {
      if (!Wl(o, e, null))
        return;
      const a = this.getAxisMotionValue(o), { min: c, max: l } = this.constraints[o];
      a.set(vt(c, l, s[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    XN.set(this.visualElement, this);
    const e = this.visualElement.current, n = is(e, "pointerdown", (c) => {
      const { drag: l, dragListener: u = !0 } = this.getProps();
      l && u && this.start(c);
    }), r = () => {
      const { dragConstraints: c } = this.getProps();
      Co(c) && c.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: s } = this.visualElement, i = s.addEventListener("measure", r);
    s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), it.read(r);
    const o = Xr(window, "resize", () => this.scalePositionWithinConstraints()), a = s.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: l }) => {
      this.isDragging && l && (Zn((u) => {
        const d = this.getAxisMotionValue(u);
        d && (this.originPoint[u] += c[u].translate, d.set(d.get() + c[u].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), n(), i(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: s = !1, dragConstraints: i = !1, dragElastic: o = im, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: s,
      dragConstraints: i,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function Wl(t, e, n) {
  return (e === !0 || e === t) && (n === null || n === t);
}
function eL(t, e = 10) {
  let n = null;
  return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
}
class tL extends li {
  constructor(e) {
    super(e), this.removeGroupControls = Qt, this.removeListeners = Qt, this.controls = new JN(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Qt;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const Rv = (t) => (e, n) => {
  t && it.postRender(() => t(e, n));
};
class nL extends li {
  constructor() {
    super(...arguments), this.removePointerDownListener = Qt;
  }
  onPointerDown(e) {
    this.session = new wE(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: IE(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: s } = this.node.getProps();
    return {
      onSessionStart: Rv(e),
      onStart: Rv(n),
      onMove: r,
      onEnd: (i, o) => {
        delete this.session, s && it.postRender(() => s(i, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = is(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Cf = oi(null);
function rL() {
  const t = Ht(Cf);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: n, register: r } = t, s = Pg();
  _e(() => r(s), []);
  const i = Je(() => n && n(s), [s, n]);
  return !e && n ? [!1, i] : [!0];
}
const oy = oi({}), DE = oi({}), Lu = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function Mv(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const Ha = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (se.test(t))
        t = parseFloat(t);
      else
        return t;
    const n = Mv(t, e.target.x), r = Mv(t, e.target.y);
    return `${n}% ${r}%`;
  }
}, sL = {
  correct: (t, { treeScale: e, projectionDelta: n }) => {
    const r = t, s = Ks.parse(t);
    if (s.length > 5)
      return r;
    const i = Ks.createTransformer(t), o = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * e.x, c = n.y.scale * e.y;
    s[0 + o] /= a, s[1 + o] /= c;
    const l = vt(a, c, 0.5);
    return typeof s[2 + o] == "number" && (s[2 + o] /= l), typeof s[3 + o] == "number" && (s[3 + o] /= l), i(s);
  }
}, Ad = {};
function iL(t) {
  Object.assign(Ad, t);
}
const { schedule: ay, cancel: pte } = P1(queueMicrotask, !1);
class oL extends s2 {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: s } = this.props, { projection: i } = e;
    iL(aL), i && (n.group && n.group.add(i), r && r.register && s && r.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), i.setOptions({
      ...i.options,
      onExitComplete: () => this.safeToRemove()
    })), Lu.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: n, visualElement: r, drag: s, isPresent: i } = this.props, o = r.projection;
    return o && (o.isPresent = i, s || e.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? o.promote() : o.relegate() || it.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), ay.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: s } = e;
    s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function OE(t) {
  const [e, n] = rL(), r = Ht(oy);
  return g.jsx(oL, { ...t, layoutGroup: r, switchLayoutGroup: Ht(DE), isPresent: e, safeToRemove: n });
}
const aL = {
  borderRadius: {
    ...Ha,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Ha,
  borderTopRightRadius: Ha,
  borderBottomLeftRadius: Ha,
  borderBottomRightRadius: Ha,
  boxShadow: sL
}, qE = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], cL = qE.length, Pv = (t) => typeof t == "string" ? parseFloat(t) : t, Iv = (t) => typeof t == "number" || se.test(t);
function lL(t, e, n, r, s, i) {
  s ? (t.opacity = vt(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    uL(r)
  ), t.opacityExit = vt(e.opacity !== void 0 ? e.opacity : 1, 0, dL(r))) : i && (t.opacity = vt(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
  for (let o = 0; o < cL; o++) {
    const a = `border${qE[o]}Radius`;
    let c = Dv(e, a), l = Dv(n, a);
    if (c === void 0 && l === void 0)
      continue;
    c || (c = 0), l || (l = 0), c === 0 || l === 0 || Iv(c) === Iv(l) ? (t[a] = Math.max(vt(Pv(c), Pv(l), r), 0), (_r.test(l) || _r.test(c)) && (t[a] += "%")) : t[a] = l;
  }
  (e.rotate || n.rotate) && (t.rotate = vt(e.rotate || 0, n.rotate || 0, r));
}
function Dv(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const uL = /* @__PURE__ */ NE(0, 0.5, j1), dL = /* @__PURE__ */ NE(0.5, 0.95, Qt);
function NE(t, e, n) {
  return (r) => r < t ? 0 : r > e ? 1 : n(Ho(t, e, r));
}
function Ov(t, e) {
  t.min = e.min, t.max = e.max;
}
function Kn(t, e) {
  Ov(t.x, e.x), Ov(t.y, e.y);
}
function qv(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function Nv(t, e, n, r, s) {
  return t -= e, t = wd(t, 1 / n, r), s !== void 0 && (t = wd(t, 1 / s, r)), t;
}
function fL(t, e = 0, n = 1, r = 0.5, s, i = t, o = t) {
  if (_r.test(e) && (e = parseFloat(e), e = vt(o.min, o.max, e / 100) - o.min), typeof e != "number")
    return;
  let a = vt(i.min, i.max, r);
  t === i && (a -= e), t.min = Nv(t.min, e, n, a, s), t.max = Nv(t.max, e, n, a, s);
}
function Lv(t, e, [n, r, s], i, o) {
  fL(t, e[n], e[r], e[s], e.scale, i, o);
}
const hL = ["x", "scaleX", "originX"], pL = ["y", "scaleY", "originY"];
function jv(t, e, n, r) {
  Lv(t.x, e, hL, n ? n.x : void 0, r ? r.x : void 0), Lv(t.y, e, pL, n ? n.y : void 0, r ? r.y : void 0);
}
function Bv(t) {
  return t.translate === 0 && t.scale === 1;
}
function LE(t) {
  return Bv(t.x) && Bv(t.y);
}
function Fv(t, e) {
  return t.min === e.min && t.max === e.max;
}
function mL(t, e) {
  return Fv(t.x, e.x) && Fv(t.y, e.y);
}
function Vv(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function jE(t, e) {
  return Vv(t.x, e.x) && Vv(t.y, e.y);
}
function Uv(t) {
  return Hn(t.x) / Hn(t.y);
}
function Wv(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class gL {
  constructor() {
    this.members = [];
  }
  add(e) {
    bl(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (sy(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(e) {
    const n = this.members.findIndex((s) => e === s);
    if (n === 0)
      return !1;
    let r;
    for (let s = n; s >= 0; s--) {
      const i = this.members[s];
      if (i.isPresent !== !1) {
        r = i;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(e, n) {
    const r = this.lead;
    if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) {
      r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: s } = e.options;
      s === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: n, resumingFrom: r } = e;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function yL(t, e, n) {
  let r = "";
  const s = t.x.translate / e.x, i = t.y.translate / e.y, o = (n == null ? void 0 : n.z) || 0;
  if ((s || i || o) && (r = `translate3d(${s}px, ${i}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), n) {
    const { transformPerspective: l, rotate: u, rotateX: d, rotateY: f, skewX: h, skewY: p } = n;
    l && (r = `perspective(${l}px) ${r}`), u && (r += `rotate(${u}deg) `), d && (r += `rotateX(${d}deg) `), f && (r += `rotateY(${f}deg) `), h && (r += `skewX(${h}deg) `), p && (r += `skewY(${p}deg) `);
  }
  const a = t.x.scale * e.x, c = t.y.scale * e.y;
  return (a !== 1 || c !== 1) && (r += `scale(${a}, ${c})`), r || "none";
}
const bL = (t, e) => t.depth - e.depth;
class vL {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    bl(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    sy(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(bL), this.isDirty = !1, this.children.forEach(e);
  }
}
function ju(t) {
  const e = on(t) ? t.get() : t;
  return uN(e) ? e.toValue() : e;
}
function xL(t, e) {
  const n = Tr.now(), r = ({ timestamp: s }) => {
    const i = s - n;
    i >= e && (Ys(r), t(i - e));
  };
  return it.read(r, !0), () => Ys(r);
}
function wL(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function AL(t, e, n) {
  const r = on(t) ? t : Oc(t);
  return r.start(ry("", r, e, n)), r.animation;
}
const Si = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, rc = typeof window < "u" && window.MotionDebug !== void 0, Wh = ["", "X", "Y", "Z"], SL = { visibility: "hidden" }, zv = 1e3;
let EL = 0;
function zh(t, e, n, r) {
  const { latestValues: s } = e;
  s[t] && (n[t] = s[t], e.setStaticValue(t, 0), r && (r[t] = 0));
}
function BE(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const n = gE(e);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: s, layoutId: i } = t.options;
    window.MotionCancelOptimisedAnimation(n, "transform", it, !(s || i));
  }
  const { parent: r } = t;
  r && !r.hasCheckedOptimisedAppear && BE(r);
}
function FE({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: s }) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      this.id = EL++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, rc && (Si.totalNodes = Si.resolvedTargetDeltas = Si.recalculatedProjection = 0), this.nodes.forEach(TL), this.nodes.forEach(IL), this.nodes.forEach(DL), this.nodes.forEach(kL), rc && window.MotionDebug.record(Si);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new vL());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new iy()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const c = this.eventHandlers.get(o);
      c && c.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = wL(o), this.instance = o;
      const { layoutId: c, layout: l, visualElement: u } = this.options;
      if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (l || c) && (this.isLayoutDirty = !0), t) {
        let d;
        const f = () => this.root.updateBlockedByResize = !1;
        t(o, () => {
          this.root.updateBlockedByResize = !0, d && d(), d = xL(f, 250), Lu.hasAnimatedSinceResize && (Lu.hasAnimatedSinceResize = !1, this.nodes.forEach(Yv));
        });
      }
      c && this.root.registerSharedNode(c, this), this.options.animate !== !1 && u && (c || l) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: h, layout: p }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const m = this.options.transition || u.getDefaultTransition() || jL, { onLayoutAnimationStart: y, onLayoutAnimationComplete: b } = u.getProps(), v = !this.targetLayout || !jE(this.targetLayout, p) || h, w = !f && h;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || w || f && (v || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, w);
          const x = {
            ...zg(m, "layout"),
            onPlay: y,
            onComplete: b
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0, x.type = !1), this.startAnimation(x);
        } else
          f || Yv(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = p;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Ys(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(OL), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && BE(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const d = this.path[u];
        d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: c } = this.options;
      if (a === void 0 && !c)
        return;
      const l = this.getTransformTemplate();
      this.prevTransformTemplateValue = l ? l(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Hv);
        return;
      }
      this.isUpdating || this.nodes.forEach(ML), this.isUpdating = !1, this.nodes.forEach(PL), this.nodes.forEach(CL), this.nodes.forEach(_L), this.clearAllSnapshots();
      const a = Tr.now();
      Kt.delta = Gs(0, 1e3 / 60, a - Kt.timestamp), Kt.timestamp = a, Kt.isProcessing = !0, qh.update.process(Kt), qh.preRender.process(Kt), qh.render.process(Kt), Kt.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, ay.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(RL), this.sharedNodes.forEach(qL);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, it.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      it.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Pt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const c = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: c,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : c
        };
      }
    }
    resetTransform() {
      if (!s)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !LE(this.projectionDelta), c = this.getTransformTemplate(), l = c ? c(this.latestValues, "") : void 0, u = l !== this.prevTransformTemplateValue;
      o && (a || Ai(this.latestValues) || u) && (s(this.instance, l), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let c = this.removeElementScroll(a);
      return o && (c = this.removeTransform(c)), BL(c), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return Pt();
      const c = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(FL))) {
        const { scroll: u } = this.root;
        u && (To(c.x, u.offset.x), To(c.y, u.offset.y));
      }
      return c;
    }
    removeElementScroll(o) {
      var a;
      const c = Pt();
      if (Kn(c, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return c;
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l], { scroll: d, options: f } = u;
        u !== this.root && d && f.layoutScroll && (d.wasRoot && Kn(c, o), To(c.x, d.offset.x), To(c.y, d.offset.y));
      }
      return c;
    }
    applyTransform(o, a = !1) {
      const c = Pt();
      Kn(c, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && ko(c, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), Ai(u.latestValues) && ko(c, u.latestValues);
      }
      return Ai(this.latestValues) && ko(c, this.latestValues), c;
    }
    removeTransform(o) {
      const a = Pt();
      Kn(a, o);
      for (let c = 0; c < this.path.length; c++) {
        const l = this.path[c];
        if (!l.instance || !Ai(l.latestValues))
          continue;
        om(l.latestValues) && l.updateSnapshot();
        const u = Pt(), d = l.measurePageBox();
        Kn(u, d), jv(a, l.latestValues, l.snapshot ? l.snapshot.layoutBox : void 0, u);
      }
      return Ai(this.latestValues) && jv(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Kt.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const c = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== c;
      if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: d, layoutId: f } = this.options;
      if (!(!this.layout || !(d || f))) {
        if (this.resolvedRelativeTargetAt = Kt.timestamp, !this.targetDelta && !this.relativeTarget) {
          const h = this.getClosestProjectingParent();
          h && h.layout && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Pt(), this.relativeTargetOrigin = Pt(), mc(this.relativeTargetOrigin, this.layout.layoutBox, h.layout.layoutBox), Kn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = Pt(), this.targetWithTransforms = Pt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), VN(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Kn(this.target, this.layout.layoutBox), ME(this.target, this.targetDelta)) : Kn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const h = this.getClosestProjectingParent();
            h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Pt(), this.relativeTargetOrigin = Pt(), mc(this.relativeTargetOrigin, this.target, h.target), Kn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          rc && Si.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || om(this.parent.latestValues) || RE(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), c = !!this.resumingFrom || this !== a;
      let l = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (l = !1), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Kt.timestamp && (l = !1), l)
        return;
      const { layout: u, layoutId: d } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d))
        return;
      Kn(this.layoutCorrected, this.layout.layoutBox);
      const f = this.treeScale.x, h = this.treeScale.y;
      ZN(this.layoutCorrected, this.treeScale, this.path, c), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = Pt());
      const { target: p } = a;
      if (!p) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (qv(this.prevProjectionDelta.x, this.projectionDelta.x), qv(this.prevProjectionDelta.y, this.projectionDelta.y)), pc(this.projectionDelta, this.layoutCorrected, p, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== h || !Wv(this.projectionDelta.x, this.prevProjectionDelta.x) || !Wv(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)), rc && Si.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const c = this.getStack();
        c && c.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = _o(), this.projectionDelta = _o(), this.projectionDeltaWithTransform = _o();
    }
    setAnimationOrigin(o, a = !1) {
      const c = this.snapshot, l = c ? c.latestValues : {}, u = { ...this.latestValues }, d = _o();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const f = Pt(), h = c ? c.source : void 0, p = this.layout ? this.layout.source : void 0, m = h !== p, y = this.getStack(), b = !y || y.members.length <= 1, v = !!(m && !b && this.options.crossfade === !0 && !this.path.some(LL));
      this.animationProgress = 0;
      let w;
      this.mixTargetDelta = (x) => {
        const A = x / 1e3;
        Gv(d.x, o.x, A), Gv(d.y, o.y, A), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (mc(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), NL(this.relativeTarget, this.relativeTargetOrigin, f, A), w && mL(this.relativeTarget, w) && (this.isProjectionDirty = !1), w || (w = Pt()), Kn(w, this.relativeTarget)), m && (this.animationValues = u, lL(u, l, this.latestValues, A, v, b)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = A;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Ys(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = it.update(() => {
        Lu.hasAnimatedSinceResize = !0, this.currentAnimation = AL(0, zv, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(zv), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: c, layout: l, latestValues: u } = o;
      if (!(!a || !c || !l)) {
        if (this !== o && this.layout && l && VE(this.options.animationType, this.layout.layoutBox, l.layoutBox)) {
          c = this.target || Pt();
          const d = Hn(this.layout.layoutBox.x);
          c.x.min = o.target.x.min, c.x.max = c.x.min + d;
          const f = Hn(this.layout.layoutBox.y);
          c.y.min = o.target.y.min, c.y.max = c.y.min + f;
        }
        Kn(a, c), ko(a, u), pc(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new gL()), this.sharedNodes.get(o).add(a);
      const l = a.options.initialPromotionConfig;
      a.promote({
        transition: l ? l.transition : void 0,
        preserveFollowOpacity: l && l.shouldPreserveFollowOpacity ? l.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: c } = {}) {
      const l = this.getStack();
      l && l.promote(this, c), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: c } = o;
      if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (a = !0), !a)
        return;
      const l = {};
      c.z && zh("z", o, l, this.animationValues);
      for (let u = 0; u < Wh.length; u++)
        zh(`rotate${Wh[u]}`, o, l, this.animationValues), zh(`skew${Wh[u]}`, o, l, this.animationValues);
      o.render();
      for (const u in l)
        o.setStaticValue(u, l[u]), this.animationValues && (this.animationValues[u] = l[u]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, c;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return SL;
      const l = {
        visibility: ""
      }, u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, l.opacity = "", l.pointerEvents = ju(o == null ? void 0 : o.pointerEvents) || "", l.transform = u ? u(this.latestValues, "") : "none", l;
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const m = {};
        return this.options.layoutId && (m.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, m.pointerEvents = ju(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !Ai(this.latestValues) && (m.transform = u ? u({}, "") : "none", this.hasProjected = !1), m;
      }
      const f = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(), l.transform = yL(this.projectionDeltaWithTransform, this.treeScale, f), u && (l.transform = u(f, l.transform));
      const { x: h, y: p } = this.projectionDelta;
      l.transformOrigin = `${h.origin * 100}% ${p.origin * 100}% 0`, d.animationValues ? l.opacity = d === this ? (c = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : l.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
      for (const m in Ad) {
        if (f[m] === void 0)
          continue;
        const { correct: y, applyTo: b } = Ad[m], v = l.transform === "none" ? f[m] : y(f[m], d);
        if (b) {
          const w = b.length;
          for (let x = 0; x < w; x++)
            l[b[x]] = v;
        } else
          l[m] = v;
      }
      return this.options.layoutId && (l.pointerEvents = d === this ? ju(o == null ? void 0 : o.pointerEvents) || "" : "none"), l;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(Hv), this.root.sharedNodes.clear();
    }
  };
}
function CL(t) {
  t.updateLayout();
}
function _L(t) {
  var e;
  const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: s } = t.layout, { animationType: i } = t.options, o = n.source !== t.layout.source;
    i === "size" ? Zn((d) => {
      const f = o ? n.measuredBox[d] : n.layoutBox[d], h = Hn(f);
      f.min = r[d].min, f.max = f.min + h;
    }) : VE(i, n.layoutBox, r) && Zn((d) => {
      const f = o ? n.measuredBox[d] : n.layoutBox[d], h = Hn(r[d]);
      f.max = f.min + h, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[d].max = t.relativeTarget[d].min + h);
    });
    const a = _o();
    pc(a, r, n.layoutBox);
    const c = _o();
    o ? pc(c, t.applyTransform(s, !0), n.measuredBox) : pc(c, r, n.layoutBox);
    const l = !LE(a);
    let u = !1;
    if (!t.resumeFrom) {
      const d = t.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: f, layout: h } = d;
        if (f && h) {
          const p = Pt();
          mc(p, n.layoutBox, f.layoutBox);
          const m = Pt();
          mc(m, r, h.layoutBox), jE(p, m) || (u = !0), d.options.layoutRoot && (t.relativeTarget = m, t.relativeTargetOrigin = p, t.relativeParent = d);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: r,
      snapshot: n,
      delta: c,
      layoutDelta: a,
      hasLayoutChanged: l,
      hasRelativeTargetChanged: u
    });
  } else if (t.isLead()) {
    const { onExitComplete: r } = t.options;
    r && r();
  }
  t.options.transition = void 0;
}
function TL(t) {
  rc && Si.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function kL(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function RL(t) {
  t.clearSnapshot();
}
function Hv(t) {
  t.clearMeasurements();
}
function ML(t) {
  t.isLayoutDirty = !1;
}
function PL(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function Yv(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function IL(t) {
  t.resolveTargetDelta();
}
function DL(t) {
  t.calcProjection();
}
function OL(t) {
  t.resetSkewAndRotation();
}
function qL(t) {
  t.removeLeadSnapshot();
}
function Gv(t, e, n) {
  t.translate = vt(e.translate, 0, n), t.scale = vt(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
}
function Kv(t, e, n, r) {
  t.min = vt(e.min, n.min, r), t.max = vt(e.max, n.max, r);
}
function NL(t, e, n, r) {
  Kv(t.x, e.x, n.x, r), Kv(t.y, e.y, n.y, r);
}
function LL(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const jL = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, $v = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), Zv = $v("applewebkit/") && !$v("chrome/") ? Math.round : Qt;
function Qv(t) {
  t.min = Zv(t.min), t.max = Zv(t.max);
}
function BL(t) {
  Qv(t.x), Qv(t.y);
}
function VE(t, e, n) {
  return t === "position" || t === "preserve-aspect" && !FN(Uv(e), Uv(n), 0.2);
}
function FL(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const VL = FE({
  attachResizeListener: (t, e) => Xr(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), Hh = {
  current: void 0
}, UE = FE({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!Hh.current) {
      const t = new VL({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), Hh.current = t;
    }
    return Hh.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), UL = {
  pan: {
    Feature: nL
  },
  drag: {
    Feature: tL,
    ProjectionNode: UE,
    MeasureLayout: OE
  }
};
function Xv(t, e) {
  const n = e ? "pointerenter" : "pointerleave", r = e ? "onHoverStart" : "onHoverEnd", s = (i, o) => {
    if (i.pointerType === "touch" || CE())
      return;
    const a = t.getProps();
    t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
    const c = a[r];
    c && it.postRender(() => c(i, o));
  };
  return is(t.current, n, s, {
    passive: !t.getProps()[r]
  });
}
class WL extends li {
  mount() {
    this.unmount = ss(Xv(this.node, !0), Xv(this.node, !1));
  }
  unmount() {
  }
}
class zL extends li {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = ss(Xr(this.node.current, "focus", () => this.onFocus()), Xr(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const WE = (t, e) => e ? t === e ? !0 : WE(t, e.parentElement) : !1;
function Yh(t, e) {
  if (!e)
    return;
  const n = new PointerEvent("pointer" + t);
  e(n, Ef(n));
}
class HL extends li {
  constructor() {
    super(...arguments), this.removeStartListeners = Qt, this.removeEndListeners = Qt, this.removeAccessibleListeners = Qt, this.startPointerPress = (e, n) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const r = this.node.getProps(), i = is(window, "pointerup", (a, c) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: l, onTapCancel: u, globalTapTarget: d } = this.node.getProps(), f = !d && !WE(this.node.current, a.target) ? u : l;
        f && it.update(() => f(a, c));
      }, {
        passive: !(r.onTap || r.onPointerUp)
      }), o = is(window, "pointercancel", (a, c) => this.cancelPress(a, c), {
        passive: !(r.onTapCancel || r.onPointerCancel)
      });
      this.removeEndListeners = ss(i, o), this.startPress(e, n);
    }, this.startAccessiblePress = () => {
      const e = (i) => {
        if (i.key !== "Enter" || this.isPressing)
          return;
        const o = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || Yh("up", (c, l) => {
            const { onTap: u } = this.node.getProps();
            u && it.postRender(() => u(c, l));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Xr(this.node.current, "keyup", o), Yh("down", (a, c) => {
          this.startPress(a, c);
        });
      }, n = Xr(this.node.current, "keydown", e), r = () => {
        this.isPressing && Yh("cancel", (i, o) => this.cancelPress(i, o));
      }, s = Xr(this.node.current, "blur", r);
      this.removeAccessibleListeners = ss(n, s);
    };
  }
  startPress(e, n) {
    this.isPressing = !0;
    const { onTapStart: r, whileTap: s } = this.node.getProps();
    s && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && it.postRender(() => r(e, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !CE();
  }
  cancelPress(e, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: r } = this.node.getProps();
    r && it.postRender(() => r(e, n));
  }
  mount() {
    const e = this.node.getProps(), n = is(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(e.onTapStart || e.onPointerStart)
    }), r = Xr(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = ss(n, r);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const cm = /* @__PURE__ */ new WeakMap(), Gh = /* @__PURE__ */ new WeakMap(), YL = (t) => {
  const e = cm.get(t.target);
  e && e(t);
}, GL = (t) => {
  t.forEach(YL);
};
function KL({ root: t, ...e }) {
  const n = t || document;
  Gh.has(n) || Gh.set(n, {});
  const r = Gh.get(n), s = JSON.stringify(e);
  return r[s] || (r[s] = new IntersectionObserver(GL, { root: t, ...e })), r[s];
}
function $L(t, e, n) {
  const r = KL(e);
  return cm.set(t, n), r.observe(t), () => {
    cm.delete(t), r.unobserve(t);
  };
}
const ZL = {
  some: 0,
  all: 1
};
class QL extends li {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: n, margin: r, amount: s = "some", once: i } = e, o = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof s == "number" ? s : ZL[s]
    }, a = (c) => {
      const { isIntersecting: l } = c;
      if (this.isInView === l || (this.isInView = l, i && !l && this.hasEnteredView))
        return;
      l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l);
      const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(), f = l ? u : d;
      f && f(c);
    };
    return $L(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(XL(e, n)) && this.startObserver();
  }
  unmount() {
  }
}
function XL({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n];
}
const JL = {
  inView: {
    Feature: QL
  },
  tap: {
    Feature: HL
  },
  focus: {
    Feature: zL
  },
  hover: {
    Feature: WL
  }
}, ej = {
  layout: {
    ProjectionNode: UE,
    MeasureLayout: OE
  }
}, cy = oi({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), _f = oi({}), ly = typeof window < "u", zE = ly ? Ig : _e, HE = oi({ strict: !1 });
let Jv = !1;
function tj(t, e, n, r, s) {
  var i;
  const { visualElement: o } = Ht(_f), a = Ht(HE), c = Ht(Cf), l = Ht(cy).reducedMotion, u = Et();
  r = r || a.renderer, !u.current && r && (u.current = r(t, {
    visualState: e,
    parent: o,
    props: n,
    presenceContext: c,
    blockInitialAnimation: c ? c.initial === !1 : !1,
    reducedMotionConfig: l
  }));
  const d = u.current, f = Ht(DE);
  d && !d.projection && s && (d.type === "html" || d.type === "svg") && rj(u.current, n, s, f), VS(() => {
    d && d.update(n, c);
  });
  const h = n[mE], p = Et(!!h && !window.MotionHandoffIsComplete && ((i = window.MotionHasOptimisedAnimation) === null || i === void 0 ? void 0 : i.call(window, h)));
  return zE(() => {
    d && (d.updateFeatures(), ay.render(d.render), p.current && d.animationState && d.animationState.animateChanges());
  }), _e(() => {
    d && (!p.current && d.animationState && d.animationState.animateChanges(), p.current = !1, Jv || (Jv = !0, queueMicrotask(nj)));
  }), d;
}
function nj() {
  window.MotionHandoffIsComplete = !0;
}
function rj(t, e, n, r) {
  const { layoutId: s, layout: i, drag: o, dragConstraints: a, layoutScroll: c, layoutRoot: l } = e;
  t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : YE(t.parent)), t.projection.setOptions({
    layoutId: s,
    layout: i,
    alwaysMeasureLayout: !!o || a && Co(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof i == "string" ? i : "both",
    initialPromotionConfig: r,
    layoutScroll: c,
    layoutRoot: l
  });
}
function YE(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : YE(t.parent);
}
function sj(t, e, n) {
  return Je(
    (r) => {
      r && t.mount && t.mount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : Co(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function Tf(t) {
  return Mc(t.animate) || Wg.some((e) => Pc(t[e]));
}
function GE(t) {
  return !!(Tf(t) || t.variants);
}
function ij(t, e) {
  if (Tf(t)) {
    const { initial: n, animate: r } = t;
    return {
      initial: n === !1 || Pc(n) ? n : void 0,
      animate: Pc(r) ? r : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function oj(t) {
  const { initial: e, animate: n } = ij(t, Ht(_f));
  return Pr(() => ({ initial: e, animate: n }), [ex(e), ex(n)]);
}
function ex(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const tx = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Yo = {};
for (const t in tx)
  Yo[t] = {
    isEnabled: (e) => tx[t].some((n) => !!e[n])
  };
function aj(t) {
  for (const e in t)
    Yo[e] = {
      ...Yo[e],
      ...t[e]
    };
}
const cj = Symbol.for("motionComponentSymbol");
function lj({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: r, Component: s }) {
  t && aj(t);
  function i(a, c) {
    let l;
    const u = {
      ...Ht(cy),
      ...a,
      layoutId: uj(a)
    }, { isStatic: d } = u, f = oj(a), h = r(a, d);
    if (!d && ly) {
      dj(u, t);
      const p = fj(u);
      l = p.MeasureLayout, f.visualElement = tj(s, h, u, e, p.ProjectionNode);
    }
    return g.jsxs(_f.Provider, { value: f, children: [l && f.visualElement ? g.jsx(l, { visualElement: f.visualElement, ...u }) : null, n(s, a, sj(h, f.visualElement, c), h, d, f.visualElement)] });
  }
  const o = ai(i);
  return o[cj] = s, o;
}
function uj({ layoutId: t }) {
  const e = Ht(oy).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function dj(t, e) {
  const n = Ht(HE).strict;
  if (e && n) {
    const r = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? xa(!1, r) : ls(!1, r);
  }
}
function fj(t) {
  const { drag: e, layout: n } = Yo;
  if (!e && !n)
    return {};
  const r = { ...e, ...n };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || n != null && n.isEnabled(t) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
const hj = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function uy(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(hj.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function KE(t, { style: e, vars: n }, r, s) {
  Object.assign(t.style, e, s && s.getProjectionStyles(r));
  for (const i in n)
    t.style.setProperty(i, n[i]);
}
const $E = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function ZE(t, e, n, r) {
  KE(t, e, void 0, r);
  for (const s in e.attrs)
    t.setAttribute($E.has(s) ? s : Sf(s), e.attrs[s]);
}
function QE(t, { layout: e, layoutId: n }) {
  return ci.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!Ad[t] || t === "opacity");
}
function dy(t, e, n) {
  var r;
  const { style: s } = t, i = {};
  for (const o in s)
    (on(s[o]) || e.style && on(e.style[o]) || QE(o, t) || ((r = n == null ? void 0 : n.getValue(o)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (i[o] = s[o]);
  return n && s && typeof s.willChange == "string" && (n.applyWillChange = !1), i;
}
function XE(t, e, n) {
  const r = dy(t, e, n);
  for (const s in t)
    if (on(t[s]) || on(e[s])) {
      const i = ml.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s;
      r[i] = t[s];
    }
  return r;
}
function fy(t) {
  const e = Et(null);
  return e.current === null && (e.current = t()), e.current;
}
function pj({ applyWillChange: t = !1, scrapeMotionValuesFromProps: e, createRenderState: n, onMount: r }, s, i, o, a) {
  const c = {
    latestValues: gj(s, i, o, a ? !1 : t, e),
    renderState: n()
  };
  return r && (c.mount = (l) => r(s, l, c)), c;
}
const JE = (t) => (e, n) => {
  const r = Ht(_f), s = Ht(Cf), i = () => pj(t, e, r, s, n);
  return n ? i() : fy(i);
};
function mj(t, e) {
  const n = yE(e);
  n && bl(t, n);
}
function nx(t, e, n) {
  const r = Array.isArray(e) ? e : [e];
  for (let s = 0; s < r.length; s++) {
    const i = Vg(t, r[s]);
    if (i) {
      const { transitionEnd: o, transition: a, ...c } = i;
      n(c, o);
    }
  }
}
function gj(t, e, n, r, s) {
  var i;
  const o = {}, a = [], c = r && ((i = t.style) === null || i === void 0 ? void 0 : i.willChange) === void 0, l = s(t, {});
  for (const y in l)
    o[y] = ju(l[y]);
  let { initial: u, animate: d } = t;
  const f = Tf(t), h = GE(t);
  e && h && !f && t.inherit !== !1 && (u === void 0 && (u = e.initial), d === void 0 && (d = e.animate));
  let p = n ? n.initial === !1 : !1;
  p = p || u === !1;
  const m = p ? d : u;
  return m && typeof m != "boolean" && !Mc(m) && nx(t, m, (y, b) => {
    for (const v in y) {
      let w = y[v];
      if (Array.isArray(w)) {
        const x = p ? w.length - 1 : 0;
        w = w[x];
      }
      w !== null && (o[v] = w);
    }
    for (const v in b)
      o[v] = b[v];
  }), c && (d && u !== !1 && !Mc(d) && nx(t, d, (y) => {
    for (const b in y)
      mj(a, b);
  }), a.length && (o.willChange = a.join(","))), o;
}
const hy = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), eC = () => ({
  ...hy(),
  attrs: {}
}), tC = (t, e) => e && typeof t == "number" ? e.transform(t) : t, yj = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, bj = ml.length;
function vj(t, e, n) {
  let r = "", s = !0;
  for (let i = 0; i < bj; i++) {
    const o = ml[i], a = t[o];
    if (a === void 0)
      continue;
    let c = !0;
    if (typeof a == "number" ? c = a === (o.startsWith("scale") ? 1 : 0) : c = parseFloat(a) === 0, !c || n) {
      const l = tC(a, Qg[o]);
      if (!c) {
        s = !1;
        const u = yj[o] || o;
        r += `${u}(${l}) `;
      }
      n && (e[o] = l);
    }
  }
  return r = r.trim(), n ? r = n(e, s ? "" : r) : s && (r = "none"), r;
}
function py(t, e, n) {
  const { style: r, vars: s, transformOrigin: i } = t;
  let o = !1, a = !1;
  for (const c in e) {
    const l = e[c];
    if (ci.has(c)) {
      o = !0;
      continue;
    } else if (W1(c)) {
      s[c] = l;
      continue;
    } else {
      const u = tC(l, Qg[c]);
      c.startsWith("origin") ? (a = !0, i[c] = u) : r[c] = u;
    }
  }
  if (e.transform || (o || n ? r.transform = vj(e, t.transform, n) : r.transform && (r.transform = "none")), a) {
    const { originX: c = "50%", originY: l = "50%", originZ: u = 0 } = i;
    r.transformOrigin = `${c} ${l} ${u}`;
  }
}
function rx(t, e, n) {
  return typeof t == "string" ? t : se.transform(e + n * t);
}
function xj(t, e, n) {
  const r = rx(e, t.x, t.width), s = rx(n, t.y, t.height);
  return `${r} ${s}`;
}
const wj = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, Aj = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Sj(t, e, n = 1, r = 0, s = !0) {
  t.pathLength = 1;
  const i = s ? wj : Aj;
  t[i.offset] = se.transform(-r);
  const o = se.transform(e), a = se.transform(n);
  t[i.array] = `${o} ${a}`;
}
function my(t, {
  attrX: e,
  attrY: n,
  attrScale: r,
  originX: s,
  originY: i,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: c = 0,
  // This is object creation, which we try to avoid per-frame.
  ...l
}, u, d) {
  if (py(t, l, d), u) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: f, style: h, dimensions: p } = t;
  f.transform && (p && (h.transform = f.transform), delete f.transform), p && (s !== void 0 || i !== void 0 || h.transform) && (h.transformOrigin = xj(p, s !== void 0 ? s : 0.5, i !== void 0 ? i : 0.5)), e !== void 0 && (f.x = e), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), o !== void 0 && Sj(f, o, a, c, !1);
}
const gy = (t) => typeof t == "string" && t.toLowerCase() === "svg", Ej = {
  useVisualState: JE({
    scrapeMotionValuesFromProps: XE,
    createRenderState: eC,
    onMount: (t, e, { renderState: n, latestValues: r }) => {
      it.read(() => {
        try {
          n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          n.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), it.render(() => {
        my(n, r, gy(e.tagName), t.transformTemplate), ZE(e, n);
      });
    }
  })
}, Cj = {
  useVisualState: JE({
    applyWillChange: !0,
    scrapeMotionValuesFromProps: dy,
    createRenderState: hy
  })
};
function nC(t, e, n) {
  for (const r in e)
    !on(e[r]) && !QE(r, n) && (t[r] = e[r]);
}
function _j({ transformTemplate: t }, e) {
  return Pr(() => {
    const n = hy();
    return py(n, e, t), Object.assign({}, n.vars, n.style);
  }, [e]);
}
function Tj(t, e) {
  const n = t.style || {}, r = {};
  return nC(r, n, t), Object.assign(r, _j(t, e)), r;
}
function kj(t, e) {
  const n = {}, r = Tj(t, e);
  return t.drag && t.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const Rj = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Sd(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || Rj.has(t);
}
let rC = (t) => !Sd(t);
function Mj(t) {
  t && (rC = (e) => e.startsWith("on") ? !Sd(e) : t(e));
}
try {
  Mj(require("@emotion/is-prop-valid").default);
} catch {
}
function Pj(t, e, n) {
  const r = {};
  for (const s in t)
    s === "values" && typeof t.values == "object" || (rC(s) || n === !0 && Sd(s) || !e && !Sd(s) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && s.startsWith("onDrag")) && (r[s] = t[s]);
  return r;
}
function Ij(t, e, n, r) {
  const s = Pr(() => {
    const i = eC();
    return my(i, e, gy(r), t.transformTemplate), {
      ...i.attrs,
      style: { ...i.style }
    };
  }, [e]);
  if (t.style) {
    const i = {};
    nC(i, t.style, t), s.style = { ...i, ...s.style };
  }
  return s;
}
function Dj(t = !1) {
  return (n, r, s, { latestValues: i }, o) => {
    const c = (uy(n) ? Ij : kj)(r, i, o, n), l = Pj(r, typeof n == "string", t), u = n !== US ? { ...l, ...c, ref: s } : {}, { children: d } = r, f = Pr(() => on(d) ? d.get() : d, [d]);
    return Mn(n, {
      ...u,
      children: f
    });
  };
}
function Oj(t, e) {
  return function(r, { forwardMotionProps: s } = { forwardMotionProps: !1 }) {
    const o = {
      ...uy(r) ? Ej : Cj,
      preloadedFeatures: t,
      useRender: Dj(s),
      createVisualElement: e,
      Component: r
    };
    return lj(o);
  };
}
const lm = { current: null }, sC = { current: !1 };
function qj() {
  if (sC.current = !0, !!ly)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => lm.current = t.matches;
      t.addListener(e), e();
    } else
      lm.current = !1;
}
function Nj(t, e, n) {
  for (const r in e) {
    const s = e[r], i = n[r];
    if (on(s))
      t.addValue(r, s);
    else if (on(i))
      t.addValue(r, Oc(s, { owner: t }));
    else if (i !== s)
      if (t.hasValue(r)) {
        const o = t.getValue(r);
        o.liveStyle === !0 ? o.jump(s) : o.hasAnimated || o.set(s);
      } else {
        const o = t.getStaticValue(r);
        t.addValue(r, Oc(o !== void 0 ? o : s, { owner: t }));
      }
  }
  for (const r in n)
    e[r] === void 0 && t.removeValue(r);
  return e;
}
const sx = /* @__PURE__ */ new WeakMap(), Lj = [...Y1, sn, Ks], jj = (t) => Lj.find(H1(t)), ix = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class Bj {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, n, r) {
    return {};
  }
  constructor({ parent: e, props: n, presenceContext: r, reducedMotionConfig: s, blockInitialAnimation: i, visualState: o }, a = {}) {
    this.applyWillChange = !1, this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Kg, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const f = Tr.now();
      this.renderScheduledAt < f && (this.renderScheduledAt = f, it.render(this.render, !1, !0));
    };
    const { latestValues: c, renderState: l } = o;
    this.latestValues = c, this.baseTarget = { ...c }, this.initialValues = n.initial ? { ...c } : {}, this.renderState = l, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = s, this.options = a, this.blockInitialAnimation = !!i, this.isControllingVariants = Tf(n), this.isVariantNode = GE(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: u, ...d } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const f in d) {
      const h = d[f];
      c[f] !== void 0 && on(h) && h.set(c[f], !1);
    }
  }
  mount(e) {
    this.current = e, sx.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), sC.current || qj(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : lm.current, Fg(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    sx.delete(this.current), this.projection && this.projection.unmount(), Ys(this.notifyUpdate), Ys(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const n = this.features[e];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, n) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const r = ci.has(e), s = n.on("change", (a) => {
      this.latestValues[e] = a, this.props.onUpdate && it.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0);
    }), i = n.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => {
      s(), i(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in Yo) {
      const n = Yo[e];
      if (!n)
        continue;
      const { isEnabled: r, Feature: s } = n;
      if (!this.features[e] && s && r(this.props) && (this.features[e] = new s(this)), this.features[e]) {
        const i = this.features[e];
        i.isMounted ? i.update() : (i.mount(), i.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Pt();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, n) {
    this.latestValues[e] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, n) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < ix.length; r++) {
      const s = ix[r];
      this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
      const i = "on" + s, o = e[i];
      o && (this.propEventSubscriptions[s] = this.on(s, o));
    }
    this.prevMotionValues = Nj(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, n) {
    const r = this.values.get(e);
    n !== r && (r && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const n = this.valueSubscriptions.get(e);
    n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, n) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let r = this.values.get(e);
    return r === void 0 && n !== void 0 && (r = Oc(n === null ? void 0 : n, { owner: this }), this.addValue(e, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, n) {
    var r;
    let s = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, e, this.options);
    return s != null && (typeof s == "string" && (V1(s) || F1(s)) ? s = parseFloat(s) : !jj(s) && Ks.test(n) && (s = eE(e, n)), this.setBaseTarget(e, on(s) ? s.get() : s)), on(s) ? s.get() : s;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, n) {
    this.baseTarget[e] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var n;
    const { initial: r } = this.props;
    let s;
    if (typeof r == "string" || typeof r == "object") {
      const o = Vg(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
      o && (s = o[e]);
    }
    if (r && s !== void 0)
      return s;
    const i = this.getBaseTargetFromProps(this.props, e);
    return i !== void 0 && !on(i) ? i : this.initialValues[e] !== void 0 && s === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, n) {
    return this.events[e] || (this.events[e] = new iy()), this.events[e].add(n);
  }
  notify(e, ...n) {
    this.events[e] && this.events[e].notify(...n);
  }
}
class iC extends Bj {
  constructor() {
    super(...arguments), this.KeyframeResolver = tE;
  }
  sortInstanceNodePosition(e, n) {
    return e.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, n) {
    return e.style ? e.style[n] : void 0;
  }
  removeValueFromRenderState(e, { vars: n, style: r }) {
    delete n[e], delete r[e];
  }
}
function Fj(t) {
  return window.getComputedStyle(t);
}
class Vj extends iC {
  constructor() {
    super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = KE;
  }
  readValueFromInstance(e, n) {
    if (ci.has(n)) {
      const r = Xg(n);
      return r && r.default || 0;
    } else {
      const r = Fj(e), s = (W1(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: n }) {
    return PE(e, n);
  }
  build(e, n, r) {
    py(e, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, n, r) {
    return dy(e, n, r);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    on(e) && (this.childSubscription = e.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class Uj extends iC {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Pt;
  }
  getBaseTargetFromProps(e, n) {
    return e[n];
  }
  readValueFromInstance(e, n) {
    if (ci.has(n)) {
      const r = Xg(n);
      return r && r.default || 0;
    }
    return n = $E.has(n) ? n : Sf(n), e.getAttribute(n);
  }
  scrapeMotionValuesFromProps(e, n, r) {
    return XE(e, n, r);
  }
  build(e, n, r) {
    my(e, n, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, n, r, s) {
    ZE(e, n, r, s);
  }
  mount(e) {
    this.isSVGTag = gy(e.tagName), super.mount(e);
  }
}
const Wj = (t, e) => uy(t) ? new Uj(e) : new Vj(e, {
  allowProjection: t !== US
}), zj = /* @__PURE__ */ Oj({
  ...PN,
  ...JL,
  ...UL,
  ...ej
}, Wj), os = /* @__PURE__ */ SO(zj);
class Hj extends E.Component {
  getSnapshotBeforeUpdate(e) {
    const n = this.props.childRef.current;
    if (n && e.isPresent && !this.props.isPresent) {
      const r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Yj({ children: t, isPresent: e }) {
  const n = Pg(), r = Et(null), s = Et({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: i } = Ht(cy);
  return VS(() => {
    const { width: o, height: a, top: c, left: l } = s.current;
    if (e || !r.current || !o || !a)
      return;
    r.current.dataset.motionPopId = n;
    const u = document.createElement("style");
    return i && (u.nonce = i), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${c}px !important;
            left: ${l}px !important;
          }
        `), () => {
      document.head.removeChild(u);
    };
  }, [e]), g.jsx(Hj, { isPresent: e, childRef: r, sizeRef: s, children: E.cloneElement(t, { ref: r }) });
}
const Gj = ({ children: t, initial: e, isPresent: n, onExitComplete: r, custom: s, presenceAffectsLayout: i, mode: o }) => {
  const a = fy(Kj), c = Pg(), l = Pr(
    () => ({
      id: c,
      initial: e,
      isPresent: n,
      custom: s,
      onExitComplete: (u) => {
        a.set(u, !0);
        for (const d of a.values())
          if (!d)
            return;
        r && r();
      },
      register: (u) => (a.set(u, !1), () => a.delete(u))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    i ? [Math.random()] : [n]
  );
  return Pr(() => {
    a.forEach((u, d) => a.set(d, !1));
  }, [n]), E.useEffect(() => {
    !n && !a.size && r && r();
  }, [n]), o === "popLayout" && (t = g.jsx(Yj, { isPresent: n, children: t })), g.jsx(Cf.Provider, { value: l, children: t });
};
function Kj() {
  return /* @__PURE__ */ new Map();
}
const zl = (t) => t.key || "";
function ox(t) {
  const e = [];
  return i2.forEach(t, (n) => {
    o2(n) && e.push(n);
  }), e;
}
const Go = ({ children: t, exitBeforeEnter: e, custom: n, initial: r = !0, onExitComplete: s, presenceAffectsLayout: i = !0, mode: o = "sync" }) => {
  ls(!e, "Replace exitBeforeEnter with mode='wait'");
  const a = Pr(() => ox(t), [t]), c = a.map(zl), l = Et(!0), u = Et(a), d = fy(() => /* @__PURE__ */ new Map()), [f, h] = Ge(a), [p, m] = Ge(a);
  zE(() => {
    l.current = !1, u.current = a;
    for (let v = 0; v < p.length; v++) {
      const w = zl(p[v]);
      c.includes(w) ? d.delete(w) : d.get(w) !== !0 && d.set(w, !1);
    }
  }, [p, c.length, c.join("-")]);
  const y = [];
  if (a !== f) {
    let v = [...a];
    for (let w = 0; w < p.length; w++) {
      const x = p[w], A = zl(x);
      c.includes(A) || (v.splice(w, 0, x), y.push(x));
    }
    o === "wait" && y.length && (v = y), m(ox(v)), h(a);
    return;
  }
  o === "wait" && p.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: b } = Ht(oy);
  return g.jsx(g.Fragment, { children: p.map((v) => {
    const w = zl(v), x = a === p || c.includes(w), A = () => {
      if (d.has(w))
        d.set(w, !0);
      else
        return;
      let C = !0;
      d.forEach((S) => {
        S || (C = !1);
      }), C && (b == null || b(), m(u.current), s && s());
    };
    return g.jsx(Gj, { isPresent: x, initial: !l.current || r ? void 0 : !1, custom: x ? void 0 : n, presenceAffectsLayout: i, mode: o, onExitComplete: x ? void 0 : A, children: v }, w);
  }) });
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $j = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), oC = (...t) => t.filter((e, n, r) => !!e && r.indexOf(e) === n).join(" ");
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Zj = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Qj = ai(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: s = "",
    children: i,
    iconNode: o,
    ...a
  }, c) => Mn(
    "svg",
    {
      ref: c,
      ...Zj,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: r ? Number(n) * 24 / Number(e) : n,
      className: oC("lucide", s),
      ...a
    },
    [
      ...o.map(([l, u]) => Mn(l, u)),
      ...Array.isArray(i) ? i : [i]
    ]
  )
);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jt = (t, e) => {
  const n = ai(
    ({ className: r, ...s }, i) => Mn(Qj, {
      ref: i,
      iconNode: e,
      className: oC(`lucide-${$j(t)}`, r),
      ...s
    })
  );
  return n.displayName = `${t}`, n;
};
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Xj = Jt("Bomb", [
  ["circle", { cx: "11", cy: "13", r: "9", key: "hd149" }],
  [
    "path",
    {
      d: "M14.35 4.65 16.3 2.7a2.41 2.41 0 0 1 3.4 0l1.6 1.6a2.4 2.4 0 0 1 0 3.4l-1.95 1.95",
      key: "jp4j1b"
    }
  ],
  ["path", { d: "m22 2-1.5 1.5", key: "ay92ug" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aC = Jt("ChartLine", [
  ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }],
  ["path", { d: "m19 9-5 5-4-4-3 3", key: "2osh9i" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jj = Jt("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eB = Jt("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Kh = Jt("CircleHelp", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const No = Jt("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kf = Jt("Info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tB = Jt("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cC = Jt("Loader", [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $h = Jt("Nut", [
  ["path", { d: "M12 4V2", key: "1k5q1u" }],
  [
    "path",
    {
      d: "M5 10v4a7.004 7.004 0 0 0 5.277 6.787c.412.104.802.292 1.102.592L12 22l.621-.621c.3-.3.69-.488 1.102-.592A7.003 7.003 0 0 0 19 14v-4",
      key: "1tgyif"
    }
  ],
  [
    "path",
    {
      d: "M12 4C8 4 4.5 6 4 8c-.243.97-.919 1.952-2 3 1.31-.082 1.972-.29 3-1 .54.92.982 1.356 2 2 1.452-.647 1.954-1.098 2.5-2 .595.995 1.151 1.427 2.5 2 1.31-.621 1.862-1.058 2.5-2 .629.977 1.162 1.423 2.5 2 1.209-.548 1.68-.967 2-2 1.032.916 1.683 1.157 3 1-1.297-1.036-1.758-2.03-2-3-.5-2-4-4-8-4Z",
      key: "tnsqj"
    }
  ]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nB = Jt("RefreshCcw", [
  ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
  ["path", { d: "M16 16h5v5", key: "ccwih5" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lC = Jt("RefreshCw", [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rB = Jt("Repeat", [
  ["path", { d: "m17 2 4 4-4 4", key: "nntrym" }],
  ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14", key: "84bu3i" }],
  ["path", { d: "m7 22-4-4 4-4", key: "1wqhfi" }],
  ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3", key: "1rx37r" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sB = Jt("TriangleAlert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iB = Jt("Volume2", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
  ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oB = Jt("VolumeX", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
    }
  ],
  ["line", { x1: "22", x2: "16", y1: "9", y2: "15", key: "1ewh16" }],
  ["line", { x1: "16", x2: "22", y1: "9", y2: "15", key: "5ykzw1" }]
]);
/**
 * @license lucide-react v0.446.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uC = Jt("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
function aB(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function dC(...t) {
  return (e) => t.forEach((n) => aB(n, e));
}
function Ke(...t) {
  return E.useCallback(dC(...t), t);
}
var Ko = E.forwardRef((t, e) => {
  const { children: n, ...r } = t, s = E.Children.toArray(n), i = s.find(cB);
  if (i) {
    const o = i.props.children, a = s.map((c) => c === i ? E.Children.count(o) > 1 ? E.Children.only(null) : E.isValidElement(o) ? o.props.children : null : c);
    return /* @__PURE__ */ g.jsx(um, { ...r, ref: e, children: E.isValidElement(o) ? E.cloneElement(o, void 0, a) : null });
  }
  return /* @__PURE__ */ g.jsx(um, { ...r, ref: e, children: n });
});
Ko.displayName = "Slot";
var um = E.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (E.isValidElement(n)) {
    const s = uB(n);
    return E.cloneElement(n, {
      ...lB(r, n.props),
      // @ts-ignore
      ref: e ? dC(e, s) : s
    });
  }
  return E.Children.count(n) > 1 ? E.Children.only(null) : null;
});
um.displayName = "SlotClone";
var fC = ({ children: t }) => /* @__PURE__ */ g.jsx(g.Fragment, { children: t });
function cB(t) {
  return E.isValidElement(t) && t.type === fC;
}
function lB(t, e) {
  const n = { ...e };
  for (const r in e) {
    const s = t[r], i = e[r];
    /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => {
      i(...a), s(...a);
    } : s && (n[r] = s) : r === "style" ? n[r] = { ...s, ...i } : r === "className" && (n[r] = [s, i].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function uB(t) {
  var r, s;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
function hC(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (n = hC(t[e])) && (r && (r += " "), r += n);
  else for (e in t) t[e] && (r && (r += " "), r += e);
  return r;
}
function dB() {
  for (var t, e, n = 0, r = ""; n < arguments.length; ) (t = arguments[n++]) && (e = hC(t)) && (r && (r += " "), r += e);
  return r;
}
const ax = (t) => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, cx = dB, yy = (t, e) => (n) => {
  var r;
  if ((e == null ? void 0 : e.variants) == null) return cx(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: s, defaultVariants: i } = e, o = Object.keys(s).map((l) => {
    const u = n == null ? void 0 : n[l], d = i == null ? void 0 : i[l];
    if (u === null) return null;
    const f = ax(u) || ax(d);
    return s[l][f];
  }), a = n && Object.entries(n).reduce((l, u) => {
    let [d, f] = u;
    return f === void 0 || (l[d] = f), l;
  }, {}), c = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((l, u) => {
    let { class: d, className: f, ...h } = u;
    return Object.entries(h).every((p) => {
      let [m, y] = p;
      return Array.isArray(y) ? y.includes({
        ...i,
        ...a
      }[m]) : {
        ...i,
        ...a
      }[m] === y;
    }) ? [
      ...l,
      d,
      f
    ] : l;
  }, []);
  return cx(t, o, c, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
}, pC = yy(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), pt = E.forwardRef(
  ({ className: t, variant: e, size: n, asChild: r = !1, ...s }, i) => {
    const o = r ? Ko : "button";
    return /* @__PURE__ */ g.jsx(
      o,
      {
        className: de(pC({ variant: e, size: n, className: t })),
        ref: i,
        ...s
      }
    );
  }
);
pt.displayName = "Button";
const mC = oi(void 0), Aa = () => {
  const t = Ht(mC);
  if (!t)
    throw new Error("useToast must be used within a ToastProvider");
  return t;
};
class fB {
  constructor() {
    this.listeners = [];
  }
  addToast(e) {
    this.listeners.forEach((n) => n(e));
  }
  addListener(e) {
    this.listeners.push(e);
  }
  removeListener(e) {
    this.listeners = this.listeners.filter((n) => n !== e);
  }
}
const Ed = new fB(), hB = ({
  children: t
}) => {
  const [e, n] = Ge([]), r = Je(
    ({ variant: i, message: o, duration: a, limit: c, errorCode: l }) => {
      n((u) => c !== void 0 && u.filter(
        (f) => f.variant === i && f.message === o
      ).length >= c ? u : [
        ...u,
        { id: Date.now(), variant: i, message: o, duration: a, limit: c, errorCode: l }
      ]);
    },
    []
  ), s = Je((i) => {
    n((o) => o.filter((a) => a.id !== i));
  }, []);
  return _e(() => {
    const i = (o) => {
      r(o);
    };
    return Ed.addListener(i), () => {
      Ed.removeListener(i);
    };
  }, [r]), /* @__PURE__ */ g.jsx(mC.Provider, { value: { addToast: r, removeToast: s }, children: /* @__PURE__ */ g.jsxs("div", { className: "relative", children: [
    t,
    /* @__PURE__ */ g.jsx(pB, { toasts: e })
  ] }) });
}, pB = ({ toasts: t }) => {
  const [e, n] = Ge(0);
  _e(() => {
    const s = () => {
      const i = document.querySelector("blink-launcher");
      if (i) {
        const o = i.getBoundingClientRect();
        n(o.top + window.scrollY);
      }
    };
    return s(), window.addEventListener("resize", s), window.addEventListener("scroll", s), () => {
      window.removeEventListener("resize", s), window.removeEventListener("scroll", s);
    };
  }, []);
  const r = fr();
  return /* @__PURE__ */ g.jsx(
    "div",
    {
      className: "fixed lg:absolute left-3 right-3 lg:left-4 lg:right-0 z-[1001] flex flex-col space-y-2 mt-2",
      style: { top: `${r ? e : 0}px` },
      children: /* @__PURE__ */ g.jsx(Go, { children: t.map((s) => /* @__PURE__ */ g.jsx(mB, { toast: s }, s.id)) })
    }
  );
}, mB = ({ toast: t }) => {
  const { removeToast: e } = Aa(), [n, r] = Ge(100), [s, i] = Ge(!1), o = Et(null), a = Et(Date.now()), c = Et(t.duration), l = fr();
  _e(() => {
    if (!t.duration) return;
    const p = () => {
      if (!s && t.duration) {
        const m = Date.now() - a.current;
        c.current = Math.max(0, t.duration - m);
        const y = c.current / t.duration * 100;
        r(y), y <= 0 && (o.current && clearInterval(o.current), e(t.id));
      }
    };
    return o.current = setInterval(p, 10), () => {
      o.current && clearInterval(o.current);
    };
  }, [s, e, t.duration, t.id]);
  const u = () => {
    e(t.id);
  }, d = () => {
    window.location.reload();
  }, f = () => {
    switch (t.variant) {
      case "success":
        return /* @__PURE__ */ g.jsx(eB, { size: 18 });
      case "error":
        return /* @__PURE__ */ g.jsx(sB, { size: 30 });
      case "notice":
        return /* @__PURE__ */ g.jsx(rB, { size: 18 });
      case "loading":
        return /* @__PURE__ */ g.jsx(
          os.div,
          {
            animate: { rotate: 360 },
            transition: { duration: 1, repeat: 1 / 0, ease: "linear" },
            children: /* @__PURE__ */ g.jsx(tB, { size: 18 })
          }
        );
      case "info":
      case "warning":
        return /* @__PURE__ */ g.jsx(kf, { size: 18 });
      default:
        return /* @__PURE__ */ g.jsx(Jj, { size: 18 });
    }
  }, h = {
    success: {
      background: "bg-green-500",
      progress: "bg-white"
    },
    error: {
      background: "bg-destructive",
      progress: "bg-white/40"
    },
    loading: {
      background: "bg-blue-500",
      progress: "bg-white"
    },
    info: {
      background: "bg-blue-500",
      progress: "bg-white"
    },
    warning: {
      background: "bg-yellow-500",
      progress: "bg-white"
    },
    notice: {
      background: "bg-primary",
      progress: "bg-green-500"
    }
  }[t.variant];
  return /* @__PURE__ */ g.jsxs(
    os.div,
    {
      initial: { opacity: 0, y: -50, scale: 0.3 },
      animate: { opacity: 1, y: 0, scale: 1 },
      exit: { opacity: 0, scale: 0.5, transition: { duration: 0.2 } },
      className: `${h.background} text-white p-4 z-[1002] rounded-lg shadow-lg flex flex-col justify-between items-stretch relative overflow-hidden w-full lg:w-[23rem]`,
      style: {
        boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 -2px 0 0 rgba(255, 255, 255, 0.1) inset"
      },
      onMouseEnter: () => i(!0),
      onMouseLeave: () => i(!1),
      children: [
        /* @__PURE__ */ g.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ g.jsxs("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ g.jsxs("div", { className: "flex items-start", children: [
              t.variant !== "error" && f(),
              /* @__PURE__ */ g.jsx("div", { className: "ml-2 flex-grow text-sm font-semibold", children: /* @__PURE__ */ g.jsxs("span", { children: [
                t.message,
                " "
              ] }) })
            ] }),
            /* @__PURE__ */ g.jsx("button", { onClick: u, className: `focus:outline-none ml-4 px-2 ${!s && !l ? "invisible" : ""}`, children: /* @__PURE__ */ g.jsx(uC, { size: 18 }) })
          ] }),
          t.variant === "error" && /* @__PURE__ */ g.jsxs("div", { className: "flex justify-between items-center mt-3", children: [
            /* @__PURE__ */ g.jsxs(
              pt,
              {
                onClick: d,
                variant: "outline",
                className: "flex items-center px-2 py-0 text-xs font-medium justify-start gap-1 bg-transparent hover:bg-white rounded focus:outline-none transition-colors ml-2",
                children: [
                  /* @__PURE__ */ g.jsx(lC, { size: 15 }),
                  "Reload"
                ]
              }
            ),
            t.errorCode !== void 0 && /* @__PURE__ */ g.jsxs("div", { className: "text-xs", children: [
              "Error code: ",
              t.errorCode
            ] })
          ] })
        ] }),
        t.duration && /* @__PURE__ */ g.jsx(
          os.div,
          {
            className: `h-1 ${h.progress} absolute bottom-0 left-0 right-0`,
            initial: { scaleX: 1 },
            animate: { scaleX: n / 100 },
            transition: { duration: 0.01, ease: "linear" },
            style: { originX: 0 }
          }
        )
      ]
    }
  );
}, vs = fI("API_BASE_URL"), gB = {
  400: "Bad request: Missing currency information.",
  401: "Unauthorized: Your session has expired. Please log in again.",
  402: "Insufficient balance: Please add funds to continue.",
  416: "Betting limit exceeded: Please lower your bet amount.",
  417: "Action forbidden due to active bonus. Please check bonus terms.",
  500: "An unexpected error occurred. Reload or contact customer support."
}, yB = (t) => gB[t] || "An unknown error occurred. Please try again.", xs = (t) => {
  var e;
  if (Ie.isAxiosError(t)) {
    const n = (e = t.response) == null ? void 0 : e.status, r = n ? yB(n) : "An unexpected error occurred.";
    Ed.addToast({
      variant: "error",
      errorCode: n,
      message: r,
      limit: 1
    }), console.error("API Error:", t.response);
  } else
    Ed.addToast({
      variant: "error",
      message: "An unexpected error occurred. Try to reload or contact customer support.",
      limit: 1
    }), console.error("Unexpected Error:", t);
};
async function bB(t) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ie.get(
      `${vs}/api/fair/current`,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (e) {
    throw xs(e), new Error(`Failed to get current seed: ${e}`);
  }
}
async function vB(t, e) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ie.get(
      `${vs}/api/fair/rotate/${e}`,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (n) {
    throw xs(n), new Error(`Failed to rotate seed: ${n}`);
  }
}
async function xB(t, e) {
  if (!t || !e) throw new Error("No token or currencyCode found");
  try {
    return (await Ie.post(
      `${vs}/api/player/currency-change`,
      { currency: e },
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (n) {
    throw Ie.isAxiosError(n) && (console.log(n.status), console.error(n.response), xs(n)), new Error(`Failed to perform game action 'currency-change': ${n}`);
  }
}
async function wB(t, e) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ie.get(
      `${vs}/api/game/${e}/config`,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (n) {
    throw xs(n), new Error(`Failed to perform game action 'game-config': ${n}`);
  }
}
async function by(t, e, n) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ie.post(
      `${vs}/api/game/${e}/bet`,
      n,
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (r) {
    throw Ie.isAxiosError(r) && xs(r), new Error(`Failed to perform game action 'bet': ${r}`);
  }
}
class AB {
  constructor() {
    this.queue = [], this.processing = !1, this.gameActive = !0, this.processedIndexes = /* @__PURE__ */ new Set(), this.batchWindow = 150, this.currentBatch = null, this.batchTimeout = null;
  }
  async processBatch(e) {
    if (!this.gameActive || e.indexes.length === 0) return;
    const n = this.queue.filter(
      (r) => r.indexes.some((s) => e.indexes.includes(s))
    );
    if (n.length !== 0) {
      this.queue = this.queue.filter(
        (r) => !r.indexes.some((s) => e.indexes.includes(s))
      );
      try {
        const r = await n[0].request();
        n.forEach((s) => s.resolve(r)), "active" in r && r.active === !1 && (this.gameActive = !1, this.clearRemainingQueue());
      } catch (r) {
        n.forEach((s) => s.reject(r));
      } finally {
        this.queue.length > 0 ? setTimeout(() => this.processNext(), 100) : this.processing = !1;
      }
    }
  }
  enqueue(e, n) {
    return new Promise((r, s) => {
      if (!this.gameActive) {
        s(new Error("Game has ended"));
        return;
      }
      const i = n.filter((a) => !this.processedIndexes.has(a));
      if (i.length === 0) {
        s(new Error("Duplicate request"));
        return;
      }
      i.forEach((a) => this.processedIndexes.add(a)), this.queue.push({ request: e, resolve: r, reject: s, indexes: i });
      const o = Date.now();
      if (!this.currentBatch)
        this.currentBatch = {
          indexes: i,
          timestamp: o
        }, this.batchTimeout = setTimeout(() => {
          if (this.currentBatch) {
            const a = this.currentBatch;
            this.currentBatch = null, this.processBatch(a);
          }
        }, this.batchWindow);
      else if (o - this.currentBatch.timestamp <= this.batchWindow)
        this.currentBatch.indexes = [...this.currentBatch.indexes, ...i];
      else {
        const a = this.currentBatch;
        this.currentBatch = {
          indexes: i,
          timestamp: o
        }, this.processBatch(a), this.batchTimeout && clearTimeout(this.batchTimeout), this.batchTimeout = setTimeout(() => {
          if (this.currentBatch) {
            const c = this.currentBatch;
            this.currentBatch = null, this.processBatch(c);
          }
        }, this.batchWindow);
      }
      this.processing || (this.processing = !0, this.processNext());
    });
  }
  async processNext() {
    if (!this.gameActive || this.queue.length === 0) {
      this.processing = !1;
      return;
    }
    if (this.currentBatch && (await new Promise((n) => setTimeout(n, this.batchWindow)), this.queue.length === 0)) {
      this.processing = !1;
      return;
    }
    const e = this.queue.shift();
    if (!e) {
      this.processing = !1;
      return;
    }
    try {
      const n = await e.request();
      "active" in n && n.active === !1 && (this.gameActive = !1, this.clearRemainingQueue()), e.resolve(n);
    } catch (n) {
      e.reject(n);
    }
    this.gameActive && this.queue.length > 0 ? setTimeout(() => this.processNext(), 100) : this.processing = !1;
  }
  clearRemainingQueue() {
    const e = new Error("Game has ended");
    this.queue.forEach(({ reject: n }) => n(e)), this.queue = [], this.batchTimeout && clearTimeout(this.batchTimeout), this.currentBatch = null;
  }
  resetQueue() {
    this.clearRemainingQueue(), this.gameActive = !0, this.processedIndexes.clear();
  }
  // Allow configuration of batch window
  setBatchWindow(e) {
    this.batchWindow = e;
  }
}
const gC = new AB();
async function SB(t, e, n) {
  if (!t) throw new Error("No authentication token found");
  const r = n.custom.selected;
  return gC.enqueue(async () => {
    try {
      return (await Ie.post(
        `${vs}/api/game/${e}/play`,
        n,
        {
          headers: {
            "Content-Type": "application/json",
            "x-token": t
          }
        }
      )).data;
    } catch (s) {
      throw Ie.isAxiosError(s) && (console.log(s.status), console.error(s.response), xs(s)), new Error(`Failed to perform game action 'play': ${s}`);
    }
  }, r);
}
function EB() {
  gC.resetQueue();
}
async function CB(t, e, n) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ie.post(
      `${vs}/api/game/${e}/play`,
      {
        gameRoundId: n,
        custom: { cashout: !0 }
      },
      {
        headers: {
          "Content-Type": "application/json",
          "x-token": t
        }
      }
    )).data;
  } catch (r) {
    throw Ie.isAxiosError(r) && (console.log(r.status), console.error(r.response), xs(r)), new Error(`Failed to perform game action 'cashout': ${r}`);
  }
}
async function _B(t) {
  if (!t) throw new Error("No authentication token found");
  try {
    return (await Ie.get(
      `${vs}/api/player/myBets`,
      {
        headers: { "x-token": t }
      }
    )).data;
  } catch (e) {
    throw xs(e), new Error(`Failed to get current seed: ${e}`);
  }
}
async function TB(t) {
  try {
    return (await Ie.get(
      `${vs}/api/game/data/${t}`
    )).data;
  } catch (e) {
    throw xs(e), new Error(`Failed to get current seed: ${e}`);
  }
}
const dm = {
  prefixSymbol: "",
  name: "",
  currencyCode: "",
  fractionalDigits: 0,
  crypto: !1,
  enabled: !0
}, yC = {
  isRoundActive: !1,
  id: null,
  currency: "",
  currencyDefinition: dm,
  wager: 0,
  betData: {
    mines: null
  },
  gameData: {
    selected: [],
    mineCount: 0,
    multiplier: 0
  }
}, kB = {
  minBet: "0",
  maxBet: "0"
}, RB = [{
  winAmount: 0,
  wagerAmount: 0,
  clientSeed: "",
  serverSeed: null,
  dateCreated: "",
  hash: "",
  nonce: 0,
  bet: "",
  result: ""
}], MB = {
  winAmount: 0,
  wagerAmount: 0,
  currency: "",
  clientSeed: "",
  hash: "",
  nonce: 0,
  dateCreated: "",
  betData: "",
  gameData: ""
}, PB = {
  balance: 0,
  isGameActive: !1,
  isFetching: !1,
  activeRoundData: yC,
  selectedCurrency: dm,
  pendingCurrency: null,
  selectedFiatCurrency: dm,
  betRanges: kB,
  initializing: !0,
  theme: "",
  isAutoPlaying: !1,
  isFinishingBet: !1,
  currentAutoBet: 0,
  isSoundMuted: !1,
  isHelpDialogOpen: !1,
  currentServerSeed: "",
  currentClientSeed: "",
  currentNonce: "0",
  newServerSeed: "",
  newClientSeed: "",
  newNonce: "0",
  isProvablyFairDialogOpen: !1,
  isLiveStatsOpen: !1,
  isLoadingCurrentSeed: !1,
  showFiat: !1,
  fiatConversionRates: {},
  isGameRoundResultOpen: !1,
  historyTables: RB,
  isLoadingHistory: !1,
  gameRoundData: MB,
  isLoadingGameRoundData: !1
}, st = ga((t, e) => ({
  // Initial state
  ...PB,
  // Actions
  setBalance: (n) => t({ balance: n }),
  setIsGameActive: (n) => {
    const { pendingCurrency: r } = e();
    if (!n && r) {
      console.log("Game ended, applying pending currency:", r), t({
        isGameActive: !1,
        selectedCurrency: r,
        pendingCurrency: null
      });
      return;
    }
    t({ isGameActive: n });
  },
  setIsFetching: (n) => t({ isFetching: n }),
  setActiveRoundData: (n) => t({ activeRoundData: n }),
  setCurrency: (n) => {
    const { isGameActive: r, selectedCurrency: s } = e();
    if (!r) {
      t({
        selectedCurrency: n,
        pendingCurrency: null
      });
      return;
    }
    console.log("Game active, storing currency update for later:", n), t({ pendingCurrency: n });
  },
  setBetRanges: (n) => t({ betRanges: n }),
  setInitializing: (n) => t({ initializing: n }),
  setTheme: (n) => t({ theme: n }),
  setIsAutoPlaying: (n) => t({ isAutoPlaying: n }),
  setIsFinishingBet: (n) => t({ isFinishingBet: n }),
  setCurrentAutoBet: (n) => t((r) => ({
    currentAutoBet: typeof n == "function" ? n(r.currentAutoBet) : n
  })),
  setIsSoundMuted: (n) => t({ isSoundMuted: n }),
  setIsHelpDialogOpen: (n) => t({ isHelpDialogOpen: n }),
  setCurrentServerSeed: (n) => t({ currentServerSeed: n }),
  setCurrentClientSeed: (n) => t({ currentClientSeed: n }),
  setCurrentNonce: (n) => t({ currentNonce: n }),
  setNewServerSeed: (n) => t({ newServerSeed: n }),
  setNewClientSeed: (n) => t({ newClientSeed: n }),
  setNewNonce: (n) => t({ newNonce: n }),
  setLiveStatsOpen: (n) => t({ isLiveStatsOpen: n }),
  applyPendingCurrency: () => {
    const { pendingCurrency: n } = e();
    n && t({
      selectedCurrency: n,
      pendingCurrency: null
    });
  },
  useNewSeeds: async (n) => {
    t({ isLoadingCurrentSeed: !0 });
    try {
      const r = e(), s = await vB(n, r.newClientSeed);
      t({
        currentServerSeed: s.hash,
        currentClientSeed: s.clientSeed,
        currentNonce: s.nonce.toString(),
        newServerSeed: s.nextHash,
        newClientSeed: "",
        newNonce: "0",
        isLoadingCurrentSeed: !1
      });
    } catch (r) {
      console.error("Failed to rotate seed:", r), t({ isLoadingCurrentSeed: !1 });
    }
  },
  setIsLoadingCurrentSeed: (n) => t({ isLoadingCurrentSeed: n }),
  fetchCurrentSeed: async (n) => {
    t({ isLoadingCurrentSeed: !0 });
    try {
      const r = await bB(n);
      t({
        currentServerSeed: r.hash,
        currentClientSeed: r.clientSeed,
        currentNonce: r.nonce.toString(),
        newServerSeed: r.nextHash,
        isLoadingCurrentSeed: !1
      });
    } catch (r) {
      console.error("Failed to fetch current seed:", r), t({ isLoadingCurrentSeed: !1 });
    }
  },
  setIsProvablyFairDialogOpen: (n) => t({ isProvablyFairDialogOpen: n }),
  finishAutoPlay: () => t({ isFinishingBet: !1, isAutoPlaying: !1 }),
  setFiatConversionRates: (n) => t({ fiatConversionRates: n }),
  setFiatCurrency: (n) => t({ selectedFiatCurrency: n }),
  setShowFiat: (n) => t({ showFiat: n }),
  setIsGameRoundResultDialogOpen: (n) => t({ isGameRoundResultOpen: n }),
  fetchHistory: async (n) => {
    t({ isLoadingHistory: !0 });
    try {
      const r = await _B(n);
      t({
        historyTables: r.items
      }), t({ isLoadingHistory: !1 });
    } catch (r) {
      console.error("Failed to fetch current seed:", r), t({ isLoadingHistory: !1 });
    }
  },
  resetSharedStates: () => t(() => ({
    activeRoundData: yC
  })),
  fetchGameRound: async (n) => {
    t({ isLoadingGameRoundData: !0 });
    try {
      const r = await TB(n);
      t({
        gameRoundData: r
      }), t({ isLoadingGameRoundData: !1 });
    } catch (r) {
      console.error("Failed to fetch current seed:", r), t({ isLoadingGameRoundData: !1 });
    }
  }
}));
function bC({ multiplier: t, amount: e }) {
  return /* @__PURE__ */ g.jsx("div", { className: "absolute inset-0 flex items-center justify-center z-20", children: /* @__PURE__ */ g.jsx("div", { className: "bg-primary rounded-md border-2 border-green-500 text-center animate-pop-in inline-flex flex-col justify-center", children: /* @__PURE__ */ g.jsx("div", { className: "px-4 py-3 select-none", children: t && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsxs("div", { className: "text-4xl font-extrabold text-green-500 leading-none mb-2", children: [
      t == null ? void 0 : t.toFixed(2),
      "x"
    ] }),
    /* @__PURE__ */ g.jsx("div", { className: "w-full h-px bg-green-500/30 mb-2" }),
    /* @__PURE__ */ g.jsxs("div", { className: "text-lg text-green-500 flex items-center justify-center font-extrabold", children: [
      "+",
      e
    ] })
  ] }) }) }) });
}
const IB = () => {
  const { result: t, totalProfit: e, multiplier: n } = XS(), { theme: r } = st(), s = () => {
    const o = {
      width: "80%",
      height: "80%",
      maxWidth: "300px",
      maxHeight: "300px",
      borderRadius: "50%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "2rem",
      fontWeight: "bold",
      color: "white",
      textTransform: "uppercase",
      boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)"
    };
    return t === "HEADS" ? { ...o, backgroundColor: "#FFD700" } : t === "TAILS" ? { ...o, backgroundColor: "#C0C0C0" } : { ...o, borderColor: "#ffffff", borderWidth: "2px" };
  }, i = fr();
  return /* @__PURE__ */ g.jsxs("div", { className: "w-full h-full flex items-center justify-center", children: [
    /* @__PURE__ */ g.jsx("div", { style: s(), children: t || "?" }),
    n !== 0 && e !== 0 && /* @__PURE__ */ g.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ g.jsx(bC, { multiplier: n, amount: e }) }),
    !i && /* @__PURE__ */ g.jsx(
      i1,
      {
        size: 600,
        duration: 8,
        colorFrom: r === "betpanda" ? "#1fe88a" : "#dc146e",
        colorTo: "#08080800",
        borderWidth: 1.5
      }
    )
  ] });
}, qt = E.forwardRef(
  ({ className: t, type: e, ...n }, r) => /* @__PURE__ */ g.jsx(
    "input",
    {
      type: e,
      className: de(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        t
      ),
      ref: r,
      ...n
    }
  )
);
qt.displayName = "Input";
var DB = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], ze = DB.reduce((t, e) => {
  const n = E.forwardRef((r, s) => {
    const { asChild: i, ...o } = r, a = i ? Ko : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ g.jsx(a, { ...o, ref: s });
  });
  return n.displayName = `Primitive.${e}`, { ...t, [e]: n };
}, {});
function vC(t, e) {
  t && Dg.flushSync(() => t.dispatchEvent(e));
}
var OB = "Label", xC = E.forwardRef((t, e) => /* @__PURE__ */ g.jsx(
  ze.label,
  {
    ...t,
    ref: e,
    onMouseDown: (n) => {
      var s;
      n.target.closest("button, input, select, textarea") || ((s = t.onMouseDown) == null || s.call(t, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
xC.displayName = OB;
var wC = xC;
const qB = yy(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
), St = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  wC,
  {
    ref: n,
    className: de(qB(), t),
    ...e
  }
));
St.displayName = wC.displayName;
const NB = "data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//PkAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAANAAAaQAAkJCQkJCQkNjY2NjY2NjZJSUlJSUlJSVtbW1tbW1ttbW1tbW1tbYCAgICAgICAkpKSkpKSkqSkpKSkpKSktra2tra2trbJycnJycnJ29vb29vb29vt7e3t7e3t7f////////8AAAAATGF2ZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGkC8X/5HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//PkZAAf2b0AAqw8AJqYpdn3RzAAWB/H8hyq4agaK6Ram6xGcO5ZlcP25Q/jD0E4BGZ0mtJnKWvb9wAM4C2AtgEYB2BDCRi5lzOiKf5bzrfF8C8BUACsAjAOwVYh5L1HH34CsQxkqxoeo1YrE4oFYyTKcnYagTAyGR4wHIQQTQDODnEzLmh6vZ52A01HOwIYhiGODeaCggp850PUavQ8uB0OEN+/3il73veG/fv3jx48ePHjyI/fv379+/fv3jx48ePHkSke973fv38d48ePHjx48iP379+/fv37948ePHjx48iP379+/fv396UpSlKU1u973ve8d48ePHjwAAw8PDw8AAAAAAw8PDw8AAAAAAw8PDw/UBgG5LdMMmf5588bg8EggVBeAGAGAWL3toIEIcmAAAEEEAQBAHwfB8HwcBAEPygIO/KAgchh/9APg+D4PgQEAQDEDg++j/ygIBgHwfB8HygIAgGI8Hw/QoMf/5dAIAgCEeD4PvlAQOYnD6rDCAwKAyqBDVRbNfoL/MPAoIMppY3m0of/mCw8ZaGRluvGW83/mEsAWYIoNhh0BJGEEROYpRihmepS/5YhIMNIFpWowMgHjALALPHBKQy2RmzImFyMUoDMrhG//KgDhgQA//PkZGEsydkgAs54ACJ5rdQBlbAAEFACoXAIMB4AgxcwCjE2BGMPoJcw5wgjCqAz///wgDxFYwHgCggDxcQOAQML4KswbwljBGBvMG4JcwHwlgqDf///+EAeLjSICAFGLooBAChgZBBmAUDcYGYN4UBbMDIEYwRwWzALAz////9FfJTj/XB3/MEYDIwRwRzAfALMEYAowRwMwgD8wMgCjAzAfCAP///////////1//4QB4YD4BaK4QAoiuo2ioo2o2o0o2ir////////+v///X/v/1/qNKNoqqNKNqNqNIrqNoqIrqcqcIrorBACv//////////7/WX///r///////0VgFmA+A8YNwIxgZgjmBkA+FQClG0VVGlG/8GF4DLxf7gYtXwGLV/giFwOIDDAFgDBYQcDF8ZoDM2nfCPlAMOgLBlgGAmIgedk7AZURfgZBhfAwXwMd51PwYL8DDoCwDDoC0DDqCwGAs/SfgYdAWgYLQWAYLAWgYLAWhEFgRBb//AwWAtCILAiC0IgtAwWAsAwWgtCILf//BgLAMFoLYMBYDAW1f////////90VcvggsCQA5OIwDgCvMDgAlxYBxMEHCuDD2w7ww7EXqMo/5fgMWTJbQMY0DeQMFEAigME//PkZDsUUbsMAO/cABz7VaAD17AAHBGAMEHAyAGALMDAMgD8DAOACEMCCNAbiEbf//npd//oNUyQ+j3///8/8/1f/8slv////////y1//+RUio3Q9UAkAOAwCEA4AwHcCoAwFkREAwA8AIAqAHAYBCAQAYAcAEiaFgtkWrD///hEBvAwG4BvgYH2EKAYZaFQAYVCJoAZA3ZoAcRfHgc0FQgY/A3AYbx9AY+w3IgYbg3gYbg3mL///wiG7//X//9+zf/wiG/t1frvhENyP1b6/stFf3/2b/+EQ3fX8GBv//qwYG+BhvDcBhvZYuv/9+79akxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq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", LB = "data:audio/mpeg;base64,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", jB = "data:audio/mpeg;base64,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x5riuJYyxljyUECT8ggOWsLQCvtVgWbeGHHhTFlM+/k3nIKCS3qanmfllSGHYkMgm4P1K37ZJGXCVRL4sRiTPUwX9pZX9LhH4zyTWOXavL8np8qGzj3sMOxLOxOH71SzYpL3/////////6wucQhqGY0/0zDUBw8f/lAkkPBMCk1VKzbu8nbeKlvdHYaAgCAQ6oo+D1hQCH2ClwlpHixmAgAtGxLCBobAMWuIjBINKwY8IDDQUATElQUpTNqE35VrBhhdNerLUtVVktHlMVZmlxcqRRmCqnibIWuvc5LLx4ZaNE+zGFtImshgaGotACQbzK4U0byIOVKHbTBZ1D8Zik/g8jM4DehHtZ9qVblcZjNmWODJo08aJSYqvYDazalkopJU4DiPfGHElNLW5KmRXqCN8n6eQ41M4ai7O3nllDSYWHjf9la74mymQqypIwRyRKZJGtAjFFD/bkptXqkdvxehf+fxhu52tep3bb+J5rmjMed7kWYFSyaD7sMswe2L4T+diluQRP2aSxZxqWpZylf9gkU5FJZZvbq//////////ulx9n6pp6O5XaXmWX/////////9ntX99/eGVhY3mTfdTN5mEAAFCpIh4DWYxgCFICSzqPKYxjEn0o6XFaYzaGX8FegEgbB80oHIqKrQcjhZimZyQ5NhiUsVFTYOloaaX1hnWA6Bs6sLHCCIvtLEmlCxzSrT/K7bcrqqszTUrRQqkiqjAbB8cUHQjKUDYRiRUbRQs5qkiodB9arTM1MzNJKwSKisEiqyvHs1rRRyrRRQsLDAqEgaDgNPWEg0mHfyKPuXubETbooCEIBgZIKrApiOlio+GBUOQCrELNMzQA2JNA0CklAEICYfkViUmuSTUm7WtptORNadO1rW7paxsO5qHXomtcOlukeRpzvRJtS1rdzade2kr/////lrZadqW1Lfcida33Xba/na1sftc6+t1t///mnW7h3LalFvKNondGpNTUqNEQlAIwO9n8qqDmAAAFIlVXyAAAAH0d4MC6KP/////////q1sd//29SZMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uQZDAP8DoASqAAAAoYgFioPSEAAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq", BB = "data:audio/mpeg;base64,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";
let qs = null;
const Cd = {}, FB = {
  diamond: NB,
  bomb: LB,
  tick: jB,
  win: BB
};
async function VB(t, e) {
  if (!qs) {
    if (!(window.AudioContext || window.webkitAudioContext)) {
      console.error("AudioContext is not supported in this browser");
      return;
    }
    qs = new AudioContext();
  }
  if (!Cd[t])
    try {
      const r = await (await fetch(e)).arrayBuffer(), s = await qs.decodeAudioData(r);
      Cd[t] = s;
    } catch (n) {
      console.error(`Failed to load sound ${t}:`, n);
    }
}
async function AC() {
  await Promise.all(Object.entries(FB).map(([t, e]) => VB(t, e)));
}
function qn(t, e = {}) {
  const n = st.getState().isSoundMuted;
  if (!qs || !Cd[t] || n) return;
  const r = qs.createBufferSource();
  if (r.buffer = Cd[t], e.pitch !== void 0) {
    const s = Math.max(0.1, Math.min(4, e.pitch));
    r.playbackRate.value = s;
  }
  if (e.volume !== void 0) {
    const s = qs.createGain();
    s.gain.value = Math.max(0, Math.min(1, e.volume)), r.connect(s), s.connect(qs.destination);
  } else
    r.connect(qs.destination);
  return r.start(), r;
}
var Le;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function n(s) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (s) => {
    const i = {};
    for (const o of s)
      i[o] = o;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), o = {};
    for (const a of i)
      o[a] = s[a];
    return t.objectValues(o);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
    return i;
  }, t.find = (s, i) => {
    for (const o of s)
      if (i(o))
        return o;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, i = " | ") {
    return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(Le || (Le = {}));
var fm;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
    // second overwrites first
  });
})(fm || (fm = {}));
const J = Le.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Ns = (t) => {
  switch (typeof t) {
    case "undefined":
      return J.undefined;
    case "string":
      return J.string;
    case "number":
      return isNaN(t) ? J.nan : J.number;
    case "boolean":
      return J.boolean;
    case "function":
      return J.function;
    case "bigint":
      return J.bigint;
    case "symbol":
      return J.symbol;
    case "object":
      return Array.isArray(t) ? J.array : t === null ? J.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? J.promise : typeof Map < "u" && t instanceof Map ? J.map : typeof Set < "u" && t instanceof Set ? J.set : typeof Date < "u" && t instanceof Date ? J.date : J.object;
    default:
      return J.unknown;
  }
}, W = Le.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), UB = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class Vn extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, r = { _errors: [] }, s = (i) => {
      for (const o of i.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(s);
        else if (o.code === "invalid_return_type")
          s(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          s(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let a = r, c = 0;
          for (; c < o.path.length; ) {
            const l = o.path[c];
            c === o.path.length - 1 ? (a[l] = a[l] || { _errors: [] }, a[l]._errors.push(n(o))) : a[l] = a[l] || { _errors: [] }, a = a[l], c++;
          }
        }
    };
    return s(this), r;
  }
  static assert(e) {
    if (!(e instanceof Vn))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Le.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(e(s))) : r.push(e(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Vn.create = (t) => new Vn(t);
const $o = (t, e) => {
  let n;
  switch (t.code) {
    case W.invalid_type:
      t.received === J.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case W.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, Le.jsonStringifyReplacer)}`;
      break;
    case W.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Le.joinValues(t.keys, ", ")}`;
      break;
    case W.invalid_union:
      n = "Invalid input";
      break;
    case W.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Le.joinValues(t.options)}`;
      break;
    case W.invalid_enum_value:
      n = `Invalid enum value. Expected ${Le.joinValues(t.options)}, received '${t.received}'`;
      break;
    case W.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case W.invalid_return_type:
      n = "Invalid function return type";
      break;
    case W.invalid_date:
      n = "Invalid date";
      break;
    case W.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : Le.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case W.too_small:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
      break;
    case W.too_big:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
      break;
    case W.custom:
      n = "Invalid input";
      break;
    case W.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case W.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case W.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = e.defaultError, Le.assertNever(t);
  }
  return { message: n };
};
let SC = $o;
function WB(t) {
  SC = t;
}
function _d() {
  return SC;
}
const Td = (t) => {
  const { data: e, path: n, errorMaps: r, issueData: s } = t, i = [...n, ...s.path || []], o = {
    ...s,
    path: i
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: i,
      message: s.message
    };
  let a = "";
  const c = r.filter((l) => !!l).slice().reverse();
  for (const l of c)
    a = l(o, { data: e, defaultError: a }).message;
  return {
    ...s,
    path: i,
    message: a
  };
}, zB = [];
function Q(t, e) {
  const n = _d(), r = Td({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      n,
      n === $o ? void 0 : $o
      // then global default map
    ].filter((s) => !!s)
  });
  t.common.issues.push(r);
}
class cn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return le;
      s.status === "dirty" && e.dirty(), r.push(s.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const s of n) {
      const i = await s.key, o = await s.value;
      r.push({
        key: i,
        value: o
      });
    }
    return cn.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const s of n) {
      const { key: i, value: o } = s;
      if (i.status === "aborted" || o.status === "aborted")
        return le;
      i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (r[i.value] = o.value);
    }
    return { status: e.value, value: r };
  }
}
const le = Object.freeze({
  status: "aborted"
}), Ro = (t) => ({ status: "dirty", value: t }), yn = (t) => ({ status: "valid", value: t }), hm = (t) => t.status === "aborted", pm = (t) => t.status === "dirty", qc = (t) => t.status === "valid", Nc = (t) => typeof Promise < "u" && t instanceof Promise;
function kd(t, e, n, r) {
  if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e.get(t);
}
function EC(t, e, n, r, s) {
  if (typeof e == "function" ? t !== e || !s : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(t, n), n;
}
var ne;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(ne || (ne = {}));
var sc, ic;
class Ir {
  constructor(e, n, r, s) {
    this._cachedPath = [], this.parent = e, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const lx = (t, e) => {
  if (qc(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Vn(t.common.issues);
      return this._error = n, this._error;
    }
  };
};
function Se(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: r, description: s } = t;
  if (e && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (o, a) => {
    var c, l;
    const { message: u } = t;
    return o.code === "invalid_enum_value" ? { message: u ?? a.defaultError } : typeof a.data > "u" ? { message: (c = u ?? r) !== null && c !== void 0 ? c : a.defaultError } : o.code !== "invalid_type" ? { message: a.defaultError } : { message: (l = u ?? n) !== null && l !== void 0 ? l : a.defaultError };
  }, description: s };
}
class Te {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Ns(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: Ns(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new cn(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Ns(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Nc(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ns(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return lx(s, i);
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ns(e)
    }, s = this._parse({ data: e, path: r.path, parent: r }), i = await (Nc(s) ? s : Promise.resolve(s));
    return lx(r, i);
  }
  refine(e, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, i) => {
      const o = e(s), a = () => i.addIssue({
        code: W.custom,
        ...r(s)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, s) => e(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1));
  }
  _refinement(e) {
    return new lr({
      schema: this,
      typeName: ae.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return kr.create(this, this._def);
  }
  nullable() {
    return Xs.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ar.create(this, this._def);
  }
  promise() {
    return Qo.create(this, this._def);
  }
  or(e) {
    return Fc.create([this, e], this._def);
  }
  and(e) {
    return Vc.create(this, e, this._def);
  }
  transform(e) {
    return new lr({
      ...Se(this._def),
      schema: this,
      typeName: ae.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new Yc({
      ...Se(this._def),
      innerType: this,
      defaultValue: n,
      typeName: ae.ZodDefault
    });
  }
  brand() {
    return new vy({
      typeName: ae.ZodBranded,
      type: this,
      ...Se(this._def)
    });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new Gc({
      ...Se(this._def),
      innerType: this,
      catchValue: n,
      typeName: ae.ZodCatch
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return vl.create(this, e);
  }
  readonly() {
    return Kc.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const HB = /^c[^\s-]{8,}$/i, YB = /^[0-9a-z]+$/, GB = /^[0-9A-HJKMNP-TV-Z]{26}$/, KB = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, $B = /^[a-z0-9_-]{21}$/i, ZB = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, QB = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, XB = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Zh;
const JB = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, e3 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, t3 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, CC = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", n3 = new RegExp(`^${CC}$`);
function _C(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function r3(t) {
  return new RegExp(`^${_C(t)}$`);
}
function TC(t) {
  let e = `${CC}T${_C(t)}`;
  const n = [];
  return n.push(t.local ? "Z?" : "Z"), t.offset && n.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${n.join("|")})`, new RegExp(`^${e}$`);
}
function s3(t, e) {
  return !!((e === "v4" || !e) && JB.test(t) || (e === "v6" || !e) && e3.test(t));
}
class ir extends Te {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== J.string) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: W.invalid_type,
        expected: J.string,
        received: i.parsedType
      }), le;
    }
    const r = new cn();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), Q(s, {
          code: W.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), Q(s, {
          code: W.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "length") {
        const o = e.data.length > i.value, a = e.data.length < i.value;
        (o || a) && (s = this._getOrReturnCtx(e, s), o ? Q(s, {
          code: W.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : a && Q(s, {
          code: W.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email")
        QB.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
          validation: "email",
          code: W.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "emoji")
        Zh || (Zh = new RegExp(XB, "u")), Zh.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
          validation: "emoji",
          code: W.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        KB.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
          validation: "uuid",
          code: W.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "nanoid")
        $B.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
          validation: "nanoid",
          code: W.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        HB.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
          validation: "cuid",
          code: W.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid2")
        YB.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
          validation: "cuid2",
          code: W.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "ulid")
        GB.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
          validation: "ulid",
          code: W.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), Q(s, {
            validation: "url",
            code: W.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        validation: "regex",
        code: W.invalid_string,
        message: i.message
      }), r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), r.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "datetime" ? TC(i).test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.invalid_string,
        validation: "datetime",
        message: i.message
      }), r.dirty()) : i.kind === "date" ? n3.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.invalid_string,
        validation: "date",
        message: i.message
      }), r.dirty()) : i.kind === "time" ? r3(i).test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.invalid_string,
        validation: "time",
        message: i.message
      }), r.dirty()) : i.kind === "duration" ? ZB.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        validation: "duration",
        code: W.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "ip" ? s3(e.data, i.version) || (s = this._getOrReturnCtx(e, s), Q(s, {
        validation: "ip",
        code: W.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64" ? t3.test(e.data) || (s = this._getOrReturnCtx(e, s), Q(s, {
        validation: "base64",
        code: W.invalid_string,
        message: i.message
      }), r.dirty()) : Le.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _regex(e, n, r) {
    return this.refinement((s) => e.test(s), {
      validation: n,
      code: W.invalid_string,
      ...ne.errToObj(r)
    });
  }
  _addCheck(e) {
    return new ir({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...ne.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...ne.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...ne.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...ne.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...ne.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...ne.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...ne.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...ne.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...ne.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...ne.errToObj(e) });
  }
  datetime(e) {
    var n, r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (n = e == null ? void 0 : e.offset) !== null && n !== void 0 ? n : !1,
      local: (r = e == null ? void 0 : e.local) !== null && r !== void 0 ? r : !1,
      ...ne.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ...ne.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...ne.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...ne.errToObj(n)
    });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n == null ? void 0 : n.position,
      ...ne.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...ne.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...ne.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...ne.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...ne.errToObj(n)
    });
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...ne.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e) {
    return this.min(1, ne.errToObj(e));
  }
  trim() {
    return new ir({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ir({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ir({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
ir.create = (t) => {
  var e;
  return new ir({
    checks: [],
    typeName: ae.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...Se(t)
  });
};
function i3(t, e) {
  const n = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, s = n > r ? n : r, i = parseInt(t.toFixed(s).replace(".", "")), o = parseInt(e.toFixed(s).replace(".", ""));
  return i % o / Math.pow(10, s);
}
class $s extends Te {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== J.number) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: W.invalid_type,
        expected: J.number,
        received: i.parsedType
      }), le;
    }
    let r;
    const s = new cn();
    for (const i of this._def.checks)
      i.kind === "int" ? Le.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? i3(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.not_finite,
        message: i.message
      }), s.dirty()) : Le.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ne.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ne.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ne.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ne.toString(n));
  }
  setLimit(e, n, r, s) {
    return new $s({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: ne.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new $s({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: ne.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ne.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ne.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ne.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ne.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ne.toString(n)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: ne.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ne.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ne.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Le.isInteger(e.value));
  }
  get isFinite() {
    let e = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
$s.create = (t) => new $s({
  checks: [],
  typeName: ae.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...Se(t)
});
class Zs extends Te {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== J.bigint) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: W.invalid_type,
        expected: J.bigint,
        received: i.parsedType
      }), le;
    }
    let r;
    const s = new cn();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), Q(r, {
        code: W.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : Le.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ne.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ne.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ne.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ne.toString(n));
  }
  setLimit(e, n, r, s) {
    return new Zs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: ne.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Zs({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ne.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ne.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ne.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ne.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ne.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
Zs.create = (t) => {
  var e;
  return new Zs({
    checks: [],
    typeName: ae.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...Se(t)
  });
};
class Lc extends Te {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== J.boolean) {
      const r = this._getOrReturnCtx(e);
      return Q(r, {
        code: W.invalid_type,
        expected: J.boolean,
        received: r.parsedType
      }), le;
    }
    return yn(e.data);
  }
}
Lc.create = (t) => new Lc({
  typeName: ae.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...Se(t)
});
class Ui extends Te {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== J.date) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: W.invalid_type,
        expected: J.date,
        received: i.parsedType
      }), le;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return Q(i, {
        code: W.invalid_date
      }), le;
    }
    const r = new cn();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), Q(s, {
        code: W.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : Le.assertNever(i);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Ui({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ne.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ne.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
Ui.create = (t) => new Ui({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: ae.ZodDate,
  ...Se(t)
});
class Rd extends Te {
  _parse(e) {
    if (this._getType(e) !== J.symbol) {
      const r = this._getOrReturnCtx(e);
      return Q(r, {
        code: W.invalid_type,
        expected: J.symbol,
        received: r.parsedType
      }), le;
    }
    return yn(e.data);
  }
}
Rd.create = (t) => new Rd({
  typeName: ae.ZodSymbol,
  ...Se(t)
});
class jc extends Te {
  _parse(e) {
    if (this._getType(e) !== J.undefined) {
      const r = this._getOrReturnCtx(e);
      return Q(r, {
        code: W.invalid_type,
        expected: J.undefined,
        received: r.parsedType
      }), le;
    }
    return yn(e.data);
  }
}
jc.create = (t) => new jc({
  typeName: ae.ZodUndefined,
  ...Se(t)
});
class Bc extends Te {
  _parse(e) {
    if (this._getType(e) !== J.null) {
      const r = this._getOrReturnCtx(e);
      return Q(r, {
        code: W.invalid_type,
        expected: J.null,
        received: r.parsedType
      }), le;
    }
    return yn(e.data);
  }
}
Bc.create = (t) => new Bc({
  typeName: ae.ZodNull,
  ...Se(t)
});
class Zo extends Te {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return yn(e.data);
  }
}
Zo.create = (t) => new Zo({
  typeName: ae.ZodAny,
  ...Se(t)
});
class Di extends Te {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return yn(e.data);
  }
}
Di.create = (t) => new Di({
  typeName: ae.ZodUnknown,
  ...Se(t)
});
class us extends Te {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return Q(n, {
      code: W.invalid_type,
      expected: J.never,
      received: n.parsedType
    }), le;
  }
}
us.create = (t) => new us({
  typeName: ae.ZodNever,
  ...Se(t)
});
class Md extends Te {
  _parse(e) {
    if (this._getType(e) !== J.undefined) {
      const r = this._getOrReturnCtx(e);
      return Q(r, {
        code: W.invalid_type,
        expected: J.void,
        received: r.parsedType
      }), le;
    }
    return yn(e.data);
  }
}
Md.create = (t) => new Md({
  typeName: ae.ZodVoid,
  ...Se(t)
});
class ar extends Te {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e), s = this._def;
    if (n.parsedType !== J.array)
      return Q(n, {
        code: W.invalid_type,
        expected: J.array,
        received: n.parsedType
      }), le;
    if (s.exactLength !== null) {
      const o = n.data.length > s.exactLength.value, a = n.data.length < s.exactLength.value;
      (o || a) && (Q(n, {
        code: o ? W.too_big : W.too_small,
        minimum: a ? s.exactLength.value : void 0,
        maximum: o ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), r.dirty());
    }
    if (s.minLength !== null && n.data.length < s.minLength.value && (Q(n, {
      code: W.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (Q(n, {
      code: W.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, a) => s.type._parseAsync(new Ir(n, o, n.path, a)))).then((o) => cn.mergeArray(r, o));
    const i = [...n.data].map((o, a) => s.type._parseSync(new Ir(n, o, n.path, a)));
    return cn.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new ar({
      ...this._def,
      minLength: { value: e, message: ne.toString(n) }
    });
  }
  max(e, n) {
    return new ar({
      ...this._def,
      maxLength: { value: e, message: ne.toString(n) }
    });
  }
  length(e, n) {
    return new ar({
      ...this._def,
      exactLength: { value: e, message: ne.toString(n) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ar.create = (t, e) => new ar({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ae.ZodArray,
  ...Se(e)
});
function xo(t) {
  if (t instanceof bt) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = kr.create(xo(r));
    }
    return new bt({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof ar ? new ar({
    ...t._def,
    type: xo(t.element)
  }) : t instanceof kr ? kr.create(xo(t.unwrap())) : t instanceof Xs ? Xs.create(xo(t.unwrap())) : t instanceof Dr ? Dr.create(t.items.map((e) => xo(e))) : t;
}
class bt extends Te {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = Le.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== J.object) {
      const l = this._getOrReturnCtx(e);
      return Q(l, {
        code: W.invalid_type,
        expected: J.object,
        received: l.parsedType
      }), le;
    }
    const { status: r, ctx: s } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof us && this._def.unknownKeys === "strip"))
      for (const l in s.data)
        o.includes(l) || a.push(l);
    const c = [];
    for (const l of o) {
      const u = i[l], d = s.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new Ir(s, d, s.path, l)),
        alwaysSet: l in s.data
      });
    }
    if (this._def.catchall instanceof us) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of a)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: s.data[u] }
          });
      else if (l === "strict")
        a.length > 0 && (Q(s, {
          code: W.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const u of a) {
        const d = s.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(
            new Ir(s, d, s.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of c) {
        const d = await u.key, f = await u.value;
        l.push({
          key: d,
          value: f,
          alwaysSet: u.alwaysSet
        });
      }
      return l;
    }).then((l) => cn.mergeObjectSync(r, l)) : cn.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return ne.errToObj, new bt({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var s, i, o, a;
          const c = (o = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = ne.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new bt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new bt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new bt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new bt({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: ae.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new bt({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return Le.objectKeys(e).forEach((r) => {
      e[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new bt({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return Le.objectKeys(this.shape).forEach((r) => {
      e[r] || (n[r] = this.shape[r]);
    }), new bt({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return xo(this);
  }
  partial(e) {
    const n = {};
    return Le.objectKeys(this.shape).forEach((r) => {
      const s = this.shape[r];
      e && !e[r] ? n[r] = s : n[r] = s.optional();
    }), new bt({
      ...this._def,
      shape: () => n
    });
  }
  required(e) {
    const n = {};
    return Le.objectKeys(this.shape).forEach((r) => {
      if (e && !e[r])
        n[r] = this.shape[r];
      else {
        let i = this.shape[r];
        for (; i instanceof kr; )
          i = i._def.innerType;
        n[r] = i;
      }
    }), new bt({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return kC(Le.objectKeys(this.shape));
  }
}
bt.create = (t, e) => new bt({
  shape: () => t,
  unknownKeys: "strip",
  catchall: us.create(),
  typeName: ae.ZodObject,
  ...Se(e)
});
bt.strictCreate = (t, e) => new bt({
  shape: () => t,
  unknownKeys: "strict",
  catchall: us.create(),
  typeName: ae.ZodObject,
  ...Se(e)
});
bt.lazycreate = (t, e) => new bt({
  shape: t,
  unknownKeys: "strip",
  catchall: us.create(),
  typeName: ae.ZodObject,
  ...Se(e)
});
class Fc extends Te {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = this._def.options;
    function s(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new Vn(a.ctx.common.issues));
      return Q(n, {
        code: W.invalid_union,
        unionErrors: o
      }), le;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
    {
      let i;
      const o = [];
      for (const c of r) {
        const l = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = c._parseSync({
          data: n.data,
          path: n.path,
          parent: l
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !i && (i = { result: u, ctx: l }), l.common.issues.length && o.push(l.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((c) => new Vn(c));
      return Q(n, {
        code: W.invalid_union,
        unionErrors: a
      }), le;
    }
  }
  get options() {
    return this._def.options;
  }
}
Fc.create = (t, e) => new Fc({
  options: t,
  typeName: ae.ZodUnion,
  ...Se(e)
});
const zr = (t) => t instanceof Wc ? zr(t.schema) : t instanceof lr ? zr(t.innerType()) : t instanceof zc ? [t.value] : t instanceof Qs ? t.options : t instanceof Hc ? Le.objectValues(t.enum) : t instanceof Yc ? zr(t._def.innerType) : t instanceof jc ? [void 0] : t instanceof Bc ? [null] : t instanceof kr ? [void 0, ...zr(t.unwrap())] : t instanceof Xs ? [null, ...zr(t.unwrap())] : t instanceof vy || t instanceof Kc ? zr(t.unwrap()) : t instanceof Gc ? zr(t._def.innerType) : [];
class Rf extends Te {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== J.object)
      return Q(n, {
        code: W.invalid_type,
        expected: J.object,
        received: n.parsedType
      }), le;
    const r = this.discriminator, s = n.data[r], i = this.optionsMap.get(s);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (Q(n, {
      code: W.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), le);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, n, r) {
    const s = /* @__PURE__ */ new Map();
    for (const i of n) {
      const o = zr(i.shape[e]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const a of o) {
        if (s.has(a))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
        s.set(a, i);
      }
    }
    return new Rf({
      typeName: ae.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: s,
      ...Se(r)
    });
  }
}
function mm(t, e) {
  const n = Ns(t), r = Ns(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === J.object && r === J.object) {
    const s = Le.objectKeys(e), i = Le.objectKeys(t).filter((a) => s.indexOf(a) !== -1), o = { ...t, ...e };
    for (const a of i) {
      const c = mm(t[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (n === J.array && r === J.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i], c = mm(o, a);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else return n === J.date && r === J.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Vc extends Te {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = (i, o) => {
      if (hm(i) || hm(o))
        return le;
      const a = mm(i.value, o.value);
      return a.valid ? ((pm(i) || pm(o)) && n.dirty(), { status: n.value, value: a.data }) : (Q(r, {
        code: W.invalid_intersection_types
      }), le);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, o]) => s(i, o)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Vc.create = (t, e, n) => new Vc({
  left: t,
  right: e,
  typeName: ae.ZodIntersection,
  ...Se(n)
});
class Dr extends Te {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== J.array)
      return Q(r, {
        code: W.invalid_type,
        expected: J.array,
        received: r.parsedType
      }), le;
    if (r.data.length < this._def.items.length)
      return Q(r, {
        code: W.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), le;
    !this._def.rest && r.data.length > this._def.items.length && (Q(r, {
      code: W.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...r.data].map((o, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new Ir(r, o, r.path, a)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(i).then((o) => cn.mergeArray(n, o)) : cn.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Dr({
      ...this._def,
      rest: e
    });
  }
}
Dr.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Dr({
    items: t,
    typeName: ae.ZodTuple,
    rest: null,
    ...Se(e)
  });
};
class Uc extends Te {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== J.object)
      return Q(r, {
        code: W.invalid_type,
        expected: J.object,
        received: r.parsedType
      }), le;
    const s = [], i = this._def.keyType, o = this._def.valueType;
    for (const a in r.data)
      s.push({
        key: i._parse(new Ir(r, a, r.path, a)),
        value: o._parse(new Ir(r, r.data[a], r.path, a)),
        alwaysSet: a in r.data
      });
    return r.common.async ? cn.mergeObjectAsync(n, s) : cn.mergeObjectSync(n, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, r) {
    return n instanceof Te ? new Uc({
      keyType: e,
      valueType: n,
      typeName: ae.ZodRecord,
      ...Se(r)
    }) : new Uc({
      keyType: ir.create(),
      valueType: e,
      typeName: ae.ZodRecord,
      ...Se(n)
    });
  }
}
class Pd extends Te {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== J.map)
      return Q(r, {
        code: W.invalid_type,
        expected: J.map,
        received: r.parsedType
      }), le;
    const s = this._def.keyType, i = this._def.valueType, o = [...r.data.entries()].map(([a, c], l) => ({
      key: s._parse(new Ir(r, a, r.path, [l, "key"])),
      value: i._parse(new Ir(r, c, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const l = await c.key, u = await c.value;
          if (l.status === "aborted" || u.status === "aborted")
            return le;
          (l.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(l.value, u.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of o) {
        const l = c.key, u = c.value;
        if (l.status === "aborted" || u.status === "aborted")
          return le;
        (l.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(l.value, u.value);
      }
      return { status: n.value, value: a };
    }
  }
}
Pd.create = (t, e, n) => new Pd({
  valueType: e,
  keyType: t,
  typeName: ae.ZodMap,
  ...Se(n)
});
class Wi extends Te {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== J.set)
      return Q(r, {
        code: W.invalid_type,
        expected: J.set,
        received: r.parsedType
      }), le;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (Q(r, {
      code: W.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (Q(r, {
      code: W.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function o(c) {
      const l = /* @__PURE__ */ new Set();
      for (const u of c) {
        if (u.status === "aborted")
          return le;
        u.status === "dirty" && n.dirty(), l.add(u.value);
      }
      return { status: n.value, value: l };
    }
    const a = [...r.data.values()].map((c, l) => i._parse(new Ir(r, c, r.path, l)));
    return r.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(e, n) {
    return new Wi({
      ...this._def,
      minSize: { value: e, message: ne.toString(n) }
    });
  }
  max(e, n) {
    return new Wi({
      ...this._def,
      maxSize: { value: e, message: ne.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Wi.create = (t, e) => new Wi({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: ae.ZodSet,
  ...Se(e)
});
class Lo extends Te {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== J.function)
      return Q(n, {
        code: W.invalid_type,
        expected: J.function,
        received: n.parsedType
      }), le;
    function r(a, c) {
      return Td({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          _d(),
          $o
        ].filter((l) => !!l),
        issueData: {
          code: W.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(a, c) {
      return Td({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          _d(),
          $o
        ].filter((l) => !!l),
        issueData: {
          code: W.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof Qo) {
      const a = this;
      return yn(async function(...c) {
        const l = new Vn([]), u = await a._def.args.parseAsync(c, i).catch((h) => {
          throw l.addIssue(r(c, h)), l;
        }), d = await Reflect.apply(o, this, u);
        return await a._def.returns._def.type.parseAsync(d, i).catch((h) => {
          throw l.addIssue(s(d, h)), l;
        });
      });
    } else {
      const a = this;
      return yn(function(...c) {
        const l = a._def.args.safeParse(c, i);
        if (!l.success)
          throw new Vn([r(c, l.error)]);
        const u = Reflect.apply(o, this, l.data), d = a._def.returns.safeParse(u, i);
        if (!d.success)
          throw new Vn([s(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Lo({
      ...this._def,
      args: Dr.create(e).rest(Di.create())
    });
  }
  returns(e) {
    return new Lo({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, r) {
    return new Lo({
      args: e || Dr.create([]).rest(Di.create()),
      returns: n || Di.create(),
      typeName: ae.ZodFunction,
      ...Se(r)
    });
  }
}
class Wc extends Te {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Wc.create = (t, e) => new Wc({
  getter: t,
  typeName: ae.ZodLazy,
  ...Se(e)
});
class zc extends Te {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return Q(n, {
        received: n.data,
        code: W.invalid_literal,
        expected: this._def.value
      }), le;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
zc.create = (t, e) => new zc({
  value: t,
  typeName: ae.ZodLiteral,
  ...Se(e)
});
function kC(t, e) {
  return new Qs({
    values: t,
    typeName: ae.ZodEnum,
    ...Se(e)
  });
}
class Qs extends Te {
  constructor() {
    super(...arguments), sc.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return Q(n, {
        expected: Le.joinValues(r),
        received: n.parsedType,
        code: W.invalid_type
      }), le;
    }
    if (kd(this, sc) || EC(this, sc, new Set(this._def.values)), !kd(this, sc).has(e.data)) {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return Q(n, {
        received: n.data,
        code: W.invalid_enum_value,
        options: r
      }), le;
    }
    return yn(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  extract(e, n = this._def) {
    return Qs.create(e, {
      ...this._def,
      ...n
    });
  }
  exclude(e, n = this._def) {
    return Qs.create(this.options.filter((r) => !e.includes(r)), {
      ...this._def,
      ...n
    });
  }
}
sc = /* @__PURE__ */ new WeakMap();
Qs.create = kC;
class Hc extends Te {
  constructor() {
    super(...arguments), ic.set(this, void 0);
  }
  _parse(e) {
    const n = Le.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== J.string && r.parsedType !== J.number) {
      const s = Le.objectValues(n);
      return Q(r, {
        expected: Le.joinValues(s),
        received: r.parsedType,
        code: W.invalid_type
      }), le;
    }
    if (kd(this, ic) || EC(this, ic, new Set(Le.getValidEnumValues(this._def.values))), !kd(this, ic).has(e.data)) {
      const s = Le.objectValues(n);
      return Q(r, {
        received: r.data,
        code: W.invalid_enum_value,
        options: s
      }), le;
    }
    return yn(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
ic = /* @__PURE__ */ new WeakMap();
Hc.create = (t, e) => new Hc({
  values: t,
  typeName: ae.ZodNativeEnum,
  ...Se(e)
});
class Qo extends Te {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== J.promise && n.common.async === !1)
      return Q(n, {
        code: W.invalid_type,
        expected: J.promise,
        received: n.parsedType
      }), le;
    const r = n.parsedType === J.promise ? n.data : Promise.resolve(n.data);
    return yn(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Qo.create = (t, e) => new Qo({
  type: t,
  typeName: ae.ZodPromise,
  ...Se(e)
});
class lr extends Te {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ae.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = this._def.effect || null, i = {
      addIssue: (o) => {
        Q(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
      const o = s.transform(r.data, i);
      if (r.common.async)
        return Promise.resolve(o).then(async (a) => {
          if (n.value === "aborted")
            return le;
          const c = await this._def.schema._parseAsync({
            data: a,
            path: r.path,
            parent: r
          });
          return c.status === "aborted" ? le : c.status === "dirty" || n.value === "dirty" ? Ro(c.value) : c;
        });
      {
        if (n.value === "aborted")
          return le;
        const a = this._def.schema._parseSync({
          data: o,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? le : a.status === "dirty" || n.value === "dirty" ? Ro(a.value) : a;
      }
    }
    if (s.type === "refinement") {
      const o = (a) => {
        const c = s.refinement(a, i);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? le : (a.status === "dirty" && n.dirty(), o(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? le : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!qc(o))
          return o;
        const a = s.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => qc(o) ? Promise.resolve(s.transform(o.value, i)).then((a) => ({ status: n.value, value: a })) : o);
    Le.assertNever(s);
  }
}
lr.create = (t, e, n) => new lr({
  schema: t,
  typeName: ae.ZodEffects,
  effect: e,
  ...Se(n)
});
lr.createWithPreprocess = (t, e, n) => new lr({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: ae.ZodEffects,
  ...Se(n)
});
class kr extends Te {
  _parse(e) {
    return this._getType(e) === J.undefined ? yn(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
kr.create = (t, e) => new kr({
  innerType: t,
  typeName: ae.ZodOptional,
  ...Se(e)
});
class Xs extends Te {
  _parse(e) {
    return this._getType(e) === J.null ? yn(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Xs.create = (t, e) => new Xs({
  innerType: t,
  typeName: ae.ZodNullable,
  ...Se(e)
});
class Yc extends Te {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === J.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Yc.create = (t, e) => new Yc({
  innerType: t,
  typeName: ae.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...Se(e)
});
class Gc extends Te {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Nc(s) ? s.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Vn(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Vn(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Gc.create = (t, e) => new Gc({
  innerType: t,
  typeName: ae.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...Se(e)
});
class Id extends Te {
  _parse(e) {
    if (this._getType(e) !== J.nan) {
      const r = this._getOrReturnCtx(e);
      return Q(r, {
        code: W.invalid_type,
        expected: J.nan,
        received: r.parsedType
      }), le;
    }
    return { status: "valid", value: e.data };
  }
}
Id.create = (t) => new Id({
  typeName: ae.ZodNaN,
  ...Se(t)
});
const o3 = Symbol("zod_brand");
class vy extends Te {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class vl extends Te {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? le : i.status === "dirty" ? (n.dirty(), Ro(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? le : s.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(e, n) {
    return new vl({
      in: e,
      out: n,
      typeName: ae.ZodPipeline
    });
  }
}
class Kc extends Te {
  _parse(e) {
    const n = this._def.innerType._parse(e), r = (s) => (qc(s) && (s.value = Object.freeze(s.value)), s);
    return Nc(n) ? n.then((s) => r(s)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Kc.create = (t, e) => new Kc({
  innerType: t,
  typeName: ae.ZodReadonly,
  ...Se(e)
});
function RC(t, e = {}, n) {
  return t ? Zo.create().superRefine((r, s) => {
    var i, o;
    if (!t(r)) {
      const a = typeof e == "function" ? e(r) : typeof e == "string" ? { message: e } : e, c = (o = (i = a.fatal) !== null && i !== void 0 ? i : n) !== null && o !== void 0 ? o : !0, l = typeof a == "string" ? { message: a } : a;
      s.addIssue({ code: "custom", ...l, fatal: c });
    }
  }) : Zo.create();
}
const a3 = {
  object: bt.lazycreate
};
var ae;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(ae || (ae = {}));
const c3 = (t, e = {
  message: `Input not instance of ${t.name}`
}) => RC((n) => n instanceof t, e), MC = ir.create, PC = $s.create, l3 = Id.create, u3 = Zs.create, IC = Lc.create, d3 = Ui.create, f3 = Rd.create, h3 = jc.create, p3 = Bc.create, m3 = Zo.create, g3 = Di.create, y3 = us.create, b3 = Md.create, v3 = ar.create, x3 = bt.create, w3 = bt.strictCreate, A3 = Fc.create, S3 = Rf.create, E3 = Vc.create, C3 = Dr.create, _3 = Uc.create, T3 = Pd.create, k3 = Wi.create, R3 = Lo.create, M3 = Wc.create, P3 = zc.create, I3 = Qs.create, D3 = Hc.create, O3 = Qo.create, ux = lr.create, q3 = kr.create, N3 = Xs.create, L3 = lr.createWithPreprocess, j3 = vl.create, B3 = () => MC().optional(), F3 = () => PC().optional(), V3 = () => IC().optional(), U3 = {
  string: (t) => ir.create({ ...t, coerce: !0 }),
  number: (t) => $s.create({ ...t, coerce: !0 }),
  boolean: (t) => Lc.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => Zs.create({ ...t, coerce: !0 }),
  date: (t) => Ui.create({ ...t, coerce: !0 })
}, W3 = le;
var De = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: $o,
  setErrorMap: WB,
  getErrorMap: _d,
  makeIssue: Td,
  EMPTY_PATH: zB,
  addIssueToContext: Q,
  ParseStatus: cn,
  INVALID: le,
  DIRTY: Ro,
  OK: yn,
  isAborted: hm,
  isDirty: pm,
  isValid: qc,
  isAsync: Nc,
  get util() {
    return Le;
  },
  get objectUtil() {
    return fm;
  },
  ZodParsedType: J,
  getParsedType: Ns,
  ZodType: Te,
  datetimeRegex: TC,
  ZodString: ir,
  ZodNumber: $s,
  ZodBigInt: Zs,
  ZodBoolean: Lc,
  ZodDate: Ui,
  ZodSymbol: Rd,
  ZodUndefined: jc,
  ZodNull: Bc,
  ZodAny: Zo,
  ZodUnknown: Di,
  ZodNever: us,
  ZodVoid: Md,
  ZodArray: ar,
  ZodObject: bt,
  ZodUnion: Fc,
  ZodDiscriminatedUnion: Rf,
  ZodIntersection: Vc,
  ZodTuple: Dr,
  ZodRecord: Uc,
  ZodMap: Pd,
  ZodSet: Wi,
  ZodFunction: Lo,
  ZodLazy: Wc,
  ZodLiteral: zc,
  ZodEnum: Qs,
  ZodNativeEnum: Hc,
  ZodPromise: Qo,
  ZodEffects: lr,
  ZodTransformer: lr,
  ZodOptional: kr,
  ZodNullable: Xs,
  ZodDefault: Yc,
  ZodCatch: Gc,
  ZodNaN: Id,
  BRAND: o3,
  ZodBranded: vy,
  ZodPipeline: vl,
  ZodReadonly: Kc,
  custom: RC,
  Schema: Te,
  ZodSchema: Te,
  late: a3,
  get ZodFirstPartyTypeKind() {
    return ae;
  },
  coerce: U3,
  any: m3,
  array: v3,
  bigint: u3,
  boolean: IC,
  date: d3,
  discriminatedUnion: S3,
  effect: ux,
  enum: I3,
  function: R3,
  instanceof: c3,
  intersection: E3,
  lazy: M3,
  literal: P3,
  map: T3,
  nan: l3,
  nativeEnum: D3,
  never: y3,
  null: p3,
  nullable: N3,
  number: PC,
  object: x3,
  oboolean: V3,
  onumber: F3,
  optional: q3,
  ostring: B3,
  pipeline: j3,
  preprocess: L3,
  promise: O3,
  record: _3,
  set: k3,
  strictObject: w3,
  string: MC,
  symbol: f3,
  transformer: ux,
  tuple: C3,
  undefined: h3,
  union: A3,
  unknown: g3,
  void: b3,
  NEVER: W3,
  ZodIssueCode: W,
  quotelessJson: UB,
  ZodError: Vn
}), z3 = 20, H3 = 1, zi = 1e6, dx = 1e6, Y3 = -7, G3 = 21, K3 = !1, xl = "[big.js] ", Ji = xl + "Invalid ", Mf = Ji + "decimal places", $3 = Ji + "rounding mode", DC = xl + "Division by zero", et = {}, Rr = void 0, Z3 = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function OC() {
  function t(e) {
    var n = this;
    if (!(n instanceof t)) return e === Rr ? OC() : new t(e);
    if (e instanceof t)
      n.s = e.s, n.e = e.e, n.c = e.c.slice();
    else {
      if (typeof e != "string") {
        if (t.strict === !0 && typeof e != "bigint")
          throw TypeError(Ji + "value");
        e = e === 0 && 1 / e < 0 ? "-0" : String(e);
      }
      Q3(n, e);
    }
    n.constructor = t;
  }
  return t.prototype = et, t.DP = z3, t.RM = H3, t.NE = Y3, t.PE = G3, t.strict = K3, t.roundDown = 0, t.roundHalfUp = 1, t.roundHalfEven = 2, t.roundUp = 3, t;
}
function Q3(t, e) {
  var n, r, s;
  if (!Z3.test(e))
    throw Error(Ji + "number");
  for (t.s = e.charAt(0) == "-" ? (e = e.slice(1), -1) : 1, (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (r = e.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +e.slice(r + 1), e = e.substring(0, r)) : n < 0 && (n = e.length), s = e.length, r = 0; r < s && e.charAt(r) == "0"; ) ++r;
  if (r == s)
    t.c = [t.e = 0];
  else {
    for (; s > 0 && e.charAt(--s) == "0"; ) ;
    for (t.e = n - r - 1, t.c = [], n = 0; r <= s; ) t.c[n++] = +e.charAt(r++);
  }
  return t;
}
function eo(t, e, n, r) {
  var s = t.c;
  if (n === Rr && (n = t.constructor.RM), n !== 0 && n !== 1 && n !== 2 && n !== 3)
    throw Error($3);
  if (e < 1)
    r = n === 3 && (r || !!s[0]) || e === 0 && (n === 1 && s[0] >= 5 || n === 2 && (s[0] > 5 || s[0] === 5 && (r || s[1] !== Rr))), s.length = 1, r ? (t.e = t.e - e + 1, s[0] = 1) : s[0] = t.e = 0;
  else if (e < s.length) {
    if (r = n === 1 && s[e] >= 5 || n === 2 && (s[e] > 5 || s[e] === 5 && (r || s[e + 1] !== Rr || s[e - 1] & 1)) || n === 3 && (r || !!s[0]), s.length = e, r) {
      for (; ++s[--e] > 9; )
        if (s[e] = 0, e === 0) {
          ++t.e, s.unshift(1);
          break;
        }
    }
    for (e = s.length; !s[--e]; ) s.pop();
  }
  return t;
}
function to(t, e, n) {
  var r = t.e, s = t.c.join(""), i = s.length;
  if (e)
    s = s.charAt(0) + (i > 1 ? "." + s.slice(1) : "") + (r < 0 ? "e" : "e+") + r;
  else if (r < 0) {
    for (; ++r; ) s = "0" + s;
    s = "0." + s;
  } else if (r > 0)
    if (++r > i)
      for (r -= i; r--; ) s += "0";
    else r < i && (s = s.slice(0, r) + "." + s.slice(r));
  else i > 1 && (s = s.charAt(0) + "." + s.slice(1));
  return t.s < 0 && n ? "-" + s : s;
}
et.abs = function() {
  var t = new this.constructor(this);
  return t.s = 1, t;
};
et.cmp = function(t) {
  var e, n = this, r = n.c, s = (t = new n.constructor(t)).c, i = n.s, o = t.s, a = n.e, c = t.e;
  if (!r[0] || !s[0]) return r[0] ? i : s[0] ? -o : 0;
  if (i != o) return i;
  if (e = i < 0, a != c) return a > c ^ e ? 1 : -1;
  for (o = (a = r.length) < (c = s.length) ? a : c, i = -1; ++i < o; )
    if (r[i] != s[i]) return r[i] > s[i] ^ e ? 1 : -1;
  return a == c ? 0 : a > c ^ e ? 1 : -1;
};
et.div = function(t) {
  var e = this, n = e.constructor, r = e.c, s = (t = new n(t)).c, i = e.s == t.s ? 1 : -1, o = n.DP;
  if (o !== ~~o || o < 0 || o > zi)
    throw Error(Mf);
  if (!s[0])
    throw Error(DC);
  if (!r[0])
    return t.s = i, t.c = [t.e = 0], t;
  var a, c, l, u, d, f = s.slice(), h = a = s.length, p = r.length, m = r.slice(0, a), y = m.length, b = t, v = b.c = [], w = 0, x = o + (b.e = e.e - t.e) + 1;
  for (b.s = i, i = x < 0 ? 0 : x, f.unshift(0); y++ < a; ) m.push(0);
  do {
    for (l = 0; l < 10; l++) {
      if (a != (y = m.length))
        u = a > y ? 1 : -1;
      else
        for (d = -1, u = 0; ++d < a; )
          if (s[d] != m[d]) {
            u = s[d] > m[d] ? 1 : -1;
            break;
          }
      if (u < 0) {
        for (c = y == a ? s : f; y; ) {
          if (m[--y] < c[y]) {
            for (d = y; d && !m[--d]; ) m[d] = 9;
            --m[d], m[y] += 10;
          }
          m[y] -= c[y];
        }
        for (; !m[0]; ) m.shift();
      } else
        break;
    }
    v[w++] = u ? l : ++l, m[0] && u ? m[y] = r[h] || 0 : m = [r[h]];
  } while ((h++ < p || m[0] !== Rr) && i--);
  return !v[0] && w != 1 && (v.shift(), b.e--, x--), w > x && eo(b, x, n.RM, m[0] !== Rr), b;
};
et.eq = function(t) {
  return this.cmp(t) === 0;
};
et.gt = function(t) {
  return this.cmp(t) > 0;
};
et.gte = function(t) {
  return this.cmp(t) > -1;
};
et.lt = function(t) {
  return this.cmp(t) < 0;
};
et.lte = function(t) {
  return this.cmp(t) < 1;
};
et.minus = et.sub = function(t) {
  var e, n, r, s, i = this, o = i.constructor, a = i.s, c = (t = new o(t)).s;
  if (a != c)
    return t.s = -c, i.plus(t);
  var l = i.c.slice(), u = i.e, d = t.c, f = t.e;
  if (!l[0] || !d[0])
    return d[0] ? t.s = -c : l[0] ? t = new o(i) : t.s = 1, t;
  if (a = u - f) {
    for ((s = a < 0) ? (a = -a, r = l) : (f = u, r = d), r.reverse(), c = a; c--; ) r.push(0);
    r.reverse();
  } else
    for (n = ((s = l.length < d.length) ? l : d).length, a = c = 0; c < n; c++)
      if (l[c] != d[c]) {
        s = l[c] < d[c];
        break;
      }
  if (s && (r = l, l = d, d = r, t.s = -t.s), (c = (n = d.length) - (e = l.length)) > 0) for (; c--; ) l[e++] = 0;
  for (c = e; n > a; ) {
    if (l[--n] < d[n]) {
      for (e = n; e && !l[--e]; ) l[e] = 9;
      --l[e], l[n] += 10;
    }
    l[n] -= d[n];
  }
  for (; l[--c] === 0; ) l.pop();
  for (; l[0] === 0; )
    l.shift(), --f;
  return l[0] || (t.s = 1, l = [f = 0]), t.c = l, t.e = f, t;
};
et.mod = function(t) {
  var e, n = this, r = n.constructor, s = n.s, i = (t = new r(t)).s;
  if (!t.c[0])
    throw Error(DC);
  return n.s = t.s = 1, e = t.cmp(n) == 1, n.s = s, t.s = i, e ? new r(n) : (s = r.DP, i = r.RM, r.DP = r.RM = 0, n = n.div(t), r.DP = s, r.RM = i, this.minus(n.times(t)));
};
et.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, t;
};
et.plus = et.add = function(t) {
  var e, n, r, s = this, i = s.constructor;
  if (t = new i(t), s.s != t.s)
    return t.s = -t.s, s.minus(t);
  var o = s.e, a = s.c, c = t.e, l = t.c;
  if (!a[0] || !l[0])
    return l[0] || (a[0] ? t = new i(s) : t.s = s.s), t;
  if (a = a.slice(), e = o - c) {
    for (e > 0 ? (c = o, r = l) : (e = -e, r = a), r.reverse(); e--; ) r.push(0);
    r.reverse();
  }
  for (a.length - l.length < 0 && (r = l, l = a, a = r), e = l.length, n = 0; e; a[e] %= 10) n = (a[--e] = a[e] + l[e] + n) / 10 | 0;
  for (n && (a.unshift(n), ++c), e = a.length; a[--e] === 0; ) a.pop();
  return t.c = a, t.e = c, t;
};
et.pow = function(t) {
  var e = this, n = new e.constructor("1"), r = n, s = t < 0;
  if (t !== ~~t || t < -dx || t > dx)
    throw Error(Ji + "exponent");
  for (s && (t = -t); t & 1 && (r = r.times(e)), t >>= 1, !!t; )
    e = e.times(e);
  return s ? n.div(r) : r;
};
et.prec = function(t, e) {
  if (t !== ~~t || t < 1 || t > zi)
    throw Error(Ji + "precision");
  return eo(new this.constructor(this), t, e);
};
et.round = function(t, e) {
  if (t === Rr) t = 0;
  else if (t !== ~~t || t < -zi || t > zi)
    throw Error(Mf);
  return eo(new this.constructor(this), t + this.e + 1, e);
};
et.sqrt = function() {
  var t, e, n, r = this, s = r.constructor, i = r.s, o = r.e, a = new s("0.5");
  if (!r.c[0]) return new s(r);
  if (i < 0)
    throw Error(xl + "No square root");
  i = Math.sqrt(+to(r, !0, !0)), i === 0 || i === 1 / 0 ? (e = r.c.join(""), e.length + o & 1 || (e += "0"), i = Math.sqrt(e), o = ((o + 1) / 2 | 0) - (o < 0 || o & 1), t = new s((i == 1 / 0 ? "5e" : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + o)) : t = new s(i + ""), o = t.e + (s.DP += 4);
  do
    n = t, t = a.times(n.plus(r.div(n)));
  while (n.c.slice(0, o).join("") !== t.c.slice(0, o).join(""));
  return eo(t, (s.DP -= 4) + t.e + 1, s.RM);
};
et.times = et.mul = function(t) {
  var e, n = this, r = n.constructor, s = n.c, i = (t = new r(t)).c, o = s.length, a = i.length, c = n.e, l = t.e;
  if (t.s = n.s == t.s ? 1 : -1, !s[0] || !i[0])
    return t.c = [t.e = 0], t;
  for (t.e = c + l, o < a && (e = s, s = i, i = e, l = o, o = a, a = l), e = new Array(l = o + a); l--; ) e[l] = 0;
  for (c = a; c--; ) {
    for (a = 0, l = o + c; l > c; )
      a = e[l] + i[c] * s[l - c - 1] + a, e[l--] = a % 10, a = a / 10 | 0;
    e[l] = a;
  }
  for (a ? ++t.e : e.shift(), c = e.length; !e[--c]; ) e.pop();
  return t.c = e, t;
};
et.toExponential = function(t, e) {
  var n = this, r = n.c[0];
  if (t !== Rr) {
    if (t !== ~~t || t < 0 || t > zi)
      throw Error(Mf);
    for (n = eo(new n.constructor(n), ++t, e); n.c.length < t; ) n.c.push(0);
  }
  return to(n, !0, !!r);
};
et.toFixed = function(t, e) {
  var n = this, r = n.c[0];
  if (t !== Rr) {
    if (t !== ~~t || t < 0 || t > zi)
      throw Error(Mf);
    for (n = eo(new n.constructor(n), t + n.e + 1, e), t = t + n.e + 1; n.c.length < t; ) n.c.push(0);
  }
  return to(n, !1, !!r);
};
et[Symbol.for("nodejs.util.inspect.custom")] = et.toJSON = et.toString = function() {
  var t = this, e = t.constructor;
  return to(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0]);
};
et.toNumber = function() {
  var t = +to(this, !0, !0);
  if (this.constructor.strict === !0 && !this.eq(t.toString()))
    throw Error(xl + "Imprecise conversion");
  return t;
};
et.toPrecision = function(t, e) {
  var n = this, r = n.constructor, s = n.c[0];
  if (t !== Rr) {
    if (t !== ~~t || t < 1 || t > zi)
      throw Error(Ji + "precision");
    for (n = eo(new r(n), t, e); n.c.length < t; ) n.c.push(0);
  }
  return to(n, t <= n.e || n.e <= r.NE || n.e >= r.PE, !!s);
};
et.valueOf = function() {
  var t = this, e = t.constructor;
  if (e.strict === !0)
    throw Error(xl + "valueOf disallowed");
  return to(t, t.e <= e.NE || t.e >= e.PE, !0);
};
var fx = OC();
class Us {
  static format(e, n, r) {
    switch (n) {
      case "USD":
        return "$" + e.toFixed(r);
      case "EUR":
        return "" + e.toFixed(r);
      default:
        return `${n} ${e.toFixed(r)}`;
    }
  }
  static formatWithSymbol(e, n, r) {
    if (typeof n > "u" || e === void 0)
      return "";
    const s = typeof n == "number" ? new fx(n) : n, i = e.prefixSymbol ?? "", o = r ? "" : e.postfixSymbol ?? "";
    return `${i}${s.toFixed(e.fractionalDigits ?? 2)}${o}`;
  }
  static jackpotFormat(e, n) {
    if (typeof n > "u" || e === void 0)
      return "";
    const i = (typeof n == "number" ? new fx(n) : n).toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    return `${e.prefixSymbol ?? ""}${i}${e.postfixSymbol ?? ""}`;
  }
  static currencySymbol(e) {
    switch (e) {
      case "USD":
        return "$";
      case "EUR":
        return "";
      case "mBTC":
        return "m";
      case "uBTC":
        return "u";
      default:
        return e ?? "";
    }
  }
  static convertCurrency(e, n, r, s) {
    if (n === r) return e;
    const i = s[`${n}_${r}`];
    return i ? e * i : (console.error(`Conversion rate not found for ${n} to ${r}`), e);
  }
  static reverseConvertCurrency(e, n, r, s) {
    if (n === r) return e;
    const i = s[`${r}_${n}`];
    return i ? e / i : (console.error(`Reverse conversion rate not found for ${n} to ${r}`), e);
  }
}
const hx = {
  mode: "manual",
  betAmount: 0,
  coinSide: "HEADS",
  stopOnWin: 0,
  stopOnLoss: 0,
  numberOfBets: "",
  onWinMode: "reset",
  onLossMode: "reset",
  onWinValue: 0,
  onLossValue: 0
}, gm = ga((t, e) => ({
  ...hx,
  errors: {},
  updateSettings: (n) => t((r) => {
    const s = { ...r, ...n };
    return n.onWinMode === "reset" && r.onWinMode !== "reset" && (s.onWinValue = 0), n.onLossMode === "reset" && r.onLossMode !== "reset" && (s.onLossValue = 0), s;
  }),
  resetSettings: () => t(hx),
  validateSettings: () => {
    const { betRanges: n, selectedCurrency: r, balance: s, selectedFiatCurrency: i, fiatConversionRates: o, showFiat: a } = st.getState(), c = e(), l = (m) => Us.convertCurrency(Number(m), r.currencyCode, i.code, o), u = r.crypto && i && a ? l(Number(n.minBet)).toFixed(i.fractionalDigits) : parseFloat(n.minBet).toFixed(r.fractionalDigits), d = r.crypto && i && a ? l(Number(n.maxBet)).toFixed(i.fractionalDigits) : parseFloat(n.maxBet).toFixed(r.fractionalDigits), f = r.crypto && i && a ? i.prefixSymbol : r.prefixSymbol, h = r.crypto && i && a ? l(Number(s)).toFixed(i.fractionalDigits) : s.toFixed(r.fractionalDigits), p = De.object({
      mode: De.enum(["manual", "auto"]),
      betAmount: De.union([
        // Allow any representation of zero (0, 0.00, etc) but not negative
        De.number().min(0).max(0, `Your bet must be at least ${f} ${u}`),
        // Handle all other positive values with the original constraints
        De.number().min(Number(u), `Your bet must be at least ${f} ${u}`).max(Number(d), `Your bet can max be ${f} ${d}`).max(Number(h), "You don't have enough balance.")
      ]),
      coinSide: De.enum(["HEADS", "TAILS", "EDGE"]),
      stopOnWin: De.number().nonnegative("Stop on win must be non-negative").max(Number(h), "You don't have enough balance."),
      stopOnLoss: De.number().nonnegative("Stop on loss must be non-negative"),
      numberOfBets: De.union([
        De.literal(""),
        De.string().refine(
          (m) => !isNaN(Number(m)) && Number(m) > 0 && Number(m) <= 1e3,
          {
            message: "Number of bets must be a positive number up to 1000 or ''"
          }
        ),
        De.number().int().positive().max(1e3, "Maximum 1000")
      ]).transform((m) => m === "" ? m : Number(m)),
      onWinMode: De.enum(["reset", "increase"]),
      onLossMode: De.enum(["reset", "increase"]),
      onWinValue: De.number().nonnegative("Cannot be less than 0"),
      onLossValue: De.number().nonnegative("Cannot be less than 0")
    });
    try {
      return p.parse(c), t({ errors: {} }), !0;
    } catch (m) {
      if (m instanceof De.ZodError) {
        const y = {};
        m.issues.forEach((b) => {
          b.path[0] && (y[b.path[0]] = b.message, console.log("newErrors", b.message));
        }), t({ errors: y });
      }
      return !1;
    }
  },
  setErrors: (n) => t({ errors: n })
}));
function gc({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ g.jsx(
    "div",
    {
      className: de("animate-pulse rounded-md bg-muted", t),
      ...e
    }
  );
}
function qC({
  betAmount: t,
  onBetAmountChange: e,
  initializing: n,
  isDisabled: r,
  error: s,
  betRanges: i
}) {
  var k, R;
  const {
    selectedCurrency: o,
    selectedFiatCurrency: a,
    fiatConversionRates: c,
    showFiat: l
  } = st(), u = Et(null), d = Je(
    (P) => {
      const M = o.crypto && a && l ? a : o;
      return P.toFixed(M.fractionalDigits);
    },
    [o, a, l]
  ), f = Je(
    (P) => Us.convertCurrency(
      P,
      o.currencyCode,
      (a == null ? void 0 : a.code) || "",
      c
    ),
    [o, a, c]
  ), h = Je(
    (P) => Us.reverseConvertCurrency(
      P,
      (a == null ? void 0 : a.code) || "",
      o.currencyCode,
      c
    ),
    [o, a, c]
  ), [p, m] = Ge(() => {
    const P = Math.max(t);
    return d(P);
  }), [y, b] = Ge(!1);
  _e(() => {
    m(d(t));
  }, [t]), _e(() => {
    if (!n && u.current) {
      u.current.focus();
      const P = Number(i.minBet), M = o.crypto && a && l ? f(P) : P;
      m(d(M));
    }
  }, [n]);
  const v = (P) => {
    m(P.target.value);
  }, w = () => {
    const P = Math.max(parseFloat(p));
    isNaN(P) || (e(P), m(d(P))), b(!1);
  }, x = (P) => {
    const M = Number(p) * P;
    e(M), m(d(M));
  }, A = `
    flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200
    ${y ? "ring-1 ring-brand" : ""}
  `, C = "flex-grow bg-transparent border-none text-white text-base h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0", S = "h-9 w-16 px-2 text-sm bg-pills text-white hover:bg-opacity-80 font-bold", _ = o.crypto && a && l ? a.code : o.currencyCode, T = Je(() => {
    const P = o.crypto && a && l ? a.fractionalDigits : o.fractionalDigits;
    return P <= 0 ? "1" : `0.${"0".repeat(P - 1)}1`;
  }, [o, a, l]);
  return /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
    /* @__PURE__ */ g.jsxs(
      St,
      {
        htmlFor: "betAmount",
        className: "text-sm text-gray-400 flex justify-between",
        children: [
          /* @__PURE__ */ g.jsx("span", { children: "Bet Amount" }),
          o.crypto && a && /* @__PURE__ */ g.jsx("span", { children: l ? /* @__PURE__ */ g.jsxs("div", { className: "flex flex-row items-center justify-center gap-1", children: [
            /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container", children: /* @__PURE__ */ g.jsx(
              "i",
              {
                className: "currency-icon currency-icon-" + ((k = o.currencyCode) == null ? void 0 : k.toLowerCase())
              }
            ) }),
            h(Number(p)).toFixed(
              o.fractionalDigits
            )
          ] }) : /* @__PURE__ */ g.jsxs("div", { className: "flex flex-row items-center justify-center gap-1", children: [
            /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container", children: /* @__PURE__ */ g.jsx(
              "i",
              {
                className: "currency-icon currency-icon-" + ((R = a.code) == null ? void 0 : R.toLowerCase())
              }
            ) }),
            " $",
            f(
              Number(p)
            ).toFixed(a.fractionalDigits)
          ] }) })
        ]
      }
    ),
    /* @__PURE__ */ g.jsx("div", { className: A, children: n ? /* @__PURE__ */ g.jsxs("div", { className: "flex items-center w-full space-x-2", children: [
      /* @__PURE__ */ g.jsx(gc, { className: "h-9 w-full bg-gray-700" }),
      /* @__PURE__ */ g.jsx(gc, { className: "h-9 w-16 bg-gray-700" }),
      /* @__PURE__ */ g.jsx(gc, { className: "h-9 w-16 bg-gray-700" })
    ] }) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsxs("div", { className: "flex items-center w-full bg-primary rounded-md px-2", children: [
        /* @__PURE__ */ g.jsx("span", { children: /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container mr-1 mb-2", children: /* @__PURE__ */ g.jsx(
          "i",
          {
            className: "currency-icon w-[20px] h-[20px] currency-icon-" + (_ == null ? void 0 : _.toLowerCase())
          }
        ) }) }),
        /* @__PURE__ */ g.jsx(
          qt,
          {
            id: "betAmount",
            type: "number",
            value: p,
            onChange: v,
            onFocus: () => b(!0),
            onBlur: w,
            className: C,
            style: { WebkitAppearance: "none", MozAppearance: "textfield" },
            step: T(),
            disabled: r,
            ref: u
          }
        )
      ] }),
      /* @__PURE__ */ g.jsx(
        pt,
        {
          variant: "secondary",
          size: "sm",
          className: S,
          onClick: () => x(0),
          disabled: r,
          children: "0"
        }
      ),
      /* @__PURE__ */ g.jsx(
        pt,
        {
          variant: "secondary",
          size: "sm",
          className: S,
          onClick: () => x(0.5),
          disabled: r,
          children: ""
        }
      ),
      /* @__PURE__ */ g.jsx(
        pt,
        {
          variant: "secondary",
          size: "sm",
          className: S,
          onClick: () => x(2),
          disabled: r,
          children: "2"
        }
      )
    ] }) }),
    s && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: s })
  ] });
}
const wl = () => {
  const { selectedCurrency: t, selectedFiatCurrency: e, showFiat: n } = st();
  return Je((s) => {
    if (t.crypto && e && n) {
      if (!e.code) return `${s}`;
      switch (e.code) {
        case "USD":
          return `$${s.toFixed(e.fractionalDigits)}`;
        case "EUR":
          return `${s.toFixed(e.fractionalDigits)}`;
        default:
          return `${e.code} ${s.toFixed(e.fractionalDigits)}`;
      }
    } else {
      if (!t.currencyCode) return `${s}`;
      switch (t.currencyCode) {
        case "USD":
          return `$${s.toFixed(t.fractionalDigits)}`;
        case "EUR":
          return `${s.toFixed(t.fractionalDigits)}`;
        default:
          return `${t.currencyCode} ${s.toFixed(t.fractionalDigits)}`;
      }
    }
  }, [t, e, n]);
};
function X3({ handleStartGame: t }) {
  const {
    isGameActive: e,
    selectedCurrency: n,
    selectedFiatCurrency: r,
    initializing: s,
    isAutoPlaying: i,
    currentAutoBet: o,
    setIsAutoPlaying: a,
    setIsFinishingBet: c,
    betRanges: l,
    fiatConversionRates: u,
    showFiat: d
  } = st(), {
    updateSettings: f,
    mode: h,
    betAmount: p,
    stopOnWin: m,
    stopOnLoss: y,
    numberOfBets: b,
    onWinMode: v,
    onLossMode: w,
    onWinValue: x,
    onLossValue: A,
    coinSide: C,
    errors: S,
    validateSettings: _
  } = gm(), [T, k] = Ge(null), { addToast: R } = Aa(), P = (G, $, fe = !1) => {
    fe && qn("tick"), f({ [G]: $ });
  }, M = () => {
    i ? (a(!1), c(!0), R({
      variant: "notice",
      message: "Stopping Autoplay...",
      duration: 2e3
    })) : _() && t();
  }, D = () => i ? b === "" ? Nt("blink.common.stopAutoBet") : `${Nt(
    "blink.common.stopAutoBet"
  )} (${o} / ${b})` : Nt(h === "auto" ? "blink.common.startAutoBet" : e ? "blink.cointoss.flipping" : "blink.common.placeBet"), O = (G) => `
      flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200
      ${T === G ? "ring-1 ring-brand" : ""}`, q = "flex-grow bg-transparent border-none text-white text-base h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0", L = "h-9 w-16 px-2 text-sm bg-pills text-white hover:bg-opacity-80 font-bold", N = "flex items-center space-x-1 bg-primary rounded-md p-1 h-11 w-1/2", j = "flex-1 px-1 py-2 rounded text-xs font-bold whitespace-nowrap overflow-hidden", V = e || i, Z = wl();
  return /* @__PURE__ */ g.jsxs("div", { className: "bg-secondary flex flex-col no-scrollbar w-full lg:w-1/3 p-4 space-y-4 order-2 lg:order-1 overflow-y-auto", children: [
    /* @__PURE__ */ g.jsxs(
      "div",
      {
        className: `bg-primary order-last lg:order-first p-2 rounded-md flex mt-4 lg:mb-4 lg:mt-0 ${V ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ g.jsx(
            "button",
            {
              onClick: () => P("mode", "manual", !0),
              disabled: e && h !== "manual",
              className: `flex-1 py-2 px-4 text-sm font-bold rounded-md transition-all ${h === "manual" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: Nt("blink.common.manual")
            }
          ),
          /* @__PURE__ */ g.jsx(
            "button",
            {
              onClick: () => P("mode", "auto", !0),
              disabled: e && h !== "auto",
              className: `flex-1 py-2 px-4 text-sm font-bold rounded-md transition-all ${h === "auto" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: Nt("blink.common.auto")
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ g.jsx(
      "div",
      {
        className: `space-y-2 ${V ? "opacity-50 pointer-events-none" : ""}`,
        children: /* @__PURE__ */ g.jsx(
          qC,
          {
            betAmount: p,
            onBetAmountChange: (G) => P("betAmount", G),
            selectedCurrency: n,
            selectedFiatCurrency: r,
            fiatConversionRates: u,
            initializing: s,
            isDisabled: V,
            error: S.betAmount,
            betRanges: l,
            showFiat: d
          }
        )
      }
    ),
    /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ g.jsx(St, { className: "text-sm text-gray-400", children: "Coin Side" }),
      /* @__PURE__ */ g.jsx("div", { className: "flex items-center space-x-2 w-full", children: /* @__PURE__ */ g.jsxs("div", { className: `${N} w-full`, children: [
        /* @__PURE__ */ g.jsx(
          "button",
          {
            onClick: () => P("coinSide", "HEADS", !0),
            className: `${j} ${C === "HEADS" ? "bg-pills text-white" : "text-gray-400"}`,
            children: Nt("blink.cointoss.heads")
          }
        ),
        /* @__PURE__ */ g.jsx(
          "button",
          {
            onClick: () => P("coinSide", "EDGE", !0),
            className: `${j} ${C === "EDGE" ? "bg-pills text-white" : "text-gray-400"}`,
            children: Nt("blink.cointoss.edge")
          }
        ),
        /* @__PURE__ */ g.jsx(
          "button",
          {
            onClick: () => P("coinSide", "TAILS", !0),
            className: `${j} ${C === "TAILS" ? "bg-pills text-white" : "text-gray-400"}`,
            children: Nt("blink.cointoss.tails")
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ g.jsx(
      "div",
      {
        className: "space-y-4 transition-all duration-300 ease-in-out",
        style: {
          maxHeight: h === "auto" ? "100%" : "0%",
          overflow: h === "auto" ? "visible" : "hidden"
        },
        children: h === "auto" && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsxs(
            "div",
            {
              className: `space-y-2 ${V ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ g.jsx(St, { htmlFor: "numberOfBets", className: "text-sm text-gray-400", children: Nt("blink.common.numberOfBets") }),
                /* @__PURE__ */ g.jsxs("div", { className: O("numberOfBets"), children: [
                  /* @__PURE__ */ g.jsx(
                    qt,
                    {
                      id: "numberOfBets",
                      value: b,
                      onChange: (G) => P("numberOfBets", G.target.value, !1),
                      onFocus: () => k("numberOfBets"),
                      onBlur: () => k(null),
                      className: q
                    }
                  ),
                  ["", "10", "100"].map((G) => /* @__PURE__ */ g.jsx(
                    pt,
                    {
                      variant: b === G ? "secondary" : "ghost",
                      onClick: () => P("numberOfBets", G, !0),
                      className: L,
                      children: G
                    },
                    G
                  ))
                ] }),
                S.numberOfBets && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: S.numberOfBets })
              ]
            }
          ),
          /* @__PURE__ */ g.jsxs(
            "div",
            {
              className: `space-y-2 ${V ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ g.jsxs(St, { className: "text-sm text-gray-400", children: [
                  " ",
                  Nt("blink.common.onWin"),
                  " "
                ] }),
                /* @__PURE__ */ g.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ g.jsxs("div", { className: N, children: [
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => P("onWinMode", "reset", !0),
                        className: `${j} ${v === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: Nt("blink.common.reset")
                      }
                    ),
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => P("onWinMode", "increase", !0),
                        className: `${j} ${v === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: Nt("blink.common.increaseBy")
                      }
                    )
                  ] }),
                  /* @__PURE__ */ g.jsxs(
                    "div",
                    {
                      className: `${O("onWinValue")} ${v === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ g.jsx(
                          qt,
                          {
                            type: "number",
                            value: x,
                            onChange: (G) => P(
                              "onWinValue",
                              parseFloat(G.target.value)
                            ),
                            onFocus: () => k("onWinValue"),
                            onBlur: () => k(null),
                            className: q,
                            disabled: v === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ g.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                S.onWinValue && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: S.onWinValue })
              ]
            }
          ),
          /* @__PURE__ */ g.jsxs(
            "div",
            {
              className: `space-y-2 ${V ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ g.jsxs(St, { className: "text-sm text-gray-400", children: [
                  " ",
                  Nt("blink.common.onLoss"),
                  " "
                ] }),
                /* @__PURE__ */ g.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ g.jsxs("div", { className: N, children: [
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => P("onLossMode", "reset", !0),
                        className: `${j} ${w === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: Nt("blink.common.reset")
                      }
                    ),
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => P("onLossMode", "increase", !0),
                        className: `${j} ${w === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: Nt("blink.common.increaseBy")
                      }
                    )
                  ] }),
                  /* @__PURE__ */ g.jsxs(
                    "div",
                    {
                      className: `${O("onLossValue")} ${w === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ g.jsx(
                          qt,
                          {
                            type: "number",
                            value: A,
                            onChange: (G) => P(
                              "onLossValue",
                              parseFloat(G.target.value)
                            ),
                            onFocus: () => k("onLossValue"),
                            onBlur: () => k(null),
                            className: q,
                            disabled: w === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ g.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                S.onLossValue && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: S.onLossValue })
              ]
            }
          ),
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "stopOnWin", className: "text-sm text-gray-400", children: Nt("blink.common.stopOnWin") }),
            /* @__PURE__ */ g.jsx("div", { className: O("stopOnWin"), children: /* @__PURE__ */ g.jsx(
              qt,
              {
                id: "stopOnWin",
                type: "number",
                value: m,
                onChange: (G) => P("stopOnWin", parseFloat(G.target.value)),
                onFocus: () => k("stopOnWin"),
                onBlur: () => k(null),
                className: q,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] }),
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "stopOnLoss", className: "text-sm text-gray-400", children: Nt("blink.common.stopOnLoss") }),
            /* @__PURE__ */ g.jsx("div", { className: O("stopOnLoss"), children: /* @__PURE__ */ g.jsx(
              qt,
              {
                id: "stopOnLoss",
                type: "number",
                value: y,
                onChange: (G) => P(
                  "stopOnLoss",
                  parseFloat(G.target.value)
                ),
                onFocus: () => k("stopOnLoss"),
                onBlur: () => k(null),
                className: q,
                style: {
                  WebkitAppearance: "none",
                  MozAppearance: "textfield"
                }
              }
            ) })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ g.jsxs("div", { className: "lg:sticky lg:bottom-0 order-first lg:order-last bg-gray-850", children: [
      /* @__PURE__ */ g.jsx(
        pt,
        {
          className: "w-full bg-gradient-to-b from-brand-gradient-start to-brand-gradient-end hover:from-brand hover:to-brand disabled:opacity-80 text-brand-cta-text text-sm font-bold py-4 rounded-lg h-11",
          onClick: M,
          children: D()
        }
      ),
      /* @__PURE__ */ g.jsx(Go, { children: p === 0 && /* @__PURE__ */ g.jsx(
        os.div,
        {
          className: "bg-blue-500 text-white p-4 mt-4 rounded-lg shadow-lg z-100",
          initial: { opacity: 0, y: 0 },
          animate: { opacity: 1, y: -5 },
          exit: { opacity: 0, y: 0 },
          transition: { duration: 0.3 },
          children: /* @__PURE__ */ g.jsxs("div", { className: "flex items-start", children: [
            /* @__PURE__ */ g.jsx("div", { className: "flex-shrink-0 w-5 self-stretch mr-3", children: /* @__PURE__ */ g.jsx("div", { className: "h-full flex items-center", children: /* @__PURE__ */ g.jsx(kf, { className: "w-5 h-5" }) }) }),
            /* @__PURE__ */ g.jsx("div", { children: /* @__PURE__ */ g.jsxs("p", { className: "text-sm ont-bold", children: [
              "Betting ",
              Z(0),
              " will enter demo mode."
            ] }) })
          ] })
        }
      ) })
    ] })
  ] });
}
const J3 = () => {
  const t = Math.floor(Math.random() * 4), e = Math.random() * window.innerWidth;
  switch (t) {
    case 0:
      return { x: e, y: 0, angle: 45 };
    case 1:
      return { x: window.innerWidth, y: e, angle: 135 };
    case 2:
      return { x: e, y: window.innerHeight, angle: 225 };
    case 3:
      return { x: 0, y: e, angle: 315 };
    default:
      return { x: 0, y: 0, angle: 45 };
  }
}, NC = ({
  minSpeed: t = 10,
  maxSpeed: e = 30,
  minDelay: n = 1200,
  maxDelay: r = 4200,
  starColor: s = "#9E00FF",
  trailColor: i = "#2EB9DF",
  starWidth: o = 10,
  starHeight: a = 1,
  className: c
}) => {
  const [l, u] = Ge(null), d = Et(null);
  return _e(() => {
    const f = () => {
      const { x: h, y: p, angle: m } = J3(), y = {
        id: Date.now(),
        x: h,
        y: p,
        angle: m,
        scale: 1,
        speed: Math.random() * (e - t) + t,
        distance: 0
      };
      u(y);
      const b = Math.random() * (r - n) + n;
      setTimeout(f, b);
    };
    return f(), () => {
    };
  }, [t, e, n, r]), _e(() => {
    const h = requestAnimationFrame(() => {
      l && u((p) => {
        if (!p) return null;
        const m = p.x + p.speed * Math.cos(p.angle * Math.PI / 180), y = p.y + p.speed * Math.sin(p.angle * Math.PI / 180), b = p.distance + p.speed, v = 1 + b / 100;
        return m < -20 || m > window.innerWidth + 20 || y < -20 || y > window.innerHeight + 20 ? null : {
          ...p,
          x: m,
          y,
          distance: b,
          scale: v
        };
      });
    });
    return () => cancelAnimationFrame(h);
  }, [l]), /* @__PURE__ */ g.jsxs(
    "svg",
    {
      ref: d,
      className: de("w-full h-full absolute inset-0", c),
      children: [
        l && /* @__PURE__ */ g.jsx(
          "rect",
          {
            x: l.x,
            y: l.y,
            width: o * l.scale,
            height: a,
            fill: "url(#gradient)",
            transform: `rotate(${l.angle}, ${l.x + o * l.scale / 2}, ${l.y + a / 2})`
          },
          l.id
        ),
        /* @__PURE__ */ g.jsx("defs", { children: /* @__PURE__ */ g.jsxs("linearGradient", { id: "gradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
          /* @__PURE__ */ g.jsx("stop", { offset: "0%", style: { stopColor: i, stopOpacity: 0 } }),
          /* @__PURE__ */ g.jsx(
            "stop",
            {
              offset: "100%",
              style: { stopColor: s, stopOpacity: 1 }
            }
          )
        ] }) })
      ]
    }
  );
}, LC = ({
  starDensity: t = 15e-5,
  allStarsTwinkle: e = !0,
  twinkleProbability: n = 0.7,
  minTwinkleSpeed: r = 0.5,
  maxTwinkleSpeed: s = 1,
  className: i
}) => {
  const [o, a] = Ge([]), c = Et(null), l = Je(
    (u, d) => {
      const f = u * d, h = Math.floor(f * t);
      return Array.from({ length: h }, () => {
        const p = e || Math.random() < n;
        return {
          x: Math.random() * u,
          y: Math.random() * d,
          radius: Math.random() * 0.05 + 0.5,
          opacity: Math.random() * 0.5 + 0.5,
          twinkleSpeed: p ? r + Math.random() * (s - r) : null
        };
      });
    },
    [
      t,
      e,
      n,
      r,
      s
    ]
  );
  return _e(() => {
    const u = () => {
      if (c.current) {
        const f = c.current;
        if (!f.getContext("2d")) return;
        const { width: p, height: m } = f.getBoundingClientRect();
        f.width = p, f.height = m, a(l(p, m));
      }
    };
    u();
    const d = new ResizeObserver(u);
    return c.current && d.observe(c.current), () => {
      c.current && d.unobserve(c.current);
    };
  }, [
    t,
    e,
    n,
    r,
    s,
    l
  ]), _e(() => {
    const u = c.current;
    if (!u) return;
    const d = u.getContext("2d");
    if (!d) return;
    let f;
    const h = () => {
      d.clearRect(0, 0, u.width, u.height), o.forEach((p) => {
        d.beginPath(), d.arc(p.x, p.y, p.radius, 0, Math.PI * 2), d.fillStyle = `rgba(255, 255, 255, ${p.opacity})`, d.fill(), p.twinkleSpeed !== null && (p.opacity = 0.5 + Math.abs(Math.sin(Date.now() * 1e-3 / p.twinkleSpeed) * 0.5));
      }), f = requestAnimationFrame(h);
    };
    return h(), () => {
      cancelAnimationFrame(f);
    };
  }, [o]), /* @__PURE__ */ g.jsx(
    "canvas",
    {
      ref: c,
      className: de("h-full w-full absolute inset-0", i)
    }
  );
}, px = {
  profit: [0],
  wins: 0,
  losses: 0,
  history: [],
  multipliers: []
}, Sa = ga((t) => ({
  ...px,
  updateProfitData: (e, n, r) => t((s) => {
    const o = s.profit[s.profit.length - 1] + e;
    return {
      profit: [...s.profit, o],
      wins: n ? s.wins + 1 : s.wins,
      losses: n ? s.losses : s.losses + 1,
      history: [...s.history, e],
      multipliers: [...s.multipliers, r]
    };
  }),
  resetProfitData: () => t(px)
})), eF = (t, e) => e.stopOnWin > 0 && t >= e.stopOnWin || e.stopOnLoss > 0 && t <= -e.stopOnLoss, tF = (t, e, n, r) => {
  if (t) {
    if (r.onWinMode === "reset") return n;
    if (r.onWinMode === "increase") {
      const s = 1 + r.onWinValue / 100;
      return e * s;
    }
  } else {
    if (r.onLossMode === "reset") return n;
    if (r.onLossMode === "increase") {
      const s = 1 + r.onLossValue / 100;
      return e * s;
    }
  }
  return e;
};
function jC() {
  const { authToken: t } = ma(), { addToast: e } = Aa();
  return { startGameAuto: Je(
    async (r, s) => {
      if (!t) return;
      const i = (d) => new Promise((f) => setTimeout(f, d)), o = st.getState(), a = s.getState();
      st.setState({
        isAutoPlaying: !0,
        isFinishingBet: !1,
        currentAutoBet: 1
      }), e({
        variant: "notice",
        message: "Starting autoplay...",
        duration: 2e3
      });
      let c = 0;
      const l = a.betAmount, u = async () => {
        const d = st.getState(), f = s.getState();
        if (!d.isAutoPlaying && !d.isFinishingBet) {
          o.finishAutoPlay();
          return;
        }
        if (!r.validateSettings()) {
          console.error("Invalid settings, stopping auto-play"), e({
            variant: "notice",
            message: "Stopping autoplay...",
            duration: 2e3
          }), o.finishAutoPlay();
          return;
        }
        if (f.numberOfBets !== "" && d.currentAutoBet > Number(f.numberOfBets)) {
          console.log("Reached maximum number of bets, stopping auto-play"), o.finishAutoPlay();
          return;
        }
        try {
          await i(r.delayMs);
          const h = s.getState().betAmount, p = r.getBetProps(h), m = await by(
            t,
            r.gameType,
            p
          );
          if (r.handleAutoGameResponse(m), await i(r.delayMs), c += m.winAmount ?? 0, console.log("Autoplay Net Profit: " + c), eF(c, f)) {
            e({
              variant: "notice",
              message: "Reached stop condition, stopping...",
              duration: 2e3
            }), o.finishAutoPlay(), r.resetGame();
            return;
          }
          const y = tF(
            m.win,
            h,
            l,
            f
          );
          y > 0 && s.setState({ betAmount: y }), r.resetGame(), st.setState((v) => ({
            currentAutoBet: v.currentAutoBet + 1
          })), st.getState().isAutoPlaying ? u() : (o.finishAutoPlay(), s.setState({ betAmount: l }));
        } catch (h) {
          console.error("Error in auto-play:", h), o.finishAutoPlay();
        }
      };
      u();
    },
    [t, e]
  ) };
}
const nF = ({ theme: t }) => {
  const { authToken: e } = ma(), n = fr(), { betAmount: r, coinSide: s, validateSettings: i, mode: o } = gm(), {
    isGameActive: a,
    setIsGameActive: c,
    selectedCurrency: l,
    setBalance: u,
    isSoundMuted: d,
    selectedFiatCurrency: f,
    showFiat: h
  } = st(), { setResult: p, setMultiplier: m, setTotalProfit: y, resetGame: b } = XS(), { updateProfitData: v } = Sa(), w = (T) => Us.reverseConvertCurrency(Number(T), f.code, l.currencyCode, fiatConversionRates);
  _e(() => {
    b(), d || AC();
  }, [d, b]);
  const x = Je(async () => {
    if (!(a || !e)) {
      b();
      try {
        const T = {
          amount: l.crypto && f && h ? w(r).toFixed(l.fractionalDigits).toString() : r.toString(),
          currency: l.currencyCode,
          custom: {
            face: s
          }
        }, k = await by(
          e,
          "cointoss",
          T
        );
        p(k.custom.face), m(k.multiplier ?? 0), y(k.winAmount), k.balance && u(k.balance), c(!1);
        const R = Us.convertCurrency(k.winAmount, l.currencyCode, f.code, fiatConversionRates);
        f.code && f.fractionalDigits && console.error(Us.format(Big(R), f.code, f.fractionalDigits)), v(k.winAmount, k.win), qn(k.win ? "win" : "lose");
      } catch (T) {
        console.error("Error placing bet:", T), T instanceof Error && console.error("Error message:", T.message);
      }
    }
  }, [
    r,
    s,
    e,
    c,
    a,
    p,
    u,
    l,
    v,
    m,
    y,
    b
  ]), A = Je(
    (T) => {
      p(T.custom.face), T.balance && u(T.balance), c(!1), m(T.multiplier ?? 0), y(T.winAmount), v(
        T.win ? T.winAmount - r : T.winAmount,
        T.win
      ), qn(T.win ? "win" : "lose");
    },
    [
      u,
      v,
      c,
      p,
      m,
      y,
      r
    ]
  ), { startGameAuto: C } = jC(), S = {
    delayMs: 250,
    // How much delay between loops
    gameType: "cointoss",
    getBetProps: (T) => ({
      amount: l.crypto && f && h ? w(T).toFixed(l.fractionalDigits).toString() : T.toString(),
      currency: st.getState().selectedCurrency.currencyCode,
      custom: {
        face: s
      }
    }),
    handleAutoGameResponse: A,
    // Passing the callback for how to handle auto-play response
    validateSettings: i,
    resetGame: b
  }, _ = Je(() => {
    a || !e || (o === "auto" ? C(S, gm) : x());
  }, [a, e, o, C, x]);
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(X3, { handleStartGame: _ }),
    /* @__PURE__ */ g.jsxs("div", { className: "relative flex-grow lg:p-6 flex items-center justify-center order-1 lg:order-2", children: [
      /* @__PURE__ */ g.jsx("div", { className: "relative z-10 bg-black p-3 lg:p-2 rounded-md w-full lg:max-w-[480px] aspect-square", children: /* @__PURE__ */ g.jsx(IB, {}) }),
      !n && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
        /* @__PURE__ */ g.jsx(
          NC,
          {
            starHeight: 5,
            starWidth: 20,
            minSpeed: 5,
            maxSpeed: 20,
            trailColor: t === "betpanda" ? "#0c2d30" : "#dc146e",
            starColor: t === "betpanda" ? "#1fe88a" : "#dc146e"
          }
        ),
        /* @__PURE__ */ g.jsx(LC, { starDensity: 2e-3 })
      ] })
    ] })
  ] });
}, rF = yy(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function sF({ className: t, variant: e, ...n }) {
  return /* @__PURE__ */ g.jsx("div", { className: de(rF({ variant: e }), t), ...n });
}
const Hl = {
  board: Array(25).fill("hidden"),
  gameRoundId: null,
  isEnded: !1,
  multiplier: 0,
  preSelectMultiplier: 0,
  revealedCells: [],
  selectedCells: [],
  totalProfit: "",
  fetchingCells: []
  // Initialize fetchingCells
}, Hi = ga((t) => ({
  ...Hl,
  selectedCells: [],
  setGameRoundId: (e) => t((n) => ({
    ...Hl,
    gameRoundId: e,
    selectedCells: n.selectedCells
  })),
  revealCell: (e, n) => t((r) => ({
    board: r.board.map((s, i) => i === e ? n : s),
    fetchingCells: r.fetchingCells.filter((s) => s !== e)
    // Remove from fetchingCells when revealed
  })),
  setMultiplier: (e) => t({ multiplier: e }),
  setPreselectMultiplier: (e) => t({ preSelectMultiplier: e }),
  updateBoard: (e) => t({ board: e }),
  resetBoard: () => t({ board: Hl.board }),
  setRevealedCells: (e) => t({ revealedCells: e }),
  toggleSelectedCell: (e) => t((n) => ({
    selectedCells: n.selectedCells.includes(e) ? n.selectedCells.filter((r) => r !== e) : [...n.selectedCells, e]
  })),
  clearSelectedCells: () => t({ selectedCells: [] }),
  endGame: (e) => t(() => ({
    isEnded: !0,
    totalProfit: e,
    fetchingCells: []
    // Clear fetchingCells when the game ends
  })),
  resetGame: () => t((e) => ({
    ...Hl,
    preSelectMultiplier: e.preSelectMultiplier,
    selectedCells: e.selectedCells
  })),
  addFetchingCell: (e) => t((n) => ({
    fetchingCells: [...n.fetchingCells, e]
  })),
  removeFetchingCell: (e) => t((n) => ({
    fetchingCells: n.fetchingCells.filter((r) => r !== e)
  }))
})), mx = {
  mode: "manual",
  betAmount: 0,
  minesCount: 5,
  stopOnWin: 0,
  stopOnLoss: 0,
  numberOfBets: "",
  onWinMode: "reset",
  onLossMode: "reset",
  onWinValue: 0,
  onLossValue: 0
}, Xo = ga((t, e) => ({
  ...mx,
  errors: {},
  updateSettings: (n) => t((r) => {
    const s = { ...r, ...n }, { clearSelectedCells: i, resetGame: o } = Hi.getState();
    return n.minesCount && i(), n.mode && o(), n.onWinMode === "reset" && r.onWinMode !== "reset" && (s.onWinValue = 0), n.onLossMode === "reset" && r.onLossMode !== "reset" && (s.onLossValue = 0), s;
  }),
  resetSettings: () => t(mx),
  validateSettings: () => {
    const { betRanges: n, selectedCurrency: r, balance: s, selectedFiatCurrency: i, fiatConversionRates: o, showFiat: a } = st.getState();
    Hi.getState();
    const c = e(), l = (m) => Us.convertCurrency(Number(m), r.currencyCode, i.code, o), u = r.crypto && i && a ? l(Number(n.minBet)).toFixed(i.fractionalDigits) : parseFloat(n.minBet).toFixed(r.fractionalDigits), d = r.crypto && i && a ? l(Number(n.maxBet)).toFixed(i.fractionalDigits) : parseFloat(n.maxBet).toFixed(r.fractionalDigits), f = r.crypto && i && a ? i.prefixSymbol : r.prefixSymbol, h = r.crypto && i && a ? l(Number(s)).toFixed(i.fractionalDigits) : s.toFixed(r.fractionalDigits), p = De.object({
      mode: De.enum(["manual", "auto"]),
      betAmount: De.union([
        De.number().max(Number(h), "You don't have enough balance."),
        // Allow any representation of zero (0, 0.00, etc) but not negative
        De.number().min(0).max(0, `Your bet must be at least ${f} ${u}`),
        // Handle all other positive values with the original constraints
        De.number().min(Number(u), `Your bet must be at least ${f} ${u}`).max(Number(d), `Your bet can max be ${f} ${d}`)
      ]),
      minesCount: De.number().int().min(1).max(24, "Mines count must be between 1 and 24"),
      stopOnWin: De.number().nonnegative("Stop on win must be non-negative").max(Number(h), "You don't have enough balance."),
      stopOnLoss: De.number().nonnegative("Stop on loss must be non-negative"),
      numberOfBets: De.union([
        De.literal(""),
        De.string().refine(
          (m) => !isNaN(Number(m)) && Number(m) > 0 && Number(m) <= 1e3,
          {
            message: "Number of bets must be a positive number up to 1000 or ''"
          }
        ),
        De.number().int().positive().max(1e3, "Maximum 1000")
      ]).transform((m) => m === "" ? m : Number(m)),
      onWinMode: De.enum(["reset", "increase"]),
      onLossMode: De.enum(["reset", "increase"]),
      onWinValue: De.number().nonnegative("Cannot be less than 0"),
      onLossValue: De.number().nonnegative("Cannot be less than 0")
    });
    try {
      return p.parse(c), t({ errors: {} }), !0;
    } catch (m) {
      if (m instanceof De.ZodError) {
        const y = {};
        m.issues.forEach((b) => {
          b.path[0] && (y[b.path[0]] = b.message, console.log("newErrors", b.message));
        }), t({ errors: y });
      }
      return !1;
    }
  },
  setErrors: (n) => t({ errors: n })
})), BC = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2076.61%2070'%3e%3cdefs%3e%3cstyle%3e.cls-1{fill:%23051d27;}.cls-2{fill:%2306e403;}.cls-3{fill:%2305a902;}.cls-4{fill:%2301e501;}.cls-5{fill:%2300d503;}.cls-6{fill:%2309fd02;}.cls-7{fill:%23019902;}.cls-8{fill:%2301e300;}.cls-9{fill:%2357fd7f;}.cls-10{fill:%2303be02;}%3c/style%3e%3c/defs%3e%3ctitle%3e3Artboard%20710%3c/title%3e%3cg%20id='Layer_1'%20data-name='Layer%201'%3e%3cpath%20class='cls-1'%20d='M38,70h0a2.75,2.75,0,0,1-2-.92L.7,29.62a2.76,2.76,0,0,1-.31-3.25L11,8.55a2.76,2.76,0,0,1,1.27-1.12L23.12,2.71a2.77,2.77,0,0,1,.62-.19L37.74,0a3.09,3.09,0,0,1,1,0L52.62,2.52a3.38,3.38,0,0,1,.62.18L64.42,7.58l.13,0h0a2.69,2.69,0,0,1,.65.45h0a3,3,0,0,1,.4.47h0l.09.14L76.23,26.6a2.73,2.73,0,0,1-.34,3.25L40.06,69.1A2.76,2.76,0,0,1,38,70Z'/%3e%3cpath%20class='cls-2'%20d='M22.13,18.75c-2.64,7-1.74,13.65,2.09,20,6.74-3.1,11.83-8.4,14.44-17C33,18.93,27.49,17.74,22.13,18.75Z'/%3e%3cpath%20class='cls-3'%20d='M73.86,28,63.33,10.1c-6.26,1.19-8.79,4.41-9,8.91C58.67,25.3,65.39,28,73.86,28Z'/%3e%3cpath%20class='cls-4'%20d='M38.49,21.94c.15,7.77,4.2,13.31,12.19,16.57l.07,0c4.5-5.59,5.9-12,3.62-19.47C48.26,16.08,42.9,16.72,38.49,21.94Z'/%3e%3cpath%20class='cls-5'%20d='M24.22,38.76q13.19,6.43,26.46-.25L38.49,21.94Z'/%3e%3cpath%20class='cls-6'%20d='M24.22,38.76c1,9.17,6.29,18.72,13.81,28.49,7.4-9,12.5-18.4,12.72-28.77Z'/%3e%3cpath%20class='cls-7'%20d='M50.75,38.48,38,67.25,73.86,28C64.47,28.32,56.19,30.75,50.75,38.48Z'/%3e%3cpath%20class='cls-8'%20d='M2.75,27.79,38,67.25,24.22,38.76C20.11,31,11.89,28.8,2.75,27.79Z'/%3e%3cpath%20class='cls-9'%20d='M13.39,10,2.75,27.79c9.33,1.22,16.19-1.21,19.54-8.88C24.57,13.79,21.22,11,13.39,10Z'/%3e%3cpolygon%20class='cls-6'%20points='2.75%2027.79%2024.22%2038.76%2022.29%2018.91%202.75%2027.79'/%3e%3cpolygon%20class='cls-6'%20points='52.14%205.23%2038.22%202.75%2024.22%205.23%2013.39%209.96%2022.29%2018.91%2038.49%2021.94%2054.37%2019.01%2063.33%2010.1%2052.14%205.23'/%3e%3cpolygon%20class='cls-10'%20points='50.74%2038.48%2073.86%2027.99%2054.37%2019.01%2050.74%2038.48'/%3e%3cpolygon%20class='cls-9'%20points='13.89%2010.83%2024.37%205.43%2038.22%202.75%2024.22%205.23%2013.39%209.96%2013.89%2010.83'/%3e%3cpolygon%20class='cls-9'%20points='22.29%2018.91%2024.22%2038.76%2021.1%2019.05%2022.29%2018.91'/%3e%3cpolygon%20class='cls-9'%20points='22.29%2018.91%2038.49%2021.94%2038.03%2022.48%2022.29%2018.91'/%3e%3cpolygon%20class='cls-9'%20points='63.33%2010.1%2053%2019.28%2054.37%2019.01%2063.33%2010.1'/%3e%3c/g%3e%3c/svg%3e", xy = "data:image/svg+xml,%3csvg%20id='Layer_1'%20data-name='Layer%201'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2070%2070'%3e%3ctitle%3ebomb%3c/title%3e%3cpath%20d='M35,70a35.47,35.47,0,0,1-8.45-1A35,35,0,1,1,49.83,3.3c3.53-2.25,8.75-.54,12.39,4.16.15.19.3.39.44.59a11.89,11.89,0,0,1,3.61,2.31,10.6,10.6,0,0,1,3.27,7.91A9,9,0,0,1,68,23.44a32.32,32.32,0,0,1,1.14,4h0A35,35,0,0,1,35,70ZM35,6.47A28.57,28.57,0,1,0,62.85,28.84h0A27.53,27.53,0,0,0,61.34,24a3.17,3.17,0,0,1-.16-2,3.2,3.2,0,0,1-1.49-1.33c-.29-.5-.6-1-.92-1.48a3.23,3.23,0,0,1-.11-3.39.92.92,0,0,0,.06-.29,3.33,3.33,0,0,1,.77-1.79,3.16,3.16,0,0,1-1.73-1.4,11.43,11.43,0,0,0-.65-.95c-1.59-2-3.35-2.68-3.87-2.62A1.81,1.81,0,0,1,53,9l-1.37.79a3.22,3.22,0,0,1-3.14.06A28.47,28.47,0,0,0,35,6.47Z'%20style='fill:%23051d27'/%3e%3cpath%20d='M66.76,35A31.62,31.62,0,0,0,66,28.14c-2.45-.61-13.43-3.53-16.07-3.53-17.55,0-28.75,14.48-28.75,32,0,2.35,5.65,7,6.14,9.19A31.8,31.8,0,0,0,66.76,35Z'%20style='fill:%23d8003e'/%3e%3cpath%20d='M58.34,27.2a31.72,31.72,0,0,1,7.67.94A31.76,31.76,0,1,0,27.33,65.83a31.77,31.77,0,0,1,31-38.63Z'%20style='fill:%23fd013e'/%3e%3cpath%20d='M51.33,6.19,45.71,9.44c-2.24,1.74-1.7,6.17,1.19,9.9S54,24.69,56.19,23l4.55-4.64Z'%20style='fill:%23d8003e'/%3e%3cellipse%20cx='56.03'%20cy='12.26'%20rx='4.6'%20ry='7.67'%20transform='translate(4.24%2036.9)%20rotate(-37.78)'%20style='fill:%23fd013e'/%3e%3cpath%20d='M41.45,38.53a1.55,1.55,0,0,1-.37,0,1.84,1.84,0,0,1-1.44-2.17c2-9.64,10.07-12,16-13.71,4.86-1.41,7-2.24,7-4.34a3.76,3.76,0,0,0-1.11-2.89c-1.91-1.81-5.63-1.67-5.67-1.66a1.84,1.84,0,1,1-.2-3.68c.22,0,5.33-.25,8.41,2.67a7.43,7.43,0,0,1,2.26,5.56c0,5.08-4.9,6.5-9.65,7.88-5.85,1.69-11.9,3.45-13.41,10.9A1.85,1.85,0,0,1,41.45,38.53Z'%20style='fill:%232a2f3c'/%3e%3cpolygon%20points='32.81%2053.29%2033.53%2054.59%2030.13%2056.91%2030.49%2053.72%2032.81%2053.29'%20style='fill:%23fff'/%3e%3cpolygon%20points='20.47%2056.89%2020.73%2057.24%2019.67%2057.76%2019.72%2056.95%2020.47%2056.89'%20style='fill:%23fff'/%3e%3cpolygon%20points='32.15%2047.91%2032.26%2048.82%2033.05%2048.66%2032.87%2047.59%2032.15%2047.91'%20style='fill:%23fff'/%3e%3cpolygon%20points='35.28%2046.02%2034.89%2047.73%2036.14%2047.94%2036.82%2046.87%2036.39%2045.91%2035.28%2046.02'%20style='fill:%23fff'/%3e%3cpolygon%20points='38.02%2048.47%2037.97%2049.28%2039.03%2048.76%2038.77%2048.41%2038.02%2048.47'%20style='fill:%23fff'/%3e%3cpolygon%20points='41.13%2049.33%2042.21%2048.85%2042.71%2050.93%2041.48%2051.1%2041.13%2049.33'%20style='fill:%23fff'/%3e%3cpolygon%20points='32.64%2039.9%2033.07%2040.85%2032.39%2041.92%2031.14%2041.71%2031.54%2040%2032.64%2039.9'%20style='fill:%23fff'/%3e%3cpolygon%20points='44.43%2045.41%2044.62%2046.48%2043.83%2046.65%2043.71%2045.74%2044.43%2045.41'%20style='fill:%23fff'/%3e%3cpolygon%20points='47.56%2043.79%2046.62%2045.17%2049.51%2046.55%2049.95%2045.02%2047.56%2043.79'%20style='fill:%23fff'/%3e%3cpolygon%20points='52.47%2047.67%2052.42%2048.48%2053.48%2047.96%2053.22%2047.61%2052.47%2047.67'%20style='fill:%23fff'/%3e%3cpolygon%20points='51.74%2051.27%2051.31%2052.23%2052.6%2053.19%2054.63%2051.91%2051.74%2051.27'%20style='fill:%23fff'/%3e%3cpolygon%20points='51.63%2058.46%2050.91%2058.78%2051.02%2059.69%2051.82%2059.53%2051.63%2058.46'%20style='fill:%23fff'/%3e%3cpolygon%20points='46.62%2039.13%2046.86%2036.72%2048.76%2036.45%2049.38%2037.45%2046.62%2039.13'%20style='fill:%23fff'/%3e%3cpolygon%20points='61.89%2033.9%2061.84%2034.71%2062.9%2034.19%2062.64%2033.84%2061.89%2033.9'%20style='fill:%23fff'/%3e%3cpolygon%20points='47.15%2033.15%2047.73%2033.71%2047.01%2034.52%2046.57%2033.86%2047.15%2033.15'%20style='fill:%23fff'/%3e%3cpolygon%20points='36.75%2033.83%2035.69%2034.34%2035.73%2033.53%2036.48%2033.47%2036.75%2033.83'%20style='fill:%23fff'/%3e%3cpolygon%20points='35.78%2037.44%2035.05%2037.77%2035.17%2038.67%2035.96%2038.51%2035.78%2037.44'%20style='fill:%23fff'/%3e%3cpolygon%20points='33.78%2034.62%2033%2035.77%2031.73%2035.41%2031.25%2033.9%2032.46%2032.87%2033.78%2034.62'%20style='fill:%23fff'/%3e%3cpolygon%20points='28.58%2024.4%2028.76%2025.46%2027.97%2025.63%2027.85%2024.72%2028.58%2024.4'%20style='fill:%23fff'/%3e%3cpolygon%20points='47%2026.82%2043.8%2040.43%2034.23%2026.82%2041.68%2041.48%2031.04%2038.34%2037.42%2042.53%2019.33%2047.76%2039.55%2044.62%2036.36%2055.09%2042.74%2047.76%2047%2051.95%2047%2046.72%2061.89%2049.86%2048.06%2043.57%2055.51%2038.34%2047%2041.48%2047%2026.82'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='56.57%2043.61%2063.67%2041.84%2063.67%2043.61%2056.57%2043.61'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='32.63%2033.01%2026.43%2022.4%2025.54%2025.05%2032.63%2033.01'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='34.41%2052.44%2028.2%2063.04%2027.31%2060.39%2034.41%2052.44'%20style='fill:%23fdcb02'/%3e%3cpolygon%20points='46.93%2044.58%2052.19%2051.23%2044.6%2047%2042.26%2052.44%2041.09%2048.21%2033.1%2050.41%2038.17%2044.58%2032.92%2042.16%2038.17%2040.35%2036.42%2037.94%2041.09%2038.54%2039.92%2029.47%2043.43%2038.54%2044.6%2037.94%2044.6%2039.75%2049.85%2037.33%2046.93%2042.16%2053.36%2042.77%2046.93%2044.58'%20style='fill:%23fff'/%3e%3c/svg%3e";
function iF({
  handleRevealCell: t,
  handleAutoSelection: e
}) {
  const {
    board: n,
    isEnded: r,
    multiplier: s,
    revealedCells: i,
    totalProfit: o,
    selectedCells: a,
    setPreselectMultiplier: c,
    fetchingCells: l
  } = Hi(), { mode: u, minesCount: d } = Xo(), { isGameActive: f, theme: h, isAutoPlaying: p, isFetching: m } = st(), y = fr(), b = i.slice(-1).join(), [v, w] = Ge(!1), x = (T) => {
    if (u === "auto" && !f && !p) {
      if (!a.includes(T) && d + a.length >= 25)
        return;
      qn("tick"), e(T);
    } else u === "manual" && f && !l.includes(T) && (qn("tick"), t(T));
  }, A = (T) => {
    w(!0), x(T);
  }, C = (T) => {
    v && x(T);
  }, S = () => {
    w(!1);
  };
  _e(() => {
    a.length === 0 && c(0), c(pI(d, a.length));
  }, [a, c, d]), _e(() => (document.addEventListener("mouseup", S), () => {
    document.removeEventListener("mouseup", S);
  }), []);
  const _ = (T, k) => {
    const R = u === "auto" && a.includes(T), P = {
      backgroundImage: k === "hidden" && h !== "neobet" ? `url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/mines/${h}/${h}_square.png)` : "none",
      backgroundSize: "cover",
      transition: "all 0.3s ease",
      borderWidth: R ? "3px" : h === "neobet" ? "0px" : "2px",
      borderStyle: "solid",
      borderColor: R ? "#9932CC" : h === "neobet" ? "" : h === "betpanda" ? "rgba(31, 232, 138, 0.7)" : "rgba(220, 1, 108, 0.7)"
    };
    return k === "diamond" ? {
      ...P,
      borderColor: "#1fe88a",
      backgroundColor: "#1fe88a"
      // Green for gems
    } : k === "mine" ? {
      ...P,
      borderColor: "rgb(248, 113, 113)",
      backgroundColor: "rgb(248, 113, 113)"
      // Red for bombs
    } : P;
  };
  return /* @__PURE__ */ g.jsxs("div", { className: "grid grid-cols-5 gap-2 h-full w-full", children: [
    n.map((T, k) => /* @__PURE__ */ g.jsxs(
      os.div,
      {
        initial: { rotateY: 0 },
        animate: { rotateY: T !== "hidden" ? 180 : 0 },
        transition: { duration: 0.3 },
        className: `w-full h-full aspect-square rounded-sm flex items-center justify-center will-change-auto
          ${r && !i.includes(k) ? "opacity-20" : ""}
          ${l.includes(k) ? "animate-custom-pulse" : ""}
          ${!r && !f && a.length === 0 ? "opacity-70" : ""}
        `,
        children: [
          /* @__PURE__ */ g.jsxs(
            pt,
            {
              onMouseDown: () => A(k),
              onMouseEnter: () => C(k),
              style: _(k, T),
              className: `w-full h-full disabled:opacity-100 text-4xl rounded-sm p-3 select-none 
              ${T === "diamond" ? "bg-green-500 border-opacity-0" : T === "mine" ? "bg-red-400 text-white border-opacity-0" : "bg-pills cursor-pointer border-secondary"}
            `,
              disabled: p || u === "manual" && (!f || T !== "hidden"),
              children: [
                l.includes(k) && h === "neobet" && /* @__PURE__ */ g.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ g.jsx("div", { className: "w-9 h-9 border-2 border-border border-t-brand rounded-full animate-spin" }) }),
                (T !== "hidden" || r) && /* @__PURE__ */ g.jsx(
                  "img",
                  {
                    src: T === "mine" ? xy : BC,
                    width: "0",
                    height: "0",
                    alt: "",
                    style: { width: "100%", height: "auto" }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ g.jsx(Go, { children: T === "diamond" && parseInt(b) === k && f && u === "manual" && /* @__PURE__ */ g.jsx(
            os.div,
            {
              initial: { opacity: 0, scale: 0.8 },
              animate: { opacity: 1, scale: 1, rotateY: 180 },
              exit: { opacity: 0, scale: 0.8 },
              transition: { duration: 0.3 },
              className: "absolute top-0 left-50",
              style: { top: "-15px" },
              children: /* @__PURE__ */ g.jsxs(
                sF,
                {
                  variant: "secondary",
                  className: "relative z-50 text-xs bg-violet-700 text-white font-black px-1.5 pointer-events-none",
                  children: [
                    s.toFixed(2),
                    "x"
                  ]
                }
              )
            }
          ) })
        ]
      },
      `${k}-${h}`
    )),
    /* @__PURE__ */ g.jsx(Go, { children: u === "auto" && a.length === 0 && /* @__PURE__ */ g.jsxs(
      os.div,
      {
        className: "absolute left-3 right-3 lg:left-0 lg:right-0 top-full mt-4 bg-blue-500 text-white p-4 rounded-lg shadow-lg",
        initial: { opacity: 0, y: -30 },
        animate: { opacity: 1, y: -5 },
        exit: { opacity: 0, y: -30 },
        transition: { duration: 0.3 },
        children: [
          /* @__PURE__ */ g.jsx("div", { className: "absolute -top-2 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-b-8 border-transparent border-b-blue-500" }),
          /* @__PURE__ */ g.jsxs("div", { className: "flex items-start", children: [
            /* @__PURE__ */ g.jsx("div", { className: "flex-shrink-0 w-5 self-stretch mr-3", children: /* @__PURE__ */ g.jsx("div", { className: "h-full flex items-center", children: /* @__PURE__ */ g.jsx(kf, { className: "w-5 h-5" }) }) }),
            /* @__PURE__ */ g.jsxs("div", { children: [
              /* @__PURE__ */ g.jsx("h2", { className: "text-sm font-bold mb-2", children: "Welcome to Auto Mode!" }),
              /* @__PURE__ */ g.jsx("p", { className: "text-sm", children: "Select the cells you want to reveal automatically. The game will play these selections for you when you start." })
            ] })
          ] })
        ]
      }
    ) }),
    r && s !== 0 && /* @__PURE__ */ g.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ g.jsx(bC, { multiplier: s, amount: o }) }),
    !y && f && !p && a.length === 0 && /* @__PURE__ */ g.jsx(
      i1,
      {
        size: 700,
        duration: 10,
        colorFrom: h === "betpanda" ? "#1fe88a" : "#dc146e",
        colorTo: "#08080800",
        borderWidth: 1.5
      }
    )
  ] });
}
function wy(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
function We(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(s) {
    if (t == null || t(s), n === !1 || !s.defaultPrevented)
      return e == null ? void 0 : e(s);
  };
}
function oF(t, e = []) {
  let n = [];
  function r(i, o) {
    const a = E.createContext(o), c = n.length;
    n = [...n, o];
    const l = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, m = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[c]) || a, y = E.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ g.jsx(m.Provider, { value: y, children: h });
    };
    l.displayName = i + "Provider";
    function u(d, f) {
      var m;
      const h = ((m = f == null ? void 0 : f[t]) == null ? void 0 : m[c]) || a, p = E.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [l, u];
  }
  const s = () => {
    const i = n.map((o) => E.createContext(o));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || i;
      return E.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: c } }),
        [a, c]
      );
    };
  };
  return s.scopeName = t, [r, aF(s, ...e)];
}
function aF(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const o = r.reduce((a, { useScope: c, scopeName: l }) => {
        const d = c(i)[`__scope${l}`];
        return { ...a, ...d };
      }, {});
      return E.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function Zt(t) {
  const e = E.useRef(t);
  return E.useEffect(() => {
    e.current = t;
  }), E.useMemo(() => (...n) => {
    var r;
    return (r = e.current) == null ? void 0 : r.call(e, ...n);
  }, []);
}
function Ea({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  }
}) {
  const [r, s] = cF({ defaultProp: e, onChange: n }), i = t !== void 0, o = i ? t : r, a = Zt(n), c = E.useCallback(
    (l) => {
      if (i) {
        const d = typeof l == "function" ? l(t) : l;
        d !== t && a(d);
      } else
        s(l);
    },
    [i, t, s, a]
  );
  return [o, c];
}
function cF({
  defaultProp: t,
  onChange: e
}) {
  const n = E.useState(t), [r] = n, s = E.useRef(r), i = Zt(e);
  return E.useEffect(() => {
    s.current !== r && (i(r), s.current = r);
  }, [r, s, i]), n;
}
var lF = E.createContext(void 0);
function Ay(t) {
  const e = E.useContext(lF);
  return t || e || "ltr";
}
function uF(t) {
  const e = E.useRef({ value: t, previous: t });
  return E.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t]);
}
var bn = globalThis != null && globalThis.document ? E.useLayoutEffect : () => {
};
function FC(t) {
  const [e, n] = E.useState(void 0);
  return bn(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const r = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length)
          return;
        const i = s[0];
        let o, a;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, l = Array.isArray(c) ? c[0] : c;
          o = l.inlineSize, a = l.blockSize;
        } else
          o = t.offsetWidth, a = t.offsetHeight;
        n({ width: o, height: a });
      });
      return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
function Sy(t, e = []) {
  let n = [];
  function r(i, o) {
    const a = E.createContext(o), c = n.length;
    n = [...n, o];
    function l(d) {
      const { scope: f, children: h, ...p } = d, m = (f == null ? void 0 : f[t][c]) || a, y = E.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ g.jsx(m.Provider, { value: y, children: h });
    }
    function u(d, f) {
      const h = (f == null ? void 0 : f[t][c]) || a, p = E.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return l.displayName = i + "Provider", [l, u];
  }
  const s = () => {
    const i = n.map((o) => E.createContext(o));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || i;
      return E.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: c } }),
        [a, c]
      );
    };
  };
  return s.scopeName = t, [r, dF(s, ...e)];
}
function dF(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const o = r.reduce((a, { useScope: c, scopeName: l }) => {
        const d = c(i)[`__scope${l}`];
        return { ...a, ...d };
      }, {});
      return E.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function VC(t) {
  const e = t + "CollectionProvider", [n, r] = Sy(e), [s, i] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (h) => {
    const { scope: p, children: m } = h, y = z.useRef(null), b = z.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ g.jsx(s, { scope: p, itemMap: b, collectionRef: y, children: m });
  };
  o.displayName = e;
  const a = t + "CollectionSlot", c = z.forwardRef(
    (h, p) => {
      const { scope: m, children: y } = h, b = i(a, m), v = Ke(p, b.collectionRef);
      return /* @__PURE__ */ g.jsx(Ko, { ref: v, children: y });
    }
  );
  c.displayName = a;
  const l = t + "CollectionItemSlot", u = "data-radix-collection-item", d = z.forwardRef(
    (h, p) => {
      const { scope: m, children: y, ...b } = h, v = z.useRef(null), w = Ke(p, v), x = i(l, m);
      return z.useEffect(() => (x.itemMap.set(v, { ref: v, ...b }), () => void x.itemMap.delete(v))), /* @__PURE__ */ g.jsx(Ko, { [u]: "", ref: w, children: y });
    }
  );
  d.displayName = l;
  function f(h) {
    const p = i(t + "CollectionConsumer", h);
    return z.useCallback(() => {
      const y = p.collectionRef.current;
      if (!y) return [];
      const b = Array.from(y.querySelectorAll(`[${u}]`));
      return Array.from(p.itemMap.values()).sort(
        (x, A) => b.indexOf(x.ref.current) - b.indexOf(A.ref.current)
      );
    }, [p.collectionRef, p.itemMap]);
  }
  return [
    { Provider: o, Slot: c, ItemSlot: d },
    f,
    r
  ];
}
var UC = ["PageUp", "PageDown"], WC = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], zC = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Ca = "Slider", [ym, fF, hF] = VC(Ca), [HC, gte] = oF(Ca, [
  hF
]), [pF, Pf] = HC(Ca), YC = E.forwardRef(
  (t, e) => {
    const {
      name: n,
      min: r = 0,
      max: s = 100,
      step: i = 1,
      orientation: o = "horizontal",
      disabled: a = !1,
      minStepsBetweenThumbs: c = 0,
      defaultValue: l = [r],
      value: u,
      onValueChange: d = () => {
      },
      onValueCommit: f = () => {
      },
      inverted: h = !1,
      form: p,
      ...m
    } = t, y = E.useRef(/* @__PURE__ */ new Set()), b = E.useRef(0), w = o === "horizontal" ? mF : gF, [x = [], A] = Ea({
      prop: u,
      defaultProp: l,
      onChange: (R) => {
        var M;
        (M = [...y.current][b.current]) == null || M.focus(), d(R);
      }
    }), C = E.useRef(x);
    function S(R) {
      const P = wF(x, R);
      k(R, P);
    }
    function _(R) {
      k(R, b.current);
    }
    function T() {
      const R = C.current[b.current];
      x[b.current] !== R && f(x);
    }
    function k(R, P, { commit: M } = { commit: !1 }) {
      const D = CF(i), O = _F(Math.round((R - r) / i) * i + r, D), q = wy(O, [r, s]);
      A((L = []) => {
        const N = vF(L, q, P);
        if (EF(N, c * i)) {
          b.current = N.indexOf(q);
          const j = String(N) !== String(L);
          return j && M && f(N), j ? N : L;
        } else
          return L;
      });
    }
    return /* @__PURE__ */ g.jsx(
      pF,
      {
        scope: t.__scopeSlider,
        name: n,
        disabled: a,
        min: r,
        max: s,
        valueIndexToChangeRef: b,
        thumbs: y.current,
        values: x,
        orientation: o,
        form: p,
        children: /* @__PURE__ */ g.jsx(ym.Provider, { scope: t.__scopeSlider, children: /* @__PURE__ */ g.jsx(ym.Slot, { scope: t.__scopeSlider, children: /* @__PURE__ */ g.jsx(
          w,
          {
            "aria-disabled": a,
            "data-disabled": a ? "" : void 0,
            ...m,
            ref: e,
            onPointerDown: We(m.onPointerDown, () => {
              a || (C.current = x);
            }),
            min: r,
            max: s,
            inverted: h,
            onSlideStart: a ? void 0 : S,
            onSlideMove: a ? void 0 : _,
            onSlideEnd: a ? void 0 : T,
            onHomeKeyDown: () => !a && k(r, 0, { commit: !0 }),
            onEndKeyDown: () => !a && k(s, x.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: R, direction: P }) => {
              if (!a) {
                const O = UC.includes(R.key) || R.shiftKey && WC.includes(R.key) ? 10 : 1, q = b.current, L = x[q], N = i * O * P;
                k(L + N, q, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
YC.displayName = Ca;
var [GC, KC] = HC(Ca, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), mF = E.forwardRef(
  (t, e) => {
    const {
      min: n,
      max: r,
      dir: s,
      inverted: i,
      onSlideStart: o,
      onSlideMove: a,
      onSlideEnd: c,
      onStepKeyDown: l,
      ...u
    } = t, [d, f] = E.useState(null), h = Ke(e, (w) => f(w)), p = E.useRef(), m = Ay(s), y = m === "ltr", b = y && !i || !y && i;
    function v(w) {
      const x = p.current || d.getBoundingClientRect(), A = [0, x.width], S = Ey(A, b ? [n, r] : [r, n]);
      return p.current = x, S(w - x.left);
    }
    return /* @__PURE__ */ g.jsx(
      GC,
      {
        scope: t.__scopeSlider,
        startEdge: b ? "left" : "right",
        endEdge: b ? "right" : "left",
        direction: b ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ g.jsx(
          $C,
          {
            dir: m,
            "data-orientation": "horizontal",
            ...u,
            ref: h,
            style: {
              ...u.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (w) => {
              const x = v(w.clientX);
              o == null || o(x);
            },
            onSlideMove: (w) => {
              const x = v(w.clientX);
              a == null || a(x);
            },
            onSlideEnd: () => {
              p.current = void 0, c == null || c();
            },
            onStepKeyDown: (w) => {
              const A = zC[b ? "from-left" : "from-right"].includes(w.key);
              l == null || l({ event: w, direction: A ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), gF = E.forwardRef(
  (t, e) => {
    const {
      min: n,
      max: r,
      inverted: s,
      onSlideStart: i,
      onSlideMove: o,
      onSlideEnd: a,
      onStepKeyDown: c,
      ...l
    } = t, u = E.useRef(null), d = Ke(e, u), f = E.useRef(), h = !s;
    function p(m) {
      const y = f.current || u.current.getBoundingClientRect(), b = [0, y.height], w = Ey(b, h ? [r, n] : [n, r]);
      return f.current = y, w(m - y.top);
    }
    return /* @__PURE__ */ g.jsx(
      GC,
      {
        scope: t.__scopeSlider,
        startEdge: h ? "bottom" : "top",
        endEdge: h ? "top" : "bottom",
        size: "height",
        direction: h ? 1 : -1,
        children: /* @__PURE__ */ g.jsx(
          $C,
          {
            "data-orientation": "vertical",
            ...l,
            ref: d,
            style: {
              ...l.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (m) => {
              const y = p(m.clientY);
              i == null || i(y);
            },
            onSlideMove: (m) => {
              const y = p(m.clientY);
              o == null || o(y);
            },
            onSlideEnd: () => {
              f.current = void 0, a == null || a();
            },
            onStepKeyDown: (m) => {
              const b = zC[h ? "from-bottom" : "from-top"].includes(m.key);
              c == null || c({ event: m, direction: b ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), $C = E.forwardRef(
  (t, e) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: s,
      onSlideEnd: i,
      onHomeKeyDown: o,
      onEndKeyDown: a,
      onStepKeyDown: c,
      ...l
    } = t, u = Pf(Ca, n);
    return /* @__PURE__ */ g.jsx(
      ze.span,
      {
        ...l,
        ref: e,
        onKeyDown: We(t.onKeyDown, (d) => {
          d.key === "Home" ? (o(d), d.preventDefault()) : d.key === "End" ? (a(d), d.preventDefault()) : UC.concat(WC).includes(d.key) && (c(d), d.preventDefault());
        }),
        onPointerDown: We(t.onPointerDown, (d) => {
          const f = d.target;
          f.setPointerCapture(d.pointerId), d.preventDefault(), u.thumbs.has(f) ? f.focus() : r(d);
        }),
        onPointerMove: We(t.onPointerMove, (d) => {
          d.target.hasPointerCapture(d.pointerId) && s(d);
        }),
        onPointerUp: We(t.onPointerUp, (d) => {
          const f = d.target;
          f.hasPointerCapture(d.pointerId) && (f.releasePointerCapture(d.pointerId), i(d));
        })
      }
    );
  }
), ZC = "SliderTrack", QC = E.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, ...r } = t, s = Pf(ZC, n);
    return /* @__PURE__ */ g.jsx(
      ze.span,
      {
        "data-disabled": s.disabled ? "" : void 0,
        "data-orientation": s.orientation,
        ...r,
        ref: e
      }
    );
  }
);
QC.displayName = ZC;
var bm = "SliderRange", XC = E.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, ...r } = t, s = Pf(bm, n), i = KC(bm, n), o = E.useRef(null), a = Ke(e, o), c = s.values.length, l = s.values.map(
      (f) => e_(f, s.min, s.max)
    ), u = c > 1 ? Math.min(...l) : 0, d = 100 - Math.max(...l);
    return /* @__PURE__ */ g.jsx(
      ze.span,
      {
        "data-orientation": s.orientation,
        "data-disabled": s.disabled ? "" : void 0,
        ...r,
        ref: a,
        style: {
          ...t.style,
          [i.startEdge]: u + "%",
          [i.endEdge]: d + "%"
        }
      }
    );
  }
);
XC.displayName = bm;
var vm = "SliderThumb", JC = E.forwardRef(
  (t, e) => {
    const n = fF(t.__scopeSlider), [r, s] = E.useState(null), i = Ke(e, (a) => s(a)), o = E.useMemo(
      () => r ? n().findIndex((a) => a.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ g.jsx(yF, { ...t, ref: i, index: o });
  }
), yF = E.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, index: r, name: s, ...i } = t, o = Pf(vm, n), a = KC(vm, n), [c, l] = E.useState(null), u = Ke(e, (v) => l(v)), d = c ? o.form || !!c.closest("form") : !0, f = FC(c), h = o.values[r], p = h === void 0 ? 0 : e_(h, o.min, o.max), m = xF(r, o.values.length), y = f == null ? void 0 : f[a.size], b = y ? AF(y, p, a.direction) : 0;
    return E.useEffect(() => {
      if (c)
        return o.thumbs.add(c), () => {
          o.thumbs.delete(c);
        };
    }, [c, o.thumbs]), /* @__PURE__ */ g.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [a.startEdge]: `calc(${p}% + ${b}px)`
        },
        children: [
          /* @__PURE__ */ g.jsx(ym.ItemSlot, { scope: t.__scopeSlider, children: /* @__PURE__ */ g.jsx(
            ze.span,
            {
              role: "slider",
              "aria-label": t["aria-label"] || m,
              "aria-valuemin": o.min,
              "aria-valuenow": h,
              "aria-valuemax": o.max,
              "aria-orientation": o.orientation,
              "data-orientation": o.orientation,
              "data-disabled": o.disabled ? "" : void 0,
              tabIndex: o.disabled ? void 0 : 0,
              ...i,
              ref: u,
              style: h === void 0 ? { display: "none" } : t.style,
              onFocus: We(t.onFocus, () => {
                o.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          d && /* @__PURE__ */ g.jsx(
            bF,
            {
              name: s ?? (o.name ? o.name + (o.values.length > 1 ? "[]" : "") : void 0),
              form: o.form,
              value: h
            },
            r
          )
        ]
      }
    );
  }
);
JC.displayName = vm;
var bF = (t) => {
  const { value: e, ...n } = t, r = E.useRef(null), s = uF(e);
  return E.useEffect(() => {
    const i = r.current, o = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(o, "value").set;
    if (s !== e && c) {
      const l = new Event("input", { bubbles: !0 });
      c.call(i, e), i.dispatchEvent(l);
    }
  }, [s, e]), /* @__PURE__ */ g.jsx("input", { style: { display: "none" }, ...n, ref: r, defaultValue: e });
};
function vF(t = [], e, n) {
  const r = [...t];
  return r[n] = e, r.sort((s, i) => s - i);
}
function e_(t, e, n) {
  const i = 100 / (n - e) * (t - e);
  return wy(i, [0, 100]);
}
function xF(t, e) {
  return e > 2 ? `Value ${t + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][t] : void 0;
}
function wF(t, e) {
  if (t.length === 1) return 0;
  const n = t.map((s) => Math.abs(s - e)), r = Math.min(...n);
  return n.indexOf(r);
}
function AF(t, e, n) {
  const r = t / 2, i = Ey([0, 50], [0, r]);
  return (r - i(e) * n) * n;
}
function SF(t) {
  return t.slice(0, -1).map((e, n) => t[n + 1] - e);
}
function EF(t, e) {
  if (e > 0) {
    const n = SF(t);
    return Math.min(...n) >= e;
  }
  return !0;
}
function Ey(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0]);
  };
}
function CF(t) {
  return (String(t).split(".")[1] || "").length;
}
function _F(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
var t_ = YC, TF = QC, kF = XC, RF = JC;
const n_ = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsxs(
  t_,
  {
    ref: n,
    className: de(
      "relative flex w-full touch-none select-none items-center",
      t
    ),
    ...e,
    children: [
      /* @__PURE__ */ g.jsx(TF, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-gray-300", children: /* @__PURE__ */ g.jsx(kF, { className: "absolute h-full bg-brand" }) }),
      /* @__PURE__ */ g.jsx(RF, { className: `block h-4 w-4 rounded-full bg-white ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disable
d:pointer-events-none disabled:opacity-50 cursor-pointer` })
    ]
  }
));
n_.displayName = t_.displayName;
function Al(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), s, i;
  for (i = 0; i < r.length; i++)
    s = r[i], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
var MF = ["color"], PF = /* @__PURE__ */ ai(function(t, e) {
  var n = t.color, r = n === void 0 ? "currentColor" : n, s = Al(t, MF);
  return Mn("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s, {
    ref: e
  }), Mn("path", {
    d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
    fill: r,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}), IF = ["color"], DF = /* @__PURE__ */ ai(function(t, e) {
  var n = t.color, r = n === void 0 ? "currentColor" : n, s = Al(t, IF);
  return Mn("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s, {
    ref: e
  }), Mn("path", {
    d: "M8.84182 3.13514C9.04327 3.32401 9.05348 3.64042 8.86462 3.84188L5.43521 7.49991L8.86462 11.1579C9.05348 11.3594 9.04327 11.6758 8.84182 11.8647C8.64036 12.0535 8.32394 12.0433 8.13508 11.8419L4.38508 7.84188C4.20477 7.64955 4.20477 7.35027 4.38508 7.15794L8.13508 3.15794C8.32394 2.95648 8.64036 2.94628 8.84182 3.13514Z",
    fill: r,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}), OF = ["color"], qF = /* @__PURE__ */ ai(function(t, e) {
  var n = t.color, r = n === void 0 ? "currentColor" : n, s = Al(t, OF);
  return Mn("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s, {
    ref: e
  }), Mn("path", {
    d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
    fill: r,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}), NF = ["color"], LF = /* @__PURE__ */ ai(function(t, e) {
  var n = t.color, r = n === void 0 ? "currentColor" : n, s = Al(t, NF);
  return Mn("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s, {
    ref: e
  }), Mn("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: r,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}), jF = ["color"], Qh = /* @__PURE__ */ ai(function(t, e) {
  var n = t.color, r = n === void 0 ? "currentColor" : n, s = Al(t, jF);
  return Mn("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s, {
    ref: e
  }), Mn("path", {
    d: "M1.84998 7.49998C1.84998 4.66458 4.05979 1.84998 7.49998 1.84998C10.2783 1.84998 11.6515 3.9064 12.2367 5H10.5C10.2239 5 10 5.22386 10 5.5C10 5.77614 10.2239 6 10.5 6H13.5C13.7761 6 14 5.77614 14 5.5V2.5C14 2.22386 13.7761 2 13.5 2C13.2239 2 13 2.22386 13 2.5V4.31318C12.2955 3.07126 10.6659 0.849976 7.49998 0.849976C3.43716 0.849976 0.849976 4.18537 0.849976 7.49998C0.849976 10.8146 3.43716 14.15 7.49998 14.15C9.44382 14.15 11.0622 13.3808 12.2145 12.2084C12.8315 11.5806 13.3133 10.839 13.6418 10.0407C13.7469 9.78536 13.6251 9.49315 13.3698 9.38806C13.1144 9.28296 12.8222 9.40478 12.7171 9.66014C12.4363 10.3425 12.0251 10.9745 11.5013 11.5074C10.5295 12.4963 9.16504 13.15 7.49998 13.15C4.05979 13.15 1.84998 10.3354 1.84998 7.49998Z",
    fill: r,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
const BF = ({
  handleStartGame: t,
  handleCashout: e
}) => {
  const {
    isGameActive: n,
    selectedCurrency: r,
    initializing: s,
    isAutoPlaying: i,
    currentAutoBet: o,
    isFinishingBet: a,
    setIsAutoPlaying: c,
    setIsFinishingBet: l,
    betRanges: u,
    selectedFiatCurrency: d,
    showFiat: f,
    fiatConversionRates: h,
    isFetching: p
  } = st(), { multiplier: m, selectedCells: y, preSelectMultiplier: b, revealedCells: v } = Hi(), {
    updateSettings: w,
    mode: x,
    betAmount: A,
    stopOnWin: C,
    stopOnLoss: S,
    numberOfBets: _,
    onWinMode: T,
    onLossMode: k,
    onWinValue: R,
    onLossValue: P,
    minesCount: M,
    errors: D,
    validateSettings: O
  } = Xo(), { addToast: q } = Aa(), L = (re) => r.crypto && d && f ? re.toFixed(d.fractionalDigits) : re.toFixed(r.fractionalDigits), N = r.crypto && d && f ? d.code : r.currencyCode, [j, V] = Ge(
    L(A)
  ), [Z, G] = Ge(null);
  _e(() => {
    if (A > Number(u.minBet))
      V(L(A));
    else if (u.minBet) {
      const re = L(Number(u.minBet));
      V(re);
    }
  }, [r, A, V]);
  const $ = (re, nt, kt = !1) => {
    kt && qn("tick"), w({ [re]: nt });
  }, fe = () => {
    i ? (c(!1), l(!0), q({
      variant: "notice",
      message: "Stopping Autoplay...",
      duration: 2e3
    })) : n ? e() : O() && t();
  }, he = () => a ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(Qh, { className: "mr-2 h-4 w-4 animate-spin" }),
    "Finishing bet..."
  ] }) : i ? _ === "" ? "Stop autobet" : `Stop autobet (${o} / ${_})` : n ? p ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(Qh, { className: "mr-2 h-4 w-4 animate-spin" }),
    "Cashing out..."
  ] }) : `Cash out ${m.toFixed(2)}x` : x === "auto" ? y.length > 0 ? "Start Autobet" : "Select cells to start" : p ? /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(Qh, { className: "mr-2 h-4 w-4 animate-spin" }),
    "Starting..."
  ] }) : "Place bet", be = (re) => `
    flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200
    ${Z === re ? "ring-1 ring-brand" : ""}`, He = "flex-grow bg-transparent border-none text-white text-base h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0", at = "h-9 w-16 px-2 text-sm bg-pills text-white hover:bg-opacity-80 font-bold", xt = "flex items-center space-x-1 bg-primary rounded-md p-1 h-11 w-1/2", tt = "flex-1 px-1 py-2 rounded text-xs font-bold whitespace-nowrap overflow-hidden", wt = "[&>.sliderTrack]:bg-red-500 [&>.sliderTrack]:h-1 [&>.sliderThumb]:h-4 [&>.sliderThumb]:w-2", F = n || i, ee = wl();
  return /* @__PURE__ */ g.jsxs("div", { className: "bg-secondary flex flex-col no-scrollbar w-full lg:w-1/3 p-4 space-y-4 order-2 lg:order-1 overflow-y-auto", children: [
    /* @__PURE__ */ g.jsxs(
      "div",
      {
        className: `bg-primary order-last lg:order-first p-2 rounded-md flex mt-4 lg:mb-4 lg:mt-0 ${F ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ g.jsx(
            "button",
            {
              onClick: () => $("mode", "manual", !0),
              disabled: n && x !== "manual",
              className: `flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all ${x === "manual" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: "Manual"
            }
          ),
          /* @__PURE__ */ g.jsx(
            "button",
            {
              onClick: () => $("mode", "auto", !0),
              disabled: n && x !== "auto",
              className: `flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all ${x === "auto" ? "bg-brand text-brand-cta-text" : "text-gray-400 hover:text-white"}`,
              children: "Auto"
            }
          )
        ]
      }
    ),
    x === "auto" && /* @__PURE__ */ g.jsxs(
      "div",
      {
        className: `flex rounded-md bg-primary p-4 py-2 lg:py-4 text-sm lg:text-base ${y.length === 0 ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ g.jsx("div", { className: "flex-1 space-y-2", children: /* @__PURE__ */ g.jsxs("div", { children: [
            /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Payout" }),
            /* @__PURE__ */ g.jsx("p", { className: "font-semibold tabular-nums text-green-500", children: ee ? ee(Number(A * b)) : "" })
          ] }) }),
          /* @__PURE__ */ g.jsx("div", { className: "mx-4 w-0.5 bg-slate-600", "aria-hidden": !0 }),
          /* @__PURE__ */ g.jsx("div", { className: "flex-1 space-y-2", children: /* @__PURE__ */ g.jsxs("div", { children: [
            /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Multiplier" }),
            /* @__PURE__ */ g.jsxs("p", { className: "font-semibold tabular-nums text-green-500", children: [
              b >= 1 ? b.toFixed(2) : "1.00",
              "x"
            ] })
          ] }) })
        ]
      }
    ),
    x === "manual" && /* @__PURE__ */ g.jsxs(
      "div",
      {
        className: `flex rounded-md bg-primary p-4 py-2 lg:py-4 text-sm lg:text-base ${v.length === 0 ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ g.jsx("div", { className: "flex-1 space-y-2", children: /* @__PURE__ */ g.jsxs("div", { children: [
            /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Payout" }),
            /* @__PURE__ */ g.jsx("p", { className: "font-semibold tabular-nums text-green-500", children: m >= 1 ? ee(A * m) : ee(0) })
          ] }) }),
          /* @__PURE__ */ g.jsx("div", { className: "mx-4 w-0.5 bg-slate-600", "aria-hidden": !0 }),
          /* @__PURE__ */ g.jsx("div", { className: "flex-1 space-y-2", children: /* @__PURE__ */ g.jsxs("div", { children: [
            /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Multiplier " }),
            /* @__PURE__ */ g.jsxs("p", { className: "font-semibold tabular-nums text-green-500", children: [
              m >= 1 ? m.toFixed(2) : "1.00",
              "x"
            ] })
          ] }) })
        ]
      }
    ),
    /* @__PURE__ */ g.jsx(
      "div",
      {
        className: `space-y-2 ${F ? "opacity-50 pointer-events-none" : ""}`,
        children: /* @__PURE__ */ g.jsx(
          qC,
          {
            betAmount: A,
            onBetAmountChange: (re) => $("betAmount", re),
            selectedCurrency: r,
            selectedFiatCurrency: d,
            fiatConversionRates: h,
            initializing: s,
            isDisabled: F,
            error: D.betAmount,
            betRanges: u,
            showFiat: f
          }
        )
      }
    ),
    /* @__PURE__ */ g.jsxs(
      "div",
      {
        className: `space-y-2 ${F ? "opacity-50 pointer-events-none" : ""}`,
        children: [
          /* @__PURE__ */ g.jsx(St, { className: "text-sm text-gray-400", children: "Mines" }),
          /* @__PURE__ */ g.jsxs("div", { className: "flex items-center space-x-3 bg-primary rounded-md p-3 h-11", children: [
            /* @__PURE__ */ g.jsx("img", { src: xy, width: "20", height: "20" }),
            /* @__PURE__ */ g.jsx(
              n_,
              {
                value: [M],
                onValueChange: (re) => $("minesCount", re[0], !1),
                min: 1,
                max: 24,
                step: 1,
                disabled: F,
                className: wt
              }
            ),
            /* @__PURE__ */ g.jsx("span", { className: "text-white font-bold bg-pills rounded-md px-2 py-1 min-w-[2rem] text-center text-sm", children: M })
          ] }),
          D.minesCount && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: D.minesCount })
        ]
      }
    ),
    /* @__PURE__ */ g.jsx(
      "div",
      {
        className: "space-y-4 transition-all duration-300 ease-in-out",
        style: {
          maxHeight: x === "auto" ? "100%" : "0%",
          overflow: x === "auto" ? "visible" : "hidden"
        },
        children: x === "auto" && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
          /* @__PURE__ */ g.jsxs(
            "div",
            {
              className: `space-y-2 ${F ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ g.jsx(St, { htmlFor: "numberOfBets", className: "text-sm text-gray-400", children: "Number of Bets" }),
                /* @__PURE__ */ g.jsxs("div", { className: be("numberOfBets"), children: [
                  /* @__PURE__ */ g.jsx(
                    qt,
                    {
                      id: "numberOfBets",
                      value: _,
                      onChange: (re) => $("numberOfBets", re.target.value, !1),
                      onFocus: () => G("numberOfBets"),
                      onBlur: () => G(null),
                      className: He
                    }
                  ),
                  ["", "10", "100"].map((re) => /* @__PURE__ */ g.jsx(
                    pt,
                    {
                      variant: "secondary",
                      onClick: () => $("numberOfBets", re, !0),
                      className: at,
                      children: re
                    },
                    re
                  ))
                ] }),
                D.numberOfBets && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: D.numberOfBets })
              ]
            }
          ),
          /* @__PURE__ */ g.jsxs(
            "div",
            {
              className: `space-y-2 ${F ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ g.jsx(St, { className: "text-sm text-gray-400", children: "On Win" }),
                /* @__PURE__ */ g.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ g.jsxs("div", { className: xt, children: [
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => $("onWinMode", "reset", !0),
                        className: `${tt} ${T === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Reset"
                      }
                    ),
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => $("onWinMode", "increase", !0),
                        className: `${tt} ${T === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Increase by"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ g.jsxs(
                    "div",
                    {
                      className: `${be("onWinValue")} ${T === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ g.jsx(
                          qt,
                          {
                            type: "number",
                            value: R,
                            onChange: (re) => $(
                              "onWinValue",
                              parseFloat(re.target.value)
                            ),
                            onFocus: () => G("onWinValue"),
                            onBlur: () => G(null),
                            className: He,
                            disabled: T === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ g.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                D.onWinValue && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: D.onWinValue })
              ]
            }
          ),
          /* @__PURE__ */ g.jsxs(
            "div",
            {
              className: `space-y-2 ${F ? "opacity-50 pointer-events-none" : ""}`,
              children: [
                /* @__PURE__ */ g.jsx(St, { className: "text-sm text-gray-400", children: "On Loss" }),
                /* @__PURE__ */ g.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ g.jsxs("div", { className: xt, children: [
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => $("onLossMode", "reset", !0),
                        className: `${tt} ${k === "reset" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Reset"
                      }
                    ),
                    /* @__PURE__ */ g.jsx(
                      "button",
                      {
                        onClick: () => $("onLossMode", "increase", !0),
                        className: `${tt} ${k === "increase" ? "bg-pills text-white" : "text-gray-400"}`,
                        children: "Increase by"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ g.jsxs(
                    "div",
                    {
                      className: `${be("onLossValue")} ${k === "reset" ? "opacity-50" : ""} flex-1`,
                      children: [
                        /* @__PURE__ */ g.jsx(
                          qt,
                          {
                            type: "number",
                            value: P,
                            onChange: (re) => $(
                              "onLossValue",
                              parseFloat(re.target.value)
                            ),
                            onFocus: () => G("onLossValue"),
                            onBlur: () => G(null),
                            className: He,
                            disabled: k === "reset",
                            style: {
                              WebkitAppearance: "none",
                              MozAppearance: "textfield"
                            }
                          }
                        ),
                        /* @__PURE__ */ g.jsx("span", { className: "text-gray-400 text-sm mr-2", children: "%" })
                      ]
                    }
                  )
                ] }),
                D.onLossValue && /* @__PURE__ */ g.jsx("span", { className: "text-red-500 text-xs", children: D.onLossValue })
              ]
            }
          ),
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "stopOnWin", className: "text-sm text-gray-400", children: "Stop on Win" }),
            /* @__PURE__ */ g.jsxs("div", { className: "flex items-center w-full bg-primary rounded-md px-2" + be("stopOnWin"), children: [
              /* @__PURE__ */ g.jsx("span", { children: /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container mr-1 mb-2", children: /* @__PURE__ */ g.jsx(
                "i",
                {
                  className: "currency-icon w-[20px] h-[20px] currency-icon-" + (N == null ? void 0 : N.toLowerCase())
                }
              ) }) }),
              /* @__PURE__ */ g.jsx(
                qt,
                {
                  id: "stopOnWin",
                  type: "number",
                  value: C,
                  onChange: (re) => $("stopOnWin", parseFloat(re.target.value)),
                  onFocus: () => G("stopOnWin"),
                  onBlur: () => G(null),
                  className: He,
                  style: {
                    WebkitAppearance: "none",
                    MozAppearance: "textfield"
                  }
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "stopOnLoss", className: "text-sm text-gray-400", children: "Stop on Loss" }),
            /* @__PURE__ */ g.jsxs(
              "div",
              {
                className: "flex items-center w-full bg-primary rounded-md px-2" + be("stopOnLoss"),
                children: [
                  /* @__PURE__ */ g.jsx("span", { children: /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container mr-1 mb-2", children: /* @__PURE__ */ g.jsx(
                    "i",
                    {
                      className: "currency-icon w-[20px] h-[20px] currency-icon-" + (N == null ? void 0 : N.toLowerCase())
                    }
                  ) }) }),
                  /* @__PURE__ */ g.jsx(
                    qt,
                    {
                      id: "stopOnLoss",
                      type: "number",
                      value: S,
                      onChange: (re) => $(
                        "stopOnLoss",
                        parseFloat(re.target.value)
                      ),
                      onFocus: () => G("stopOnLoss"),
                      onBlur: () => G(null),
                      className: He,
                      style: {
                        WebkitAppearance: "none",
                        MozAppearance: "textfield"
                      }
                    }
                  )
                ]
              }
            )
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ g.jsxs("div", { className: "lg:sticky lg:bottom-0 order-first lg:order-last bg-gray-850", children: [
      /* @__PURE__ */ g.jsx(
        pt,
        {
          className: "w-full bg-gradient-to-b select-none from-brand-gradient-start to-brand-gradient-end hover:from-brand hover:to-brand disabled:opacity-70 text-brand-cta-text text-sm font-bold py-4 rounded-lg h-11",
          onClick: fe,
          disabled: x === "auto" && y.length === 0 && !n && !i || a || p || n && v.length === 0,
          children: he()
        }
      ),
      /* @__PURE__ */ g.jsx(Go, { children: A === 0 && /* @__PURE__ */ g.jsx(
        os.div,
        {
          className: "bg-blue-500 text-white p-4 mt-4 rounded-lg shadow-lg z-100",
          initial: { opacity: 0, y: 0 },
          animate: { opacity: 1, y: -5 },
          exit: { opacity: 0, y: 0 },
          transition: { duration: 0.3 },
          children: /* @__PURE__ */ g.jsxs("div", { className: "flex items-start", children: [
            /* @__PURE__ */ g.jsx("div", { className: "flex-shrink-0 w-5 self-stretch mr-3", children: /* @__PURE__ */ g.jsx("div", { className: "h-full flex items-center", children: /* @__PURE__ */ g.jsx(kf, { className: "w-5 h-5" }) }) }),
            /* @__PURE__ */ g.jsx("div", { children: /* @__PURE__ */ g.jsxs("p", { className: "text-sm ont-bold", children: [
              "Betting ",
              ee(0),
              " will enter demo mode."
            ] }) })
          ] })
        }
      ) })
    ] })
  ] });
};
function gx() {
  const { multipliers: t } = Sa(), e = Et(null), n = fr();
  return _e(() => {
    e.current && (e.current.scrollLeft = 0);
  }, [t]), /* @__PURE__ */ g.jsxs(
    "div",
    {
      ref: e,
      className: `
         bg-secondary h-[50px] ${t.length === 0 ? "bg-opacity-0" : "bg-opacity-30"} scrollbar-hide
        ${n ? "mb-0 w-[94vw] max-w-full" : "p-2 absolute top-0 left-0 right-0 w-full"}
      `,
      children: [
        /* @__PURE__ */ g.jsx("div", { className: "flex flex-row-reverse space-x-reverse space-x-2 w-max select-none", children: /* @__PURE__ */ g.jsx(Go, { initial: !1, children: [...t].map((r, s) => /* @__PURE__ */ g.jsx(
          os.div,
          {
            initial: { opacity: 0, scale: 0.8, x: 20 },
            animate: {
              opacity: 1,
              scale: 1,
              x: 0,
              transition: {
                type: "spring",
                stiffness: 500,
                damping: 30,
                mass: 1
              }
            },
            exit: {
              opacity: 0,
              scale: 0.8,
              x: -20,
              transition: { duration: 0.2 }
            },
            className: `
                flex-shrink-0 px-3 py-2 rounded-md text-sm font-bold text-white shadow-lg
                ${r === 0 ? "bg-gradient-to-br from-red-500 to-red-700" : "bg-gradient-to-br from-green-500 to-green-600"}
              `,
            style: {
              textShadow: "0 1px 2px rgba(0, 0, 0, 0.2)"
            },
            children: r === 0 ? "0.00x" : r.toFixed(2) + "x"
          },
          s
        )) }) }),
        t.length !== 0 && /* @__PURE__ */ g.jsx("div", { className: "absolute top-0 right-0 bottom-0 w-20 pointer-events-none bg-gradient-to-l from-gray-800 to-transparent" })
      ]
    }
  );
}
const FF = 350, VF = () => {
  const { authToken: t } = ma(), e = fr(), n = Et(null), r = Et([]), s = Et(null), i = Et(!1), { betAmount: o, minesCount: a, mode: c, updateSettings: l, validateSettings: u } = Xo(), {
    theme: d,
    isGameActive: f,
    setIsGameActive: h,
    selectedCurrency: p,
    setInitializing: m,
    setBalance: y,
    balance: b,
    setIsAutoPlaying: v,
    isSoundMuted: w,
    activeRoundData: x,
    selectedFiatCurrency: A,
    showFiat: C,
    fiatConversionRates: S,
    setIsFetching: _,
    resetSharedStates: T
  } = st(), {
    setGameRoundId: k,
    revealCell: R,
    setMultiplier: P,
    setRevealedCells: M,
    revealedCells: D,
    gameRoundId: O,
    endGame: q,
    resetGame: L,
    toggleSelectedCell: N,
    selectedCells: j,
    updateBoard: V,
    board: Z,
    addFetchingCell: G,
    removeFetchingCell: $,
    fetchingCells: fe
  } = Hi(), { updateProfitData: he } = Sa(), { addToast: be } = Aa(), He = wl(), at = (Y) => Us.reverseConvertCurrency(Number(Y), A.code, p.currencyCode, S);
  _e(() => {
    w || AC(), (async () => {
      if (t)
        await xt();
      else
        throw m(!1), new Error("No authToken found.");
    })();
  }, [x, t]);
  const xt = Je(async () => {
    if (t && x.isRoundActive) {
      const { id: Y, wager: ye, betData: te, gameData: ve } = x;
      k(Number(Y)), h(!0), P(ve.multiplier), l({
        minesCount: Number(te.mines),
        betAmount: ye
      }), M(ve.selected), ve.selected.forEach((Ee) => {
        R(Ee, "diamond");
      });
    }
  }, []), tt = Je(async () => {
    if (t) {
      _(!0), L();
      try {
        const Y = {
          amount: p.crypto && A && C ? at(o).toFixed(p.fractionalDigits).toString() : o.toString(),
          currency: p.currencyCode,
          custom: {
            mines: a
          }
        }, ye = await by(
          t,
          "mines",
          Y
        );
        k(ye.roundId), ye.balance && y(ye.balance), h(ye.active);
      } catch (Y) {
        console.error("Error starting game:", Y), h(!1);
      } finally {
        _(!1);
      }
    }
  }, [
    o,
    k,
    a,
    L,
    p.currencyCode,
    y,
    h,
    t,
    be
  ]), wt = Je(
    (Y) => {
      Y.balance && y(Y.balance);
      const ye = Z.map((te, ve) => Y.custom.mines.includes(ve) ? "mine" : "diamond");
      V(ye), M(Y.custom.selected), Y.win ? (qn("win"), he(Y.winAmount ?? 0, Y.win, Y.multiplier ?? 0), P(Y.multiplier ?? 0)) : (qn("bomb"), he(Y.winAmount ?? 0, Y.win, Y.multiplier ?? 0)), q(He(Number(Y.winAmount)) ?? "");
    },
    [
      y,
      V,
      M,
      he,
      Z,
      q,
      P
    ]
  ), { startGameAuto: F } = jC(), ee = {
    delayMs: 1e3,
    gameType: "mines",
    getBetProps: (Y) => ({
      amount: p.crypto && A && C ? at(Y).toFixed(p.fractionalDigits).toString() : Y.toString(),
      currency: st.getState().selectedCurrency.currencyCode,
      custom: {
        mines: a,
        selected: j
      }
    }),
    handleAutoGameResponse: wt,
    validateSettings: u,
    resetGame: L
  }, re = Je(() => {
    f || !t || (EB(), c === "auto" && j.length > 0 ? F(ee, Xo) : tt());
  }, [
    f,
    t,
    c,
    j,
    F,
    tt
  ]), nt = Je(
    (Y, ye) => {
      if (M(Y.custom.selected), P(Y.multiplier), Y.custom.selected.forEach((te) => {
        R(
          te,
          Y.custom.mines.includes(te) ? "mine" : "diamond"
        );
      }), Y.active && !ye) {
        const ve = 1 + Y.custom.selected.length / 100;
        qn("diamond", { pitch: ve });
      } else {
        const te = Z.map((ve, Ee) => Y.custom.mines.includes(Ee) ? "mine" : "diamond");
        V(te), q(He(Number(Y.winAmount)) ?? ""), he(-o, Y.win, Y.multiplier ?? 0), h(!1), qn(Y.win ? "win" : "bomb");
      }
    },
    [
      o,
      q,
      R,
      h,
      P,
      M,
      he,
      Z,
      V
    ]
  ), kt = Je(async () => {
    if (r.current.length === 0 || i.current) return;
    i.current = !0;
    const Y = [...new Set(r.current)];
    if (r.current = [], !t || !f || !O) {
      i.current = !1;
      return;
    }
    try {
      const ye = {
        gameRoundId: O.toString(),
        custom: { selected: Y }
      };
      Y.forEach((ve) => G(ve));
      const te = await SB(
        t,
        "mines",
        ye
      );
      Y.forEach((ve) => $(ve)), nt(te, !1), te.active || (q(He(Number(te.winAmount)) ?? ""), h(!1), qn(te.win ? "win" : "bomb"));
    } catch (ye) {
      Y.forEach((te) => $(te)), ye instanceof Error ? ye.message === "Game has ended" && h(!1) : console.error("Unexpected error:", ye);
    } finally {
      i.current = !1, r.current.length > 0 && kt();
    }
  }, [
    t,
    f,
    O,
    nt,
    q,
    h,
    qn,
    G,
    $
  ]), Yn = Je(
    (Y) => {
      !t || !f || D.includes(Y) || !O || fe.includes(Y) || (r.current.push(Y), G(Y), console.log("Added cell to batch:", Y, "Current batch:", r.current), s.current && clearTimeout(s.current), s.current = setTimeout(() => {
        kt();
      }, FF));
    },
    [
      t,
      f,
      D,
      O,
      fe,
      kt
    ]
  ), Pn = Je(async () => {
    if (!t) return;
    if (st.getState().isAutoPlaying) {
      v(!1), n.current && clearTimeout(n.current);
      return;
    }
    if (!(!f || !O)) {
      if (D.length === 0) {
        be({
          variant: "error",
          message: "You have to select a cell before cashout.",
          duration: 2e3
        });
        return;
      }
      try {
        _(!0);
        const ye = await CB(
          t,
          "mines",
          O.toString()
        );
        P(ye.multiplier), console.log("endgame", He(Number(ye.winAmount)) ?? "");
        const te = o * ye.multiplier;
        q(He(Number(te)) ?? "");
        const ve = Z.map((Ee, xn) => ye.custom.mines.includes(xn) ? "mine" : "diamond");
        V(ve), b && y(b + ye.winAmount), he(ye.winAmount - o, ye.win, ye.multiplier ?? 0), h(!1), qn("win");
      } catch (ye) {
        console.error("Error cashing out:", ye);
      } finally {
        _(!1);
      }
    }
  }, [
    f,
    O,
    P,
    q,
    y,
    b,
    he,
    h,
    v,
    o,
    Z,
    V,
    t,
    be,
    D.length
  ]);
  _e(() => () => {
    s.current && clearTimeout(s.current);
  }, []), _e(() => {
    f || (r.current = [], s.current && clearTimeout(s.current));
  }, [f]);
  const Rt = d === "neobet" && !e ? {
    backgroundImage: `url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/mines/${d}/mines-bg.jpg)`,
    backgroundSize: "cover",
    backgroundPosition: "center"
  } : {};
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    /* @__PURE__ */ g.jsx(
      BF,
      {
        handleStartGame: re,
        handleCashout: Pn
      }
    ),
    /* @__PURE__ */ g.jsxs(
      "div",
      {
        className: "relative flex-grow lg:p-6 flex flex-col items-center justify-center order-1 lg:order-2",
        style: Rt,
        children: [
          !e && /* @__PURE__ */ g.jsx(gx, {}),
          /* @__PURE__ */ g.jsx("div", { className: `relative w-full ${e ? "" : "lg:max-w-[480px]"}`, children: /* @__PURE__ */ g.jsxs("div", { className: "relative z-10 bg-black p-3 lg:p-2 rounded-md w-full aspect-square", children: [
            e && /* @__PURE__ */ g.jsx(gx, {}),
            /* @__PURE__ */ g.jsx(
              iF,
              {
                handleRevealCell: Yn,
                handleAutoSelection: N
              }
            )
          ] }) }),
          !e && d !== "neobet" && /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
            /* @__PURE__ */ g.jsx(
              NC,
              {
                starHeight: 5,
                starWidth: 20,
                minSpeed: 5,
                maxSpeed: 20,
                trailColor: d === "betpanda" ? "#0c2d30" : "#dc016c",
                starColor: d === "betpanda" ? "#1fe88a" : "#dc016c"
              }
            ),
            /* @__PURE__ */ g.jsx(LC, { starDensity: 2e-3 })
          ] })
        ]
      }
    )
  ] });
}, UF = '*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:Nunito Sans,sans-serif;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}:root,:host{--background: 0 0% 100%;--foreground: 222.2 84% 4.9%;--card: 0 0% 100%;--card-foreground: 222.2 84% 4.9%;--popover: 0 0% 100%;--popover-foreground: 222.2 84% 4.9%;--primary: 222.2 47.4% 11.2%;--primary-foreground: 210 40% 98%;--secondary: 210 40% 96.1%;--secondary-foreground: 222.2 47.4% 11.2%;--muted: 210 40% 96.1%;--muted-foreground: 215.4 16.3% 46.9%;--accent: 210 40% 96.1%;--accent-foreground: 222.2 47.4% 11.2%;--destructive: 0 84.2% 60.2%;--destructive-foreground: 210 40% 98%;--border: 214.3 31.8% 91.4%;--input: 214.3 31.8% 91.4%;--ring: 222.2 84% 4.9%;--radius: .5rem;--chart-1: 12 76% 61%;--chart-2: 173 58% 39%;--chart-3: 197 37% 24%;--chart-4: 43 74% 66%;--chart-5: 27 87% 67%}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.no-scrollbar::-webkit-scrollbar{display:none}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.pointer-events-none{pointer-events:none}.pointer-events-auto{pointer-events:auto}.visible{visibility:visible}.invisible{visibility:hidden}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.inset-0{top:0;right:0;bottom:0;left:0}.inset-x-0{left:0;right:0}.inset-y-0{top:0;bottom:0}.-top-2{top:-.5rem}.bottom-0{bottom:0}.left-0{left:0}.left-1\\/2{left:50%}.left-2{left:.5rem}.left-3{left:.75rem}.left-\\[50\\%\\]{left:50%}.right-0{right:0}.right-3{right:.75rem}.right-4{right:1rem}.top-0{top:0}.top-4{top:1rem}.top-\\[50\\%\\]{top:50%}.top-full{top:100%}.z-10{z-index:10}.z-20{z-index:20}.z-50{z-index:50}.z-\\[1000\\]{z-index:1000}.z-\\[1001\\]{z-index:1001}.z-\\[1002\\]{z-index:1002}.order-1{order:1}.order-2{order:2}.order-first{order:-9999}.order-last{order:9999}.m-auto{margin:auto}.-mx-1{margin-left:-.25rem;margin-right:-.25rem}.mx-4{margin-left:1rem;margin-right:1rem}.mx-auto{margin-left:auto;margin-right:auto}.my-1{margin-top:.25rem;margin-bottom:.25rem}.mb-0{margin-bottom:0}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.mb-8{margin-bottom:2rem}.ml-2{margin-left:.5rem}.ml-4{margin-left:1rem}.ml-auto{margin-left:auto}.mr-1{margin-right:.25rem}.mr-2{margin-right:.5rem}.mr-3{margin-right:.75rem}.mr-4{margin-right:1rem}.mt-10{margin-top:2.5rem}.mt-2{margin-top:.5rem}.mt-24{margin-top:6rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-5{margin-top:1.25rem}.mt-6{margin-top:1.5rem}.mt-8{margin-top:2rem}.mt-auto{margin-top:auto}.block{display:block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.grid{display:grid}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.h-0{height:0px}.h-1{height:.25rem}.h-10{height:2.5rem}.h-11{height:2.75rem}.h-14{height:3.5rem}.h-16{height:4rem}.h-2{height:.5rem}.h-2\\.5{height:.625rem}.h-3\\.5{height:.875rem}.h-4{height:1rem}.h-44{height:11rem}.h-5{height:1.25rem}.h-6{height:1.5rem}.h-8{height:2rem}.h-9{height:2.25rem}.h-\\[1px\\]{height:1px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-\\[50vh\\]{height:50vh}.h-\\[55px\\]{height:55px}.h-auto{height:auto}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-\\[90\\%\\]{max-height:90%}.max-h-\\[90vh\\]{max-height:90vh}.max-h-\\[98vh\\]{max-height:98vh}.max-h-\\[calc\\(90vh-4rem\\)\\]{max-height:calc(90vh - 4rem)}.min-h-screen{min-height:100vh}.w-0{width:0px}.w-0\\.5{width:.125rem}.w-1\\/2{width:50%}.w-10{width:2.5rem}.w-12{width:3rem}.w-16{width:4rem}.w-2{width:.5rem}.w-2\\.5{width:.625rem}.w-20{width:5rem}.w-3\\.5{width:.875rem}.w-3\\/4{width:75%}.w-4{width:1rem}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-64{width:16rem}.w-72{width:18rem}.w-8{width:2rem}.w-80{width:20rem}.w-9{width:2.25rem}.w-\\[100px\\]{width:100px}.w-\\[110px\\]{width:110px}.w-\\[1px\\]{width:1px}.w-\\[20px\\]{width:20px}.w-\\[30\\%\\]{width:30%}.w-\\[70\\%\\]{width:70%}.w-\\[94vw\\]{width:94vw}.w-full{width:100%}.w-max{width:max-content}.min-w-\\[2rem\\]{min-width:2rem}.min-w-\\[8rem\\]{min-width:8rem}.max-w-\\[300px\\]{max-width:300px}.max-w-full{max-width:100%}.max-w-lg{max-width:32rem}.max-w-md{max-width:28rem}.max-w-xl{max-width:36rem}.flex-1{flex:1 1 0%}.flex-shrink-0,.shrink-0{flex-shrink:0}.flex-grow,.grow{flex-grow:1}.caption-bottom{caption-side:bottom}.-translate-x-1\\/2,.translate-x-\\[-50\\%\\]{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.translate-y-\\[-50\\%\\]{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes custom-pulse{0%,to{transform:scale(.95)}50%{transform:scale(1.05)}}.animate-custom-pulse{animation:custom-pulse .8s cubic-bezier(.4,0,.6,1) infinite}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-default{cursor:default}.cursor-move{cursor:move}.cursor-pointer{cursor:pointer}.touch-none{touch-action:none}.select-none{-webkit-user-select:none;user-select:none}.resize{resize:both}.list-disc{list-style-type:disc}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-wrap{flex-wrap:wrap}.items-start{align-items:flex-start}.items-center{align-items:center}.items-stretch{align-items:stretch}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1{gap:.25rem}.gap-1\\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-x-1>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.25rem * var(--tw-space-x-reverse));margin-left:calc(.25rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-3>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.75rem * var(--tw-space-x-reverse));margin-left:calc(.75rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-6>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1.5rem * var(--tw-space-x-reverse));margin-left:calc(1.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-0>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(0px * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0px * var(--tw-space-y-reverse))}.space-y-1\\.5>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.375rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.375rem * var(--tw-space-y-reverse))}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.space-x-reverse>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 1}.self-stretch{align-self:stretch}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.whitespace-nowrap{white-space:nowrap}.break-words{overflow-wrap:break-word}.rounded{border-radius:var(--radius)}.rounded-\\[inherit\\]{border-radius:inherit}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xl{border-radius:.75rem}.rounded-t-\\[10px\\]{border-top-left-radius:10px;border-top-right-radius:10px}.border{border-width:1px}.border-2{border-width:2px}.border-4{border-width:4px}.border-b{border-bottom-width:1px}.border-b-8{border-bottom-width:8px}.border-l{border-left-width:1px}.border-l-8{border-left-width:8px}.border-r{border-right-width:1px}.border-r-8{border-right-width:8px}.border-t{border-top-width:1px}.border-none{border-style:none}.border-border{border-color:hsl(var(--border))}.border-gray-700{--tw-border-opacity: 1;border-color:rgb(55 65 81 / var(--tw-border-opacity))}.border-green-500{--tw-border-opacity: 1;border-color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-border-opacity)))}.border-input{border-color:hsl(var(--input))}.border-red-500{--tw-border-opacity: 1;border-color:rgb(239 68 68 / var(--tw-border-opacity))}.border-secondary{--tw-border-opacity: 1;border-color:hsl(var(--twc-secondary) / var(--twc-secondary-opacity, var(--tw-border-opacity)))}.border-slate-600{--tw-border-opacity: 1;border-color:rgb(71 85 105 / var(--tw-border-opacity))}.border-slate-600\\/30{border-color:#4755694d}.border-slate-600\\/50{border-color:#47556980}.border-transparent{border-color:transparent}.border-b-blue-500{--tw-border-opacity: 1;border-bottom-color:rgb(59 130 246 / var(--tw-border-opacity))}.border-l-transparent{border-left-color:transparent}.border-t-brand{--tw-border-opacity: 1;border-top-color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-border-opacity)))}.border-t-transparent{border-top-color:transparent}.border-opacity-0{--tw-border-opacity: 0}.bg-\\[\\#04202b\\]{--tw-bg-opacity: 1;background-color:rgb(4 32 43 / var(--tw-bg-opacity))}.bg-\\[\\#0e1621\\]{--tw-bg-opacity: 1;background-color:rgb(14 22 33 / var(--tw-bg-opacity))}.bg-\\[\\#152538\\]{--tw-bg-opacity: 1;background-color:rgb(21 37 56 / var(--tw-bg-opacity))}.bg-\\[\\#2d3845\\]{--tw-bg-opacity: 1;background-color:rgb(45 56 69 / var(--tw-bg-opacity))}.bg-\\[\\#ff00ff\\]{--tw-bg-opacity: 1;background-color:rgb(255 0 255 / var(--tw-bg-opacity))}.bg-background{background-color:hsl(var(--background))}.bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.bg-black\\/80{background-color:#000c}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))}.bg-border{background-color:hsl(var(--border))}.bg-brand{--tw-bg-opacity: 1;background-color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-bg-opacity)))}.bg-card{background-color:hsl(var(--card))}.bg-destructive{--tw-bg-opacity: 1;background-color:hsl(var(--twc-destructive) / var(--twc-destructive-opacity, var(--tw-bg-opacity)))}.bg-gray-300{--tw-bg-opacity: 1;background-color:rgb(209 213 219 / var(--tw-bg-opacity))}.bg-gray-700{--tw-bg-opacity: 1;background-color:rgb(55 65 81 / var(--tw-bg-opacity))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity))}.bg-gray-950{--tw-bg-opacity: 1;background-color:rgb(3 7 18 / var(--tw-bg-opacity))}.bg-green-500{--tw-bg-opacity: 1;background-color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-bg-opacity)))}.bg-green-500\\/30{background-color:hsl(var(--twc-green-500) / .3)}.bg-muted{background-color:hsl(var(--muted))}.bg-muted\\/50{background-color:hsl(var(--muted) / .5)}.bg-pills{--tw-bg-opacity: 1;background-color:hsl(var(--twc-pills) / var(--twc-pills-opacity, var(--tw-bg-opacity)))}.bg-popover{background-color:hsl(var(--popover))}.bg-primary{--tw-bg-opacity: 1;background-color:hsl(var(--twc-primary) / var(--twc-primary-opacity, var(--tw-bg-opacity)))}.bg-red-400{--tw-bg-opacity: 1;background-color:rgb(248 113 113 / var(--tw-bg-opacity))}.bg-secondary{--tw-bg-opacity: 1;background-color:hsl(var(--twc-secondary) / var(--twc-secondary-opacity, var(--tw-bg-opacity)))}.bg-slate-600{--tw-bg-opacity: 1;background-color:rgb(71 85 105 / var(--tw-bg-opacity))}.bg-transparent{background-color:transparent}.bg-violet-700{--tw-bg-opacity: 1;background-color:rgb(109 40 217 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-white\\/40{background-color:#fff6}.bg-yellow-500{--tw-bg-opacity: 1;background-color:rgb(234 179 8 / var(--tw-bg-opacity))}.bg-opacity-0{--tw-bg-opacity: 0}.bg-opacity-30{--tw-bg-opacity: .3}.bg-gradient-to-b{background-image:linear-gradient(to bottom,var(--tw-gradient-stops))}.bg-gradient-to-br{background-image:linear-gradient(to bottom right,var(--tw-gradient-stops))}.bg-gradient-to-l{background-image:linear-gradient(to left,var(--tw-gradient-stops))}.bg-none{background-image:none}.from-brand-gradient-start{--tw-gradient-from: hsl(var(--twc-brand-gradient-start) / var(--twc-brand-gradient-start-opacity, 1)) var(--tw-gradient-from-position);--tw-gradient-to: hsl(var(--twc-brand-gradient-start) / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.from-gray-800{--tw-gradient-from: #1f2937 var(--tw-gradient-from-position);--tw-gradient-to: rgb(31 41 55 / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.from-green-500{--tw-gradient-from: hsl(var(--twc-green-500) / var(--twc-green-500-opacity, 1)) var(--tw-gradient-from-position);--tw-gradient-to: hsl(var(--twc-green-500) / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.from-red-500{--tw-gradient-from: #ef4444 var(--tw-gradient-from-position);--tw-gradient-to: rgb(239 68 68 / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.to-brand-gradient-end{--tw-gradient-to: hsl(var(--twc-brand-gradient-end) / var(--twc-brand-gradient-end-opacity, 1)) var(--tw-gradient-to-position)}.to-green-600{--tw-gradient-to: #16a34a var(--tw-gradient-to-position)}.to-red-700{--tw-gradient-to: #b91c1c var(--tw-gradient-to-position)}.to-transparent{--tw-gradient-to: transparent var(--tw-gradient-to-position)}.fill-current{fill:currentColor}.p-0{padding:0}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-8{padding:2rem}.p-\\[1px\\]{padding:1px}.px-1{padding-left:.25rem;padding-right:.25rem}.px-1\\.5{padding-left:.375rem;padding-right:.375rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-2\\.5{padding-left:.625rem;padding-right:.625rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.px-8{padding-left:2rem;padding-right:2rem}.py-0{padding-top:0;padding-bottom:0}.py-0\\.5{padding-top:.125rem;padding-bottom:.125rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pb-4{padding-bottom:1rem}.pb-\\[56px\\]{padding-bottom:56px}.pl-2\\.5{padding-left:.625rem}.pl-5{padding-left:1.25rem}.pl-8{padding-left:2rem}.pr-2{padding-right:.5rem}.pr-2\\.5{padding-right:.625rem}.pr-8{padding-right:2rem}.pt-0{padding-top:0}.pt-6{padding-top:1.5rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.align-middle{vertical-align:middle}.text-2xl{font-size:1.5rem;line-height:2rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-black{font-weight:900}.font-bold{font-weight:700}.font-extrabold{font-weight:800}.font-medium{font-weight:500}.font-semibold{font-weight:600}.uppercase{text-transform:uppercase}.lowercase{text-transform:lowercase}.tabular-nums{--tw-numeric-spacing: tabular-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.leading-none{line-height:1}.tracking-tight{letter-spacing:-.025em}.tracking-widest{letter-spacing:.1em}.text-brand{--tw-text-opacity: 1;color:hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-text-opacity)))}.text-brand-cta-text{--tw-text-opacity: 1;color:hsl(var(--twc-brand-cta-text) / var(--twc-brand-cta-text-opacity, var(--tw-text-opacity)))}.text-card-foreground{color:hsl(var(--card-foreground))}.text-foreground{color:hsl(var(--foreground))}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.text-green-400{--tw-text-opacity: 1;color:rgb(74 222 128 / var(--tw-text-opacity))}.text-green-500{--tw-text-opacity: 1;color:hsl(var(--twc-green-500) / var(--twc-green-500-opacity, var(--tw-text-opacity)))}.text-muted-foreground{color:hsl(var(--muted-foreground))}.text-popover-foreground{color:hsl(var(--popover-foreground))}.text-primary{--tw-text-opacity: 1;color:hsl(var(--twc-primary) / var(--twc-primary-opacity, var(--tw-text-opacity)))}.text-red-400{--tw-text-opacity: 1;color:rgb(248 113 113 / var(--tw-text-opacity))}.text-red-500{--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}.text-slate-400{--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline-offset-4{text-underline-offset:4px}.opacity-0{opacity:0}.opacity-100{opacity:1}.opacity-20{opacity:.2}.opacity-50{opacity:.5}.opacity-60{opacity:.6}.opacity-70{opacity:.7}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-2xl{--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / .25);--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-lg{--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-md{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.ring-1{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.ring-brand{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-ring-opacity)))}.ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.duration-200{transition-duration:.2s}.duration-300{transition-duration:.3s}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.will-change-auto{will-change:auto}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.animate-in{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.fade-in-0{--tw-enter-opacity: 0}.zoom-in-95{--tw-enter-scale: .95}.duration-200{animation-duration:.2s}.duration-300{animation-duration:.3s}.ease-in-out{animation-timing-function:cubic-bezier(.4,0,.2,1)}.betpanda,[data-theme=betpanda]{--twc-brand: 152.39999999999998 76.1% 44.3%;--twc-brand-gradient-start: 152.39999999999998 76.1% 44.3%;--twc-brand-gradient-end: 152.29999999999995 74.6% 37.1%;--twc-pills: 210.5 60% 18.6%;--twc-primary: 212.39999999999998 72.5% 10%;--twc-secondary: 212.60000000000002 45.5% 15.1%;--twc-green-500: 120.30000000000001 100% 45.3%}.betplay,[data-theme=betplay],.betplay-alt,[data-theme=betplay-alt]{--twc-brand: 333 83.3% 47.1%;--twc-brand-cta-text: 0 0% 100%;--twc-brand-gradient-start: 333 83.3% 47.1%;--twc-brand-gradient-end: 309.20000000000005 84% 32%;--twc-pills: 210.5 60% 18.6%;--twc-primary: 212.39999999999998 72.5% 10%;--twc-secondary: 212.60000000000002 45.5% 15.1%;--twc-border: 330.29999999999995 100% 43.1%;--twc-border-opacity: .64;--twc-green-500: 120.30000000000001 100% 45.3%}.neobet,[data-theme=neobet]{--twc-brand: 333 83.3% 47.1%;--twc-brand-cta-text: 0 0% 100%;--twc-brand-gradient-start: 333 83.3% 47.1%;--twc-brand-gradient-end: 309.20000000000005 84% 32%;--twc-pills: 210.5 60% 18.6%;--twc-primary: 212.39999999999998 72.5% 10%;--twc-secondary: 212.60000000000002 45.5% 15.1%;--twc-border: 330.29999999999995 100% 43.1%;--twc-border-opacity: .64;--twc-destructive: .30000000000001137 72.3% 50.4%;--twc-green-500: 120.30000000000001 100% 45.3%}.theme2,[data-theme=theme2]{--twc-brand: 120 100% 25.1%;--twc-primary: 0 0% 100%;--twc-secondary: 0 0% 94.1%}.\\[border\\:calc\\(var\\(--border-width\\)\\*1px\\)_solid_transparent\\]{border:calc(var(--border-width) * 1px) solid transparent}.\\!\\[mask-clip\\:padding-box\\,border-box\\]{-webkit-mask-clip:padding-box,border-box!important;mask-clip:padding-box,border-box!important}.\\!\\[mask-composite\\:intersect\\]{-webkit-mask-composite:source-in,xor!important;mask-composite:intersect!important}.\\[mask\\:linear-gradient\\(transparent\\,transparent\\)\\,linear-gradient\\(white\\,white\\)\\]{-webkit-mask:linear-gradient(transparent,transparent),linear-gradient(white,white);mask:linear-gradient(transparent,transparent),linear-gradient(white,white)}.currency-icon-container{order:1;width:20px;height:14px;text-align:left}.currency-icon-container i{width:14px;height:14px}.round-result .currency-icon-container{order:1;width:30px;height:20px;text-align:left}.round-result .currency-icon-container i{width:20px;height:20px}.currency-icon{background-repeat:no-repeat;background-size:100% auto;background-position:center;display:inline-block}.currency-icon-btc{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/btc.png)}.currency-icon-eur{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/eur.png)}.currency-icon-mbtc{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/mbtc.png)}.currency-icon-ubtc{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/ubtc.png)}.currency-icon-usdt{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/usdt.png)}.currency-icon-nano{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/nano.png)}.currency-icon-eth{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/eth.png)}.currency-icon-meth{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/meth.png)}.currency-icon-ltc{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/ltc.png)}.currency-icon-mltc{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/mltc.png)}.currency-icon-bnb{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/bnb.png)}.currency-icon-doge{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/doge.png)}.currency-icon-usd{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/usd.png)}.currency-icon-gold{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/gold.png)}.currency-icon-sol{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/sol.png)}.currency-icon-xmr{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/xmr.png)}.currency-icon-php{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/php.png)}.currency-icon-trx{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/trx.png)}.currency-icon-usdc{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/usdc.png)}.currency-icon-busd{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/busd.png)}.currency-icon-xrp{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/xrp.png)}.currency-icon-sand{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/sand.png)}.currency-icon-shib{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/shib.png)}.currency-icon-matic{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/matic.png)}.currency-icon-ton{background-image:url(https://nano-public.s3.eu-west-1.amazonaws.com/blink/images/icons/toncoin.png)}.file\\:border-0::file-selector-button{border-width:0px}.file\\:bg-transparent::file-selector-button{background-color:transparent}.file\\:text-sm::file-selector-button{font-size:.875rem;line-height:1.25rem}.file\\:font-medium::file-selector-button{font-weight:500}.file\\:text-foreground::file-selector-button{color:hsl(var(--foreground))}.placeholder\\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.after\\:absolute:after{content:var(--tw-content);position:absolute}.after\\:aspect-square:after{content:var(--tw-content);aspect-ratio:1 / 1}.after\\:w-\\[calc\\(var\\(--size\\)\\*1px\\)\\]:after{content:var(--tw-content);width:calc(var(--size) * 1px)}@keyframes border-beam{to{content:var(--tw-content);offset-distance:100%}}.after\\:animate-border-beam:after{content:var(--tw-content);animation:border-beam calc(var(--duration)*1s) infinite linear}.after\\:\\[animation-delay\\:var\\(--delay\\)\\]:after{content:var(--tw-content);animation-delay:var(--delay)}.after\\:\\[background\\:linear-gradient\\(to_left\\,var\\(--color-from\\)\\,var\\(--color-to\\)\\,transparent\\)\\]:after{content:var(--tw-content);background:linear-gradient(to left,var(--color-from),var(--color-to),transparent)}.after\\:\\[offset-anchor\\:calc\\(var\\(--anchor\\)\\*1\\%\\)_50\\%\\]:after{content:var(--tw-content);offset-anchor:calc(var(--anchor) * 1%) 50%}.after\\:\\[offset-path\\:rect\\(0_auto_auto_0_round_calc\\(var\\(--size\\)\\*1px\\)\\)\\]:after{content:var(--tw-content);offset-path:rect(0 auto auto 0 round calc(var(--size) * 1px))}@media (hover: hover) and (pointer: fine){.hover\\:bg-\\[\\#1a2634\\]:hover{--tw-bg-opacity: 1;background-color:rgb(26 38 52 / var(--tw-bg-opacity))}.hover\\:bg-\\[\\#2d3845\\]:hover{--tw-bg-opacity: 1;background-color:rgb(45 56 69 / var(--tw-bg-opacity))}.hover\\:bg-\\[\\#ff33ff\\]:hover{--tw-bg-opacity: 1;background-color:rgb(255 51 255 / var(--tw-bg-opacity))}.hover\\:bg-accent:hover{background-color:hsl(var(--accent))}.hover\\:bg-brand\\/80:hover{background-color:hsl(var(--twc-brand) / .8)}.hover\\:bg-destructive\\/80:hover{background-color:hsl(var(--twc-destructive) / .8)}.hover\\:bg-destructive\\/90:hover{background-color:hsl(var(--twc-destructive) / .9)}.hover\\:bg-gray-700:hover{--tw-bg-opacity: 1;background-color:rgb(55 65 81 / var(--tw-bg-opacity))}.hover\\:bg-muted\\/50:hover{background-color:hsl(var(--muted) / .5)}.hover\\:bg-primary\\/80:hover{background-color:hsl(var(--twc-primary) / .8)}.hover\\:bg-primary\\/90:hover{background-color:hsl(var(--twc-primary) / .9)}.hover\\:bg-red-500:hover{--tw-bg-opacity: 1;background-color:rgb(239 68 68 / var(--tw-bg-opacity))}.hover\\:bg-secondary\\/80:hover{background-color:hsl(var(--twc-secondary) / .8)}.hover\\:bg-white:hover{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.hover\\:bg-opacity-80:hover{--tw-bg-opacity: .8}.hover\\:from-brand:hover{--tw-gradient-from: hsl(var(--twc-brand) / var(--twc-brand-opacity, 1)) var(--tw-gradient-from-position);--tw-gradient-to: hsl(var(--twc-brand) / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.hover\\:to-brand:hover{--tw-gradient-to: hsl(var(--twc-brand) / var(--twc-brand-opacity, 1)) var(--tw-gradient-to-position)}.hover\\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.hover\\:text-white:hover{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}}.focus\\:bg-accent:focus{background-color:hsl(var(--accent))}.focus\\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.focus\\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\\:border-0:focus-visible{border-width:0px}.focus-visible\\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\\:ring-0:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-brand:focus-visible{--tw-ring-opacity: 1;--tw-ring-color: hsl(var(--twc-brand) / var(--twc-brand-opacity, var(--tw-ring-opacity)))}.focus-visible\\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.focus-visible\\:ring-offset-0:focus-visible{--tw-ring-offset-width: 0px}.focus-visible\\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-100:disabled{opacity:1}.disabled\\:opacity-50:disabled{opacity:.5}.disabled\\:opacity-70:disabled{opacity:.7}.disabled\\:opacity-80:disabled{opacity:.8}@media (hover: hover) and (pointer: fine){.group:hover .group-hover\\:text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}}.peer:disabled~.peer-disabled\\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\\:opacity-70{opacity:.7}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}@keyframes accordion-up{0%{height:var(--radix-accordion-content-height)}to{height:0}}.data-\\[state\\=closed\\]\\:animate-accordion-up[data-state=closed]{animation:accordion-up .2s ease-out}@keyframes accordion-down{0%{height:0}to{height:var(--radix-accordion-content-height)}}.data-\\[state\\=open\\]\\:animate-accordion-down[data-state=open]{animation:accordion-down .2s ease-out}.data-\\[state\\=open\\]\\:bg-accent[data-state=open]{background-color:hsl(var(--accent))}.data-\\[state\\=open\\]\\:bg-secondary[data-state=open]{--tw-bg-opacity: 1;background-color:hsl(var(--twc-secondary) / var(--twc-secondary-opacity, var(--tw-bg-opacity)))}.data-\\[state\\=selected\\]\\:bg-muted[data-state=selected]{background-color:hsl(var(--muted))}.data-\\[state\\=open\\]\\:text-muted-foreground[data-state=open]{color:hsl(var(--muted-foreground))}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[state\\=closed\\]\\:duration-300[data-state=closed]{transition-duration:.3s}.data-\\[state\\=open\\]\\:duration-500[data-state=open]{transition-duration:.5s}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.data-\\[state\\=closed\\]\\:slide-out-to-bottom[data-state=closed]{--tw-exit-translate-y: 100%}.data-\\[state\\=closed\\]\\:slide-out-to-left[data-state=closed]{--tw-exit-translate-x: -100%}.data-\\[state\\=closed\\]\\:slide-out-to-left-1\\/2[data-state=closed]{--tw-exit-translate-x: -50%}.data-\\[state\\=closed\\]\\:slide-out-to-right[data-state=closed]{--tw-exit-translate-x: 100%}.data-\\[state\\=closed\\]\\:slide-out-to-top[data-state=closed]{--tw-exit-translate-y: -100%}.data-\\[state\\=closed\\]\\:slide-out-to-top-\\[48\\%\\][data-state=closed]{--tw-exit-translate-y: -48%}.data-\\[state\\=open\\]\\:slide-in-from-bottom[data-state=open]{--tw-enter-translate-y: 100%}.data-\\[state\\=open\\]\\:slide-in-from-left[data-state=open]{--tw-enter-translate-x: -100%}.data-\\[state\\=open\\]\\:slide-in-from-left-1\\/2[data-state=open]{--tw-enter-translate-x: -50%}.data-\\[state\\=open\\]\\:slide-in-from-right[data-state=open]{--tw-enter-translate-x: 100%}.data-\\[state\\=open\\]\\:slide-in-from-top[data-state=open]{--tw-enter-translate-y: -100%}.data-\\[state\\=open\\]\\:slide-in-from-top-\\[48\\%\\][data-state=open]{--tw-enter-translate-y: -48%}.data-\\[state\\=closed\\]\\:duration-300[data-state=closed]{animation-duration:.3s}.data-\\[state\\=open\\]\\:duration-500[data-state=open]{animation-duration:.5s}@media (min-width: 640px){.sm\\:w-\\[30\\%\\]{width:30%}.sm\\:w-\\[70\\%\\]{width:70%}.sm\\:max-w-\\[425px\\]{max-width:425px}.sm\\:max-w-sm{max-width:24rem}.sm\\:flex-row{flex-direction:row}.sm\\:justify-end{justify-content:flex-end}.sm\\:space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.sm\\:space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.sm\\:space-y-0>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(0px * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0px * var(--tw-space-y-reverse))}.sm\\:rounded-lg{border-radius:var(--radius)}.sm\\:text-left{text-align:left}}@media (min-width: 768px){.md\\:ml-\\[60px\\]{margin-left:60px}.md\\:flex{display:flex}.md\\:hidden{display:none}.md\\:max-w-\\[600px\\]{max-width:600px}}@media (min-width: 1024px){.lg\\:absolute{position:absolute}.lg\\:sticky{position:sticky}.lg\\:bottom-0{bottom:0}.lg\\:left-0{left:0}.lg\\:left-4{left:1rem}.lg\\:right-0{right:0}.lg\\:order-1{order:1}.lg\\:order-2{order:2}.lg\\:order-first{order:-9999}.lg\\:order-last{order:9999}.lg\\:mb-0{margin-bottom:0}.lg\\:mb-10{margin-bottom:2.5rem}.lg\\:mb-4{margin-bottom:1rem}.lg\\:mt-0{margin-top:0}.lg\\:mt-10{margin-top:2.5rem}.lg\\:h-\\[600px\\]{height:600px}.lg\\:min-h-screen{min-height:100vh}.lg\\:w-1\\/3{width:33.333333%}.lg\\:w-\\[23rem\\]{width:23rem}.lg\\:max-w-\\[1200px\\]{max-width:1200px}.lg\\:max-w-\\[340px\\]{max-width:340px}.lg\\:max-w-\\[480px\\]{max-width:480px}.lg\\:flex-row{flex-direction:row}.lg\\:rounded-lg{border-radius:var(--radius)}.lg\\:p-2{padding:.5rem}.lg\\:p-6{padding:1.5rem}.lg\\:py-4{padding-top:1rem;padding-bottom:1rem}.lg\\:pt-10{padding-top:2.5rem}.lg\\:text-base{font-size:1rem;line-height:1.5rem}}.\\[\\&\\:has\\(\\[role\\=checkbox\\]\\)\\]\\:pr-0:has([role=checkbox]){padding-right:0}.\\[\\&\\>\\.sliderThumb\\]\\:h-4>.sliderThumb{height:1rem}.\\[\\&\\>\\.sliderThumb\\]\\:w-2>.sliderThumb{width:.5rem}.\\[\\&\\>\\.sliderTrack\\]\\:h-1>.sliderTrack{height:.25rem}.\\[\\&\\>\\.sliderTrack\\]\\:bg-red-500>.sliderTrack{--tw-bg-opacity: 1;background-color:rgb(239 68 68 / var(--tw-bg-opacity))}.\\[\\&\\>\\[role\\=checkbox\\]\\]\\:translate-y-\\[2px\\]>[role=checkbox]{--tw-translate-y: 2px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\\[\\&\\>tr\\]\\:last\\:border-b-0:last-child>tr{border-bottom-width:0px}.\\[\\&\\[data-state\\=open\\]\\>svg\\]\\:rotate-180[data-state=open]>svg{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\\[\\&_tr\\:last-child\\]\\:border-0 tr:last-child{border-width:0px}.\\[\\&_tr\\]\\:border-b tr{border-bottom-width:1px}';
function r_(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Zt(t);
  E.useEffect(() => {
    const r = (s) => {
      s.key === "Escape" && n(s);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var WF = "DismissableLayer", xm = "dismissableLayer.update", zF = "dismissableLayer.pointerDownOutside", HF = "dismissableLayer.focusOutside", yx, s_ = E.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), i_ = E.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: s,
      onFocusOutside: i,
      onInteractOutside: o,
      onDismiss: a,
      ...c
    } = t, l = E.useContext(s_), [u, d] = E.useState(null), f = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = E.useState({}), p = Ke(e, (S) => d(S)), m = Array.from(l.layers), [y] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), b = m.indexOf(y), v = u ? m.indexOf(u) : -1, w = l.layersWithOutsidePointerEventsDisabled.size > 0, x = v >= b, A = KF((S) => {
      const _ = S.target, T = [...l.branches].some((k) => k.contains(_));
      !x || T || (s == null || s(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, f), C = $F((S) => {
      const _ = S.target;
      [...l.branches].some((k) => k.contains(_)) || (i == null || i(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, f);
    return r_((S) => {
      v === l.layers.size - 1 && (r == null || r(S), !S.defaultPrevented && a && (S.preventDefault(), a()));
    }, f), E.useEffect(() => {
      if (u)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (yx = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(u)), l.layers.add(u), bx(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = yx);
        };
    }, [u, f, n, l]), E.useEffect(() => () => {
      u && (l.layers.delete(u), l.layersWithOutsidePointerEventsDisabled.delete(u), bx());
    }, [u, l]), E.useEffect(() => {
      const S = () => h({});
      return document.addEventListener(xm, S), () => document.removeEventListener(xm, S);
    }, []), /* @__PURE__ */ g.jsx(
      ze.div,
      {
        ...c,
        ref: p,
        style: {
          pointerEvents: w ? x ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: We(t.onFocusCapture, C.onFocusCapture),
        onBlurCapture: We(t.onBlurCapture, C.onBlurCapture),
        onPointerDownCapture: We(
          t.onPointerDownCapture,
          A.onPointerDownCapture
        )
      }
    );
  }
);
i_.displayName = WF;
var YF = "DismissableLayerBranch", GF = E.forwardRef((t, e) => {
  const n = E.useContext(s_), r = E.useRef(null), s = Ke(e, r);
  return E.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ g.jsx(ze.div, { ...t, ref: s });
});
GF.displayName = YF;
function KF(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Zt(t), r = E.useRef(!1), s = E.useRef(() => {
  });
  return E.useEffect(() => {
    const i = (a) => {
      if (a.target && !r.current) {
        let c = function() {
          o_(
            zF,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: a };
        a.pointerType === "touch" ? (e.removeEventListener("click", s.current), s.current = c, e.addEventListener("click", s.current, { once: !0 })) : c();
      } else
        e.removeEventListener("click", s.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(o), e.removeEventListener("pointerdown", i), e.removeEventListener("click", s.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function $F(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Zt(t), r = E.useRef(!1);
  return E.useEffect(() => {
    const s = (i) => {
      i.target && !r.current && o_(HF, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", s), () => e.removeEventListener("focusin", s);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function bx() {
  const t = new CustomEvent(xm);
  document.dispatchEvent(t);
}
function o_(t, e, n, { discrete: r }) {
  const s = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && s.addEventListener(t, e, { once: !0 }), r ? vC(s, i) : s.dispatchEvent(i);
}
var ZF = E.useId || (() => {
}), QF = 0;
function jo(t) {
  const [e, n] = E.useState(ZF());
  return bn(() => {
    n((r) => r ?? String(QF++));
  }, [t]), e ? `radix-${e}` : "";
}
const XF = ["top", "right", "bottom", "left"], Js = Math.min, jn = Math.max, Dd = Math.round, Yl = Math.floor, ei = (t) => ({
  x: t,
  y: t
}), JF = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, e5 = {
  start: "end",
  end: "start"
};
function wm(t, e, n) {
  return jn(t, Js(e, n));
}
function ds(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function fs(t) {
  return t.split("-")[0];
}
function _a(t) {
  return t.split("-")[1];
}
function Cy(t) {
  return t === "x" ? "y" : "x";
}
function _y(t) {
  return t === "y" ? "height" : "width";
}
function ti(t) {
  return ["top", "bottom"].includes(fs(t)) ? "y" : "x";
}
function Ty(t) {
  return Cy(ti(t));
}
function t5(t, e, n) {
  n === void 0 && (n = !1);
  const r = _a(t), s = Ty(t), i = _y(s);
  let o = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (o = Od(o)), [o, Od(o)];
}
function n5(t) {
  const e = Od(t);
  return [Am(t), e, Am(e)];
}
function Am(t) {
  return t.replace(/start|end/g, (e) => e5[e]);
}
function r5(t, e, n) {
  const r = ["left", "right"], s = ["right", "left"], i = ["top", "bottom"], o = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? s : r : e ? r : s;
    case "left":
    case "right":
      return e ? i : o;
    default:
      return [];
  }
}
function s5(t, e, n, r) {
  const s = _a(t);
  let i = r5(fs(t), n === "start", r);
  return s && (i = i.map((o) => o + "-" + s), e && (i = i.concat(i.map(Am)))), i;
}
function Od(t) {
  return t.replace(/left|right|bottom|top/g, (e) => JF[e]);
}
function i5(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function a_(t) {
  return typeof t != "number" ? i5(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function qd(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: s
  } = t;
  return {
    width: r,
    height: s,
    top: n,
    left: e,
    right: e + r,
    bottom: n + s,
    x: e,
    y: n
  };
}
function vx(t, e, n) {
  let {
    reference: r,
    floating: s
  } = t;
  const i = ti(e), o = Ty(e), a = _y(o), c = fs(e), l = i === "y", u = r.x + r.width / 2 - s.width / 2, d = r.y + r.height / 2 - s.height / 2, f = r[a] / 2 - s[a] / 2;
  let h;
  switch (c) {
    case "top":
      h = {
        x: u,
        y: r.y - s.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: r.x - s.width,
        y: d
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (_a(e)) {
    case "start":
      h[o] -= f * (n && l ? -1 : 1);
      break;
    case "end":
      h[o] += f * (n && l ? -1 : 1);
      break;
  }
  return h;
}
const o5 = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: s = "absolute",
    middleware: i = [],
    platform: o
  } = n, a = i.filter(Boolean), c = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let l = await o.getElementRects({
    reference: t,
    floating: e,
    strategy: s
  }), {
    x: u,
    y: d
  } = vx(l, r, c), f = r, h = {}, p = 0;
  for (let m = 0; m < a.length; m++) {
    const {
      name: y,
      fn: b
    } = a[m], {
      x: v,
      y: w,
      data: x,
      reset: A
    } = await b({
      x: u,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: s,
      middlewareData: h,
      rects: l,
      platform: o,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = v ?? u, d = w ?? d, h = {
      ...h,
      [y]: {
        ...h[y],
        ...x
      }
    }, A && p <= 50 && (p++, typeof A == "object" && (A.placement && (f = A.placement), A.rects && (l = A.rects === !0 ? await o.getElementRects({
      reference: t,
      floating: e,
      strategy: s
    }) : A.rects), {
      x: u,
      y: d
    } = vx(l, f, c)), m = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: s,
    middlewareData: h
  };
};
async function $c(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: s,
    platform: i,
    rects: o,
    elements: a,
    strategy: c
  } = t, {
    boundary: l = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = ds(e, t), p = a_(h), y = a[f ? d === "floating" ? "reference" : "floating" : d], b = qd(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(y))) == null || n ? y : y.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: l,
    rootBoundary: u,
    strategy: c
  })), v = d === "floating" ? {
    x: r,
    y: s,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), x = await (i.isElement == null ? void 0 : i.isElement(w)) ? await (i.getScale == null ? void 0 : i.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, A = qd(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: v,
    offsetParent: w,
    strategy: c
  }) : v);
  return {
    top: (b.top - A.top + p.top) / x.y,
    bottom: (A.bottom - b.bottom + p.bottom) / x.y,
    left: (b.left - A.left + p.left) / x.x,
    right: (A.right - b.right + p.right) / x.x
  };
}
const a5 = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: s,
      rects: i,
      platform: o,
      elements: a,
      middlewareData: c
    } = e, {
      element: l,
      padding: u = 0
    } = ds(t, e) || {};
    if (l == null)
      return {};
    const d = a_(u), f = {
      x: n,
      y: r
    }, h = Ty(s), p = _y(h), m = await o.getDimensions(l), y = h === "y", b = y ? "top" : "left", v = y ? "bottom" : "right", w = y ? "clientHeight" : "clientWidth", x = i.reference[p] + i.reference[h] - f[h] - i.floating[p], A = f[h] - i.reference[h], C = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(l));
    let S = C ? C[w] : 0;
    (!S || !await (o.isElement == null ? void 0 : o.isElement(C))) && (S = a.floating[w] || i.floating[p]);
    const _ = x / 2 - A / 2, T = S / 2 - m[p] / 2 - 1, k = Js(d[b], T), R = Js(d[v], T), P = k, M = S - m[p] - R, D = S / 2 - m[p] / 2 + _, O = wm(P, D, M), q = !c.arrow && _a(s) != null && D !== O && i.reference[p] / 2 - (D < P ? k : R) - m[p] / 2 < 0, L = q ? D < P ? D - P : D - M : 0;
    return {
      [h]: f[h] + L,
      data: {
        [h]: O,
        centerOffset: D - O - L,
        ...q && {
          alignmentOffset: L
        }
      },
      reset: q
    };
  }
}), c5 = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: s,
        middlewareData: i,
        rects: o,
        initialPlacement: a,
        platform: c,
        elements: l
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...y
      } = ds(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const b = fs(s), v = ti(a), w = fs(a) === a, x = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)), A = f || (w || !m ? [Od(a)] : n5(a)), C = p !== "none";
      !f && C && A.push(...s5(a, m, p, x));
      const S = [a, ...A], _ = await $c(e, y), T = [];
      let k = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (u && T.push(_[b]), d) {
        const D = t5(s, o, x);
        T.push(_[D[0]], _[D[1]]);
      }
      if (k = [...k, {
        placement: s,
        overflows: T
      }], !T.every((D) => D <= 0)) {
        var R, P;
        const D = (((R = i.flip) == null ? void 0 : R.index) || 0) + 1, O = S[D];
        if (O)
          return {
            data: {
              index: D,
              overflows: k
            },
            reset: {
              placement: O
            }
          };
        let q = (P = k.filter((L) => L.overflows[0] <= 0).sort((L, N) => L.overflows[1] - N.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!q)
          switch (h) {
            case "bestFit": {
              var M;
              const L = (M = k.filter((N) => {
                if (C) {
                  const j = ti(N.placement);
                  return j === v || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  j === "y";
                }
                return !0;
              }).map((N) => [N.placement, N.overflows.filter((j) => j > 0).reduce((j, V) => j + V, 0)]).sort((N, j) => N[1] - j[1])[0]) == null ? void 0 : M[0];
              L && (q = L);
              break;
            }
            case "initialPlacement":
              q = a;
              break;
          }
        if (s !== q)
          return {
            reset: {
              placement: q
            }
          };
      }
      return {};
    }
  };
};
function xx(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function wx(t) {
  return XF.some((e) => t[e] >= 0);
}
const l5 = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...s
      } = ds(t, e);
      switch (r) {
        case "referenceHidden": {
          const i = await $c(e, {
            ...s,
            elementContext: "reference"
          }), o = xx(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: wx(o)
            }
          };
        }
        case "escaped": {
          const i = await $c(e, {
            ...s,
            altBoundary: !0
          }), o = xx(i, n.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: wx(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function u5(t, e) {
  const {
    placement: n,
    platform: r,
    elements: s
  } = t, i = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = fs(n), a = _a(n), c = ti(n) === "y", l = ["left", "top"].includes(o) ? -1 : 1, u = i && c ? -1 : 1, d = ds(e, t);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof p == "number" && (h = a === "end" ? p * -1 : p), c ? {
    x: h * u,
    y: f * l
  } : {
    x: f * l,
    y: h * u
  };
}
const d5 = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: s,
        y: i,
        placement: o,
        middlewareData: a
      } = e, c = await u5(e, t);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: s + c.x,
        y: i + c.y,
        data: {
          ...c,
          placement: o
        }
      };
    }
  };
}, f5 = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: s
      } = e, {
        mainAxis: i = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (y) => {
            let {
              x: b,
              y: v
            } = y;
            return {
              x: b,
              y: v
            };
          }
        },
        ...c
      } = ds(t, e), l = {
        x: n,
        y: r
      }, u = await $c(e, c), d = ti(fs(s)), f = Cy(d);
      let h = l[f], p = l[d];
      if (i) {
        const y = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", v = h + u[y], w = h - u[b];
        h = wm(v, h, w);
      }
      if (o) {
        const y = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", v = p + u[y], w = p - u[b];
        p = wm(v, p, w);
      }
      const m = a.fn({
        ...e,
        [f]: h,
        [d]: p
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r,
          enabled: {
            [f]: i,
            [d]: o
          }
        }
      };
    }
  };
}, h5 = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: s,
        rects: i,
        middlewareData: o
      } = e, {
        offset: a = 0,
        mainAxis: c = !0,
        crossAxis: l = !0
      } = ds(t, e), u = {
        x: n,
        y: r
      }, d = ti(s), f = Cy(d);
      let h = u[f], p = u[d];
      const m = ds(a, e), y = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (c) {
        const w = f === "y" ? "height" : "width", x = i.reference[f] - i.floating[w] + y.mainAxis, A = i.reference[f] + i.reference[w] - y.mainAxis;
        h < x ? h = x : h > A && (h = A);
      }
      if (l) {
        var b, v;
        const w = f === "y" ? "width" : "height", x = ["top", "left"].includes(fs(s)), A = i.reference[d] - i.floating[w] + (x && ((b = o.offset) == null ? void 0 : b[d]) || 0) + (x ? 0 : y.crossAxis), C = i.reference[d] + i.reference[w] + (x ? 0 : ((v = o.offset) == null ? void 0 : v[d]) || 0) - (x ? y.crossAxis : 0);
        p < A ? p = A : p > C && (p = C);
      }
      return {
        [f]: h,
        [d]: p
      };
    }
  };
}, p5 = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: s,
        rects: i,
        platform: o,
        elements: a
      } = e, {
        apply: c = () => {
        },
        ...l
      } = ds(t, e), u = await $c(e, l), d = fs(s), f = _a(s), h = ti(s) === "y", {
        width: p,
        height: m
      } = i.floating;
      let y, b;
      d === "top" || d === "bottom" ? (y = d, b = f === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (b = d, y = f === "end" ? "top" : "bottom");
      const v = m - u.top - u.bottom, w = p - u.left - u.right, x = Js(m - u[y], v), A = Js(p - u[b], w), C = !e.middlewareData.shift;
      let S = x, _ = A;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (_ = w), (r = e.middlewareData.shift) != null && r.enabled.y && (S = v), C && !f) {
        const k = jn(u.left, 0), R = jn(u.right, 0), P = jn(u.top, 0), M = jn(u.bottom, 0);
        h ? _ = p - 2 * (k !== 0 || R !== 0 ? k + R : jn(u.left, u.right)) : S = m - 2 * (P !== 0 || M !== 0 ? P + M : jn(u.top, u.bottom));
      }
      await c({
        ...e,
        availableWidth: _,
        availableHeight: S
      });
      const T = await o.getDimensions(a.floating);
      return p !== T.width || m !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function If() {
  return typeof window < "u";
}
function Ta(t) {
  return c_(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Un(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function qr(t) {
  var e;
  return (e = (c_(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function c_(t) {
  return If() ? t instanceof Node || t instanceof Un(t).Node : !1;
}
function ur(t) {
  return If() ? t instanceof Element || t instanceof Un(t).Element : !1;
}
function Or(t) {
  return If() ? t instanceof HTMLElement || t instanceof Un(t).HTMLElement : !1;
}
function Ax(t) {
  return !If() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Un(t).ShadowRoot;
}
function Sl(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: s
  } = dr(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(s);
}
function m5(t) {
  return ["table", "td", "th"].includes(Ta(t));
}
function Df(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function ky(t) {
  const e = Ry(), n = ur(t) ? dr(t) : t;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function g5(t) {
  let e = ni(t);
  for (; Or(e) && !Jo(e); ) {
    if (ky(e))
      return e;
    if (Df(e))
      return null;
    e = ni(e);
  }
  return null;
}
function Ry() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Jo(t) {
  return ["html", "body", "#document"].includes(Ta(t));
}
function dr(t) {
  return Un(t).getComputedStyle(t);
}
function Of(t) {
  return ur(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function ni(t) {
  if (Ta(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Ax(t) && t.host || // Fallback.
    qr(t)
  );
  return Ax(e) ? e.host : e;
}
function l_(t) {
  const e = ni(t);
  return Jo(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Or(e) && Sl(e) ? e : l_(e);
}
function Zc(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const s = l_(t), i = s === ((r = t.ownerDocument) == null ? void 0 : r.body), o = Un(s);
  if (i) {
    const a = Sm(o);
    return e.concat(o, o.visualViewport || [], Sl(s) ? s : [], a && n ? Zc(a) : []);
  }
  return e.concat(s, Zc(s, [], n));
}
function Sm(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function u_(t) {
  const e = dr(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const s = Or(t), i = s ? t.offsetWidth : n, o = s ? t.offsetHeight : r, a = Dd(n) !== i || Dd(r) !== o;
  return a && (n = i, r = o), {
    width: n,
    height: r,
    $: a
  };
}
function My(t) {
  return ur(t) ? t : t.contextElement;
}
function Bo(t) {
  const e = My(t);
  if (!Or(e))
    return ei(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: s,
    $: i
  } = u_(e);
  let o = (i ? Dd(n.width) : n.width) / r, a = (i ? Dd(n.height) : n.height) / s;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const y5 = /* @__PURE__ */ ei(0);
function d_(t) {
  const e = Un(t);
  return !Ry() || !e.visualViewport ? y5 : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function b5(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Un(t) ? !1 : e;
}
function Yi(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const s = t.getBoundingClientRect(), i = My(t);
  let o = ei(1);
  e && (r ? ur(r) && (o = Bo(r)) : o = Bo(t));
  const a = b5(i, n, r) ? d_(i) : ei(0);
  let c = (s.left + a.x) / o.x, l = (s.top + a.y) / o.y, u = s.width / o.x, d = s.height / o.y;
  if (i) {
    const f = Un(i), h = r && ur(r) ? Un(r) : r;
    let p = f, m = Sm(p);
    for (; m && r && h !== p; ) {
      const y = Bo(m), b = m.getBoundingClientRect(), v = dr(m), w = b.left + (m.clientLeft + parseFloat(v.paddingLeft)) * y.x, x = b.top + (m.clientTop + parseFloat(v.paddingTop)) * y.y;
      c *= y.x, l *= y.y, u *= y.x, d *= y.y, c += w, l += x, p = Un(m), m = Sm(p);
    }
  }
  return qd({
    width: u,
    height: d,
    x: c,
    y: l
  });
}
function v5(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: s
  } = t;
  const i = s === "fixed", o = qr(r), a = e ? Df(e.floating) : !1;
  if (r === o || a && i)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = ei(1);
  const u = ei(0), d = Or(r);
  if ((d || !d && !i) && ((Ta(r) !== "body" || Sl(o)) && (c = Of(r)), Or(r))) {
    const f = Yi(r);
    l = Bo(r), u.x = f.x + r.clientLeft, u.y = f.y + r.clientTop;
  }
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - c.scrollLeft * l.x + u.x,
    y: n.y * l.y - c.scrollTop * l.y + u.y
  };
}
function x5(t) {
  return Array.from(t.getClientRects());
}
function Em(t, e) {
  const n = Of(t).scrollLeft;
  return e ? e.left + n : Yi(qr(t)).left + n;
}
function w5(t) {
  const e = qr(t), n = Of(t), r = t.ownerDocument.body, s = jn(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), i = jn(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + Em(t);
  const a = -n.scrollTop;
  return dr(r).direction === "rtl" && (o += jn(e.clientWidth, r.clientWidth) - s), {
    width: s,
    height: i,
    x: o,
    y: a
  };
}
function A5(t, e) {
  const n = Un(t), r = qr(t), s = n.visualViewport;
  let i = r.clientWidth, o = r.clientHeight, a = 0, c = 0;
  if (s) {
    i = s.width, o = s.height;
    const l = Ry();
    (!l || l && e === "fixed") && (a = s.offsetLeft, c = s.offsetTop);
  }
  return {
    width: i,
    height: o,
    x: a,
    y: c
  };
}
function S5(t, e) {
  const n = Yi(t, !0, e === "fixed"), r = n.top + t.clientTop, s = n.left + t.clientLeft, i = Or(t) ? Bo(t) : ei(1), o = t.clientWidth * i.x, a = t.clientHeight * i.y, c = s * i.x, l = r * i.y;
  return {
    width: o,
    height: a,
    x: c,
    y: l
  };
}
function Sx(t, e, n) {
  let r;
  if (e === "viewport")
    r = A5(t, n);
  else if (e === "document")
    r = w5(qr(t));
  else if (ur(e))
    r = S5(e, n);
  else {
    const s = d_(t);
    r = {
      ...e,
      x: e.x - s.x,
      y: e.y - s.y
    };
  }
  return qd(r);
}
function f_(t, e) {
  const n = ni(t);
  return n === e || !ur(n) || Jo(n) ? !1 : dr(n).position === "fixed" || f_(n, e);
}
function E5(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = Zc(t, [], !1).filter((a) => ur(a) && Ta(a) !== "body"), s = null;
  const i = dr(t).position === "fixed";
  let o = i ? ni(t) : t;
  for (; ur(o) && !Jo(o); ) {
    const a = dr(o), c = ky(o);
    !c && a.position === "fixed" && (s = null), (i ? !c && !s : !c && a.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || Sl(o) && !c && f_(t, o)) ? r = r.filter((u) => u !== o) : s = a, o = ni(o);
  }
  return e.set(t, r), r;
}
function C5(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: s
  } = t;
  const o = [...n === "clippingAncestors" ? Df(e) ? [] : E5(e, this._c) : [].concat(n), r], a = o[0], c = o.reduce((l, u) => {
    const d = Sx(e, u, s);
    return l.top = jn(d.top, l.top), l.right = Js(d.right, l.right), l.bottom = Js(d.bottom, l.bottom), l.left = jn(d.left, l.left), l;
  }, Sx(e, a, s));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function _5(t) {
  const {
    width: e,
    height: n
  } = u_(t);
  return {
    width: e,
    height: n
  };
}
function T5(t, e, n) {
  const r = Or(e), s = qr(e), i = n === "fixed", o = Yi(t, !0, i, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = ei(0);
  if (r || !r && !i)
    if ((Ta(e) !== "body" || Sl(s)) && (a = Of(e)), r) {
      const h = Yi(e, !0, i, e);
      c.x = h.x + e.clientLeft, c.y = h.y + e.clientTop;
    } else s && (c.x = Em(s));
  let l = 0, u = 0;
  if (s && !r && !i) {
    const h = s.getBoundingClientRect();
    u = h.top + a.scrollTop, l = h.left + a.scrollLeft - // RTL <body> scrollbar.
    Em(s, h);
  }
  const d = o.left + a.scrollLeft - c.x - l, f = o.top + a.scrollTop - c.y - u;
  return {
    x: d,
    y: f,
    width: o.width,
    height: o.height
  };
}
function Xh(t) {
  return dr(t).position === "static";
}
function Ex(t, e) {
  if (!Or(t) || dr(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return qr(t) === n && (n = n.ownerDocument.body), n;
}
function h_(t, e) {
  const n = Un(t);
  if (Df(t))
    return n;
  if (!Or(t)) {
    let s = ni(t);
    for (; s && !Jo(s); ) {
      if (ur(s) && !Xh(s))
        return s;
      s = ni(s);
    }
    return n;
  }
  let r = Ex(t, e);
  for (; r && m5(r) && Xh(r); )
    r = Ex(r, e);
  return r && Jo(r) && Xh(r) && !ky(r) ? n : r || g5(t) || n;
}
const k5 = async function(t) {
  const e = this.getOffsetParent || h_, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: T5(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function R5(t) {
  return dr(t).direction === "rtl";
}
const M5 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: v5,
  getDocumentElement: qr,
  getClippingRect: C5,
  getOffsetParent: h_,
  getElementRects: k5,
  getClientRects: x5,
  getDimensions: _5,
  getScale: Bo,
  isElement: ur,
  isRTL: R5
};
function P5(t, e) {
  let n = null, r;
  const s = qr(t);
  function i() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function o(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), i();
    const {
      left: l,
      top: u,
      width: d,
      height: f
    } = t.getBoundingClientRect();
    if (a || e(), !d || !f)
      return;
    const h = Yl(u), p = Yl(s.clientWidth - (l + d)), m = Yl(s.clientHeight - (u + f)), y = Yl(l), v = {
      rootMargin: -h + "px " + -p + "px " + -m + "px " + -y + "px",
      threshold: jn(0, Js(1, c)) || 1
    };
    let w = !0;
    function x(A) {
      const C = A[0].intersectionRatio;
      if (C !== c) {
        if (!w)
          return o();
        C ? o(!1, C) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      w = !1;
    }
    try {
      n = new IntersectionObserver(x, {
        ...v,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x, v);
    }
    n.observe(t);
  }
  return o(!0), i;
}
function I5(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: i = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, l = My(t), u = s || i ? [...l ? Zc(l) : [], ...Zc(e)] : [];
  u.forEach((b) => {
    s && b.addEventListener("scroll", n, {
      passive: !0
    }), i && b.addEventListener("resize", n);
  });
  const d = l && a ? P5(l, n) : null;
  let f = -1, h = null;
  o && (h = new ResizeObserver((b) => {
    let [v] = b;
    v && v.target === l && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var w;
      (w = h) == null || w.observe(e);
    })), n();
  }), l && !c && h.observe(l), h.observe(e));
  let p, m = c ? Yi(t) : null;
  c && y();
  function y() {
    const b = Yi(t);
    m && (b.x !== m.x || b.y !== m.y || b.width !== m.width || b.height !== m.height) && n(), m = b, p = requestAnimationFrame(y);
  }
  return n(), () => {
    var b;
    u.forEach((v) => {
      s && v.removeEventListener("scroll", n), i && v.removeEventListener("resize", n);
    }), d == null || d(), (b = h) == null || b.disconnect(), h = null, c && cancelAnimationFrame(p);
  };
}
const D5 = d5, O5 = f5, q5 = c5, N5 = p5, L5 = l5, Cx = a5, j5 = h5, B5 = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), s = {
    platform: M5,
    ...n
  }, i = {
    ...s.platform,
    _c: r
  };
  return o5(t, e, {
    ...s,
    platform: i
  });
};
var Bu = typeof document < "u" ? Ig : _e;
function Nd(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, s;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Nd(t[r], e[r]))
          return !1;
      return !0;
    }
    if (s = Object.keys(t), n = s.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, s[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = s[r];
      if (!(i === "_owner" && t.$$typeof) && !Nd(t[i], e[i]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function p_(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _x(t, e) {
  const n = p_(t);
  return Math.round(e * n) / n;
}
function Jh(t) {
  const e = E.useRef(t);
  return Bu(() => {
    e.current = t;
  }), e;
}
function F5(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: s,
    elements: {
      reference: i,
      floating: o
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: l
  } = t, [u, d] = E.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = E.useState(r);
  Nd(f, r) || h(r);
  const [p, m] = E.useState(null), [y, b] = E.useState(null), v = E.useCallback((N) => {
    N !== C.current && (C.current = N, m(N));
  }, []), w = E.useCallback((N) => {
    N !== S.current && (S.current = N, b(N));
  }, []), x = i || p, A = o || y, C = E.useRef(null), S = E.useRef(null), _ = E.useRef(u), T = c != null, k = Jh(c), R = Jh(s), P = Jh(l), M = E.useCallback(() => {
    if (!C.current || !S.current)
      return;
    const N = {
      placement: e,
      strategy: n,
      middleware: f
    };
    R.current && (N.platform = R.current), B5(C.current, S.current, N).then((j) => {
      const V = {
        ...j,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: P.current !== !1
      };
      D.current && !Nd(_.current, V) && (_.current = V, Dg.flushSync(() => {
        d(V);
      }));
    });
  }, [f, e, n, R, P]);
  Bu(() => {
    l === !1 && _.current.isPositioned && (_.current.isPositioned = !1, d((N) => ({
      ...N,
      isPositioned: !1
    })));
  }, [l]);
  const D = E.useRef(!1);
  Bu(() => (D.current = !0, () => {
    D.current = !1;
  }), []), Bu(() => {
    if (x && (C.current = x), A && (S.current = A), x && A) {
      if (k.current)
        return k.current(x, A, M);
      M();
    }
  }, [x, A, M, k, T]);
  const O = E.useMemo(() => ({
    reference: C,
    floating: S,
    setReference: v,
    setFloating: w
  }), [v, w]), q = E.useMemo(() => ({
    reference: x,
    floating: A
  }), [x, A]), L = E.useMemo(() => {
    const N = {
      position: n,
      left: 0,
      top: 0
    };
    if (!q.floating)
      return N;
    const j = _x(q.floating, u.x), V = _x(q.floating, u.y);
    return a ? {
      ...N,
      transform: "translate(" + j + "px, " + V + "px)",
      ...p_(q.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: j,
      top: V
    };
  }, [n, a, q.floating, u.x, u.y]);
  return E.useMemo(() => ({
    ...u,
    update: M,
    refs: O,
    elements: q,
    floatingStyles: L
  }), [u, M, O, q, L]);
}
const V5 = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: s
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? Cx({
        element: r.current,
        padding: s
      }).fn(n) : {} : r ? Cx({
        element: r,
        padding: s
      }).fn(n) : {};
    }
  };
}, U5 = (t, e) => ({
  ...D5(t),
  options: [t, e]
}), W5 = (t, e) => ({
  ...O5(t),
  options: [t, e]
}), z5 = (t, e) => ({
  ...j5(t),
  options: [t, e]
}), H5 = (t, e) => ({
  ...q5(t),
  options: [t, e]
}), Y5 = (t, e) => ({
  ...N5(t),
  options: [t, e]
}), G5 = (t, e) => ({
  ...L5(t),
  options: [t, e]
}), K5 = (t, e) => ({
  ...V5(t),
  options: [t, e]
});
var $5 = "Arrow", m_ = E.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: s = 5, ...i } = t;
  return /* @__PURE__ */ g.jsx(
    ze.svg,
    {
      ...i,
      ref: e,
      width: r,
      height: s,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ g.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
m_.displayName = $5;
var Z5 = m_, Py = "Popper", [g_, y_] = Sy(Py), [Q5, b_] = g_(Py), v_ = (t) => {
  const { __scopePopper: e, children: n } = t, [r, s] = E.useState(null);
  return /* @__PURE__ */ g.jsx(Q5, { scope: e, anchor: r, onAnchorChange: s, children: n });
};
v_.displayName = Py;
var x_ = "PopperAnchor", w_ = E.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...s } = t, i = b_(x_, n), o = E.useRef(null), a = Ke(e, o);
    return E.useEffect(() => {
      i.onAnchorChange((r == null ? void 0 : r.current) || o.current);
    }), r ? null : /* @__PURE__ */ g.jsx(ze.div, { ...s, ref: a });
  }
);
w_.displayName = x_;
var Iy = "PopperContent", [X5, J5] = g_(Iy), A_ = E.forwardRef(
  (t, e) => {
    var He, at, xt, tt, wt, F;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: s = 0,
      align: i = "center",
      alignOffset: o = 0,
      arrowPadding: a = 0,
      avoidCollisions: c = !0,
      collisionBoundary: l = [],
      collisionPadding: u = 0,
      sticky: d = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: p,
      ...m
    } = t, y = b_(Iy, n), [b, v] = E.useState(null), w = Ke(e, (ee) => v(ee)), [x, A] = E.useState(null), C = FC(x), S = (C == null ? void 0 : C.width) ?? 0, _ = (C == null ? void 0 : C.height) ?? 0, T = r + (i !== "center" ? "-" + i : ""), k = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, R = Array.isArray(l) ? l : [l], P = R.length > 0, M = {
      padding: k,
      boundary: R.filter(t4),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: P
    }, { refs: D, floatingStyles: O, placement: q, isPositioned: L, middlewareData: N } = F5({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: T,
      whileElementsMounted: (...ee) => I5(...ee, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: y.anchor
      },
      middleware: [
        U5({ mainAxis: s + _, alignmentAxis: o }),
        c && W5({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? z5() : void 0,
          ...M
        }),
        c && H5({ ...M }),
        Y5({
          ...M,
          apply: ({ elements: ee, rects: re, availableWidth: nt, availableHeight: kt }) => {
            const { width: Yn, height: Pn } = re.reference, Rt = ee.floating.style;
            Rt.setProperty("--radix-popper-available-width", `${nt}px`), Rt.setProperty("--radix-popper-available-height", `${kt}px`), Rt.setProperty("--radix-popper-anchor-width", `${Yn}px`), Rt.setProperty("--radix-popper-anchor-height", `${Pn}px`);
          }
        }),
        x && K5({ element: x, padding: a }),
        n4({ arrowWidth: S, arrowHeight: _ }),
        f && G5({ strategy: "referenceHidden", ...M })
      ]
    }), [j, V] = C_(q), Z = Zt(p);
    bn(() => {
      L && (Z == null || Z());
    }, [L, Z]);
    const G = (He = N.arrow) == null ? void 0 : He.x, $ = (at = N.arrow) == null ? void 0 : at.y, fe = ((xt = N.arrow) == null ? void 0 : xt.centerOffset) !== 0, [he, be] = E.useState();
    return bn(() => {
      b && be(window.getComputedStyle(b).zIndex);
    }, [b]), /* @__PURE__ */ g.jsx(
      "div",
      {
        ref: D.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...O,
          transform: L ? O.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: he,
          "--radix-popper-transform-origin": [
            (tt = N.transformOrigin) == null ? void 0 : tt.x,
            (wt = N.transformOrigin) == null ? void 0 : wt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((F = N.hide) == null ? void 0 : F.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ g.jsx(
          X5,
          {
            scope: n,
            placedSide: j,
            onArrowChange: A,
            arrowX: G,
            arrowY: $,
            shouldHideArrow: fe,
            children: /* @__PURE__ */ g.jsx(
              ze.div,
              {
                "data-side": j,
                "data-align": V,
                ...m,
                ref: w,
                style: {
                  ...m.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: L ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
A_.displayName = Iy;
var S_ = "PopperArrow", e4 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, E_ = E.forwardRef(function(e, n) {
  const { __scopePopper: r, ...s } = e, i = J5(S_, r), o = e4[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ g.jsx(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ g.jsx(
          Z5,
          {
            ...s,
            ref: n,
            style: {
              ...s.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
E_.displayName = S_;
function t4(t) {
  return t !== null;
}
var n4 = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var y, b, v;
    const { placement: n, rects: r, middlewareData: s } = e, o = ((y = s.arrow) == null ? void 0 : y.centerOffset) !== 0, a = o ? 0 : t.arrowWidth, c = o ? 0 : t.arrowHeight, [l, u] = C_(n), d = { start: "0%", center: "50%", end: "100%" }[u], f = (((b = s.arrow) == null ? void 0 : b.x) ?? 0) + a / 2, h = (((v = s.arrow) == null ? void 0 : v.y) ?? 0) + c / 2;
    let p = "", m = "";
    return l === "bottom" ? (p = o ? d : `${f}px`, m = `${-c}px`) : l === "top" ? (p = o ? d : `${f}px`, m = `${r.floating.height + c}px`) : l === "right" ? (p = `${-c}px`, m = o ? d : `${h}px`) : l === "left" && (p = `${r.floating.width + c}px`, m = o ? d : `${h}px`), { data: { x: p, y: m } };
  }
});
function C_(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var r4 = v_, s4 = w_, i4 = A_, o4 = E_;
function a4(t, e) {
  return E.useReducer((n, r) => e[n][r] ?? n, t);
}
var __ = (t) => {
  const { present: e, children: n } = t, r = c4(e), s = typeof n == "function" ? n({ present: r.isPresent }) : E.Children.only(n), i = Ke(r.ref, l4(s));
  return typeof n == "function" || r.isPresent ? E.cloneElement(s, { ref: i }) : null;
};
__.displayName = "Presence";
function c4(t) {
  const [e, n] = E.useState(), r = E.useRef({}), s = E.useRef(t), i = E.useRef("none"), o = t ? "mounted" : "unmounted", [a, c] = a4(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return E.useEffect(() => {
    const l = Gl(r.current);
    i.current = a === "mounted" ? l : "none";
  }, [a]), bn(() => {
    const l = r.current, u = s.current;
    if (u !== t) {
      const f = i.current, h = Gl(l);
      t ? c("MOUNT") : h === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), s.current = t;
    }
  }, [t, c]), bn(() => {
    if (e) {
      const l = (d) => {
        const h = Gl(r.current).includes(d.animationName);
        d.target === e && h && Dg.flushSync(() => c("ANIMATION_END"));
      }, u = (d) => {
        d.target === e && (i.current = Gl(r.current));
      };
      return e.addEventListener("animationstart", u), e.addEventListener("animationcancel", l), e.addEventListener("animationend", l), () => {
        e.removeEventListener("animationstart", u), e.removeEventListener("animationcancel", l), e.removeEventListener("animationend", l);
      };
    } else
      c("ANIMATION_END");
  }, [e, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: E.useCallback((l) => {
      l && (r.current = getComputedStyle(l)), n(l);
    }, [])
  };
}
function Gl(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function l4(t) {
  var r, s;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var u4 = "VisuallyHidden", T_ = E.forwardRef(
  (t, e) => /* @__PURE__ */ g.jsx(
    ze.span,
    {
      ...t,
      ref: e,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...t.style
      }
    }
  )
);
T_.displayName = u4;
var d4 = T_, [qf, yte] = Sy("Tooltip", [
  y_
]), Nf = y_(), k_ = "TooltipProvider", f4 = 700, Cm = "tooltip.open", [h4, Dy] = qf(k_), R_ = (t) => {
  const {
    __scopeTooltip: e,
    delayDuration: n = f4,
    skipDelayDuration: r = 300,
    disableHoverableContent: s = !1,
    children: i
  } = t, [o, a] = E.useState(!0), c = E.useRef(!1), l = E.useRef(0);
  return E.useEffect(() => {
    const u = l.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ g.jsx(
    h4,
    {
      scope: e,
      isOpenDelayed: o,
      delayDuration: n,
      onOpen: E.useCallback(() => {
        window.clearTimeout(l.current), a(!1);
      }, []),
      onClose: E.useCallback(() => {
        window.clearTimeout(l.current), l.current = window.setTimeout(
          () => a(!0),
          r
        );
      }, [r]),
      isPointerInTransitRef: c,
      onPointerInTransitChange: E.useCallback((u) => {
        c.current = u;
      }, []),
      disableHoverableContent: s,
      children: i
    }
  );
};
R_.displayName = k_;
var Lf = "Tooltip", [p4, jf] = qf(Lf), M_ = (t) => {
  const {
    __scopeTooltip: e,
    children: n,
    open: r,
    defaultOpen: s = !1,
    onOpenChange: i,
    disableHoverableContent: o,
    delayDuration: a
  } = t, c = Dy(Lf, t.__scopeTooltip), l = Nf(e), [u, d] = E.useState(null), f = jo(), h = E.useRef(0), p = o ?? c.disableHoverableContent, m = a ?? c.delayDuration, y = E.useRef(!1), [b = !1, v] = Ea({
    prop: r,
    defaultProp: s,
    onChange: (S) => {
      S ? (c.onOpen(), document.dispatchEvent(new CustomEvent(Cm))) : c.onClose(), i == null || i(S);
    }
  }), w = E.useMemo(() => b ? y.current ? "delayed-open" : "instant-open" : "closed", [b]), x = E.useCallback(() => {
    window.clearTimeout(h.current), y.current = !1, v(!0);
  }, [v]), A = E.useCallback(() => {
    window.clearTimeout(h.current), v(!1);
  }, [v]), C = E.useCallback(() => {
    window.clearTimeout(h.current), h.current = window.setTimeout(() => {
      y.current = !0, v(!0);
    }, m);
  }, [m, v]);
  return E.useEffect(() => () => window.clearTimeout(h.current), []), /* @__PURE__ */ g.jsx(r4, { ...l, children: /* @__PURE__ */ g.jsx(
    p4,
    {
      scope: e,
      contentId: f,
      open: b,
      stateAttribute: w,
      trigger: u,
      onTriggerChange: d,
      onTriggerEnter: E.useCallback(() => {
        c.isOpenDelayed ? C() : x();
      }, [c.isOpenDelayed, C, x]),
      onTriggerLeave: E.useCallback(() => {
        p ? A() : window.clearTimeout(h.current);
      }, [A, p]),
      onOpen: x,
      onClose: A,
      disableHoverableContent: p,
      children: n
    }
  ) });
};
M_.displayName = Lf;
var _m = "TooltipTrigger", P_ = E.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, s = jf(_m, n), i = Dy(_m, n), o = Nf(n), a = E.useRef(null), c = Ke(e, a, s.onTriggerChange), l = E.useRef(!1), u = E.useRef(!1), d = E.useCallback(() => l.current = !1, []);
    return E.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), /* @__PURE__ */ g.jsx(s4, { asChild: !0, ...o, children: /* @__PURE__ */ g.jsx(
      ze.button,
      {
        "aria-describedby": s.open ? s.contentId : void 0,
        "data-state": s.stateAttribute,
        ...r,
        ref: c,
        onPointerMove: We(t.onPointerMove, (f) => {
          f.pointerType !== "touch" && !u.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(), u.current = !0);
        }),
        onPointerLeave: We(t.onPointerLeave, () => {
          s.onTriggerLeave(), u.current = !1;
        }),
        onPointerDown: We(t.onPointerDown, () => {
          l.current = !0, document.addEventListener("pointerup", d, { once: !0 });
        }),
        onFocus: We(t.onFocus, () => {
          l.current || s.onOpen();
        }),
        onBlur: We(t.onBlur, s.onClose),
        onClick: We(t.onClick, s.onClose)
      }
    ) });
  }
);
P_.displayName = _m;
var m4 = "TooltipPortal", [bte, g4] = qf(m4, {
  forceMount: void 0
}), ea = "TooltipContent", I_ = E.forwardRef(
  (t, e) => {
    const n = g4(ea, t.__scopeTooltip), { forceMount: r = n.forceMount, side: s = "top", ...i } = t, o = jf(ea, t.__scopeTooltip);
    return /* @__PURE__ */ g.jsx(__, { present: r || o.open, children: o.disableHoverableContent ? /* @__PURE__ */ g.jsx(D_, { side: s, ...i, ref: e }) : /* @__PURE__ */ g.jsx(y4, { side: s, ...i, ref: e }) });
  }
), y4 = E.forwardRef((t, e) => {
  const n = jf(ea, t.__scopeTooltip), r = Dy(ea, t.__scopeTooltip), s = E.useRef(null), i = Ke(e, s), [o, a] = E.useState(null), { trigger: c, onClose: l } = n, u = s.current, { onPointerInTransitChange: d } = r, f = E.useCallback(() => {
    a(null), d(!1);
  }, [d]), h = E.useCallback(
    (p, m) => {
      const y = p.currentTarget, b = { x: p.clientX, y: p.clientY }, v = w4(b, y.getBoundingClientRect()), w = A4(b, v), x = S4(m.getBoundingClientRect()), A = C4([...w, ...x]);
      a(A), d(!0);
    },
    [d]
  );
  return E.useEffect(() => () => f(), [f]), E.useEffect(() => {
    if (c && u) {
      const p = (y) => h(y, u), m = (y) => h(y, c);
      return c.addEventListener("pointerleave", p), u.addEventListener("pointerleave", m), () => {
        c.removeEventListener("pointerleave", p), u.removeEventListener("pointerleave", m);
      };
    }
  }, [c, u, h, f]), E.useEffect(() => {
    if (o) {
      const p = (m) => {
        const y = m.target, b = { x: m.clientX, y: m.clientY }, v = (c == null ? void 0 : c.contains(y)) || (u == null ? void 0 : u.contains(y)), w = !E4(b, o);
        v ? f() : w && (f(), l());
      };
      return document.addEventListener("pointermove", p), () => document.removeEventListener("pointermove", p);
    }
  }, [c, u, o, l, f]), /* @__PURE__ */ g.jsx(D_, { ...t, ref: i });
}), [b4, v4] = qf(Lf, { isInside: !1 }), D_ = E.forwardRef(
  (t, e) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": s,
      onEscapeKeyDown: i,
      onPointerDownOutside: o,
      ...a
    } = t, c = jf(ea, n), l = Nf(n), { onClose: u } = c;
    return E.useEffect(() => (document.addEventListener(Cm, u), () => document.removeEventListener(Cm, u)), [u]), E.useEffect(() => {
      if (c.trigger) {
        const d = (f) => {
          const h = f.target;
          h != null && h.contains(c.trigger) && u();
        };
        return window.addEventListener("scroll", d, { capture: !0 }), () => window.removeEventListener("scroll", d, { capture: !0 });
      }
    }, [c.trigger, u]), /* @__PURE__ */ g.jsx(
      i_,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: o,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: u,
        children: /* @__PURE__ */ g.jsxs(
          i4,
          {
            "data-state": c.stateAttribute,
            ...l,
            ...a,
            ref: e,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ g.jsx(fC, { children: r }),
              /* @__PURE__ */ g.jsx(b4, { scope: n, isInside: !0, children: /* @__PURE__ */ g.jsx(d4, { id: c.contentId, role: "tooltip", children: s || r }) })
            ]
          }
        )
      }
    );
  }
);
I_.displayName = ea;
var O_ = "TooltipArrow", x4 = E.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, s = Nf(n);
    return v4(
      O_,
      n
    ).isInside ? null : /* @__PURE__ */ g.jsx(o4, { ...s, ...r, ref: e });
  }
);
x4.displayName = O_;
function w4(t, e) {
  const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), s = Math.abs(e.right - t.x), i = Math.abs(e.left - t.x);
  switch (Math.min(n, r, s, i)) {
    case i:
      return "left";
    case s:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function A4(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      r.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return r;
}
function S4(t) {
  const { top: e, right: n, bottom: r, left: s } = t;
  return [
    { x: s, y: e },
    { x: n, y: e },
    { x: n, y: r },
    { x: s, y: r }
  ];
}
function E4(t, e) {
  const { x: n, y: r } = t;
  let s = !1;
  for (let i = 0, o = e.length - 1; i < e.length; o = i++) {
    const a = e[i].x, c = e[i].y, l = e[o].x, u = e[o].y;
    c > r != u > r && n < (l - a) * (r - c) / (u - c) + a && (s = !s);
  }
  return s;
}
function C4(t) {
  const e = t.slice();
  return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), _4(e);
}
function _4(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1], o = e[e.length - 2];
      if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) e.pop();
      else break;
    }
    e.push(s);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const s = t[r];
    for (; n.length >= 2; ) {
      const i = n[n.length - 1], o = n[n.length - 2];
      if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) n.pop();
      else break;
    }
    n.push(s);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var T4 = R_, k4 = M_, R4 = P_, q_ = I_;
const Fu = T4, Vu = k4, Uu = R4, yc = E.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => /* @__PURE__ */ g.jsx(
  q_,
  {
    ref: r,
    sideOffset: e,
    className: de(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      t
    ),
    ...n
  }
));
yc.displayName = q_.displayName;
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function El(t) {
  return t + 0.5 | 0;
}
const Ls = (t, e, n) => Math.max(Math.min(t, n), e);
function oc(t) {
  return Ls(El(t * 2.55), 0, 255);
}
function Ws(t) {
  return Ls(El(t * 255), 0, 255);
}
function $r(t) {
  return Ls(El(t / 2.55) / 100, 0, 1);
}
function Tx(t) {
  return Ls(El(t * 100), 0, 100);
}
const $n = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Tm = [..."0123456789ABCDEF"], M4 = (t) => Tm[t & 15], P4 = (t) => Tm[(t & 240) >> 4] + Tm[t & 15], Kl = (t) => (t & 240) >> 4 === (t & 15), I4 = (t) => Kl(t.r) && Kl(t.g) && Kl(t.b) && Kl(t.a);
function D4(t) {
  var e = t.length, n;
  return t[0] === "#" && (e === 4 || e === 5 ? n = {
    r: 255 & $n[t[1]] * 17,
    g: 255 & $n[t[2]] * 17,
    b: 255 & $n[t[3]] * 17,
    a: e === 5 ? $n[t[4]] * 17 : 255
  } : (e === 7 || e === 9) && (n = {
    r: $n[t[1]] << 4 | $n[t[2]],
    g: $n[t[3]] << 4 | $n[t[4]],
    b: $n[t[5]] << 4 | $n[t[6]],
    a: e === 9 ? $n[t[7]] << 4 | $n[t[8]] : 255
  })), n;
}
const O4 = (t, e) => t < 255 ? e(t) : "";
function q4(t) {
  var e = I4(t) ? M4 : P4;
  return t ? "#" + e(t.r) + e(t.g) + e(t.b) + O4(t.a, e) : void 0;
}
const N4 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function N_(t, e, n) {
  const r = e * Math.min(n, 1 - n), s = (i, o = (i + t / 30) % 12) => n - r * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [s(0), s(8), s(4)];
}
function L4(t, e, n) {
  const r = (s, i = (s + t / 60) % 6) => n - n * e * Math.max(Math.min(i, 4 - i, 1), 0);
  return [r(5), r(3), r(1)];
}
function j4(t, e, n) {
  const r = N_(t, 1, 0.5);
  let s;
  for (e + n > 1 && (s = 1 / (e + n), e *= s, n *= s), s = 0; s < 3; s++)
    r[s] *= 1 - e - n, r[s] += e;
  return r;
}
function B4(t, e, n, r, s) {
  return t === s ? (e - n) / r + (e < n ? 6 : 0) : e === s ? (n - t) / r + 2 : (t - e) / r + 4;
}
function Oy(t) {
  const n = t.r / 255, r = t.g / 255, s = t.b / 255, i = Math.max(n, r, s), o = Math.min(n, r, s), a = (i + o) / 2;
  let c, l, u;
  return i !== o && (u = i - o, l = a > 0.5 ? u / (2 - i - o) : u / (i + o), c = B4(n, r, s, u, i), c = c * 60 + 0.5), [c | 0, l || 0, a];
}
function qy(t, e, n, r) {
  return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, r)).map(Ws);
}
function Ny(t, e, n) {
  return qy(N_, t, e, n);
}
function F4(t, e, n) {
  return qy(j4, t, e, n);
}
function V4(t, e, n) {
  return qy(L4, t, e, n);
}
function L_(t) {
  return (t % 360 + 360) % 360;
}
function U4(t) {
  const e = N4.exec(t);
  let n = 255, r;
  if (!e)
    return;
  e[5] !== r && (n = e[6] ? oc(+e[5]) : Ws(+e[5]));
  const s = L_(+e[2]), i = +e[3] / 100, o = +e[4] / 100;
  return e[1] === "hwb" ? r = F4(s, i, o) : e[1] === "hsv" ? r = V4(s, i, o) : r = Ny(s, i, o), {
    r: r[0],
    g: r[1],
    b: r[2],
    a: n
  };
}
function W4(t, e) {
  var n = Oy(t);
  n[0] = L_(n[0] + e), n = Ny(n), t.r = n[0], t.g = n[1], t.b = n[2];
}
function z4(t) {
  if (!t)
    return;
  const e = Oy(t), n = e[0], r = Tx(e[1]), s = Tx(e[2]);
  return t.a < 255 ? `hsla(${n}, ${r}%, ${s}%, ${$r(t.a)})` : `hsl(${n}, ${r}%, ${s}%)`;
}
const kx = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Rx = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function H4() {
  const t = {}, e = Object.keys(Rx), n = Object.keys(kx);
  let r, s, i, o, a;
  for (r = 0; r < e.length; r++) {
    for (o = a = e[r], s = 0; s < n.length; s++)
      i = n[s], a = a.replace(i, kx[i]);
    i = parseInt(Rx[o], 16), t[a] = [i >> 16 & 255, i >> 8 & 255, i & 255];
  }
  return t;
}
let $l;
function Y4(t) {
  $l || ($l = H4(), $l.transparent = [0, 0, 0, 0]);
  const e = $l[t.toLowerCase()];
  return e && {
    r: e[0],
    g: e[1],
    b: e[2],
    a: e.length === 4 ? e[3] : 255
  };
}
const G4 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function K4(t) {
  const e = G4.exec(t);
  let n = 255, r, s, i;
  if (e) {
    if (e[7] !== r) {
      const o = +e[7];
      n = e[8] ? oc(o) : Ls(o * 255, 0, 255);
    }
    return r = +e[1], s = +e[3], i = +e[5], r = 255 & (e[2] ? oc(r) : Ls(r, 0, 255)), s = 255 & (e[4] ? oc(s) : Ls(s, 0, 255)), i = 255 & (e[6] ? oc(i) : Ls(i, 0, 255)), {
      r,
      g: s,
      b: i,
      a: n
    };
  }
}
function $4(t) {
  return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${$r(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`);
}
const ep = (t) => t <= 31308e-7 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - 0.055, ho = (t) => t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
function Z4(t, e, n) {
  const r = ho($r(t.r)), s = ho($r(t.g)), i = ho($r(t.b));
  return {
    r: Ws(ep(r + n * (ho($r(e.r)) - r))),
    g: Ws(ep(s + n * (ho($r(e.g)) - s))),
    b: Ws(ep(i + n * (ho($r(e.b)) - i))),
    a: t.a + n * (e.a - t.a)
  };
}
function Zl(t, e, n) {
  if (t) {
    let r = Oy(t);
    r[e] = Math.max(0, Math.min(r[e] + r[e] * n, e === 0 ? 360 : 1)), r = Ny(r), t.r = r[0], t.g = r[1], t.b = r[2];
  }
}
function j_(t, e) {
  return t && Object.assign(e || {}, t);
}
function Mx(t) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = Ws(t[3]))) : (e = j_(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = Ws(e.a)), e;
}
function Q4(t) {
  return t.charAt(0) === "r" ? K4(t) : U4(t);
}
class Qc {
  constructor(e) {
    if (e instanceof Qc)
      return e;
    const n = typeof e;
    let r;
    n === "object" ? r = Mx(e) : n === "string" && (r = D4(e) || Y4(e) || Q4(e)), this._rgb = r, this._valid = !!r;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var e = j_(this._rgb);
    return e && (e.a = $r(e.a)), e;
  }
  set rgb(e) {
    this._rgb = Mx(e);
  }
  rgbString() {
    return this._valid ? $4(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? q4(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? z4(this._rgb) : void 0;
  }
  mix(e, n) {
    if (e) {
      const r = this.rgb, s = e.rgb;
      let i;
      const o = n === i ? 0.5 : n, a = 2 * o - 1, c = r.a - s.a, l = ((a * c === -1 ? a : (a + c) / (1 + a * c)) + 1) / 2;
      i = 1 - l, r.r = 255 & l * r.r + i * s.r + 0.5, r.g = 255 & l * r.g + i * s.g + 0.5, r.b = 255 & l * r.b + i * s.b + 0.5, r.a = o * r.a + (1 - o) * s.a, this.rgb = r;
    }
    return this;
  }
  interpolate(e, n) {
    return e && (this._rgb = Z4(this._rgb, e._rgb, n)), this;
  }
  clone() {
    return new Qc(this.rgb);
  }
  alpha(e) {
    return this._rgb.a = Ws(e), this;
  }
  clearer(e) {
    const n = this._rgb;
    return n.a *= 1 - e, this;
  }
  greyscale() {
    const e = this._rgb, n = El(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
    return e.r = e.g = e.b = n, this;
  }
  opaquer(e) {
    const n = this._rgb;
    return n.a *= 1 + e, this;
  }
  negate() {
    const e = this._rgb;
    return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
  }
  lighten(e) {
    return Zl(this._rgb, 2, e), this;
  }
  darken(e) {
    return Zl(this._rgb, 2, -e), this;
  }
  saturate(e) {
    return Zl(this._rgb, 1, e), this;
  }
  desaturate(e) {
    return Zl(this._rgb, 1, -e), this;
  }
  rotate(e) {
    return W4(this._rgb, e), this;
  }
}
/*!
 * Chart.js v4.4.4
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
function Wr() {
}
const X4 = /* @__PURE__ */ (() => {
  let t = 0;
  return () => t++;
})();
function je(t) {
  return t === null || typeof t > "u";
}
function mt(t) {
  if (Array.isArray && Array.isArray(t))
    return !0;
  const e = Object.prototype.toString.call(t);
  return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
}
function Pe(t) {
  return t !== null && Object.prototype.toString.call(t) === "[object Object]";
}
function Ct(t) {
  return (typeof t == "number" || t instanceof Number) && isFinite(+t);
}
function On(t, e) {
  return Ct(t) ? t : e;
}
function Ae(t, e) {
  return typeof t > "u" ? e : t;
}
const J4 = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 : +t / e, B_ = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;
function ut(t, e, n) {
  if (t && typeof t.call == "function")
    return t.apply(n, e);
}
function Xe(t, e, n, r) {
  let s, i, o;
  if (mt(t))
    for (i = t.length, s = 0; s < i; s++)
      e.call(n, t[s], s);
  else if (Pe(t))
    for (o = Object.keys(t), i = o.length, s = 0; s < i; s++)
      e.call(n, t[o[s]], o[s]);
}
function Ld(t, e) {
  let n, r, s, i;
  if (!t || !e || t.length !== e.length)
    return !1;
  for (n = 0, r = t.length; n < r; ++n)
    if (s = t[n], i = e[n], s.datasetIndex !== i.datasetIndex || s.index !== i.index)
      return !1;
  return !0;
}
function jd(t) {
  if (mt(t))
    return t.map(jd);
  if (Pe(t)) {
    const e = /* @__PURE__ */ Object.create(null), n = Object.keys(t), r = n.length;
    let s = 0;
    for (; s < r; ++s)
      e[n[s]] = jd(t[n[s]]);
    return e;
  }
  return t;
}
function F_(t) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(t) === -1;
}
function eV(t, e, n, r) {
  if (!F_(t))
    return;
  const s = e[t], i = n[t];
  Pe(s) && Pe(i) ? Xc(s, i, r) : e[t] = jd(i);
}
function Xc(t, e, n) {
  const r = mt(e) ? e : [
    e
  ], s = r.length;
  if (!Pe(t))
    return t;
  n = n || {};
  const i = n.merger || eV;
  let o;
  for (let a = 0; a < s; ++a) {
    if (o = r[a], !Pe(o))
      continue;
    const c = Object.keys(o);
    for (let l = 0, u = c.length; l < u; ++l)
      i(c[l], t, o, n);
  }
  return t;
}
function bc(t, e) {
  return Xc(t, e, {
    merger: tV
  });
}
function tV(t, e, n) {
  if (!F_(t))
    return;
  const r = e[t], s = n[t];
  Pe(r) && Pe(s) ? bc(r, s) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = jd(s));
}
const Px = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (t) => t,
  // default resolvers
  x: (t) => t.x,
  y: (t) => t.y
};
function nV(t) {
  const e = t.split("."), n = [];
  let r = "";
  for (const s of e)
    r += s, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = "");
  return n;
}
function rV(t) {
  const e = nV(t);
  return (n) => {
    for (const r of e) {
      if (r === "")
        break;
      n = n && n[r];
    }
    return n;
  };
}
function ri(t, e) {
  return (Px[e] || (Px[e] = rV(e)))(t);
}
function Ly(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const Jc = (t) => typeof t < "u", si = (t) => typeof t == "function", Ix = (t, e) => {
  if (t.size !== e.size)
    return !1;
  for (const n of t)
    if (!e.has(n))
      return !1;
  return !0;
};
function sV(t) {
  return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu";
}
const ht = Math.PI, ft = 2 * ht, iV = ft + ht, Bd = Number.POSITIVE_INFINITY, oV = ht / 180, It = ht / 2, yi = ht / 4, Dx = ht * 2 / 3, js = Math.log10, Mr = Math.sign;
function vc(t, e, n) {
  return Math.abs(t - e) < n;
}
function Ox(t) {
  const e = Math.round(t);
  t = vc(t, e, t / 1e3) ? e : t;
  const n = Math.pow(10, Math.floor(js(t))), r = t / n;
  return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n;
}
function aV(t) {
  const e = [], n = Math.sqrt(t);
  let r;
  for (r = 1; r < n; r++)
    t % r === 0 && (e.push(r), e.push(t / r));
  return n === (n | 0) && e.push(n), e.sort((s, i) => s - i).pop(), e;
}
function ta(t) {
  return !isNaN(parseFloat(t)) && isFinite(t);
}
function cV(t, e) {
  const n = Math.round(t);
  return n - e <= t && n + e >= t;
}
function V_(t, e, n) {
  let r, s, i;
  for (r = 0, s = t.length; r < s; r++)
    i = t[r][n], isNaN(i) || (e.min = Math.min(e.min, i), e.max = Math.max(e.max, i));
}
function or(t) {
  return t * (ht / 180);
}
function jy(t) {
  return t * (180 / ht);
}
function qx(t) {
  if (!Ct(t))
    return;
  let e = 1, n = 0;
  for (; Math.round(t * e) / e !== t; )
    e *= 10, n++;
  return n;
}
function U_(t, e) {
  const n = e.x - t.x, r = e.y - t.y, s = Math.sqrt(n * n + r * r);
  let i = Math.atan2(r, n);
  return i < -0.5 * ht && (i += ft), {
    angle: i,
    distance: s
  };
}
function km(t, e) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
function lV(t, e) {
  return (t - e + iV) % ft - ht;
}
function Nn(t) {
  return (t % ft + ft) % ft;
}
function el(t, e, n, r) {
  const s = Nn(t), i = Nn(e), o = Nn(n), a = Nn(i - s), c = Nn(o - s), l = Nn(s - i), u = Nn(s - o);
  return s === i || s === o || r && i === o || a > c && l < u;
}
function Yt(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function uV(t) {
  return Yt(t, -32768, 32767);
}
function Jr(t, e, n, r = 1e-6) {
  return t >= Math.min(e, n) - r && t <= Math.max(e, n) + r;
}
function By(t, e, n) {
  n = n || ((o) => t[o] < e);
  let r = t.length - 1, s = 0, i;
  for (; r - s > 1; )
    i = s + r >> 1, n(i) ? s = i : r = i;
  return {
    lo: s,
    hi: r
  };
}
const es = (t, e, n, r) => By(t, n, r ? (s) => {
  const i = t[s][e];
  return i < n || i === n && t[s + 1][e] === n;
} : (s) => t[s][e] < n), dV = (t, e, n) => By(t, n, (r) => t[r][e] >= n);
function fV(t, e, n) {
  let r = 0, s = t.length;
  for (; r < s && t[r] < e; )
    r++;
  for (; s > r && t[s - 1] > n; )
    s--;
  return r > 0 || s < t.length ? t.slice(r, s) : t;
}
const W_ = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function hV(t, e) {
  if (t._chartjs) {
    t._chartjs.listeners.push(e);
    return;
  }
  Object.defineProperty(t, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        e
      ]
    }
  }), W_.forEach((n) => {
    const r = "_onData" + Ly(n), s = t[n];
    Object.defineProperty(t, n, {
      configurable: !0,
      enumerable: !1,
      value(...i) {
        const o = s.apply(this, i);
        return t._chartjs.listeners.forEach((a) => {
          typeof a[r] == "function" && a[r](...i);
        }), o;
      }
    });
  });
}
function Nx(t, e) {
  const n = t._chartjs;
  if (!n)
    return;
  const r = n.listeners, s = r.indexOf(e);
  s !== -1 && r.splice(s, 1), !(r.length > 0) && (W_.forEach((i) => {
    delete t[i];
  }), delete t._chartjs);
}
function z_(t) {
  const e = new Set(t);
  return e.size === t.length ? t : Array.from(e);
}
const H_ = function() {
  return typeof window > "u" ? function(t) {
    return t();
  } : window.requestAnimationFrame;
}();
function Y_(t, e) {
  let n = [], r = !1;
  return function(...s) {
    n = s, r || (r = !0, H_.call(window, () => {
      r = !1, t.apply(e, n);
    }));
  };
}
function pV(t, e) {
  let n;
  return function(...r) {
    return e ? (clearTimeout(n), n = setTimeout(t, e, r)) : t.apply(this, r), e;
  };
}
const Fy = (t) => t === "start" ? "left" : t === "end" ? "right" : "center", rn = (t, e, n) => t === "start" ? e : t === "end" ? n : (e + n) / 2, mV = (t, e, n, r) => t === (r ? "left" : "right") ? n : t === "center" ? (e + n) / 2 : e;
function G_(t, e, n) {
  const r = e.length;
  let s = 0, i = r;
  if (t._sorted) {
    const { iScale: o, _parsed: a } = t, c = o.axis, { min: l, max: u, minDefined: d, maxDefined: f } = o.getUserBounds();
    d && (s = Yt(Math.min(
      // @ts-expect-error Need to type _parsed
      es(a, c, l).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? r : es(e, c, o.getPixelForValue(l)).lo
    ), 0, r - 1)), f ? i = Yt(Math.max(
      // @ts-expect-error Need to type _parsed
      es(a, o.axis, u, !0).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      n ? 0 : es(e, c, o.getPixelForValue(u), !0).hi + 1
    ), s, r) - s : i = r - s;
  }
  return {
    start: s,
    count: i
  };
}
function K_(t) {
  const { xScale: e, yScale: n, _scaleRanges: r } = t, s = {
    xmin: e.min,
    xmax: e.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!r)
    return t._scaleRanges = s, !0;
  const i = r.xmin !== e.min || r.xmax !== e.max || r.ymin !== n.min || r.ymax !== n.max;
  return Object.assign(r, s), i;
}
const Ql = (t) => t === 0 || t === 1, Lx = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * ft / n)), jx = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * ft / n) + 1, xc = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * It) + 1,
  easeOutSine: (t) => Math.sin(t * It),
  easeInOutSine: (t) => -0.5 * (Math.cos(ht * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => Ql(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => Ql(t) ? t : Lx(t, 0.075, 0.3),
  easeOutElastic: (t) => Ql(t) ? t : jx(t, 0.075, 0.3),
  easeInOutElastic(t) {
    return Ql(t) ? t : t < 0.5 ? 0.5 * Lx(t * 2, 0.1125, 0.45) : 0.5 + 0.5 * jx(t * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(t) {
    return t * t * ((1.70158 + 1) * t - 1.70158);
  },
  easeOutBack(t) {
    return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1;
  },
  easeInOutBack(t) {
    let e = 1.70158;
    return (t /= 0.5) < 1 ? 0.5 * (t * t * (((e *= 1.525) + 1) * t - e)) : 0.5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2);
  },
  easeInBounce: (t) => 1 - xc.easeOutBounce(1 - t),
  easeOutBounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? xc.easeInBounce(t * 2) * 0.5 : xc.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function Vy(t) {
  if (t && typeof t == "object") {
    const e = t.toString();
    return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
  }
  return !1;
}
function Bx(t) {
  return Vy(t) ? t : new Qc(t);
}
function tp(t) {
  return Vy(t) ? t : new Qc(t).saturate(0.5).darken(0.1).hexString();
}
const gV = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], yV = [
  "color",
  "borderColor",
  "backgroundColor"
];
function bV(t) {
  t.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), t.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
  }), t.set("animations", {
    colors: {
      type: "color",
      properties: yV
    },
    numbers: {
      type: "number",
      properties: gV
    }
  }), t.describe("animations", {
    _fallback: "animation"
  }), t.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (e) => e | 0
        }
      }
    }
  });
}
function vV(t) {
  t.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const Fx = /* @__PURE__ */ new Map();
function xV(t, e) {
  e = e || {};
  const n = t + JSON.stringify(e);
  let r = Fx.get(n);
  return r || (r = new Intl.NumberFormat(t, e), Fx.set(n, r)), r;
}
function Cl(t, e, n) {
  return xV(e, n).format(t);
}
const $_ = {
  values(t) {
    return mt(t) ? t : "" + t;
  },
  numeric(t, e, n) {
    if (t === 0)
      return "0";
    const r = this.chart.options.locale;
    let s, i = t;
    if (n.length > 1) {
      const l = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (l < 1e-4 || l > 1e15) && (s = "scientific"), i = wV(t, n);
    }
    const o = js(Math.abs(i)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), c = {
      notation: s,
      minimumFractionDigits: a,
      maximumFractionDigits: a
    };
    return Object.assign(c, this.options.ticks.format), Cl(t, r, c);
  },
  logarithmic(t, e, n) {
    if (t === 0)
      return "0";
    const r = n[e].significand || t / Math.pow(10, Math.floor(js(t)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(r) || e > 0.8 * n.length ? $_.numeric.call(this, t, e, n) : "";
  }
};
function wV(t, e) {
  let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
  return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n;
}
var Bf = {
  formatters: $_
};
function AV(t) {
  t.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (e, n) => n.lineWidth,
      tickColor: (e, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Bf.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", {
    _fallback: !1,
    _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
    _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
  }), t.describe("scales", {
    _fallback: "scale"
  }), t.describe("scale.ticks", {
    _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
    _indexable: (e) => e !== "backdropPadding"
  });
}
const Gi = /* @__PURE__ */ Object.create(null), Rm = /* @__PURE__ */ Object.create(null);
function wc(t, e) {
  if (!e)
    return t;
  const n = e.split(".");
  for (let r = 0, s = n.length; r < s; ++r) {
    const i = n[r];
    t = t[i] || (t[i] = /* @__PURE__ */ Object.create(null));
  }
  return t;
}
function np(t, e, n) {
  return typeof e == "string" ? Xc(wc(t, e), n) : Xc(wc(t, ""), e);
}
class SV {
  constructor(e, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (r) => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (r, s) => tp(s.backgroundColor), this.hoverBorderColor = (r, s) => tp(s.borderColor), this.hoverColor = (r, s) => tp(s.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n);
  }
  set(e, n) {
    return np(this, e, n);
  }
  get(e) {
    return wc(this, e);
  }
  describe(e, n) {
    return np(Rm, e, n);
  }
  override(e, n) {
    return np(Gi, e, n);
  }
  route(e, n, r, s) {
    const i = wc(this, e), o = wc(this, r), a = "_" + n;
    Object.defineProperties(i, {
      [a]: {
        value: i[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const c = this[a], l = o[s];
          return Pe(c) ? Object.assign({}, l, c) : Ae(c, l);
        },
        set(c) {
          this[a] = c;
        }
      }
    });
  }
  apply(e) {
    e.forEach((n) => n(this));
  }
}
var _t = /* @__PURE__ */ new SV({
  _scriptable: (t) => !t.startsWith("on"),
  _indexable: (t) => t !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  bV,
  vV,
  AV
]);
function EV(t) {
  return !t || je(t.size) || je(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family;
}
function Fd(t, e, n, r, s) {
  let i = e[s];
  return i || (i = e[s] = t.measureText(s).width, n.push(s)), i > r && (r = i), r;
}
function CV(t, e, n, r) {
  r = r || {};
  let s = r.data = r.data || {}, i = r.garbageCollect = r.garbageCollect || [];
  r.font !== e && (s = r.data = {}, i = r.garbageCollect = [], r.font = e), t.save(), t.font = e;
  let o = 0;
  const a = n.length;
  let c, l, u, d, f;
  for (c = 0; c < a; c++)
    if (d = n[c], d != null && !mt(d))
      o = Fd(t, s, i, o, d);
    else if (mt(d))
      for (l = 0, u = d.length; l < u; l++)
        f = d[l], f != null && !mt(f) && (o = Fd(t, s, i, o, f));
  t.restore();
  const h = i.length / 2;
  if (h > n.length) {
    for (c = 0; c < h; c++)
      delete s[i[c]];
    i.splice(0, h);
  }
  return o;
}
function bi(t, e, n) {
  const r = t.currentDevicePixelRatio, s = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((e - s) * r) / r + s;
}
function Vx(t, e) {
  !e && !t || (e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore());
}
function Mm(t, e, n, r) {
  Z_(t, e, n, r, null);
}
function Z_(t, e, n, r, s) {
  let i, o, a, c, l, u, d, f;
  const h = e.pointStyle, p = e.rotation, m = e.radius;
  let y = (p || 0) * oV;
  if (h && typeof h == "object" && (i = h.toString(), i === "[object HTMLImageElement]" || i === "[object HTMLCanvasElement]")) {
    t.save(), t.translate(n, r), t.rotate(y), t.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t.restore();
    return;
  }
  if (!(isNaN(m) || m <= 0)) {
    switch (t.beginPath(), h) {
      default:
        s ? t.ellipse(n, r, s / 2, m, 0, 0, ft) : t.arc(n, r, m, 0, ft), t.closePath();
        break;
      case "triangle":
        u = s ? s / 2 : m, t.moveTo(n + Math.sin(y) * u, r - Math.cos(y) * m), y += Dx, t.lineTo(n + Math.sin(y) * u, r - Math.cos(y) * m), y += Dx, t.lineTo(n + Math.sin(y) * u, r - Math.cos(y) * m), t.closePath();
        break;
      case "rectRounded":
        l = m * 0.516, c = m - l, o = Math.cos(y + yi) * c, d = Math.cos(y + yi) * (s ? s / 2 - l : c), a = Math.sin(y + yi) * c, f = Math.sin(y + yi) * (s ? s / 2 - l : c), t.arc(n - d, r - a, l, y - ht, y - It), t.arc(n + f, r - o, l, y - It, y), t.arc(n + d, r + a, l, y, y + It), t.arc(n - f, r + o, l, y + It, y + ht), t.closePath();
        break;
      case "rect":
        if (!p) {
          c = Math.SQRT1_2 * m, u = s ? s / 2 : c, t.rect(n - u, r - c, 2 * u, 2 * c);
          break;
        }
        y += yi;
      case "rectRot":
        d = Math.cos(y) * (s ? s / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (s ? s / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + f, r - o), t.lineTo(n + d, r + a), t.lineTo(n - f, r + o), t.closePath();
        break;
      case "crossRot":
        y += yi;
      case "cross":
        d = Math.cos(y) * (s ? s / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (s ? s / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + f, r - o), t.lineTo(n - f, r + o);
        break;
      case "star":
        d = Math.cos(y) * (s ? s / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (s ? s / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + f, r - o), t.lineTo(n - f, r + o), y += yi, d = Math.cos(y) * (s ? s / 2 : m), o = Math.cos(y) * m, a = Math.sin(y) * m, f = Math.sin(y) * (s ? s / 2 : m), t.moveTo(n - d, r - a), t.lineTo(n + d, r + a), t.moveTo(n + f, r - o), t.lineTo(n - f, r + o);
        break;
      case "line":
        o = s ? s / 2 : Math.cos(y) * m, a = Math.sin(y) * m, t.moveTo(n - o, r - a), t.lineTo(n + o, r + a);
        break;
      case "dash":
        t.moveTo(n, r), t.lineTo(n + Math.cos(y) * (s ? s / 2 : m), r + Math.sin(y) * m);
        break;
      case !1:
        t.closePath();
        break;
    }
    t.fill(), e.borderWidth > 0 && t.stroke();
  }
}
function ts(t, e, n) {
  return n = n || 0.5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n;
}
function Ff(t, e) {
  t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();
}
function Vf(t) {
  t.restore();
}
function _V(t, e, n, r, s) {
  if (!e)
    return t.lineTo(n.x, n.y);
  if (s === "middle") {
    const i = (e.x + n.x) / 2;
    t.lineTo(i, e.y), t.lineTo(i, n.y);
  } else s === "after" != !!r ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y);
  t.lineTo(n.x, n.y);
}
function TV(t, e, n, r) {
  if (!e)
    return t.lineTo(n.x, n.y);
  t.bezierCurveTo(r ? e.cp1x : e.cp2x, r ? e.cp1y : e.cp2y, r ? n.cp2x : n.cp1x, r ? n.cp2y : n.cp1y, n.x, n.y);
}
function kV(t, e) {
  e.translation && t.translate(e.translation[0], e.translation[1]), je(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);
}
function RV(t, e, n, r, s) {
  if (s.strikethrough || s.underline) {
    const i = t.measureText(r), o = e - i.actualBoundingBoxLeft, a = e + i.actualBoundingBoxRight, c = n - i.actualBoundingBoxAscent, l = n + i.actualBoundingBoxDescent, u = s.strikethrough ? (c + l) / 2 : l;
    t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = s.decorationWidth || 2, t.moveTo(o, u), t.lineTo(a, u), t.stroke();
  }
}
function MV(t, e) {
  const n = t.fillStyle;
  t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n;
}
function Ki(t, e, n, r, s, i = {}) {
  const o = mt(e) ? e : [
    e
  ], a = i.strokeWidth > 0 && i.strokeColor !== "";
  let c, l;
  for (t.save(), t.font = s.string, kV(t, i), c = 0; c < o.length; ++c)
    l = o[c], i.backdrop && MV(t, i.backdrop), a && (i.strokeColor && (t.strokeStyle = i.strokeColor), je(i.strokeWidth) || (t.lineWidth = i.strokeWidth), t.strokeText(l, n, r, i.maxWidth)), t.fillText(l, n, r, i.maxWidth), RV(t, n, r, l, i), r += Number(s.lineHeight);
  t.restore();
}
function tl(t, e) {
  const { x: n, y: r, w: s, h: i, radius: o } = e;
  t.arc(n + o.topLeft, r + o.topLeft, o.topLeft, 1.5 * ht, ht, !0), t.lineTo(n, r + i - o.bottomLeft), t.arc(n + o.bottomLeft, r + i - o.bottomLeft, o.bottomLeft, ht, It, !0), t.lineTo(n + s - o.bottomRight, r + i), t.arc(n + s - o.bottomRight, r + i - o.bottomRight, o.bottomRight, It, 0, !0), t.lineTo(n + s, r + o.topRight), t.arc(n + s - o.topRight, r + o.topRight, o.topRight, 0, -It, !0), t.lineTo(n + o.topLeft, r);
}
const PV = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, IV = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function DV(t, e) {
  const n = ("" + t).match(PV);
  if (!n || n[1] === "normal")
    return e * 1.2;
  switch (t = +n[2], n[3]) {
    case "px":
      return t;
    case "%":
      t /= 100;
      break;
  }
  return e * t;
}
const OV = (t) => +t || 0;
function Uy(t, e) {
  const n = {}, r = Pe(e), s = r ? Object.keys(e) : e, i = Pe(t) ? r ? (o) => Ae(t[o], t[e[o]]) : (o) => t[o] : () => t;
  for (const o of s)
    n[o] = OV(i(o));
  return n;
}
function Q_(t) {
  return Uy(t, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Oi(t) {
  return Uy(t, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function ln(t) {
  const e = Q_(t);
  return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
}
function Ft(t, e) {
  t = t || {}, e = e || _t.font;
  let n = Ae(t.size, e.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let r = Ae(t.style, e.style);
  r && !("" + r).match(IV) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0);
  const s = {
    family: Ae(t.family, e.family),
    lineHeight: DV(Ae(t.lineHeight, e.lineHeight), n),
    size: n,
    style: r,
    weight: Ae(t.weight, e.weight),
    string: ""
  };
  return s.string = EV(s), s;
}
function ac(t, e, n, r) {
  let s, i, o;
  for (s = 0, i = t.length; s < i; ++s)
    if (o = t[s], o !== void 0 && o !== void 0)
      return o;
}
function qV(t, e, n) {
  const { min: r, max: s } = t, i = B_(e, (s - r) / 2), o = (a, c) => n && a === 0 ? 0 : a + c;
  return {
    min: o(r, -Math.abs(i)),
    max: o(s, i)
  };
}
function ui(t, e) {
  return Object.assign(Object.create(t), e);
}
function Wy(t, e = [
  ""
], n, r, s = () => t[0]) {
  const i = n || t;
  typeof r > "u" && (r = tT("_fallback", t));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: t,
    _rootScopes: i,
    _fallback: r,
    _getTarget: s,
    override: (a) => Wy([
      a,
      ...t
    ], e, i, r)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, c) {
      return delete a[c], delete a._keys, delete t[0][c], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, c) {
      return J_(a, c, () => WV(c, e, t, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, c) {
      return Reflect.getOwnPropertyDescriptor(a._scopes[0], c);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(a, c) {
      return Wx(a).includes(c);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(a) {
      return Wx(a);
    },
    /**
    * A trap for setting property values.
    */
    set(a, c, l) {
      const u = a._storage || (a._storage = s());
      return a[c] = u[c] = l, delete a._keys, !0;
    }
  });
}
function na(t, e, n, r) {
  const s = {
    _cacheable: !1,
    _proxy: t,
    _context: e,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: X_(t, r),
    setContext: (i) => na(t, i, n, r),
    override: (i) => na(t.override(i), e, n, r)
  };
  return new Proxy(s, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(i, o) {
      return delete i[o], delete t[o], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(i, o, a) {
      return J_(i, o, () => LV(i, o, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(i, o) {
      return i._descriptors.allKeys ? Reflect.has(t, o) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(t, o);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t);
    },
    /**
    * A trap for the in operator.
    */
    has(i, o) {
      return Reflect.has(t, o);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(t);
    },
    /**
    * A trap for setting property values.
    */
    set(i, o, a) {
      return t[o] = a, delete i[o], !0;
    }
  });
}
function X_(t, e = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = e.scriptable, _indexable: r = e.indexable, _allKeys: s = e.allKeys } = t;
  return {
    allKeys: s,
    scriptable: n,
    indexable: r,
    isScriptable: si(n) ? n : () => n,
    isIndexable: si(r) ? r : () => r
  };
}
const NV = (t, e) => t ? t + Ly(e) : e, zy = (t, e) => Pe(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function J_(t, e, n) {
  if (Object.prototype.hasOwnProperty.call(t, e) || e === "constructor")
    return t[e];
  const r = n();
  return t[e] = r, r;
}
function LV(t, e, n) {
  const { _proxy: r, _context: s, _subProxy: i, _descriptors: o } = t;
  let a = r[e];
  return si(a) && o.isScriptable(e) && (a = jV(e, a, t, n)), mt(a) && a.length && (a = BV(e, a, t, o.isIndexable)), zy(e, a) && (a = na(a, s, i && i[e], o)), a;
}
function jV(t, e, n, r) {
  const { _proxy: s, _context: i, _subProxy: o, _stack: a } = n;
  if (a.has(t))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t);
  a.add(t);
  let c = e(i, o || r);
  return a.delete(t), zy(t, c) && (c = Hy(s._scopes, s, t, c)), c;
}
function BV(t, e, n, r) {
  const { _proxy: s, _context: i, _subProxy: o, _descriptors: a } = n;
  if (typeof i.index < "u" && r(t))
    return e[i.index % e.length];
  if (Pe(e[0])) {
    const c = e, l = s._scopes.filter((u) => u !== c);
    e = [];
    for (const u of c) {
      const d = Hy(l, s, t, u);
      e.push(na(d, i, o && o[t], a));
    }
  }
  return e;
}
function eT(t, e, n) {
  return si(t) ? t(e, n) : t;
}
const FV = (t, e) => t === !0 ? e : typeof t == "string" ? ri(e, t) : void 0;
function VV(t, e, n, r, s) {
  for (const i of e) {
    const o = FV(n, i);
    if (o) {
      t.add(o);
      const a = eT(o._fallback, n, s);
      if (typeof a < "u" && a !== n && a !== r)
        return a;
    } else if (o === !1 && typeof r < "u" && n !== r)
      return null;
  }
  return !1;
}
function Hy(t, e, n, r) {
  const s = e._rootScopes, i = eT(e._fallback, n, r), o = [
    ...t,
    ...s
  ], a = /* @__PURE__ */ new Set();
  a.add(r);
  let c = Ux(a, o, n, i || n, r);
  return c === null || typeof i < "u" && i !== n && (c = Ux(a, o, i, c, r), c === null) ? !1 : Wy(Array.from(a), [
    ""
  ], s, i, () => UV(e, n, r));
}
function Ux(t, e, n, r, s) {
  for (; n; )
    n = VV(t, e, n, r, s);
  return n;
}
function UV(t, e, n) {
  const r = t._getTarget();
  e in r || (r[e] = {});
  const s = r[e];
  return mt(s) && Pe(n) ? n : s || {};
}
function WV(t, e, n, r) {
  let s;
  for (const i of e)
    if (s = tT(NV(i, t), n), typeof s < "u")
      return zy(t, s) ? Hy(n, r, t, s) : s;
}
function tT(t, e) {
  for (const n of e) {
    if (!n)
      continue;
    const r = n[t];
    if (typeof r < "u")
      return r;
  }
}
function Wx(t) {
  let e = t._keys;
  return e || (e = t._keys = zV(t._scopes)), e;
}
function zV(t) {
  const e = /* @__PURE__ */ new Set();
  for (const n of t)
    for (const r of Object.keys(n).filter((s) => !s.startsWith("_")))
      e.add(r);
  return Array.from(e);
}
function nT(t, e, n, r) {
  const { iScale: s } = t, { key: i = "r" } = this._parsing, o = new Array(r);
  let a, c, l, u;
  for (a = 0, c = r; a < c; ++a)
    l = a + n, u = e[l], o[a] = {
      r: s.parse(ri(u, i), l)
    };
  return o;
}
const HV = Number.EPSILON || 1e-14, ra = (t, e) => e < t.length && !t[e].skip && t[e], rT = (t) => t === "x" ? "y" : "x";
function YV(t, e, n, r) {
  const s = t.skip ? e : t, i = e, o = n.skip ? e : n, a = km(i, s), c = km(o, i);
  let l = a / (a + c), u = c / (a + c);
  l = isNaN(l) ? 0 : l, u = isNaN(u) ? 0 : u;
  const d = r * l, f = r * u;
  return {
    previous: {
      x: i.x - d * (o.x - s.x),
      y: i.y - d * (o.y - s.y)
    },
    next: {
      x: i.x + f * (o.x - s.x),
      y: i.y + f * (o.y - s.y)
    }
  };
}
function GV(t, e, n) {
  const r = t.length;
  let s, i, o, a, c, l = ra(t, 0);
  for (let u = 0; u < r - 1; ++u)
    if (c = l, l = ra(t, u + 1), !(!c || !l)) {
      if (vc(e[u], 0, HV)) {
        n[u] = n[u + 1] = 0;
        continue;
      }
      s = n[u] / e[u], i = n[u + 1] / e[u], a = Math.pow(s, 2) + Math.pow(i, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[u] = s * o * e[u], n[u + 1] = i * o * e[u]);
    }
}
function KV(t, e, n = "x") {
  const r = rT(n), s = t.length;
  let i, o, a, c = ra(t, 0);
  for (let l = 0; l < s; ++l) {
    if (o = a, a = c, c = ra(t, l + 1), !a)
      continue;
    const u = a[n], d = a[r];
    o && (i = (u - o[n]) / 3, a[`cp1${n}`] = u - i, a[`cp1${r}`] = d - i * e[l]), c && (i = (c[n] - u) / 3, a[`cp2${n}`] = u + i, a[`cp2${r}`] = d + i * e[l]);
  }
}
function $V(t, e = "x") {
  const n = rT(e), r = t.length, s = Array(r).fill(0), i = Array(r);
  let o, a, c, l = ra(t, 0);
  for (o = 0; o < r; ++o)
    if (a = c, c = l, l = ra(t, o + 1), !!c) {
      if (l) {
        const u = l[e] - c[e];
        s[o] = u !== 0 ? (l[n] - c[n]) / u : 0;
      }
      i[o] = a ? l ? Mr(s[o - 1]) !== Mr(s[o]) ? 0 : (s[o - 1] + s[o]) / 2 : s[o - 1] : s[o];
    }
  GV(t, s, i), KV(t, i, e);
}
function Xl(t, e, n) {
  return Math.max(Math.min(t, n), e);
}
function ZV(t, e) {
  let n, r, s, i, o, a = ts(t[0], e);
  for (n = 0, r = t.length; n < r; ++n)
    o = i, i = a, a = n < r - 1 && ts(t[n + 1], e), i && (s = t[n], o && (s.cp1x = Xl(s.cp1x, e.left, e.right), s.cp1y = Xl(s.cp1y, e.top, e.bottom)), a && (s.cp2x = Xl(s.cp2x, e.left, e.right), s.cp2y = Xl(s.cp2y, e.top, e.bottom)));
}
function QV(t, e, n, r, s) {
  let i, o, a, c;
  if (e.spanGaps && (t = t.filter((l) => !l.skip)), e.cubicInterpolationMode === "monotone")
    $V(t, s);
  else {
    let l = r ? t[t.length - 1] : t[0];
    for (i = 0, o = t.length; i < o; ++i)
      a = t[i], c = YV(l, a, t[Math.min(i + 1, o - (r ? 0 : 1)) % o], e.tension), a.cp1x = c.previous.x, a.cp1y = c.previous.y, a.cp2x = c.next.x, a.cp2y = c.next.y, l = a;
  }
  e.capBezierPoints && ZV(t, n);
}
function Yy() {
  return typeof window < "u" && typeof document < "u";
}
function Gy(t) {
  let e = t.parentNode;
  return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
}
function Vd(t, e, n) {
  let r;
  return typeof t == "string" ? (r = parseInt(t, 10), t.indexOf("%") !== -1 && (r = r / 100 * e.parentNode[n])) : r = t, r;
}
const Uf = (t) => t.ownerDocument.defaultView.getComputedStyle(t, null);
function XV(t, e) {
  return Uf(t).getPropertyValue(e);
}
const JV = [
  "top",
  "right",
  "bottom",
  "left"
];
function qi(t, e, n) {
  const r = {};
  n = n ? "-" + n : "";
  for (let s = 0; s < 4; s++) {
    const i = JV[s];
    r[i] = parseFloat(t[e + "-" + i + n]) || 0;
  }
  return r.width = r.left + r.right, r.height = r.top + r.bottom, r;
}
const eU = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot);
function tU(t, e) {
  const n = t.touches, r = n && n.length ? n[0] : t, { offsetX: s, offsetY: i } = r;
  let o = !1, a, c;
  if (eU(s, i, t.target))
    a = s, c = i;
  else {
    const l = e.getBoundingClientRect();
    a = r.clientX - l.left, c = r.clientY - l.top, o = !0;
  }
  return {
    x: a,
    y: c,
    box: o
  };
}
function Ei(t, e) {
  if ("native" in t)
    return t;
  const { canvas: n, currentDevicePixelRatio: r } = e, s = Uf(n), i = s.boxSizing === "border-box", o = qi(s, "padding"), a = qi(s, "border", "width"), { x: c, y: l, box: u } = tU(t, n), d = o.left + (u && a.left), f = o.top + (u && a.top);
  let { width: h, height: p } = e;
  return i && (h -= o.width + a.width, p -= o.height + a.height), {
    x: Math.round((c - d) / h * n.width / r),
    y: Math.round((l - f) / p * n.height / r)
  };
}
function nU(t, e, n) {
  let r, s;
  if (e === void 0 || n === void 0) {
    const i = t && Gy(t);
    if (!i)
      e = t.clientWidth, n = t.clientHeight;
    else {
      const o = i.getBoundingClientRect(), a = Uf(i), c = qi(a, "border", "width"), l = qi(a, "padding");
      e = o.width - l.width - c.width, n = o.height - l.height - c.height, r = Vd(a.maxWidth, i, "clientWidth"), s = Vd(a.maxHeight, i, "clientHeight");
    }
  }
  return {
    width: e,
    height: n,
    maxWidth: r || Bd,
    maxHeight: s || Bd
  };
}
const Jl = (t) => Math.round(t * 10) / 10;
function rU(t, e, n, r) {
  const s = Uf(t), i = qi(s, "margin"), o = Vd(s.maxWidth, t, "clientWidth") || Bd, a = Vd(s.maxHeight, t, "clientHeight") || Bd, c = nU(t, e, n);
  let { width: l, height: u } = c;
  if (s.boxSizing === "content-box") {
    const f = qi(s, "border", "width"), h = qi(s, "padding");
    l -= h.width + f.width, u -= h.height + f.height;
  }
  return l = Math.max(0, l - i.width), u = Math.max(0, r ? l / r : u - i.height), l = Jl(Math.min(l, o, c.maxWidth)), u = Jl(Math.min(u, a, c.maxHeight)), l && !u && (u = Jl(l / 2)), (e !== void 0 || n !== void 0) && r && c.height && u > c.height && (u = c.height, l = Jl(Math.floor(u * r))), {
    width: l,
    height: u
  };
}
function zx(t, e, n) {
  const r = e || 1, s = Math.floor(t.height * r), i = Math.floor(t.width * r);
  t.height = Math.floor(t.height), t.width = Math.floor(t.width);
  const o = t.canvas;
  return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), t.currentDevicePixelRatio !== r || o.height !== s || o.width !== i ? (t.currentDevicePixelRatio = r, o.height = s, o.width = i, t.ctx.setTransform(r, 0, 0, r, 0, 0), !0) : !1;
}
const sU = function() {
  let t = !1;
  try {
    const e = {
      get passive() {
        return t = !0, !1;
      }
    };
    Yy() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e));
  } catch {
  }
  return t;
}();
function Hx(t, e) {
  const n = XV(t, e), r = n && n.match(/^(\d+)(\.\d+)?px$/);
  return r ? +r[1] : void 0;
}
function Ci(t, e, n, r) {
  return {
    x: t.x + n * (e.x - t.x),
    y: t.y + n * (e.y - t.y)
  };
}
function iU(t, e, n, r) {
  return {
    x: t.x + n * (e.x - t.x),
    y: r === "middle" ? n < 0.5 ? t.y : e.y : r === "after" ? n < 1 ? t.y : e.y : n > 0 ? e.y : t.y
  };
}
function oU(t, e, n, r) {
  const s = {
    x: t.cp2x,
    y: t.cp2y
  }, i = {
    x: e.cp1x,
    y: e.cp1y
  }, o = Ci(t, s, n), a = Ci(s, i, n), c = Ci(i, e, n), l = Ci(o, a, n), u = Ci(a, c, n);
  return Ci(l, u, n);
}
const aU = function(t, e) {
  return {
    x(n) {
      return t + t + e - n;
    },
    setWidth(n) {
      e = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, r) {
      return n - r;
    },
    leftForLtr(n, r) {
      return n - r;
    }
  };
}, cU = function() {
  return {
    x(t) {
      return t;
    },
    setWidth(t) {
    },
    textAlign(t) {
      return t;
    },
    xPlus(t, e) {
      return t + e;
    },
    leftForLtr(t, e) {
      return t;
    }
  };
};
function Fo(t, e, n) {
  return t ? aU(e, n) : cU();
}
function sT(t, e) {
  let n, r;
  (e === "ltr" || e === "rtl") && (n = t.canvas.style, r = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", e, "important"), t.prevTextDirection = r);
}
function iT(t, e) {
  e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]));
}
function oT(t) {
  return t === "angle" ? {
    between: el,
    compare: lV,
    normalize: Nn
  } : {
    between: Jr,
    compare: (e, n) => e - n,
    normalize: (e) => e
  };
}
function Yx({ start: t, end: e, count: n, loop: r, style: s }) {
  return {
    start: t % n,
    end: e % n,
    loop: r && (e - t + 1) % n === 0,
    style: s
  };
}
function lU(t, e, n) {
  const { property: r, start: s, end: i } = n, { between: o, normalize: a } = oT(r), c = e.length;
  let { start: l, end: u, loop: d } = t, f, h;
  if (d) {
    for (l += c, u += c, f = 0, h = c; f < h && o(a(e[l % c][r]), s, i); ++f)
      l--, u--;
    l %= c, u %= c;
  }
  return u < l && (u += c), {
    start: l,
    end: u,
    loop: d,
    style: t.style
  };
}
function aT(t, e, n) {
  if (!n)
    return [
      t
    ];
  const { property: r, start: s, end: i } = n, o = e.length, { compare: a, between: c, normalize: l } = oT(r), { start: u, end: d, loop: f, style: h } = lU(t, e, n), p = [];
  let m = !1, y = null, b, v, w;
  const x = () => c(s, w, b) && a(s, w) !== 0, A = () => a(i, b) === 0 || c(i, w, b), C = () => m || x(), S = () => !m || A();
  for (let _ = u, T = u; _ <= d; ++_)
    v = e[_ % o], !v.skip && (b = l(v[r]), b !== w && (m = c(b, s, i), y === null && C() && (y = a(b, s) === 0 ? _ : T), y !== null && S() && (p.push(Yx({
      start: y,
      end: _,
      loop: f,
      count: o,
      style: h
    })), y = null), T = _, w = b));
  return y !== null && p.push(Yx({
    start: y,
    end: d,
    loop: f,
    count: o,
    style: h
  })), p;
}
function cT(t, e) {
  const n = [], r = t.segments;
  for (let s = 0; s < r.length; s++) {
    const i = aT(r[s], t.points, e);
    i.length && n.push(...i);
  }
  return n;
}
function uU(t, e, n, r) {
  let s = 0, i = e - 1;
  if (n && !r)
    for (; s < e && !t[s].skip; )
      s++;
  for (; s < e && t[s].skip; )
    s++;
  for (s %= e, n && (i += s); i > s && t[i % e].skip; )
    i--;
  return i %= e, {
    start: s,
    end: i
  };
}
function dU(t, e, n, r) {
  const s = t.length, i = [];
  let o = e, a = t[e], c;
  for (c = e + 1; c <= n; ++c) {
    const l = t[c % s];
    l.skip || l.stop ? a.skip || (r = !1, i.push({
      start: e % s,
      end: (c - 1) % s,
      loop: r
    }), e = o = l.stop ? c : null) : (o = c, a.skip && (e = c)), a = l;
  }
  return o !== null && i.push({
    start: e % s,
    end: o % s,
    loop: r
  }), i;
}
function fU(t, e) {
  const n = t.points, r = t.options.spanGaps, s = n.length;
  if (!s)
    return [];
  const i = !!t._loop, { start: o, end: a } = uU(n, s, i, r);
  if (r === !0)
    return Gx(t, [
      {
        start: o,
        end: a,
        loop: i
      }
    ], n, e);
  const c = a < o ? a + s : a, l = !!t._fullLoop && o === 0 && a === s - 1;
  return Gx(t, dU(n, o, c, l), n, e);
}
function Gx(t, e, n, r) {
  return !r || !r.setContext || !n ? e : hU(t, e, n, r);
}
function hU(t, e, n, r) {
  const s = t._chart.getContext(), i = Kx(t.options), { _datasetIndex: o, options: { spanGaps: a } } = t, c = n.length, l = [];
  let u = i, d = e[0].start, f = d;
  function h(p, m, y, b) {
    const v = a ? -1 : 1;
    if (p !== m) {
      for (p += c; n[p % c].skip; )
        p -= v;
      for (; n[m % c].skip; )
        m += v;
      p % c !== m % c && (l.push({
        start: p % c,
        end: m % c,
        loop: y,
        style: b
      }), u = b, d = m % c);
    }
  }
  for (const p of e) {
    d = a ? d : p.start;
    let m = n[d % c], y;
    for (f = d + 1; f <= p.end; f++) {
      const b = n[f % c];
      y = Kx(r.setContext(ui(s, {
        type: "segment",
        p0: m,
        p1: b,
        p0DataIndex: (f - 1) % c,
        p1DataIndex: f % c,
        datasetIndex: o
      }))), pU(y, u) && h(d, f - 1, p.loop, u), m = b, u = y;
    }
    d < f - 1 && h(d, f - 1, p.loop, u);
  }
  return l;
}
function Kx(t) {
  return {
    backgroundColor: t.backgroundColor,
    borderCapStyle: t.borderCapStyle,
    borderDash: t.borderDash,
    borderDashOffset: t.borderDashOffset,
    borderJoinStyle: t.borderJoinStyle,
    borderWidth: t.borderWidth,
    borderColor: t.borderColor
  };
}
function pU(t, e) {
  if (!e)
    return !1;
  const n = [], r = function(s, i) {
    return Vy(i) ? (n.includes(i) || n.push(i), n.indexOf(i)) : i;
  };
  return JSON.stringify(t, r) !== JSON.stringify(e, r);
}
/*!
 * Chart.js v4.4.4
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class mU {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(e, n, r, s) {
    const i = n.listeners[s], o = n.duration;
    i.forEach((a) => a({
      chart: e,
      initial: n.initial,
      numSteps: o,
      currentStep: Math.min(r - n.start, o)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = H_.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(e = Date.now()) {
    let n = 0;
    this._charts.forEach((r, s) => {
      if (!r.running || !r.items.length)
        return;
      const i = r.items;
      let o = i.length - 1, a = !1, c;
      for (; o >= 0; --o)
        c = i[o], c._active ? (c._total > r.duration && (r.duration = c._total), c.tick(e), a = !0) : (i[o] = i[i.length - 1], i.pop());
      a && (s.draw(), this._notify(s, r, e, "progress")), i.length || (r.running = !1, this._notify(s, r, e, "complete"), r.initial = !1), n += i.length;
    }), this._lastDate = e, n === 0 && (this._running = !1);
  }
  _getAnims(e) {
    const n = this._charts;
    let r = n.get(e);
    return r || (r = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(e, r)), r;
  }
  listen(e, n, r) {
    this._getAnims(e).listeners[n].push(r);
  }
  add(e, n) {
    !n || !n.length || this._getAnims(e).items.push(...n);
  }
  has(e) {
    return this._getAnims(e).items.length > 0;
  }
  start(e) {
    const n = this._charts.get(e);
    n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((r, s) => Math.max(r, s._duration), 0), this._refresh());
  }
  running(e) {
    if (!this._running)
      return !1;
    const n = this._charts.get(e);
    return !(!n || !n.running || !n.items.length);
  }
  stop(e) {
    const n = this._charts.get(e);
    if (!n || !n.items.length)
      return;
    const r = n.items;
    let s = r.length - 1;
    for (; s >= 0; --s)
      r[s].cancel();
    n.items = [], this._notify(e, n, Date.now(), "complete");
  }
  remove(e) {
    return this._charts.delete(e);
  }
}
var Hr = /* @__PURE__ */ new mU();
const $x = "transparent", gU = {
  boolean(t, e, n) {
    return n > 0.5 ? e : t;
  },
  color(t, e, n) {
    const r = Bx(t || $x), s = r.valid && Bx(e || $x);
    return s && s.valid ? s.mix(r, n).hexString() : e;
  },
  number(t, e, n) {
    return t + (e - t) * n;
  }
};
class yU {
  constructor(e, n, r, s) {
    const i = n[r];
    s = ac([
      e.to,
      s,
      i,
      e.from
    ]);
    const o = ac([
      e.from,
      i,
      s
    ]);
    this._active = !0, this._fn = e.fn || gU[e.type || typeof o], this._easing = xc[e.easing] || xc.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = r, this._from = o, this._to = s, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(e, n, r) {
    if (this._active) {
      this._notify(!1);
      const s = this._target[this._prop], i = r - this._start, o = this._duration - i;
      this._start = r, this._duration = Math.floor(Math.max(o, e.duration)), this._total += i, this._loop = !!e.loop, this._to = ac([
        e.to,
        n,
        s,
        e.from
      ]), this._from = ac([
        e.from,
        s,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(e) {
    const n = e - this._start, r = this._duration, s = this._prop, i = this._from, o = this._loop, a = this._to;
    let c;
    if (this._active = i !== a && (o || n < r), !this._active) {
      this._target[s] = a, this._notify(!0);
      return;
    }
    if (n < 0) {
      this._target[s] = i;
      return;
    }
    c = n / r % 2, c = o && c > 1 ? 2 - c : c, c = this._easing(Math.min(1, Math.max(0, c))), this._target[s] = this._fn(i, a, c);
  }
  wait() {
    const e = this._promises || (this._promises = []);
    return new Promise((n, r) => {
      e.push({
        res: n,
        rej: r
      });
    });
  }
  _notify(e) {
    const n = e ? "res" : "rej", r = this._promises || [];
    for (let s = 0; s < r.length; s++)
      r[s][n]();
  }
}
class lT {
  constructor(e, n) {
    this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(e) {
    if (!Pe(e))
      return;
    const n = Object.keys(_t.animation), r = this._properties;
    Object.getOwnPropertyNames(e).forEach((s) => {
      const i = e[s];
      if (!Pe(i))
        return;
      const o = {};
      for (const a of n)
        o[a] = i[a];
      (mt(i.properties) && i.properties || [
        s
      ]).forEach((a) => {
        (a === s || !r.has(a)) && r.set(a, o);
      });
    });
  }
  _animateOptions(e, n) {
    const r = n.options, s = vU(e, r);
    if (!s)
      return [];
    const i = this._createAnimations(s, r);
    return r.$shared && bU(e.options.$animations, r).then(() => {
      e.options = r;
    }, () => {
    }), i;
  }
  _createAnimations(e, n) {
    const r = this._properties, s = [], i = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now();
    let c;
    for (c = o.length - 1; c >= 0; --c) {
      const l = o[c];
      if (l.charAt(0) === "$")
        continue;
      if (l === "options") {
        s.push(...this._animateOptions(e, n));
        continue;
      }
      const u = n[l];
      let d = i[l];
      const f = r.get(l);
      if (d)
        if (f && d.active()) {
          d.update(f, u, a);
          continue;
        } else
          d.cancel();
      if (!f || !f.duration) {
        e[l] = u;
        continue;
      }
      i[l] = d = new yU(f, e, l, u), s.push(d);
    }
    return s;
  }
  update(e, n) {
    if (this._properties.size === 0) {
      Object.assign(e, n);
      return;
    }
    const r = this._createAnimations(e, n);
    if (r.length)
      return Hr.add(this._chart, r), !0;
  }
}
function bU(t, e) {
  const n = [], r = Object.keys(e);
  for (let s = 0; s < r.length; s++) {
    const i = t[r[s]];
    i && i.active() && n.push(i.wait());
  }
  return Promise.all(n);
}
function vU(t, e) {
  if (!e)
    return;
  let n = t.options;
  if (!n) {
    t.options = e;
    return;
  }
  return n.$shared && (t.options = n = Object.assign({}, n, {
    $shared: !1,
    $animations: {}
  })), n;
}
function Zx(t, e) {
  const n = t && t.options || {}, r = n.reverse, s = n.min === void 0 ? e : 0, i = n.max === void 0 ? e : 0;
  return {
    start: r ? i : s,
    end: r ? s : i
  };
}
function xU(t, e, n) {
  if (n === !1)
    return !1;
  const r = Zx(t, n), s = Zx(e, n);
  return {
    top: s.end,
    right: r.end,
    bottom: s.start,
    left: r.start
  };
}
function wU(t) {
  let e, n, r, s;
  return Pe(t) ? (e = t.top, n = t.right, r = t.bottom, s = t.left) : e = n = r = s = t, {
    top: e,
    right: n,
    bottom: r,
    left: s,
    disabled: t === !1
  };
}
function uT(t, e) {
  const n = [], r = t._getSortedDatasetMetas(e);
  let s, i;
  for (s = 0, i = r.length; s < i; ++s)
    n.push(r[s].index);
  return n;
}
function Qx(t, e, n, r = {}) {
  const s = t.keys, i = r.mode === "single";
  let o, a, c, l;
  if (e !== null) {
    for (o = 0, a = s.length; o < a; ++o) {
      if (c = +s[o], c === n) {
        if (r.all)
          continue;
        break;
      }
      l = t.values[c], Ct(l) && (i || e === 0 || Mr(e) === Mr(l)) && (e += l);
    }
    return e;
  }
}
function AU(t, e) {
  const { iScale: n, vScale: r } = e, s = n.axis === "x" ? "x" : "y", i = r.axis === "x" ? "x" : "y", o = Object.keys(t), a = new Array(o.length);
  let c, l, u;
  for (c = 0, l = o.length; c < l; ++c)
    u = o[c], a[c] = {
      [s]: u,
      [i]: t[u]
    };
  return a;
}
function Xx(t, e) {
  const n = t && t.options.stacked;
  return n || n === void 0 && e.stack !== void 0;
}
function SU(t, e, n) {
  return `${t.id}.${e.id}.${n.stack || n.type}`;
}
function EU(t) {
  const { min: e, max: n, minDefined: r, maxDefined: s } = t.getUserBounds();
  return {
    min: r ? e : Number.NEGATIVE_INFINITY,
    max: s ? n : Number.POSITIVE_INFINITY
  };
}
function CU(t, e, n) {
  const r = t[e] || (t[e] = {});
  return r[n] || (r[n] = {});
}
function Jx(t, e, n, r) {
  for (const s of e.getMatchingVisibleMetas(r).reverse()) {
    const i = t[s.index];
    if (n && i > 0 || !n && i < 0)
      return s.index;
  }
  return null;
}
function ew(t, e) {
  const { chart: n, _cachedMeta: r } = t, s = n._stacks || (n._stacks = {}), { iScale: i, vScale: o, index: a } = r, c = i.axis, l = o.axis, u = SU(i, o, r), d = e.length;
  let f;
  for (let h = 0; h < d; ++h) {
    const p = e[h], { [c]: m, [l]: y } = p, b = p._stacks || (p._stacks = {});
    f = b[l] = CU(s, u, m), f[a] = y, f._top = Jx(f, o, !0, r.type), f._bottom = Jx(f, o, !1, r.type);
    const v = f._visualValues || (f._visualValues = {});
    v[a] = y;
  }
}
function rp(t, e) {
  const n = t.scales;
  return Object.keys(n).filter((r) => n[r].axis === e).shift();
}
function _U(t, e) {
  return ui(t, {
    active: !1,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: "default",
    type: "dataset"
  });
}
function TU(t, e, n) {
  return ui(t, {
    active: !1,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: e,
    mode: "default",
    type: "data"
  });
}
function Ya(t, e) {
  const n = t.controller.index, r = t.vScale && t.vScale.axis;
  if (r) {
    e = e || t._parsed;
    for (const s of e) {
      const i = s._stacks;
      if (!i || i[r] === void 0 || i[r][n] === void 0)
        return;
      delete i[r][n], i[r]._visualValues !== void 0 && i[r]._visualValues[n] !== void 0 && delete i[r]._visualValues[n];
    }
  }
}
const sp = (t) => t === "reset" || t === "none", tw = (t, e) => e ? t : Object.assign({}, t), kU = (t, e, n) => t && !e.hidden && e._stacked && {
  keys: uT(n, !0),
  values: null
};
class cr {
  constructor(e, n) {
    this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const e = this._cachedMeta;
    this.configure(), this.linkScales(), e._stacked = Xx(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(e) {
    this.index !== e && Ya(this._cachedMeta), this.index = e;
  }
  linkScales() {
    const e = this.chart, n = this._cachedMeta, r = this.getDataset(), s = (d, f, h, p) => d === "x" ? f : d === "r" ? p : h, i = n.xAxisID = Ae(r.xAxisID, rp(e, "x")), o = n.yAxisID = Ae(r.yAxisID, rp(e, "y")), a = n.rAxisID = Ae(r.rAxisID, rp(e, "r")), c = n.indexAxis, l = n.iAxisID = s(c, i, o, a), u = n.vAxisID = s(c, o, i, a);
    n.xScale = this.getScaleForId(i), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(l), n.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(e) {
    return this.chart.scales[e];
  }
  _getOtherScale(e) {
    const n = this._cachedMeta;
    return e === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const e = this._cachedMeta;
    this._data && Nx(this._data, this), e._stacked && Ya(e);
  }
  _dataCheck() {
    const e = this.getDataset(), n = e.data || (e.data = []), r = this._data;
    if (Pe(n)) {
      const s = this._cachedMeta;
      this._data = AU(n, s);
    } else if (r !== n) {
      if (r) {
        Nx(r, this);
        const s = this._cachedMeta;
        Ya(s), s._parsed = [];
      }
      n && Object.isExtensible(n) && hV(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const e = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(e) {
    const n = this._cachedMeta, r = this.getDataset();
    let s = !1;
    this._dataCheck();
    const i = n._stacked;
    n._stacked = Xx(n.vScale, n), n.stack !== r.stack && (s = !0, Ya(n), n.stack = r.stack), this._resyncElements(e), (s || i !== n._stacked) && ew(this, n._parsed);
  }
  configure() {
    const e = this.chart.config, n = e.datasetScopeKeys(this._type), r = e.getOptionScopes(this.getDataset(), n, !0);
    this.options = e.createResolver(r, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(e, n) {
    const { _cachedMeta: r, _data: s } = this, { iScale: i, _stacked: o } = r, a = i.axis;
    let c = e === 0 && n === s.length ? !0 : r._sorted, l = e > 0 && r._parsed[e - 1], u, d, f;
    if (this._parsing === !1)
      r._parsed = s, r._sorted = !0, f = s;
    else {
      mt(s[e]) ? f = this.parseArrayData(r, s, e, n) : Pe(s[e]) ? f = this.parseObjectData(r, s, e, n) : f = this.parsePrimitiveData(r, s, e, n);
      const h = () => d[a] === null || l && d[a] < l[a];
      for (u = 0; u < n; ++u)
        r._parsed[u + e] = d = f[u], c && (h() && (c = !1), l = d);
      r._sorted = c;
    }
    o && ew(this, f);
  }
  parsePrimitiveData(e, n, r, s) {
    const { iScale: i, vScale: o } = e, a = i.axis, c = o.axis, l = i.getLabels(), u = i === o, d = new Array(s);
    let f, h, p;
    for (f = 0, h = s; f < h; ++f)
      p = f + r, d[f] = {
        [a]: u || i.parse(l[p], p),
        [c]: o.parse(n[p], p)
      };
    return d;
  }
  parseArrayData(e, n, r, s) {
    const { xScale: i, yScale: o } = e, a = new Array(s);
    let c, l, u, d;
    for (c = 0, l = s; c < l; ++c)
      u = c + r, d = n[u], a[c] = {
        x: i.parse(d[0], u),
        y: o.parse(d[1], u)
      };
    return a;
  }
  parseObjectData(e, n, r, s) {
    const { xScale: i, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: c = "y" } = this._parsing, l = new Array(s);
    let u, d, f, h;
    for (u = 0, d = s; u < d; ++u)
      f = u + r, h = n[f], l[u] = {
        x: i.parse(ri(h, a), f),
        y: o.parse(ri(h, c), f)
      };
    return l;
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e];
  }
  getDataElement(e) {
    return this._cachedMeta.data[e];
  }
  applyStack(e, n, r) {
    const s = this.chart, i = this._cachedMeta, o = n[e.axis], a = {
      keys: uT(s, !0),
      values: n._stacks[e.axis]._visualValues
    };
    return Qx(a, o, i.index, {
      mode: r
    });
  }
  updateRangeFromParsed(e, n, r, s) {
    const i = r[n.axis];
    let o = i === null ? NaN : i;
    const a = s && r._stacks[n.axis];
    s && a && (s.values = a, o = Qx(s, i, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o);
  }
  getMinMax(e, n) {
    const r = this._cachedMeta, s = r._parsed, i = r._sorted && e === r.iScale, o = s.length, a = this._getOtherScale(e), c = kU(n, r, this.chart), l = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: d } = EU(a);
    let f, h;
    function p() {
      h = s[f];
      const m = h[a.axis];
      return !Ct(h[e.axis]) || u > m || d < m;
    }
    for (f = 0; f < o && !(!p() && (this.updateRangeFromParsed(l, e, h, c), i)); ++f)
      ;
    if (i) {
      for (f = o - 1; f >= 0; --f)
        if (!p()) {
          this.updateRangeFromParsed(l, e, h, c);
          break;
        }
    }
    return l;
  }
  getAllParsedValues(e) {
    const n = this._cachedMeta._parsed, r = [];
    let s, i, o;
    for (s = 0, i = n.length; s < i; ++s)
      o = n[s][e.axis], Ct(o) && r.push(o);
    return r;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, r = n.iScale, s = n.vScale, i = this.getParsed(e);
    return {
      label: r ? "" + r.getLabelForValue(i[r.axis]) : "",
      value: s ? "" + s.getLabelForValue(i[s.axis]) : ""
    };
  }
  _update(e) {
    const n = this._cachedMeta;
    this.update(e || "default"), n._clip = wU(Ae(this.options.clip, xU(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(e) {
  }
  draw() {
    const e = this._ctx, n = this.chart, r = this._cachedMeta, s = r.data || [], i = n.chartArea, o = [], a = this._drawStart || 0, c = this._drawCount || s.length - a, l = this.options.drawActiveElementsOnTop;
    let u;
    for (r.dataset && r.dataset.draw(e, i, a, c), u = a; u < a + c; ++u) {
      const d = s[u];
      d.hidden || (d.active && l ? o.push(d) : d.draw(e, i));
    }
    for (u = 0; u < o.length; ++u)
      o[u].draw(e, i);
  }
  getStyle(e, n) {
    const r = n ? "active" : "default";
    return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(e || 0, r);
  }
  getContext(e, n, r) {
    const s = this.getDataset();
    let i;
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[e];
      i = o.$context || (o.$context = TU(this.getContext(), e, o)), i.parsed = this.getParsed(e), i.raw = s.data[e], i.index = i.dataIndex = e;
    } else
      i = this.$context || (this.$context = _U(this.chart.getContext(), this.index)), i.dataset = s, i.index = i.datasetIndex = this.index;
    return i.active = !!n, i.mode = r, i;
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e);
  }
  resolveDataElementOptions(e, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, e);
  }
  _resolveElementOptions(e, n = "default", r) {
    const s = n === "active", i = this._cachedDataOpts, o = e + "-" + n, a = i[o], c = this.enableOptionSharing && Jc(r);
    if (a)
      return tw(a, c);
    const l = this.chart.config, u = l.datasetElementScopeKeys(this._type, e), d = s ? [
      `${e}Hover`,
      "hover",
      e,
      ""
    ] : [
      e,
      ""
    ], f = l.getOptionScopes(this.getDataset(), u), h = Object.keys(_t.elements[e]), p = () => this.getContext(r, s, n), m = l.resolveNamedOptions(f, h, p, d);
    return m.$shared && (m.$shared = c, i[o] = Object.freeze(tw(m, c))), m;
  }
  _resolveAnimations(e, n, r) {
    const s = this.chart, i = this._cachedDataOpts, o = `animation-${n}`, a = i[o];
    if (a)
      return a;
    let c;
    if (s.options.animation !== !1) {
      const u = this.chart.config, d = u.datasetAnimationScopeKeys(this._type, n), f = u.getOptionScopes(this.getDataset(), d);
      c = u.createResolver(f, this.getContext(e, r, n));
    }
    const l = new lT(s, c && c.animations);
    return c && c._cacheable && (i[o] = Object.freeze(l)), l;
  }
  getSharedOptions(e) {
    if (e.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
  }
  includeOptions(e, n) {
    return !n || sp(e) || this.chart._animationsDisabled;
  }
  _getSharedOptions(e, n) {
    const r = this.resolveDataElementOptions(e, n), s = this._sharedOptions, i = this.getSharedOptions(r), o = this.includeOptions(n, i) || i !== s;
    return this.updateSharedOptions(i, n, r), {
      sharedOptions: i,
      includeOptions: o
    };
  }
  updateElement(e, n, r, s) {
    sp(s) ? Object.assign(e, r) : this._resolveAnimations(n, s).update(e, r);
  }
  updateSharedOptions(e, n, r) {
    e && !sp(n) && this._resolveAnimations(void 0, n).update(e, r);
  }
  _setStyle(e, n, r, s) {
    e.active = s;
    const i = this.getStyle(n, s);
    this._resolveAnimations(n, r, s).update(e, {
      options: !s && this.getSharedOptions(i) || i
    });
  }
  removeHoverStyle(e, n, r) {
    this._setStyle(e, r, "active", !1);
  }
  setHoverStyle(e, n, r) {
    this._setStyle(e, r, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !0);
  }
  _resyncElements(e) {
    const n = this._data, r = this._cachedMeta.data;
    for (const [a, c, l] of this._syncList)
      this[a](c, l);
    this._syncList = [];
    const s = r.length, i = n.length, o = Math.min(i, s);
    o && this.parse(0, o), i > s ? this._insertElements(s, i - s, e) : i < s && this._removeElements(i, s - i);
  }
  _insertElements(e, n, r = !0) {
    const s = this._cachedMeta, i = s.data, o = e + n;
    let a;
    const c = (l) => {
      for (l.length += n, a = l.length - 1; a >= o; a--)
        l[a] = l[a - n];
    };
    for (c(i), a = e; a < o; ++a)
      i[a] = new this.dataElementType();
    this._parsing && c(s._parsed), this.parse(e, n), r && this.updateElements(i, e, n, "reset");
  }
  updateElements(e, n, r, s) {
  }
  _removeElements(e, n) {
    const r = this._cachedMeta;
    if (this._parsing) {
      const s = r._parsed.splice(e, n);
      r._stacked && Ya(r, s);
    }
    r.data.splice(e, n);
  }
  _sync(e) {
    if (this._parsing)
      this._syncList.push(e);
    else {
      const [n, r, s] = e;
      this[n](r, s);
    }
    this.chart._dataChanges.push([
      this.index,
      ...e
    ]);
  }
  _onDataPush() {
    const e = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - e,
      e
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(e, n) {
    n && this._sync([
      "_removeElements",
      e,
      n
    ]);
    const r = arguments.length - 2;
    r && this._sync([
      "_insertElements",
      e,
      r
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
K(cr, "defaults", {}), K(cr, "datasetElementType", null), K(cr, "dataElementType", null);
function RU(t, e) {
  if (!t._cache.$bar) {
    const n = t.getMatchingVisibleMetas(e);
    let r = [];
    for (let s = 0, i = n.length; s < i; s++)
      r = r.concat(n[s].controller.getAllParsedValues(t));
    t._cache.$bar = z_(r.sort((s, i) => s - i));
  }
  return t._cache.$bar;
}
function MU(t) {
  const e = t.iScale, n = RU(e, t.type);
  let r = e._length, s, i, o, a;
  const c = () => {
    o === 32767 || o === -32768 || (Jc(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o);
  };
  for (s = 0, i = n.length; s < i; ++s)
    o = e.getPixelForValue(n[s]), c();
  for (a = void 0, s = 0, i = e.ticks.length; s < i; ++s)
    o = e.getPixelForTick(s), c();
  return r;
}
function PU(t, e, n, r) {
  const s = n.barThickness;
  let i, o;
  return je(s) ? (i = e.min * n.categoryPercentage, o = n.barPercentage) : (i = s * r, o = 1), {
    chunk: i / r,
    ratio: o,
    start: e.pixels[t] - i / 2
  };
}
function IU(t, e, n, r) {
  const s = e.pixels, i = s[t];
  let o = t > 0 ? s[t - 1] : null, a = t < s.length - 1 ? s[t + 1] : null;
  const c = n.categoryPercentage;
  o === null && (o = i - (a === null ? e.end - e.start : a - i)), a === null && (a = i + i - o);
  const l = i - (i - Math.min(o, a)) / 2 * c;
  return {
    chunk: Math.abs(a - o) / 2 * c / r,
    ratio: n.barPercentage,
    start: l
  };
}
function DU(t, e, n, r) {
  const s = n.parse(t[0], r), i = n.parse(t[1], r), o = Math.min(s, i), a = Math.max(s, i);
  let c = o, l = a;
  Math.abs(o) > Math.abs(a) && (c = a, l = o), e[n.axis] = l, e._custom = {
    barStart: c,
    barEnd: l,
    start: s,
    end: i,
    min: o,
    max: a
  };
}
function dT(t, e, n, r) {
  return mt(t) ? DU(t, e, n, r) : e[n.axis] = n.parse(t, r), e;
}
function nw(t, e, n, r) {
  const s = t.iScale, i = t.vScale, o = s.getLabels(), a = s === i, c = [];
  let l, u, d, f;
  for (l = n, u = n + r; l < u; ++l)
    f = e[l], d = {}, d[s.axis] = a || s.parse(o[l], l), c.push(dT(f, d, i, l));
  return c;
}
function ip(t) {
  return t && t.barStart !== void 0 && t.barEnd !== void 0;
}
function OU(t, e, n) {
  return t !== 0 ? Mr(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1);
}
function qU(t) {
  let e, n, r, s, i;
  return t.horizontal ? (e = t.base > t.x, n = "left", r = "right") : (e = t.base < t.y, n = "bottom", r = "top"), e ? (s = "end", i = "start") : (s = "start", i = "end"), {
    start: n,
    end: r,
    reverse: e,
    top: s,
    bottom: i
  };
}
function NU(t, e, n, r) {
  let s = e.borderSkipped;
  const i = {};
  if (!s) {
    t.borderSkipped = i;
    return;
  }
  if (s === !0) {
    t.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: o, end: a, reverse: c, top: l, bottom: u } = qU(t);
  s === "middle" && n && (t.enableBorderRadius = !0, (n._top || 0) === r ? s = l : (n._bottom || 0) === r ? s = u : (i[rw(u, o, a, c)] = !0, s = l)), i[rw(s, o, a, c)] = !0, t.borderSkipped = i;
}
function rw(t, e, n, r) {
  return r ? (t = LU(t, e, n), t = sw(t, n, e)) : t = sw(t, e, n), t;
}
function LU(t, e, n) {
  return t === e ? n : t === n ? e : t;
}
function sw(t, e, n) {
  return t === "start" ? e : t === "end" ? n : t;
}
function jU(t, { inflateAmount: e }, n) {
  t.inflateAmount = e === "auto" ? n === 1 ? 0.33 : 0 : e;
}
class Wu extends cr {
  parsePrimitiveData(e, n, r, s) {
    return nw(e, n, r, s);
  }
  parseArrayData(e, n, r, s) {
    return nw(e, n, r, s);
  }
  parseObjectData(e, n, r, s) {
    const { iScale: i, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: c = "y" } = this._parsing, l = i.axis === "x" ? a : c, u = o.axis === "x" ? a : c, d = [];
    let f, h, p, m;
    for (f = r, h = r + s; f < h; ++f)
      m = n[f], p = {}, p[i.axis] = i.parse(ri(m, l), f), d.push(dT(ri(m, u), p, o, f));
    return d;
  }
  updateRangeFromParsed(e, n, r, s) {
    super.updateRangeFromParsed(e, n, r, s);
    const i = r._custom;
    i && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, i.min), e.max = Math.max(e.max, i.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, { iScale: r, vScale: s } = n, i = this.getParsed(e), o = i._custom, a = ip(o) ? "[" + o.start + ", " + o.end + "]" : "" + s.getLabelForValue(i[s.axis]);
    return {
      label: "" + r.getLabelForValue(i[r.axis]),
      value: a
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const e = this._cachedMeta;
    e.stack = this.getDataset().stack;
  }
  update(e) {
    const n = this._cachedMeta;
    this.updateElements(n.data, 0, n.data.length, e);
  }
  updateElements(e, n, r, s) {
    const i = s === "reset", { index: o, _cachedMeta: { vScale: a } } = this, c = a.getBasePixel(), l = a.isHorizontal(), u = this._getRuler(), { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, s);
    for (let h = n; h < n + r; h++) {
      const p = this.getParsed(h), m = i || je(p[a.axis]) ? {
        base: c,
        head: c
      } : this._calculateBarValuePixels(h), y = this._calculateBarIndexPixels(h, u), b = (p._stacks || {})[a.axis], v = {
        horizontal: l,
        base: m.base,
        enableBorderRadius: !b || ip(p._custom) || o === b._top || o === b._bottom,
        x: l ? m.head : y.center,
        y: l ? y.center : m.head,
        height: l ? y.size : Math.abs(m.size),
        width: l ? Math.abs(m.size) : y.size
      };
      f && (v.options = d || this.resolveDataElementOptions(h, e[h].active ? "active" : s));
      const w = v.options || e[h].options;
      NU(v, w, b, o), jU(v, w, u.ratio), this.updateElement(e[h], h, v, s);
    }
  }
  _getStacks(e, n) {
    const { iScale: r } = this._cachedMeta, s = r.getMatchingVisibleMetas(this._type).filter((u) => u.controller.options.grouped), i = r.options.stacked, o = [], a = this._cachedMeta.controller.getParsed(n), c = a && a[r.axis], l = (u) => {
      const d = u._parsed.find((h) => h[r.axis] === c), f = d && d[u.vScale.axis];
      if (je(f) || isNaN(f))
        return !0;
    };
    for (const u of s)
      if (!(n !== void 0 && l(u)) && ((i === !1 || o.indexOf(u.stack) === -1 || i === void 0 && u.stack === void 0) && o.push(u.stack), u.index === e))
        break;
    return o.length || o.push(void 0), o;
  }
  _getStackCount(e) {
    return this._getStacks(void 0, e).length;
  }
  _getStackIndex(e, n, r) {
    const s = this._getStacks(e, r), i = n !== void 0 ? s.indexOf(n) : -1;
    return i === -1 ? s.length - 1 : i;
  }
  _getRuler() {
    const e = this.options, n = this._cachedMeta, r = n.iScale, s = [];
    let i, o;
    for (i = 0, o = n.data.length; i < o; ++i)
      s.push(r.getPixelForValue(this.getParsed(i)[r.axis], i));
    const a = e.barThickness;
    return {
      min: a || MU(n),
      pixels: s,
      start: r._startPixel,
      end: r._endPixel,
      stackCount: this._getStackCount(),
      scale: r,
      grouped: e.grouped,
      ratio: a ? 1 : e.categoryPercentage * e.barPercentage
    };
  }
  _calculateBarValuePixels(e) {
    const { _cachedMeta: { vScale: n, _stacked: r, index: s }, options: { base: i, minBarLength: o } } = this, a = i || 0, c = this.getParsed(e), l = c._custom, u = ip(l);
    let d = c[n.axis], f = 0, h = r ? this.applyStack(n, c, r) : d, p, m;
    h !== d && (f = h - d, h = d), u && (d = l.barStart, h = l.barEnd - l.barStart, d !== 0 && Mr(d) !== Mr(l.barEnd) && (f = 0), f += d);
    const y = !je(i) && !u ? i : f;
    let b = n.getPixelForValue(y);
    if (this.chart.getDataVisibility(e) ? p = n.getPixelForValue(f + h) : p = b, m = p - b, Math.abs(m) < o) {
      m = OU(m, n, a) * o, d === a && (b -= m / 2);
      const v = n.getPixelForDecimal(0), w = n.getPixelForDecimal(1), x = Math.min(v, w), A = Math.max(v, w);
      b = Math.max(Math.min(b, A), x), p = b + m, r && !u && (c._stacks[n.axis]._visualValues[s] = n.getValueForPixel(p) - n.getValueForPixel(b));
    }
    if (b === n.getPixelForValue(a)) {
      const v = Mr(m) * n.getLineWidthForValue(a) / 2;
      b += v, m -= v;
    }
    return {
      size: m,
      base: b,
      head: p,
      center: p + m / 2
    };
  }
  _calculateBarIndexPixels(e, n) {
    const r = n.scale, s = this.options, i = s.skipNull, o = Ae(s.maxBarThickness, 1 / 0);
    let a, c;
    if (n.grouped) {
      const l = i ? this._getStackCount(e) : n.stackCount, u = s.barThickness === "flex" ? IU(e, n, s, l) : PU(e, n, s, l), d = this._getStackIndex(this.index, this._cachedMeta.stack, i ? e : void 0);
      a = u.start + u.chunk * d + u.chunk / 2, c = Math.min(o, u.chunk * u.ratio);
    } else
      a = r.getPixelForValue(this.getParsed(e)[r.axis], e), c = Math.min(o, n.min * n.ratio);
    return {
      base: a - c / 2,
      head: a + c / 2,
      center: a,
      size: c
    };
  }
  draw() {
    const e = this._cachedMeta, n = e.vScale, r = e.data, s = r.length;
    let i = 0;
    for (; i < s; ++i)
      this.getParsed(i)[n.axis] !== null && !r[i].hidden && r[i].draw(this._ctx);
  }
}
K(Wu, "id", "bar"), K(Wu, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), K(Wu, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class zu extends cr {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(e, n, r, s) {
    const i = super.parsePrimitiveData(e, n, r, s);
    for (let o = 0; o < i.length; o++)
      i[o]._custom = this.resolveDataElementOptions(o + r).radius;
    return i;
  }
  parseArrayData(e, n, r, s) {
    const i = super.parseArrayData(e, n, r, s);
    for (let o = 0; o < i.length; o++) {
      const a = n[r + o];
      i[o]._custom = Ae(a[2], this.resolveDataElementOptions(o + r).radius);
    }
    return i;
  }
  parseObjectData(e, n, r, s) {
    const i = super.parseObjectData(e, n, r, s);
    for (let o = 0; o < i.length; o++) {
      const a = n[r + o];
      i[o]._custom = Ae(a && a.r && +a.r, this.resolveDataElementOptions(o + r).radius);
    }
    return i;
  }
  getMaxOverflow() {
    const e = this._cachedMeta.data;
    let n = 0;
    for (let r = e.length - 1; r >= 0; --r)
      n = Math.max(n, e[r].size(this.resolveDataElementOptions(r)) / 2);
    return n > 0 && n;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, r = this.chart.data.labels || [], { xScale: s, yScale: i } = n, o = this.getParsed(e), a = s.getLabelForValue(o.x), c = i.getLabelForValue(o.y), l = o._custom;
    return {
      label: r[e] || "",
      value: "(" + a + ", " + c + (l ? ", " + l : "") + ")"
    };
  }
  update(e) {
    const n = this._cachedMeta.data;
    this.updateElements(n, 0, n.length, e);
  }
  updateElements(e, n, r, s) {
    const i = s === "reset", { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: c, includeOptions: l } = this._getSharedOptions(n, s), u = o.axis, d = a.axis;
    for (let f = n; f < n + r; f++) {
      const h = e[f], p = !i && this.getParsed(f), m = {}, y = m[u] = i ? o.getPixelForDecimal(0.5) : o.getPixelForValue(p[u]), b = m[d] = i ? a.getBasePixel() : a.getPixelForValue(p[d]);
      m.skip = isNaN(y) || isNaN(b), l && (m.options = c || this.resolveDataElementOptions(f, h.active ? "active" : s), i && (m.options.radius = 0)), this.updateElement(h, f, m, s);
    }
  }
  resolveDataElementOptions(e, n) {
    const r = this.getParsed(e);
    let s = super.resolveDataElementOptions(e, n);
    s.$shared && (s = Object.assign({}, s, {
      $shared: !1
    }));
    const i = s.radius;
    return n !== "active" && (s.radius = 0), s.radius += Ae(r && r._custom, i), s;
  }
}
K(zu, "id", "bubble"), K(zu, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), K(zu, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function BU(t, e, n) {
  let r = 1, s = 1, i = 0, o = 0;
  if (e < ft) {
    const a = t, c = a + e, l = Math.cos(a), u = Math.sin(a), d = Math.cos(c), f = Math.sin(c), h = (w, x, A) => el(w, a, c, !0) ? 1 : Math.max(x, x * n, A, A * n), p = (w, x, A) => el(w, a, c, !0) ? -1 : Math.min(x, x * n, A, A * n), m = h(0, l, d), y = h(It, u, f), b = p(ht, l, d), v = p(ht + It, u, f);
    r = (m - b) / 2, s = (y - v) / 2, i = -(m + b) / 2, o = -(y + v) / 2;
  }
  return {
    ratioX: r,
    ratioY: s,
    offsetX: i,
    offsetY: o
  };
}
class ki extends cr {
  constructor(e, n) {
    super(e, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(e, n) {
    const r = this.getDataset().data, s = this._cachedMeta;
    if (this._parsing === !1)
      s._parsed = r;
    else {
      let i = (c) => +r[c];
      if (Pe(r[e])) {
        const { key: c = "value" } = this._parsing;
        i = (l) => +ri(r[l], c);
      }
      let o, a;
      for (o = e, a = e + n; o < a; ++o)
        s._parsed[o] = i(o);
    }
  }
  _getRotation() {
    return or(this.options.rotation - 90);
  }
  _getCircumference() {
    return or(this.options.circumference);
  }
  _getRotationExtents() {
    let e = ft, n = -ft;
    for (let r = 0; r < this.chart.data.datasets.length; ++r)
      if (this.chart.isDatasetVisible(r) && this.chart.getDatasetMeta(r).type === this._type) {
        const s = this.chart.getDatasetMeta(r).controller, i = s._getRotation(), o = s._getCircumference();
        e = Math.min(e, i), n = Math.max(n, i + o);
      }
    return {
      rotation: e,
      circumference: n - e
    };
  }
  update(e) {
    const n = this.chart, { chartArea: r } = n, s = this._cachedMeta, i = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(i) + this.options.spacing, a = Math.max((Math.min(r.width, r.height) - o) / 2, 0), c = Math.min(J4(this.options.cutout, a), 1), l = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: f, ratioY: h, offsetX: p, offsetY: m } = BU(d, u, c), y = (r.width - o) / f, b = (r.height - o) / h, v = Math.max(Math.min(y, b) / 2, 0), w = B_(this.options.radius, v), x = Math.max(w * c, 0), A = (w - x) / this._getVisibleDatasetWeightTotal();
    this.offsetX = p * w, this.offsetY = m * w, s.total = this.calculateTotal(), this.outerRadius = w - A * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - A * l, 0), this.updateElements(i, 0, i.length, e);
  }
  _circumference(e, n) {
    const r = this.options, s = this._cachedMeta, i = this._getCircumference();
    return n && r.animation.animateRotate || !this.chart.getDataVisibility(e) || s._parsed[e] === null || s.data[e].hidden ? 0 : this.calculateCircumference(s._parsed[e] * i / ft);
  }
  updateElements(e, n, r, s) {
    const i = s === "reset", o = this.chart, a = o.chartArea, l = o.options.animation, u = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, f = i && l.animateScale, h = f ? 0 : this.innerRadius, p = f ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: y } = this._getSharedOptions(n, s);
    let b = this._getRotation(), v;
    for (v = 0; v < n; ++v)
      b += this._circumference(v, i);
    for (v = n; v < n + r; ++v) {
      const w = this._circumference(v, i), x = e[v], A = {
        x: u + this.offsetX,
        y: d + this.offsetY,
        startAngle: b,
        endAngle: b + w,
        circumference: w,
        outerRadius: p,
        innerRadius: h
      };
      y && (A.options = m || this.resolveDataElementOptions(v, x.active ? "active" : s)), b += w, this.updateElement(x, v, A, s);
    }
  }
  calculateTotal() {
    const e = this._cachedMeta, n = e.data;
    let r = 0, s;
    for (s = 0; s < n.length; s++) {
      const i = e._parsed[s];
      i !== null && !isNaN(i) && this.chart.getDataVisibility(s) && !n[s].hidden && (r += Math.abs(i));
    }
    return r;
  }
  calculateCircumference(e) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(e) ? ft * (Math.abs(e) / n) : 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, r = this.chart, s = r.data.labels || [], i = Cl(n._parsed[e], r.options.locale);
    return {
      label: s[e] || "",
      value: i
    };
  }
  getMaxBorderWidth(e) {
    let n = 0;
    const r = this.chart;
    let s, i, o, a, c;
    if (!e) {
      for (s = 0, i = r.data.datasets.length; s < i; ++s)
        if (r.isDatasetVisible(s)) {
          o = r.getDatasetMeta(s), e = o.data, a = o.controller;
          break;
        }
    }
    if (!e)
      return 0;
    for (s = 0, i = e.length; s < i; ++s)
      c = a.resolveDataElementOptions(s), c.borderAlign !== "inner" && (n = Math.max(n, c.borderWidth || 0, c.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(e) {
    let n = 0;
    for (let r = 0, s = e.length; r < s; ++r) {
      const i = this.resolveDataElementOptions(r);
      n = Math.max(n, i.offset || 0, i.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(e) {
    let n = 0;
    for (let r = 0; r < e; ++r)
      this.chart.isDatasetVisible(r) && (n += this._getRingWeight(r));
    return n;
  }
  _getRingWeight(e) {
    return Math.max(Ae(this.chart.data.datasets[e].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
K(ki, "id", "doughnut"), K(ki, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), K(ki, "descriptors", {
  _scriptable: (e) => e !== "spacing",
  _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
}), K(ki, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const n = e.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: r, color: s } } = e.legend.options;
            return n.labels.map((i, o) => {
              const c = e.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: i,
                fillStyle: c.backgroundColor,
                strokeStyle: c.borderColor,
                fontColor: s,
                lineWidth: c.borderWidth,
                pointStyle: r,
                hidden: !e.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(e, n, r) {
        r.chart.toggleDataVisibility(n.index), r.chart.update();
      }
    }
  }
});
class Hu extends cr {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(e) {
    const n = this._cachedMeta, { dataset: r, data: s = [], _dataset: i } = n, o = this.chart._animationsDisabled;
    let { start: a, count: c } = G_(n, s, o);
    this._drawStart = a, this._drawCount = c, K_(n) && (a = 0, c = s.length), r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!i._decimated, r.points = s;
    const l = this.resolveDatasetElementOptions(e);
    this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(r, void 0, {
      animated: !o,
      options: l
    }, e), this.updateElements(s, a, c, e);
  }
  updateElements(e, n, r, s) {
    const i = s === "reset", { iScale: o, vScale: a, _stacked: c, _dataset: l } = this._cachedMeta, { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, s), f = o.axis, h = a.axis, { spanGaps: p, segment: m } = this.options, y = ta(p) ? p : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || i || s === "none", v = n + r, w = e.length;
    let x = n > 0 && this.getParsed(n - 1);
    for (let A = 0; A < w; ++A) {
      const C = e[A], S = b ? C : {};
      if (A < n || A >= v) {
        S.skip = !0;
        continue;
      }
      const _ = this.getParsed(A), T = je(_[h]), k = S[f] = o.getPixelForValue(_[f], A), R = S[h] = i || T ? a.getBasePixel() : a.getPixelForValue(c ? this.applyStack(a, _, c) : _[h], A);
      S.skip = isNaN(k) || isNaN(R) || T, S.stop = A > 0 && Math.abs(_[f] - x[f]) > y, m && (S.parsed = _, S.raw = l.data[A]), d && (S.options = u || this.resolveDataElementOptions(A, C.active ? "active" : s)), b || this.updateElement(C, A, S, s), x = _;
    }
  }
  getMaxOverflow() {
    const e = this._cachedMeta, n = e.dataset, r = n.options && n.options.borderWidth || 0, s = e.data || [];
    if (!s.length)
      return r;
    const i = s[0].size(this.resolveDataElementOptions(0)), o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
    return Math.max(r, i, o) / 2;
  }
  draw() {
    const e = this._cachedMeta;
    e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
  }
}
K(Hu, "id", "line"), K(Hu, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), K(Hu, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class Ac extends cr {
  constructor(e, n) {
    super(e, n), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, r = this.chart, s = r.data.labels || [], i = Cl(n._parsed[e].r, r.options.locale);
    return {
      label: s[e] || "",
      value: i
    };
  }
  parseObjectData(e, n, r, s) {
    return nT.bind(this)(e, n, r, s);
  }
  update(e) {
    const n = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(n, 0, n.length, e);
  }
  getMinMax() {
    const e = this._cachedMeta, n = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return e.data.forEach((r, s) => {
      const i = this.getParsed(s).r;
      !isNaN(i) && this.chart.getDataVisibility(s) && (i < n.min && (n.min = i), i > n.max && (n.max = i));
    }), n;
  }
  _updateRadius() {
    const e = this.chart, n = e.chartArea, r = e.options, s = Math.min(n.right - n.left, n.bottom - n.top), i = Math.max(s / 2, 0), o = Math.max(r.cutoutPercentage ? i / 100 * r.cutoutPercentage : 1, 0), a = (i - o) / e.getVisibleDatasetCount();
    this.outerRadius = i - a * this.index, this.innerRadius = this.outerRadius - a;
  }
  updateElements(e, n, r, s) {
    const i = s === "reset", o = this.chart, c = o.options.animation, l = this._cachedMeta.rScale, u = l.xCenter, d = l.yCenter, f = l.getIndexAngle(0) - 0.5 * ht;
    let h = f, p;
    const m = 360 / this.countVisibleElements();
    for (p = 0; p < n; ++p)
      h += this._computeAngle(p, s, m);
    for (p = n; p < n + r; p++) {
      const y = e[p];
      let b = h, v = h + this._computeAngle(p, s, m), w = o.getDataVisibility(p) ? l.getDistanceFromCenterForValue(this.getParsed(p).r) : 0;
      h = v, i && (c.animateScale && (w = 0), c.animateRotate && (b = v = f));
      const x = {
        x: u,
        y: d,
        innerRadius: 0,
        outerRadius: w,
        startAngle: b,
        endAngle: v,
        options: this.resolveDataElementOptions(p, y.active ? "active" : s)
      };
      this.updateElement(y, p, x, s);
    }
  }
  countVisibleElements() {
    const e = this._cachedMeta;
    let n = 0;
    return e.data.forEach((r, s) => {
      !isNaN(this.getParsed(s).r) && this.chart.getDataVisibility(s) && n++;
    }), n;
  }
  _computeAngle(e, n, r) {
    return this.chart.getDataVisibility(e) ? or(this.resolveDataElementOptions(e, n).angle || r) : 0;
  }
}
K(Ac, "id", "polarArea"), K(Ac, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), K(Ac, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const n = e.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: r, color: s } } = e.legend.options;
            return n.labels.map((i, o) => {
              const c = e.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: i,
                fillStyle: c.backgroundColor,
                strokeStyle: c.borderColor,
                fontColor: s,
                lineWidth: c.borderWidth,
                pointStyle: r,
                hidden: !e.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(e, n, r) {
        r.chart.toggleDataVisibility(n.index), r.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class Pm extends ki {
}
K(Pm, "id", "pie"), K(Pm, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class Yu extends cr {
  getLabelAndValue(e) {
    const n = this._cachedMeta.vScale, r = this.getParsed(e);
    return {
      label: n.getLabels()[e],
      value: "" + n.getLabelForValue(r[n.axis])
    };
  }
  parseObjectData(e, n, r, s) {
    return nT.bind(this)(e, n, r, s);
  }
  update(e) {
    const n = this._cachedMeta, r = n.dataset, s = n.data || [], i = n.iScale.getLabels();
    if (r.points = s, e !== "resize") {
      const o = this.resolveDatasetElementOptions(e);
      this.options.showLine || (o.borderWidth = 0);
      const a = {
        _loop: !0,
        _fullLoop: i.length === s.length,
        options: o
      };
      this.updateElement(r, void 0, a, e);
    }
    this.updateElements(s, 0, s.length, e);
  }
  updateElements(e, n, r, s) {
    const i = this._cachedMeta.rScale, o = s === "reset";
    for (let a = n; a < n + r; a++) {
      const c = e[a], l = this.resolveDataElementOptions(a, c.active ? "active" : s), u = i.getPointPositionForValue(a, this.getParsed(a).r), d = o ? i.xCenter : u.x, f = o ? i.yCenter : u.y, h = {
        x: d,
        y: f,
        angle: u.angle,
        skip: isNaN(d) || isNaN(f),
        options: l
      };
      this.updateElement(c, a, h, s);
    }
  }
}
K(Yu, "id", "radar"), K(Yu, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), K(Yu, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class Gu extends cr {
  getLabelAndValue(e) {
    const n = this._cachedMeta, r = this.chart.data.labels || [], { xScale: s, yScale: i } = n, o = this.getParsed(e), a = s.getLabelForValue(o.x), c = i.getLabelForValue(o.y);
    return {
      label: r[e] || "",
      value: "(" + a + ", " + c + ")"
    };
  }
  update(e) {
    const n = this._cachedMeta, { data: r = [] } = n, s = this.chart._animationsDisabled;
    let { start: i, count: o } = G_(n, r, s);
    if (this._drawStart = i, this._drawCount = o, K_(n) && (i = 0, o = r.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: a, _dataset: c } = n;
      a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!c._decimated, a.points = r;
      const l = this.resolveDatasetElementOptions(e);
      l.segment = this.options.segment, this.updateElement(a, void 0, {
        animated: !s,
        options: l
      }, e);
    } else this.datasetElementType && (delete n.dataset, this.datasetElementType = !1);
    this.updateElements(r, i, o, e);
  }
  addElements() {
    const { showLine: e } = this.options;
    !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(e, n, r, s) {
    const i = s === "reset", { iScale: o, vScale: a, _stacked: c, _dataset: l } = this._cachedMeta, u = this.resolveDataElementOptions(n, s), d = this.getSharedOptions(u), f = this.includeOptions(s, d), h = o.axis, p = a.axis, { spanGaps: m, segment: y } = this.options, b = ta(m) ? m : Number.POSITIVE_INFINITY, v = this.chart._animationsDisabled || i || s === "none";
    let w = n > 0 && this.getParsed(n - 1);
    for (let x = n; x < n + r; ++x) {
      const A = e[x], C = this.getParsed(x), S = v ? A : {}, _ = je(C[p]), T = S[h] = o.getPixelForValue(C[h], x), k = S[p] = i || _ ? a.getBasePixel() : a.getPixelForValue(c ? this.applyStack(a, C, c) : C[p], x);
      S.skip = isNaN(T) || isNaN(k) || _, S.stop = x > 0 && Math.abs(C[h] - w[h]) > b, y && (S.parsed = C, S.raw = l.data[x]), f && (S.options = d || this.resolveDataElementOptions(x, A.active ? "active" : s)), v || this.updateElement(A, x, S, s), w = C;
    }
    this.updateSharedOptions(d, s, u);
  }
  getMaxOverflow() {
    const e = this._cachedMeta, n = e.data || [];
    if (!this.options.showLine) {
      let a = 0;
      for (let c = n.length - 1; c >= 0; --c)
        a = Math.max(a, n[c].size(this.resolveDataElementOptions(c)) / 2);
      return a > 0 && a;
    }
    const r = e.dataset, s = r.options && r.options.borderWidth || 0;
    if (!n.length)
      return s;
    const i = n[0].size(this.resolveDataElementOptions(0)), o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));
    return Math.max(s, i, o) / 2;
  }
}
K(Gu, "id", "scatter"), K(Gu, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), K(Gu, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var FU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: Wu,
  BubbleController: zu,
  DoughnutController: ki,
  LineController: Hu,
  PieController: Pm,
  PolarAreaController: Ac,
  RadarController: Yu,
  ScatterController: Gu
});
function vi() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Ky {
  constructor(e) {
    K(this, "options");
    this.options = e || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(e) {
    Object.assign(Ky.prototype, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return vi();
  }
  parse() {
    return vi();
  }
  format() {
    return vi();
  }
  add() {
    return vi();
  }
  diff() {
    return vi();
  }
  startOf() {
    return vi();
  }
  endOf() {
    return vi();
  }
}
var VU = {
  _date: Ky
};
function UU(t, e, n, r) {
  const { controller: s, data: i, _sorted: o } = t, a = s._cachedMeta.iScale;
  if (a && e === a.axis && e !== "r" && o && i.length) {
    const c = a._reversePixels ? dV : es;
    if (r) {
      if (s._sharedOptions) {
        const l = i[0], u = typeof l.getRange == "function" && l.getRange(e);
        if (u) {
          const d = c(i, e, n - u), f = c(i, e, n + u);
          return {
            lo: d.lo,
            hi: f.hi
          };
        }
      }
    } else return c(i, e, n);
  }
  return {
    lo: 0,
    hi: i.length - 1
  };
}
function _l(t, e, n, r, s) {
  const i = t.getSortedVisibleDatasetMetas(), o = n[e];
  for (let a = 0, c = i.length; a < c; ++a) {
    const { index: l, data: u } = i[a], { lo: d, hi: f } = UU(i[a], e, o, s);
    for (let h = d; h <= f; ++h) {
      const p = u[h];
      p.skip || r(p, l, h);
    }
  }
}
function WU(t) {
  const e = t.indexOf("x") !== -1, n = t.indexOf("y") !== -1;
  return function(r, s) {
    const i = e ? Math.abs(r.x - s.x) : 0, o = n ? Math.abs(r.y - s.y) : 0;
    return Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2));
  };
}
function op(t, e, n, r, s) {
  const i = [];
  return !s && !t.isPointInArea(e) || _l(t, n, e, function(a, c, l) {
    !s && !ts(a, t.chartArea, 0) || a.inRange(e.x, e.y, r) && i.push({
      element: a,
      datasetIndex: c,
      index: l
    });
  }, !0), i;
}
function zU(t, e, n, r) {
  let s = [];
  function i(o, a, c) {
    const { startAngle: l, endAngle: u } = o.getProps([
      "startAngle",
      "endAngle"
    ], r), { angle: d } = U_(o, {
      x: e.x,
      y: e.y
    });
    el(d, l, u) && s.push({
      element: o,
      datasetIndex: a,
      index: c
    });
  }
  return _l(t, n, e, i), s;
}
function HU(t, e, n, r, s, i) {
  let o = [];
  const a = WU(n);
  let c = Number.POSITIVE_INFINITY;
  function l(u, d, f) {
    const h = u.inRange(e.x, e.y, s);
    if (r && !h)
      return;
    const p = u.getCenterPoint(s);
    if (!(!!i || t.isPointInArea(p)) && !h)
      return;
    const y = a(e, p);
    y < c ? (o = [
      {
        element: u,
        datasetIndex: d,
        index: f
      }
    ], c = y) : y === c && o.push({
      element: u,
      datasetIndex: d,
      index: f
    });
  }
  return _l(t, n, e, l), o;
}
function ap(t, e, n, r, s, i) {
  return !i && !t.isPointInArea(e) ? [] : n === "r" && !r ? zU(t, e, n, s) : HU(t, e, n, r, s, i);
}
function iw(t, e, n, r, s) {
  const i = [], o = n === "x" ? "inXRange" : "inYRange";
  let a = !1;
  return _l(t, n, e, (c, l, u) => {
    c[o] && c[o](e[n], s) && (i.push({
      element: c,
      datasetIndex: l,
      index: u
    }), a = a || c.inRange(e.x, e.y, s));
  }), r && !a ? [] : i;
}
var YU = {
  evaluateInteractionItems: _l,
  modes: {
    index(t, e, n, r) {
      const s = Ei(e, t), i = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? op(t, s, i, r, o) : ap(t, s, i, !1, r, o), c = [];
      return a.length ? (t.getSortedVisibleDatasetMetas().forEach((l) => {
        const u = a[0].index, d = l.data[u];
        d && !d.skip && c.push({
          element: d,
          datasetIndex: l.index,
          index: u
        });
      }), c) : [];
    },
    dataset(t, e, n, r) {
      const s = Ei(e, t), i = n.axis || "xy", o = n.includeInvisible || !1;
      let a = n.intersect ? op(t, s, i, r, o) : ap(t, s, i, !1, r, o);
      if (a.length > 0) {
        const c = a[0].datasetIndex, l = t.getDatasetMeta(c).data;
        a = [];
        for (let u = 0; u < l.length; ++u)
          a.push({
            element: l[u],
            datasetIndex: c,
            index: u
          });
      }
      return a;
    },
    point(t, e, n, r) {
      const s = Ei(e, t), i = n.axis || "xy", o = n.includeInvisible || !1;
      return op(t, s, i, r, o);
    },
    nearest(t, e, n, r) {
      const s = Ei(e, t), i = n.axis || "xy", o = n.includeInvisible || !1;
      return ap(t, s, i, n.intersect, r, o);
    },
    x(t, e, n, r) {
      const s = Ei(e, t);
      return iw(t, s, "x", n.intersect, r);
    },
    y(t, e, n, r) {
      const s = Ei(e, t);
      return iw(t, s, "y", n.intersect, r);
    }
  }
};
const fT = [
  "left",
  "top",
  "right",
  "bottom"
];
function Ga(t, e) {
  return t.filter((n) => n.pos === e);
}
function ow(t, e) {
  return t.filter((n) => fT.indexOf(n.pos) === -1 && n.box.axis === e);
}
function Ka(t, e) {
  return t.sort((n, r) => {
    const s = e ? r : n, i = e ? n : r;
    return s.weight === i.weight ? s.index - i.index : s.weight - i.weight;
  });
}
function GU(t) {
  const e = [];
  let n, r, s, i, o, a;
  for (n = 0, r = (t || []).length; n < r; ++n)
    s = t[n], { position: i, options: { stack: o, stackWeight: a = 1 } } = s, e.push({
      index: n,
      box: s,
      pos: i,
      horizontal: s.isHorizontal(),
      weight: s.weight,
      stack: o && i + o,
      stackWeight: a
    });
  return e;
}
function KU(t) {
  const e = {};
  for (const n of t) {
    const { stack: r, pos: s, stackWeight: i } = n;
    if (!r || !fT.includes(s))
      continue;
    const o = e[r] || (e[r] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    o.count++, o.weight += i;
  }
  return e;
}
function $U(t, e) {
  const n = KU(t), { vBoxMaxWidth: r, hBoxMaxHeight: s } = e;
  let i, o, a;
  for (i = 0, o = t.length; i < o; ++i) {
    a = t[i];
    const { fullSize: c } = a.box, l = n[a.stack], u = l && a.stackWeight / l.weight;
    a.horizontal ? (a.width = u ? u * r : c && e.availableWidth, a.height = s) : (a.width = r, a.height = u ? u * s : c && e.availableHeight);
  }
  return n;
}
function ZU(t) {
  const e = GU(t), n = Ka(e.filter((l) => l.box.fullSize), !0), r = Ka(Ga(e, "left"), !0), s = Ka(Ga(e, "right")), i = Ka(Ga(e, "top"), !0), o = Ka(Ga(e, "bottom")), a = ow(e, "x"), c = ow(e, "y");
  return {
    fullSize: n,
    leftAndTop: r.concat(i),
    rightAndBottom: s.concat(c).concat(o).concat(a),
    chartArea: Ga(e, "chartArea"),
    vertical: r.concat(s).concat(c),
    horizontal: i.concat(o).concat(a)
  };
}
function aw(t, e, n, r) {
  return Math.max(t[n], e[n]) + Math.max(t[r], e[r]);
}
function hT(t, e) {
  t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);
}
function QU(t, e, n, r) {
  const { pos: s, box: i } = n, o = t.maxPadding;
  if (!Pe(s)) {
    n.size && (t[s] -= n.size);
    const d = r[n.stack] || {
      size: 0,
      count: 1
    };
    d.size = Math.max(d.size, n.horizontal ? i.height : i.width), n.size = d.size / d.count, t[s] += n.size;
  }
  i.getPadding && hT(o, i.getPadding());
  const a = Math.max(0, e.outerWidth - aw(o, t, "left", "right")), c = Math.max(0, e.outerHeight - aw(o, t, "top", "bottom")), l = a !== t.w, u = c !== t.h;
  return t.w = a, t.h = c, n.horizontal ? {
    same: l,
    other: u
  } : {
    same: u,
    other: l
  };
}
function XU(t) {
  const e = t.maxPadding;
  function n(r) {
    const s = Math.max(e[r] - t[r], 0);
    return t[r] += s, s;
  }
  t.y += n("top"), t.x += n("left"), n("right"), n("bottom");
}
function JU(t, e) {
  const n = e.maxPadding;
  function r(s) {
    const i = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return s.forEach((o) => {
      i[o] = Math.max(e[o], n[o]);
    }), i;
  }
  return r(t ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function cc(t, e, n, r) {
  const s = [];
  let i, o, a, c, l, u;
  for (i = 0, o = t.length, l = 0; i < o; ++i) {
    a = t[i], c = a.box, c.update(a.width || e.w, a.height || e.h, JU(a.horizontal, e));
    const { same: d, other: f } = QU(e, n, a, r);
    l |= d && s.length, u = u || f, c.fullSize || s.push(a);
  }
  return l && cc(s, e, n, r) || u;
}
function eu(t, e, n, r, s) {
  t.top = n, t.left = e, t.right = e + r, t.bottom = n + s, t.width = r, t.height = s;
}
function cw(t, e, n, r) {
  const s = n.padding;
  let { x: i, y: o } = e;
  for (const a of t) {
    const c = a.box, l = r[a.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    }, u = a.stackWeight / l.weight || 1;
    if (a.horizontal) {
      const d = e.w * u, f = l.size || c.height;
      Jc(l.start) && (o = l.start), c.fullSize ? eu(c, s.left, o, n.outerWidth - s.right - s.left, f) : eu(c, e.left + l.placed, o, d, f), l.start = o, l.placed += d, o = c.bottom;
    } else {
      const d = e.h * u, f = l.size || c.width;
      Jc(l.start) && (i = l.start), c.fullSize ? eu(c, i, s.top, f, n.outerHeight - s.bottom - s.top) : eu(c, i, e.top + l.placed, f, d), l.start = i, l.placed += d, i = c.right;
    }
  }
  e.x = i, e.y = o;
}
var an = {
  addBox(t, e) {
    t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            e.draw(n);
          }
        }
      ];
    }, t.boxes.push(e);
  },
  removeBox(t, e) {
    const n = t.boxes ? t.boxes.indexOf(e) : -1;
    n !== -1 && t.boxes.splice(n, 1);
  },
  configure(t, e, n) {
    e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight;
  },
  update(t, e, n, r) {
    if (!t)
      return;
    const s = ln(t.options.layout.padding), i = Math.max(e - s.width, 0), o = Math.max(n - s.height, 0), a = ZU(t.boxes), c = a.vertical, l = a.horizontal;
    Xe(t.boxes, (m) => {
      typeof m.beforeLayout == "function" && m.beforeLayout();
    });
    const u = c.reduce((m, y) => y.box.options && y.box.options.display === !1 ? m : m + 1, 0) || 1, d = Object.freeze({
      outerWidth: e,
      outerHeight: n,
      padding: s,
      availableWidth: i,
      availableHeight: o,
      vBoxMaxWidth: i / 2 / u,
      hBoxMaxHeight: o / 2
    }), f = Object.assign({}, s);
    hT(f, ln(r));
    const h = Object.assign({
      maxPadding: f,
      w: i,
      h: o,
      x: s.left,
      y: s.top
    }, s), p = $U(c.concat(l), d);
    cc(a.fullSize, h, d, p), cc(c, h, d, p), cc(l, h, d, p) && cc(c, h, d, p), XU(h), cw(a.leftAndTop, h, d, p), h.x += h.w, h.y += h.h, cw(a.rightAndBottom, h, d, p), t.chartArea = {
      left: h.left,
      top: h.top,
      right: h.left + h.w,
      bottom: h.top + h.h,
      height: h.h,
      width: h.w
    }, Xe(a.chartArea, (m) => {
      const y = m.box;
      Object.assign(y, t.chartArea), y.update(h.w, h.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class pT {
  acquireContext(e, n) {
  }
  releaseContext(e) {
    return !1;
  }
  addEventListener(e, n, r) {
  }
  removeEventListener(e, n, r) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(e, n, r, s) {
    return n = Math.max(0, n || e.width), r = r || e.height, {
      width: n,
      height: Math.max(0, s ? Math.floor(n / s) : r)
    };
  }
  isAttached(e) {
    return !0;
  }
  updateConfig(e) {
  }
}
class eW extends pT {
  acquireContext(e) {
    return e && e.getContext && e.getContext("2d") || null;
  }
  updateConfig(e) {
    e.options.animation = !1;
  }
}
const Ku = "$chartjs", tW = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, lw = (t) => t === null || t === "";
function nW(t, e) {
  const n = t.style, r = t.getAttribute("height"), s = t.getAttribute("width");
  if (t[Ku] = {
    initial: {
      height: r,
      width: s,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", lw(s)) {
    const i = Hx(t, "width");
    i !== void 0 && (t.width = i);
  }
  if (lw(r))
    if (t.style.height === "")
      t.height = t.width / (e || 2);
    else {
      const i = Hx(t, "height");
      i !== void 0 && (t.height = i);
    }
  return t;
}
const mT = sU ? {
  passive: !0
} : !1;
function rW(t, e, n) {
  t && t.addEventListener(e, n, mT);
}
function sW(t, e, n) {
  t && t.canvas && t.canvas.removeEventListener(e, n, mT);
}
function iW(t, e) {
  const n = tW[t.type] || t.type, { x: r, y: s } = Ei(t, e);
  return {
    type: n,
    chart: e,
    native: t,
    x: r !== void 0 ? r : null,
    y: s !== void 0 ? s : null
  };
}
function Ud(t, e) {
  for (const n of t)
    if (n === e || n.contains(e))
      return !0;
}
function oW(t, e, n) {
  const r = t.canvas, s = new MutationObserver((i) => {
    let o = !1;
    for (const a of i)
      o = o || Ud(a.addedNodes, r), o = o && !Ud(a.removedNodes, r);
    o && n();
  });
  return s.observe(document, {
    childList: !0,
    subtree: !0
  }), s;
}
function aW(t, e, n) {
  const r = t.canvas, s = new MutationObserver((i) => {
    let o = !1;
    for (const a of i)
      o = o || Ud(a.removedNodes, r), o = o && !Ud(a.addedNodes, r);
    o && n();
  });
  return s.observe(document, {
    childList: !0,
    subtree: !0
  }), s;
}
const nl = /* @__PURE__ */ new Map();
let uw = 0;
function gT() {
  const t = window.devicePixelRatio;
  t !== uw && (uw = t, nl.forEach((e, n) => {
    n.currentDevicePixelRatio !== t && e();
  }));
}
function cW(t, e) {
  nl.size || window.addEventListener("resize", gT), nl.set(t, e);
}
function lW(t) {
  nl.delete(t), nl.size || window.removeEventListener("resize", gT);
}
function uW(t, e, n) {
  const r = t.canvas, s = r && Gy(r);
  if (!s)
    return;
  const i = Y_((a, c) => {
    const l = s.clientWidth;
    n(a, c), l < s.clientWidth && n();
  }, window), o = new ResizeObserver((a) => {
    const c = a[0], l = c.contentRect.width, u = c.contentRect.height;
    l === 0 && u === 0 || i(l, u);
  });
  return o.observe(s), cW(t, i), o;
}
function cp(t, e, n) {
  n && n.disconnect(), e === "resize" && lW(t);
}
function dW(t, e, n) {
  const r = t.canvas, s = Y_((i) => {
    t.ctx !== null && n(iW(i, t));
  }, t);
  return rW(r, e, s), s;
}
class fW extends pT {
  acquireContext(e, n) {
    const r = e && e.getContext && e.getContext("2d");
    return r && r.canvas === e ? (nW(e, n), r) : null;
  }
  releaseContext(e) {
    const n = e.canvas;
    if (!n[Ku])
      return !1;
    const r = n[Ku].initial;
    [
      "height",
      "width"
    ].forEach((i) => {
      const o = r[i];
      je(o) ? n.removeAttribute(i) : n.setAttribute(i, o);
    });
    const s = r.style || {};
    return Object.keys(s).forEach((i) => {
      n.style[i] = s[i];
    }), n.width = n.width, delete n[Ku], !0;
  }
  addEventListener(e, n, r) {
    this.removeEventListener(e, n);
    const s = e.$proxies || (e.$proxies = {}), o = {
      attach: oW,
      detach: aW,
      resize: uW
    }[n] || dW;
    s[n] = o(e, n, r);
  }
  removeEventListener(e, n) {
    const r = e.$proxies || (e.$proxies = {}), s = r[n];
    if (!s)
      return;
    ({
      attach: cp,
      detach: cp,
      resize: cp
    }[n] || sW)(e, n, s), r[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(e, n, r, s) {
    return rU(e, n, r, s);
  }
  isAttached(e) {
    const n = e && Gy(e);
    return !!(n && n.isConnected);
  }
}
function hW(t) {
  return !Yy() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? eW : fW;
}
var Iu;
let ws = (Iu = class {
  constructor() {
    K(this, "x");
    K(this, "y");
    K(this, "active", !1);
    K(this, "options");
    K(this, "$animations");
  }
  tooltipPosition(e) {
    const { x: n, y: r } = this.getProps([
      "x",
      "y"
    ], e);
    return {
      x: n,
      y: r
    };
  }
  hasValue() {
    return ta(this.x) && ta(this.y);
  }
  getProps(e, n) {
    const r = this.$animations;
    if (!n || !r)
      return this;
    const s = {};
    return e.forEach((i) => {
      s[i] = r[i] && r[i].active() ? r[i]._to : this[i];
    }), s;
  }
}, K(Iu, "defaults", {}), K(Iu, "defaultRoutes"), Iu);
function pW(t, e) {
  const n = t.options.ticks, r = mW(t), s = Math.min(n.maxTicksLimit || r, r), i = n.major.enabled ? yW(e) : [], o = i.length, a = i[0], c = i[o - 1], l = [];
  if (o > s)
    return bW(e, l, i, o / s), l;
  const u = gW(i, e, s);
  if (o > 0) {
    let d, f;
    const h = o > 1 ? Math.round((c - a) / (o - 1)) : null;
    for (tu(e, l, u, je(h) ? 0 : a - h, a), d = 0, f = o - 1; d < f; d++)
      tu(e, l, u, i[d], i[d + 1]);
    return tu(e, l, u, c, je(h) ? e.length : c + h), l;
  }
  return tu(e, l, u), l;
}
function mW(t) {
  const e = t.options.offset, n = t._tickSize(), r = t._length / n + (e ? 0 : 1), s = t._maxLength / n;
  return Math.floor(Math.min(r, s));
}
function gW(t, e, n) {
  const r = vW(t), s = e.length / n;
  if (!r)
    return Math.max(s, 1);
  const i = aV(r);
  for (let o = 0, a = i.length - 1; o < a; o++) {
    const c = i[o];
    if (c > s)
      return c;
  }
  return Math.max(s, 1);
}
function yW(t) {
  const e = [];
  let n, r;
  for (n = 0, r = t.length; n < r; n++)
    t[n].major && e.push(n);
  return e;
}
function bW(t, e, n, r) {
  let s = 0, i = n[0], o;
  for (r = Math.ceil(r), o = 0; o < t.length; o++)
    o === i && (e.push(t[o]), s++, i = n[s * r]);
}
function tu(t, e, n, r, s) {
  const i = Ae(r, 0), o = Math.min(Ae(s, t.length), t.length);
  let a = 0, c, l, u;
  for (n = Math.ceil(n), s && (c = s - r, n = c / Math.floor(c / n)), u = i; u < 0; )
    a++, u = Math.round(i + a * n);
  for (l = Math.max(i, 0); l < o; l++)
    l === u && (e.push(t[l]), a++, u = Math.round(i + a * n));
}
function vW(t) {
  const e = t.length;
  let n, r;
  if (e < 2)
    return !1;
  for (r = t[0], n = 1; n < e; ++n)
    if (t[n] - t[n - 1] !== r)
      return !1;
  return r;
}
const xW = (t) => t === "left" ? "right" : t === "right" ? "left" : t, dw = (t, e, n) => e === "top" || e === "left" ? t[e] + n : t[e] - n, fw = (t, e) => Math.min(e || t, t);
function hw(t, e) {
  const n = [], r = t.length / e, s = t.length;
  let i = 0;
  for (; i < s; i += r)
    n.push(t[Math.floor(i)]);
  return n;
}
function wW(t, e, n) {
  const r = t.ticks.length, s = Math.min(e, r - 1), i = t._startPixel, o = t._endPixel, a = 1e-6;
  let c = t.getPixelForTick(s), l;
  if (!(n && (r === 1 ? l = Math.max(c - i, o - c) : e === 0 ? l = (t.getPixelForTick(1) - c) / 2 : l = (c - t.getPixelForTick(s - 1)) / 2, c += s < e ? l : -l, c < i - a || c > o + a)))
    return c;
}
function AW(t, e) {
  Xe(t, (n) => {
    const r = n.gc, s = r.length / 2;
    let i;
    if (s > e) {
      for (i = 0; i < s; ++i)
        delete n.data[r[i]];
      r.splice(0, s);
    }
  });
}
function $a(t) {
  return t.drawTicks ? t.tickLength : 0;
}
function pw(t, e) {
  if (!t.display)
    return 0;
  const n = Ft(t.font, e), r = ln(t.padding);
  return (mt(t.text) ? t.text.length : 1) * n.lineHeight + r.height;
}
function SW(t, e) {
  return ui(t, {
    scale: e,
    type: "scale"
  });
}
function EW(t, e, n) {
  return ui(t, {
    tick: n,
    index: e,
    type: "tick"
  });
}
function CW(t, e, n) {
  let r = Fy(t);
  return (n && e !== "right" || !n && e === "right") && (r = xW(r)), r;
}
function _W(t, e, n, r) {
  const { top: s, left: i, bottom: o, right: a, chart: c } = t, { chartArea: l, scales: u } = c;
  let d = 0, f, h, p;
  const m = o - s, y = a - i;
  if (t.isHorizontal()) {
    if (h = rn(r, i, a), Pe(n)) {
      const b = Object.keys(n)[0], v = n[b];
      p = u[b].getPixelForValue(v) + m - e;
    } else n === "center" ? p = (l.bottom + l.top) / 2 + m - e : p = dw(t, n, e);
    f = a - i;
  } else {
    if (Pe(n)) {
      const b = Object.keys(n)[0], v = n[b];
      h = u[b].getPixelForValue(v) - y + e;
    } else n === "center" ? h = (l.left + l.right) / 2 - y + e : h = dw(t, n, e);
    p = rn(r, o, s), d = n === "left" ? -It : It;
  }
  return {
    titleX: h,
    titleY: p,
    maxWidth: f,
    rotation: d
  };
}
class no extends ws {
  constructor(e) {
    super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(e) {
    this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
  }
  parse(e, n) {
    return e;
  }
  getUserBounds() {
    let { _userMin: e, _userMax: n, _suggestedMin: r, _suggestedMax: s } = this;
    return e = On(e, Number.POSITIVE_INFINITY), n = On(n, Number.NEGATIVE_INFINITY), r = On(r, Number.POSITIVE_INFINITY), s = On(s, Number.NEGATIVE_INFINITY), {
      min: On(e, r),
      max: On(n, s),
      minDefined: Ct(e),
      maxDefined: Ct(n)
    };
  }
  getMinMax(e) {
    let { min: n, max: r, minDefined: s, maxDefined: i } = this.getUserBounds(), o;
    if (s && i)
      return {
        min: n,
        max: r
      };
    const a = this.getMatchingVisibleMetas();
    for (let c = 0, l = a.length; c < l; ++c)
      o = a[c].controller.getMinMax(this, e), s || (n = Math.min(n, o.min)), i || (r = Math.max(r, o.max));
    return n = i && n > r ? r : n, r = s && n > r ? n : r, {
      min: On(n, On(r, n)),
      max: On(r, On(n, r))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const e = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    ut(this.options.beforeUpdate, [
      this
    ]);
  }
  update(e, n, r) {
    const { beginAtZero: s, grace: i, ticks: o } = this.options, a = o.sampleSize;
    this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = r = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = qV(this, i, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const c = a < this.ticks.length;
    this._convertTicksToLabels(c ? hw(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = pW(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), c && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let e = this.options.reverse, n, r;
    this.isHorizontal() ? (n = this.left, r = this.right) : (n = this.top, r = this.bottom, e = !e), this._startPixel = n, this._endPixel = r, this._reversePixels = e, this._length = r - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    ut(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    ut(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    ut(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(e) {
    this.chart.notifyPlugins(e, this.getContext()), ut(this.options[e], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    ut(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(e) {
    const n = this.options.ticks;
    let r, s, i;
    for (r = 0, s = e.length; r < s; r++)
      i = e[r], i.label = ut(n.callback, [
        i.value,
        r,
        e
      ], this);
  }
  afterTickToLabelConversion() {
    ut(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    ut(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const e = this.options, n = e.ticks, r = fw(this.ticks.length, e.ticks.maxTicksLimit), s = n.minRotation || 0, i = n.maxRotation;
    let o = s, a, c, l;
    if (!this._isVisible() || !n.display || s >= i || r <= 1 || !this.isHorizontal()) {
      this.labelRotation = s;
      return;
    }
    const u = this._getLabelSizes(), d = u.widest.width, f = u.highest.height, h = Yt(this.chart.width - d, 0, this.maxWidth);
    a = e.offset ? this.maxWidth / r : h / (r - 1), d + 6 > a && (a = h / (r - (e.offset ? 0.5 : 1)), c = this.maxHeight - $a(e.grid) - n.padding - pw(e.title, this.chart.options.font), l = Math.sqrt(d * d + f * f), o = jy(Math.min(Math.asin(Yt((u.highest.height + 6) / a, -1, 1)), Math.asin(Yt(c / l, -1, 1)) - Math.asin(Yt(f / l, -1, 1)))), o = Math.max(s, Math.min(i, o))), this.labelRotation = o;
  }
  afterCalculateLabelRotation() {
    ut(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    ut(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const e = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: r, title: s, grid: i } } = this, o = this._isVisible(), a = this.isHorizontal();
    if (o) {
      const c = pw(s, n.options.font);
      if (a ? (e.width = this.maxWidth, e.height = $a(i) + c) : (e.height = this.maxHeight, e.width = $a(i) + c), r.display && this.ticks.length) {
        const { first: l, last: u, widest: d, highest: f } = this._getLabelSizes(), h = r.padding * 2, p = or(this.labelRotation), m = Math.cos(p), y = Math.sin(p);
        if (a) {
          const b = r.mirror ? 0 : y * d.width + m * f.height;
          e.height = Math.min(this.maxHeight, e.height + b + h);
        } else {
          const b = r.mirror ? 0 : m * d.width + y * f.height;
          e.width = Math.min(this.maxWidth, e.width + b + h);
        }
        this._calculatePadding(l, u, y, m);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(e, n, r, s) {
    const { ticks: { align: i, padding: o }, position: a } = this.options, c = this.labelRotation !== 0, l = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let f = 0, h = 0;
      c ? l ? (f = s * e.width, h = r * n.height) : (f = r * e.height, h = s * n.width) : i === "start" ? h = n.width : i === "end" ? f = e.width : i !== "inner" && (f = e.width / 2, h = n.width / 2), this.paddingLeft = Math.max((f - u + o) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h - d + o) * this.width / (this.width - d), 0);
    } else {
      let u = n.height / 2, d = e.height / 2;
      i === "start" ? (u = 0, d = e.height) : i === "end" && (u = n.height, d = 0), this.paddingTop = u + o, this.paddingBottom = d + o;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    ut(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: e, position: n } = this.options;
    return n === "top" || n === "bottom" || e === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(e) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(e);
    let n, r;
    for (n = 0, r = e.length; n < r; n++)
      je(e[n].label) && (e.splice(n, 1), r--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let e = this._labelSizes;
    if (!e) {
      const n = this.options.ticks.sampleSize;
      let r = this.ticks;
      n < r.length && (r = hw(r, n)), this._labelSizes = e = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit);
    }
    return e;
  }
  _computeLabelSizes(e, n, r) {
    const { ctx: s, _longestTextCache: i } = this, o = [], a = [], c = Math.floor(n / fw(n, r));
    let l = 0, u = 0, d, f, h, p, m, y, b, v, w, x, A;
    for (d = 0; d < n; d += c) {
      if (p = e[d].label, m = this._resolveTickFontOptions(d), s.font = y = m.string, b = i[y] = i[y] || {
        data: {},
        gc: []
      }, v = m.lineHeight, w = x = 0, !je(p) && !mt(p))
        w = Fd(s, b.data, b.gc, w, p), x = v;
      else if (mt(p))
        for (f = 0, h = p.length; f < h; ++f)
          A = p[f], !je(A) && !mt(A) && (w = Fd(s, b.data, b.gc, w, A), x += v);
      o.push(w), a.push(x), l = Math.max(w, l), u = Math.max(x, u);
    }
    AW(i, n);
    const C = o.indexOf(l), S = a.indexOf(u), _ = (T) => ({
      width: o[T] || 0,
      height: a[T] || 0
    });
    return {
      first: _(0),
      last: _(n - 1),
      widest: _(C),
      highest: _(S),
      widths: o,
      heights: a
    };
  }
  getLabelForValue(e) {
    return e;
  }
  getPixelForValue(e, n) {
    return NaN;
  }
  getValueForPixel(e) {
  }
  getPixelForTick(e) {
    const n = this.ticks;
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value);
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e);
    const n = this._startPixel + e * this._length;
    return uV(this._alignToPixels ? bi(this.chart, n, 0) : n);
  }
  getDecimalForPixel(e) {
    const n = (e - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: e, max: n } = this;
    return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0;
  }
  getContext(e) {
    const n = this.ticks || [];
    if (e >= 0 && e < n.length) {
      const r = n[e];
      return r.$context || (r.$context = EW(this.getContext(), e, r));
    }
    return this.$context || (this.$context = SW(this.chart.getContext(), this));
  }
  _tickSize() {
    const e = this.options.ticks, n = or(this.labelRotation), r = Math.abs(Math.cos(n)), s = Math.abs(Math.sin(n)), i = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = i ? i.widest.width + o : 0, c = i ? i.highest.height + o : 0;
    return this.isHorizontal() ? c * r > a * s ? a / r : c / s : c * s < a * r ? c / r : a / s;
  }
  _isVisible() {
    const e = this.options.display;
    return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(e) {
    const n = this.axis, r = this.chart, s = this.options, { grid: i, position: o, border: a } = s, c = i.offset, l = this.isHorizontal(), d = this.ticks.length + (c ? 1 : 0), f = $a(i), h = [], p = a.setContext(this.getContext()), m = p.display ? p.width : 0, y = m / 2, b = function(q) {
      return bi(r, q, m);
    };
    let v, w, x, A, C, S, _, T, k, R, P, M;
    if (o === "top")
      v = b(this.bottom), S = this.bottom - f, T = v - y, R = b(e.top) + y, M = e.bottom;
    else if (o === "bottom")
      v = b(this.top), R = e.top, M = b(e.bottom) - y, S = v + y, T = this.top + f;
    else if (o === "left")
      v = b(this.right), C = this.right - f, _ = v - y, k = b(e.left) + y, P = e.right;
    else if (o === "right")
      v = b(this.left), k = e.left, P = b(e.right) - y, C = v + y, _ = this.left + f;
    else if (n === "x") {
      if (o === "center")
        v = b((e.top + e.bottom) / 2 + 0.5);
      else if (Pe(o)) {
        const q = Object.keys(o)[0], L = o[q];
        v = b(this.chart.scales[q].getPixelForValue(L));
      }
      R = e.top, M = e.bottom, S = v + y, T = S + f;
    } else if (n === "y") {
      if (o === "center")
        v = b((e.left + e.right) / 2);
      else if (Pe(o)) {
        const q = Object.keys(o)[0], L = o[q];
        v = b(this.chart.scales[q].getPixelForValue(L));
      }
      C = v - y, _ = C - f, k = e.left, P = e.right;
    }
    const D = Ae(s.ticks.maxTicksLimit, d), O = Math.max(1, Math.ceil(d / D));
    for (w = 0; w < d; w += O) {
      const q = this.getContext(w), L = i.setContext(q), N = a.setContext(q), j = L.lineWidth, V = L.color, Z = N.dash || [], G = N.dashOffset, $ = L.tickWidth, fe = L.tickColor, he = L.tickBorderDash || [], be = L.tickBorderDashOffset;
      x = wW(this, w, c), x !== void 0 && (A = bi(r, x, j), l ? C = _ = k = P = A : S = T = R = M = A, h.push({
        tx1: C,
        ty1: S,
        tx2: _,
        ty2: T,
        x1: k,
        y1: R,
        x2: P,
        y2: M,
        width: j,
        color: V,
        borderDash: Z,
        borderDashOffset: G,
        tickWidth: $,
        tickColor: fe,
        tickBorderDash: he,
        tickBorderDashOffset: be
      }));
    }
    return this._ticksLength = d, this._borderValue = v, h;
  }
  _computeLabelItems(e) {
    const n = this.axis, r = this.options, { position: s, ticks: i } = r, o = this.isHorizontal(), a = this.ticks, { align: c, crossAlign: l, padding: u, mirror: d } = i, f = $a(r.grid), h = f + u, p = d ? -u : h, m = -or(this.labelRotation), y = [];
    let b, v, w, x, A, C, S, _, T, k, R, P, M = "middle";
    if (s === "top")
      C = this.bottom - p, S = this._getXAxisLabelAlignment();
    else if (s === "bottom")
      C = this.top + p, S = this._getXAxisLabelAlignment();
    else if (s === "left") {
      const O = this._getYAxisLabelAlignment(f);
      S = O.textAlign, A = O.x;
    } else if (s === "right") {
      const O = this._getYAxisLabelAlignment(f);
      S = O.textAlign, A = O.x;
    } else if (n === "x") {
      if (s === "center")
        C = (e.top + e.bottom) / 2 + h;
      else if (Pe(s)) {
        const O = Object.keys(s)[0], q = s[O];
        C = this.chart.scales[O].getPixelForValue(q) + h;
      }
      S = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (s === "center")
        A = (e.left + e.right) / 2 - h;
      else if (Pe(s)) {
        const O = Object.keys(s)[0], q = s[O];
        A = this.chart.scales[O].getPixelForValue(q);
      }
      S = this._getYAxisLabelAlignment(f).textAlign;
    }
    n === "y" && (c === "start" ? M = "top" : c === "end" && (M = "bottom"));
    const D = this._getLabelSizes();
    for (b = 0, v = a.length; b < v; ++b) {
      w = a[b], x = w.label;
      const O = i.setContext(this.getContext(b));
      _ = this.getPixelForTick(b) + i.labelOffset, T = this._resolveTickFontOptions(b), k = T.lineHeight, R = mt(x) ? x.length : 1;
      const q = R / 2, L = O.color, N = O.textStrokeColor, j = O.textStrokeWidth;
      let V = S;
      o ? (A = _, S === "inner" && (b === v - 1 ? V = this.options.reverse ? "left" : "right" : b === 0 ? V = this.options.reverse ? "right" : "left" : V = "center"), s === "top" ? l === "near" || m !== 0 ? P = -R * k + k / 2 : l === "center" ? P = -D.highest.height / 2 - q * k + k : P = -D.highest.height + k / 2 : l === "near" || m !== 0 ? P = k / 2 : l === "center" ? P = D.highest.height / 2 - q * k : P = D.highest.height - R * k, d && (P *= -1), m !== 0 && !O.showLabelBackdrop && (A += k / 2 * Math.sin(m))) : (C = _, P = (1 - R) * k / 2);
      let Z;
      if (O.showLabelBackdrop) {
        const G = ln(O.backdropPadding), $ = D.heights[b], fe = D.widths[b];
        let he = P - G.top, be = 0 - G.left;
        switch (M) {
          case "middle":
            he -= $ / 2;
            break;
          case "bottom":
            he -= $;
            break;
        }
        switch (S) {
          case "center":
            be -= fe / 2;
            break;
          case "right":
            be -= fe;
            break;
          case "inner":
            b === v - 1 ? be -= fe : b > 0 && (be -= fe / 2);
            break;
        }
        Z = {
          left: be,
          top: he,
          width: fe + G.width,
          height: $ + G.height,
          color: O.backdropColor
        };
      }
      y.push({
        label: x,
        font: T,
        textOffset: P,
        options: {
          rotation: m,
          color: L,
          strokeColor: N,
          strokeWidth: j,
          textAlign: V,
          textBaseline: M,
          translation: [
            A,
            C
          ],
          backdrop: Z
        }
      });
    }
    return y;
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: n } = this.options;
    if (-or(this.labelRotation))
      return e === "top" ? "left" : "right";
    let s = "center";
    return n.align === "start" ? s = "left" : n.align === "end" ? s = "right" : n.align === "inner" && (s = "inner"), s;
  }
  _getYAxisLabelAlignment(e) {
    const { position: n, ticks: { crossAlign: r, mirror: s, padding: i } } = this.options, o = this._getLabelSizes(), a = e + i, c = o.widest.width;
    let l, u;
    return n === "left" ? s ? (u = this.right + i, r === "near" ? l = "left" : r === "center" ? (l = "center", u += c / 2) : (l = "right", u += c)) : (u = this.right - a, r === "near" ? l = "right" : r === "center" ? (l = "center", u -= c / 2) : (l = "left", u = this.left)) : n === "right" ? s ? (u = this.left + i, r === "near" ? l = "right" : r === "center" ? (l = "center", u -= c / 2) : (l = "left", u -= c)) : (u = this.left + a, r === "near" ? l = "left" : r === "center" ? (l = "center", u += c / 2) : (l = "right", u = this.right)) : l = "right", {
      textAlign: l,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const e = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      };
  }
  drawBackground() {
    const { ctx: e, options: { backgroundColor: n }, left: r, top: s, width: i, height: o } = this;
    n && (e.save(), e.fillStyle = n, e.fillRect(r, s, i, o), e.restore());
  }
  getLineWidthForValue(e) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const s = this.ticks.findIndex((i) => i.value === e);
    return s >= 0 ? n.setContext(this.getContext(s)).lineWidth : 0;
  }
  drawGrid(e) {
    const n = this.options.grid, r = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
    let i, o;
    const a = (c, l, u) => {
      !u.width || !u.color || (r.save(), r.lineWidth = u.width, r.strokeStyle = u.color, r.setLineDash(u.borderDash || []), r.lineDashOffset = u.borderDashOffset, r.beginPath(), r.moveTo(c.x, c.y), r.lineTo(l.x, l.y), r.stroke(), r.restore());
    };
    if (n.display)
      for (i = 0, o = s.length; i < o; ++i) {
        const c = s[i];
        n.drawOnChartArea && a({
          x: c.x1,
          y: c.y1
        }, {
          x: c.x2,
          y: c.y2
        }, c), n.drawTicks && a({
          x: c.tx1,
          y: c.ty1
        }, {
          x: c.tx2,
          y: c.ty2
        }, {
          color: c.tickColor,
          width: c.tickWidth,
          borderDash: c.tickBorderDash,
          borderDashOffset: c.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: e, ctx: n, options: { border: r, grid: s } } = this, i = r.setContext(this.getContext()), o = r.display ? i.width : 0;
    if (!o)
      return;
    const a = s.setContext(this.getContext(0)).lineWidth, c = this._borderValue;
    let l, u, d, f;
    this.isHorizontal() ? (l = bi(e, this.left, o) - o / 2, u = bi(e, this.right, a) + a / 2, d = f = c) : (d = bi(e, this.top, o) - o / 2, f = bi(e, this.bottom, a) + a / 2, l = u = c), n.save(), n.lineWidth = i.width, n.strokeStyle = i.color, n.beginPath(), n.moveTo(l, d), n.lineTo(u, f), n.stroke(), n.restore();
  }
  drawLabels(e) {
    if (!this.options.ticks.display)
      return;
    const r = this.ctx, s = this._computeLabelArea();
    s && Ff(r, s);
    const i = this.getLabelItems(e);
    for (const o of i) {
      const a = o.options, c = o.font, l = o.label, u = o.textOffset;
      Ki(r, l, 0, u, c, a);
    }
    s && Vf(r);
  }
  drawTitle() {
    const { ctx: e, options: { position: n, title: r, reverse: s } } = this;
    if (!r.display)
      return;
    const i = Ft(r.font), o = ln(r.padding), a = r.align;
    let c = i.lineHeight / 2;
    n === "bottom" || n === "center" || Pe(n) ? (c += o.bottom, mt(r.text) && (c += i.lineHeight * (r.text.length - 1))) : c += o.top;
    const { titleX: l, titleY: u, maxWidth: d, rotation: f } = _W(this, c, n, a);
    Ki(e, r.text, 0, 0, i, {
      color: r.color,
      maxWidth: d,
      rotation: f,
      textAlign: CW(a, n, s),
      textBaseline: "middle",
      translation: [
        l,
        u
      ]
    });
  }
  draw(e) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
  }
  _layers() {
    const e = this.options, n = e.ticks && e.ticks.z || 0, r = Ae(e.grid && e.grid.z, -1), s = Ae(e.border && e.border.z, 0);
    return !this._isVisible() || this.draw !== no.prototype.draw ? [
      {
        z: n,
        draw: (i) => {
          this.draw(i);
        }
      }
    ] : [
      {
        z: r,
        draw: (i) => {
          this.drawBackground(), this.drawGrid(i), this.drawTitle();
        }
      },
      {
        z: s,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (i) => {
          this.drawLabels(i);
        }
      }
    ];
  }
  getMatchingVisibleMetas(e) {
    const n = this.chart.getSortedVisibleDatasetMetas(), r = this.axis + "AxisID", s = [];
    let i, o;
    for (i = 0, o = n.length; i < o; ++i) {
      const a = n[i];
      a[r] === this.id && (!e || a.type === e) && s.push(a);
    }
    return s;
  }
  _resolveTickFontOptions(e) {
    const n = this.options.ticks.setContext(this.getContext(e));
    return Ft(n.font);
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / e;
  }
}
class nu {
  constructor(e, n, r) {
    this.type = e, this.scope = n, this.override = r, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
  }
  register(e) {
    const n = Object.getPrototypeOf(e);
    let r;
    RW(n) && (r = this.register(n));
    const s = this.items, i = e.id, o = this.scope + "." + i;
    if (!i)
      throw new Error("class does not have id: " + e);
    return i in s || (s[i] = e, TW(e, o, r), this.override && _t.override(e.id, e.overrides)), o;
  }
  get(e) {
    return this.items[e];
  }
  unregister(e) {
    const n = this.items, r = e.id, s = this.scope;
    r in n && delete n[r], s && r in _t[s] && (delete _t[s][r], this.override && delete Gi[r]);
  }
}
function TW(t, e, n) {
  const r = Xc(/* @__PURE__ */ Object.create(null), [
    n ? _t.get(n) : {},
    _t.get(e),
    t.defaults
  ]);
  _t.set(e, r), t.defaultRoutes && kW(e, t.defaultRoutes), t.descriptors && _t.describe(e, t.descriptors);
}
function kW(t, e) {
  Object.keys(e).forEach((n) => {
    const r = n.split("."), s = r.pop(), i = [
      t
    ].concat(r).join("."), o = e[n].split("."), a = o.pop(), c = o.join(".");
    _t.route(i, s, c, a);
  });
}
function RW(t) {
  return "id" in t && "defaults" in t;
}
class MW {
  constructor() {
    this.controllers = new nu(cr, "datasets", !0), this.elements = new nu(ws, "elements"), this.plugins = new nu(Object, "plugins"), this.scales = new nu(no, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...e) {
    this._each("register", e);
  }
  remove(...e) {
    this._each("unregister", e);
  }
  addControllers(...e) {
    this._each("register", e, this.controllers);
  }
  addElements(...e) {
    this._each("register", e, this.elements);
  }
  addPlugins(...e) {
    this._each("register", e, this.plugins);
  }
  addScales(...e) {
    this._each("register", e, this.scales);
  }
  getController(e) {
    return this._get(e, this.controllers, "controller");
  }
  getElement(e) {
    return this._get(e, this.elements, "element");
  }
  getPlugin(e) {
    return this._get(e, this.plugins, "plugin");
  }
  getScale(e) {
    return this._get(e, this.scales, "scale");
  }
  removeControllers(...e) {
    this._each("unregister", e, this.controllers);
  }
  removeElements(...e) {
    this._each("unregister", e, this.elements);
  }
  removePlugins(...e) {
    this._each("unregister", e, this.plugins);
  }
  removeScales(...e) {
    this._each("unregister", e, this.scales);
  }
  _each(e, n, r) {
    [
      ...n
    ].forEach((s) => {
      const i = r || this._getRegistryForType(s);
      r || i.isForType(s) || i === this.plugins && s.id ? this._exec(e, i, s) : Xe(s, (o) => {
        const a = r || this._getRegistryForType(o);
        this._exec(e, a, o);
      });
    });
  }
  _exec(e, n, r) {
    const s = Ly(e);
    ut(r["before" + s], [], r), n[e](r), ut(r["after" + s], [], r);
  }
  _getRegistryForType(e) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const r = this._typedRegistries[n];
      if (r.isForType(e))
        return r;
    }
    return this.plugins;
  }
  _get(e, n, r) {
    const s = n.get(e);
    if (s === void 0)
      throw new Error('"' + e + '" is not a registered ' + r + ".");
    return s;
  }
}
var br = /* @__PURE__ */ new MW();
class PW {
  constructor() {
    this._init = [];
  }
  notify(e, n, r, s) {
    n === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install"));
    const i = s ? this._descriptors(e).filter(s) : this._descriptors(e), o = this._notify(i, e, n, r);
    return n === "afterDestroy" && (this._notify(i, e, "stop"), this._notify(this._init, e, "uninstall")), o;
  }
  _notify(e, n, r, s) {
    s = s || {};
    for (const i of e) {
      const o = i.plugin, a = o[r], c = [
        n,
        s,
        i.options
      ];
      if (ut(a, c, o) === !1 && s.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    je(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(e) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(e);
    return this._notifyStateChanges(e), n;
  }
  _createDescriptors(e, n) {
    const r = e && e.config, s = Ae(r.options && r.options.plugins, {}), i = IW(r);
    return s === !1 && !n ? [] : OW(e, i, s, n);
  }
  _notifyStateChanges(e) {
    const n = this._oldCache || [], r = this._cache, s = (i, o) => i.filter((a) => !o.some((c) => a.plugin.id === c.plugin.id));
    this._notify(s(n, r), e, "stop"), this._notify(s(r, n), e, "start");
  }
}
function IW(t) {
  const e = {}, n = [], r = Object.keys(br.plugins.items);
  for (let i = 0; i < r.length; i++)
    n.push(br.getPlugin(r[i]));
  const s = t.plugins || [];
  for (let i = 0; i < s.length; i++) {
    const o = s[i];
    n.indexOf(o) === -1 && (n.push(o), e[o.id] = !0);
  }
  return {
    plugins: n,
    localIds: e
  };
}
function DW(t, e) {
  return !e && t === !1 ? null : t === !0 ? {} : t;
}
function OW(t, { plugins: e, localIds: n }, r, s) {
  const i = [], o = t.getContext();
  for (const a of e) {
    const c = a.id, l = DW(r[c], s);
    l !== null && i.push({
      plugin: a,
      options: qW(t.config, {
        plugin: a,
        local: n[c]
      }, l, o)
    });
  }
  return i;
}
function qW(t, { plugin: e, local: n }, r, s) {
  const i = t.pluginScopeKeys(e), o = t.getOptionScopes(r, i);
  return n && e.defaults && o.push(e.defaults), t.createResolver(o, s, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Im(t, e) {
  const n = _t.datasets[t] || {};
  return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x";
}
function NW(t, e) {
  let n = t;
  return t === "_index_" ? n = e : t === "_value_" && (n = e === "x" ? "y" : "x"), n;
}
function LW(t, e) {
  return t === e ? "_index_" : "_value_";
}
function mw(t) {
  if (t === "x" || t === "y" || t === "r")
    return t;
}
function jW(t) {
  if (t === "top" || t === "bottom")
    return "x";
  if (t === "left" || t === "right")
    return "y";
}
function Dm(t, ...e) {
  if (mw(t))
    return t;
  for (const n of e) {
    const r = n.axis || jW(n.position) || t.length > 1 && mw(t[0].toLowerCase());
    if (r)
      return r;
  }
  throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);
}
function gw(t, e, n) {
  if (n[e + "AxisID"] === t)
    return {
      axis: e
    };
}
function BW(t, e) {
  if (e.data && e.data.datasets) {
    const n = e.data.datasets.filter((r) => r.xAxisID === t || r.yAxisID === t);
    if (n.length)
      return gw(t, "x", n[0]) || gw(t, "y", n[0]);
  }
  return {};
}
function FW(t, e) {
  const n = Gi[t.type] || {
    scales: {}
  }, r = e.scales || {}, s = Im(t.type, e), i = /* @__PURE__ */ Object.create(null);
  return Object.keys(r).forEach((o) => {
    const a = r[o];
    if (!Pe(a))
      return console.error(`Invalid scale configuration for scale: ${o}`);
    if (a._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
    const c = Dm(o, a, BW(o, t), _t.scales[a.type]), l = LW(c, s), u = n.scales || {};
    i[o] = bc(/* @__PURE__ */ Object.create(null), [
      {
        axis: c
      },
      a,
      u[c],
      u[l]
    ]);
  }), t.data.datasets.forEach((o) => {
    const a = o.type || t.type, c = o.indexAxis || Im(a, e), u = (Gi[a] || {}).scales || {};
    Object.keys(u).forEach((d) => {
      const f = NW(d, c), h = o[f + "AxisID"] || f;
      i[h] = i[h] || /* @__PURE__ */ Object.create(null), bc(i[h], [
        {
          axis: f
        },
        r[h],
        u[d]
      ]);
    });
  }), Object.keys(i).forEach((o) => {
    const a = i[o];
    bc(a, [
      _t.scales[a.type],
      _t.scale
    ]);
  }), i;
}
function yT(t) {
  const e = t.options || (t.options = {});
  e.plugins = Ae(e.plugins, {}), e.scales = FW(t, e);
}
function bT(t) {
  return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t;
}
function VW(t) {
  return t = t || {}, t.data = bT(t.data), yT(t), t;
}
const yw = /* @__PURE__ */ new Map(), vT = /* @__PURE__ */ new Set();
function ru(t, e) {
  let n = yw.get(t);
  return n || (n = e(), yw.set(t, n), vT.add(n)), n;
}
const Za = (t, e, n) => {
  const r = ri(e, n);
  r !== void 0 && t.add(r);
};
class UW {
  constructor(e) {
    this._config = VW(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(e) {
    this._config.type = e;
  }
  get data() {
    return this._config.data;
  }
  set data(e) {
    this._config.data = bT(e);
  }
  get options() {
    return this._config.options;
  }
  set options(e) {
    this._config.options = e;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const e = this._config;
    this.clearCache(), yT(e);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(e) {
    return ru(e, () => [
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(e, n) {
    return ru(`${e}.transition.${n}`, () => [
      [
        `datasets.${e}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(e, n) {
    return ru(`${e}-${n}`, () => [
      [
        `datasets.${e}.elements.${n}`,
        `datasets.${e}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(e) {
    const n = e.id, r = this.type;
    return ru(`${r}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...e.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(e, n) {
    const r = this._scopeCache;
    let s = r.get(e);
    return (!s || n) && (s = /* @__PURE__ */ new Map(), r.set(e, s)), s;
  }
  getOptionScopes(e, n, r) {
    const { options: s, type: i } = this, o = this._cachedScopes(e, r), a = o.get(n);
    if (a)
      return a;
    const c = /* @__PURE__ */ new Set();
    n.forEach((u) => {
      e && (c.add(e), u.forEach((d) => Za(c, e, d))), u.forEach((d) => Za(c, s, d)), u.forEach((d) => Za(c, Gi[i] || {}, d)), u.forEach((d) => Za(c, _t, d)), u.forEach((d) => Za(c, Rm, d));
    });
    const l = Array.from(c);
    return l.length === 0 && l.push(/* @__PURE__ */ Object.create(null)), vT.has(n) && o.set(n, l), l;
  }
  chartOptionScopes() {
    const { options: e, type: n } = this;
    return [
      e,
      Gi[n] || {},
      _t.datasets[n] || {},
      {
        type: n
      },
      _t,
      Rm
    ];
  }
  resolveNamedOptions(e, n, r, s = [
    ""
  ]) {
    const i = {
      $shared: !0
    }, { resolver: o, subPrefixes: a } = bw(this._resolverCache, e, s);
    let c = o;
    if (zW(o, n)) {
      i.$shared = !1, r = si(r) ? r() : r;
      const l = this.createResolver(e, r, a);
      c = na(o, r, l);
    }
    for (const l of n)
      i[l] = c[l];
    return i;
  }
  createResolver(e, n, r = [
    ""
  ], s) {
    const { resolver: i } = bw(this._resolverCache, e, r);
    return Pe(n) ? na(i, n, void 0, s) : i;
  }
}
function bw(t, e, n) {
  let r = t.get(e);
  r || (r = /* @__PURE__ */ new Map(), t.set(e, r));
  const s = n.join();
  let i = r.get(s);
  return i || (i = {
    resolver: Wy(e, n),
    subPrefixes: n.filter((a) => !a.toLowerCase().includes("hover"))
  }, r.set(s, i)), i;
}
const WW = (t) => Pe(t) && Object.getOwnPropertyNames(t).some((e) => si(t[e]));
function zW(t, e) {
  const { isScriptable: n, isIndexable: r } = X_(t);
  for (const s of e) {
    const i = n(s), o = r(s), a = (o || i) && t[s];
    if (i && (si(a) || WW(a)) || o && mt(a))
      return !0;
  }
  return !1;
}
var HW = "4.4.4";
const YW = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function vw(t, e) {
  return t === "top" || t === "bottom" || YW.indexOf(t) === -1 && e === "x";
}
function xw(t, e) {
  return function(n, r) {
    return n[t] === r[t] ? n[e] - r[e] : n[t] - r[t];
  };
}
function ww(t) {
  const e = t.chart, n = e.options.animation;
  e.notifyPlugins("afterRender"), ut(n && n.onComplete, [
    t
  ], e);
}
function GW(t) {
  const e = t.chart, n = e.options.animation;
  ut(n && n.onProgress, [
    t
  ], e);
}
function xT(t) {
  return Yy() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;
}
const $u = {}, Aw = (t) => {
  const e = xT(t);
  return Object.values($u).filter((n) => n.canvas === e).pop();
};
function KW(t, e, n) {
  const r = Object.keys(t);
  for (const s of r) {
    const i = +s;
    if (i >= e) {
      const o = t[s];
      delete t[s], (n > 0 || i > e) && (t[i + n] = o);
    }
  }
}
function $W(t, e, n, r) {
  return !n || t.type === "mouseout" ? null : r ? e : t;
}
function su(t, e, n) {
  return t.options.clip ? t[n] : e[n];
}
function ZW(t, e) {
  const { xScale: n, yScale: r } = t;
  return n && r ? {
    left: su(n, e, "left"),
    right: su(n, e, "right"),
    top: su(r, e, "top"),
    bottom: su(r, e, "bottom")
  } : e;
}
class Zr {
  static register(...e) {
    br.add(...e), Sw();
  }
  static unregister(...e) {
    br.remove(...e), Sw();
  }
  constructor(e, n) {
    const r = this.config = new UW(n), s = xT(e), i = Aw(s);
    if (i)
      throw new Error("Canvas is already in use. Chart with ID '" + i.id + "' must be destroyed before the canvas with ID '" + i.canvas.id + "' can be reused.");
    const o = r.createResolver(r.chartOptionScopes(), this.getContext());
    this.platform = new (r.platform || hW(s))(), this.platform.updateConfig(r);
    const a = this.platform.acquireContext(s, o.aspectRatio), c = a && a.canvas, l = c && c.height, u = c && c.width;
    if (this.id = X4(), this.ctx = a, this.canvas = c, this.width = u, this.height = l, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new PW(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = pV((d) => this.update(d), o.resizeDelay || 0), this._dataChanges = [], $u[this.id] = this, !a || !c) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Hr.listen(this, "complete", ww), Hr.listen(this, "progress", GW), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: e, maintainAspectRatio: n }, width: r, height: s, _aspectRatio: i } = this;
    return je(e) ? n && i ? i : s ? r / s : null : e;
  }
  get data() {
    return this.config.data;
  }
  set data(e) {
    this.config.data = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this.config.options = e;
  }
  get registry() {
    return br;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : zx(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return Vx(this.canvas, this.ctx), this;
  }
  stop() {
    return Hr.stop(this), this;
  }
  resize(e, n) {
    Hr.running(this) ? this._resizeBeforeDraw = {
      width: e,
      height: n
    } : this._resize(e, n);
  }
  _resize(e, n) {
    const r = this.options, s = this.canvas, i = r.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(s, e, n, i), a = r.devicePixelRatio || this.platform.getDevicePixelRatio(), c = this.width ? "resize" : "attach";
    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, zx(this, a, !0) && (this.notifyPlugins("resize", {
      size: o
    }), ut(r.onResize, [
      this,
      o
    ], this), this.attached && this._doResize(c) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    Xe(n, (r, s) => {
      r.id = s;
    });
  }
  buildOrUpdateScales() {
    const e = this.options, n = e.scales, r = this.scales, s = Object.keys(r).reduce((o, a) => (o[a] = !1, o), {});
    let i = [];
    n && (i = i.concat(Object.keys(n).map((o) => {
      const a = n[o], c = Dm(o, a), l = c === "r", u = c === "x";
      return {
        options: a,
        dposition: l ? "chartArea" : u ? "bottom" : "left",
        dtype: l ? "radialLinear" : u ? "category" : "linear"
      };
    }))), Xe(i, (o) => {
      const a = o.options, c = a.id, l = Dm(c, a), u = Ae(a.type, o.dtype);
      (a.position === void 0 || vw(a.position, l) !== vw(o.dposition)) && (a.position = o.dposition), s[c] = !0;
      let d = null;
      if (c in r && r[c].type === u)
        d = r[c];
      else {
        const f = br.getScale(u);
        d = new f({
          id: c,
          type: u,
          ctx: this.ctx,
          chart: this
        }), r[d.id] = d;
      }
      d.init(a, e);
    }), Xe(s, (o, a) => {
      o || delete r[a];
    }), Xe(r, (o) => {
      an.configure(this, o, o.options), an.addBox(this, o);
    });
  }
  _updateMetasets() {
    const e = this._metasets, n = this.data.datasets.length, r = e.length;
    if (e.sort((s, i) => s.index - i.index), r > n) {
      for (let s = n; s < r; ++s)
        this._destroyDatasetMeta(s);
      e.splice(n, r - n);
    }
    this._sortedMetasets = e.slice(0).sort(xw("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: e, data: { datasets: n } } = this;
    e.length > n.length && delete this._stacks, e.forEach((r, s) => {
      n.filter((i) => i === r._dataset).length === 0 && this._destroyDatasetMeta(s);
    });
  }
  buildOrUpdateControllers() {
    const e = [], n = this.data.datasets;
    let r, s;
    for (this._removeUnreferencedMetasets(), r = 0, s = n.length; r < s; r++) {
      const i = n[r];
      let o = this.getDatasetMeta(r);
      const a = i.type || this.config.type;
      if (o.type && o.type !== a && (this._destroyDatasetMeta(r), o = this.getDatasetMeta(r)), o.type = a, o.indexAxis = i.indexAxis || Im(a, this.options), o.order = i.order || 0, o.index = r, o.label = "" + i.label, o.visible = this.isDatasetVisible(r), o.controller)
        o.controller.updateIndex(r), o.controller.linkScales();
      else {
        const c = br.getController(a), { datasetElementType: l, dataElementType: u } = _t.datasets[a];
        Object.assign(c, {
          dataElementType: br.getElement(u),
          datasetElementType: l && br.getElement(l)
        }), o.controller = new c(this, r), e.push(o.controller);
      }
    }
    return this._updateMetasets(), e;
  }
  _resetElements() {
    Xe(this.data.datasets, (e, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(e) {
    const n = this.config;
    n.update();
    const r = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !r.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: e,
      cancelable: !0
    }) === !1)
      return;
    const i = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let o = 0;
    for (let l = 0, u = this.data.datasets.length; l < u; l++) {
      const { controller: d } = this.getDatasetMeta(l), f = !s && i.indexOf(d) === -1;
      d.buildOrUpdateElements(f), o = Math.max(+d.getMaxOverflow(), o);
    }
    o = this._minPadding = r.layout.autoPadding ? o : 0, this._updateLayout(o), s || Xe(i, (l) => {
      l.reset();
    }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
      mode: e
    }), this._layers.sort(xw("z", "_idx"));
    const { _active: a, _lastEvent: c } = this;
    c ? this._eventHandler(c, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();
  }
  _updateScales() {
    Xe(this.scales, (e) => {
      an.removeBox(this, e);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const e = this.options, n = new Set(Object.keys(this._listeners)), r = new Set(e.events);
    (!Ix(n, r) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || [];
    for (const { method: r, start: s, count: i } of n) {
      const o = r === "_removeElements" ? -i : i;
      KW(e, s, o);
    }
  }
  _getUniformDataChanges() {
    const e = this._dataChanges;
    if (!e || !e.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, r = (i) => new Set(e.filter((o) => o[0] === i).map((o, a) => a + "," + o.splice(1).join(","))), s = r(0);
    for (let i = 1; i < n; i++)
      if (!Ix(s, r(i)))
        return;
    return Array.from(s).map((i) => i.split(",")).map((i) => ({
      method: i[1],
      start: +i[2],
      count: +i[3]
    }));
  }
  _updateLayout(e) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    an.update(this, this.width, this.height, e);
    const n = this.chartArea, r = n.width <= 0 || n.height <= 0;
    this._layers = [], Xe(this.boxes, (s) => {
      r && s.position === "chartArea" || (s.configure && s.configure(), this._layers.push(...s._layers()));
    }, this), this._layers.forEach((s, i) => {
      s._idx = i;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(e) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: e,
      cancelable: !0
    }) !== !1) {
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, r = this.data.datasets.length; n < r; ++n)
        this._updateDataset(n, si(e) ? e({
          datasetIndex: n
        }) : e);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: e
      });
    }
  }
  _updateDataset(e, n) {
    const r = this.getDatasetMeta(e), s = {
      meta: r,
      index: e,
      mode: n,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", s) !== !1 && (r.controller._update(n), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Hr.has(this) ? this.attached && !Hr.running(this) && Hr.start(this) : (this.draw(), ww({
      chart: this
    })));
  }
  draw() {
    let e;
    if (this._resizeBeforeDraw) {
      const { width: r, height: s } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(r, s);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const n = this._layers;
    for (e = 0; e < n.length && n[e].z <= 0; ++e)
      n[e].draw(this.chartArea);
    for (this._drawDatasets(); e < n.length; ++e)
      n[e].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(e) {
    const n = this._sortedMetasets, r = [];
    let s, i;
    for (s = 0, i = n.length; s < i; ++s) {
      const o = n[s];
      (!e || o.visible) && r.push(o);
    }
    return r;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const e = this.getSortedVisibleDatasetMetas();
    for (let n = e.length - 1; n >= 0; --n)
      this._drawDataset(e[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(e) {
    const n = this.ctx, r = e._clip, s = !r.disabled, i = ZW(e, this.chartArea), o = {
      meta: e,
      index: e.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (s && Ff(n, {
      left: r.left === !1 ? 0 : i.left - r.left,
      right: r.right === !1 ? this.width : i.right + r.right,
      top: r.top === !1 ? 0 : i.top - r.top,
      bottom: r.bottom === !1 ? this.height : i.bottom + r.bottom
    }), e.controller.draw(), s && Vf(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o));
  }
  isPointInArea(e) {
    return ts(e, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, n, r, s) {
    const i = YU.modes[n];
    return typeof i == "function" ? i(this, e, r, s) : [];
  }
  getDatasetMeta(e) {
    const n = this.data.datasets[e], r = this._metasets;
    let s = r.filter((i) => i && i._dataset === n).pop();
    return s || (s = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: e,
      _dataset: n,
      _parsed: [],
      _sorted: !1
    }, r.push(s)), s;
  }
  getContext() {
    return this.$context || (this.$context = ui(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(e) {
    const n = this.data.datasets[e];
    if (!n)
      return !1;
    const r = this.getDatasetMeta(e);
    return typeof r.hidden == "boolean" ? !r.hidden : !n.hidden;
  }
  setDatasetVisibility(e, n) {
    const r = this.getDatasetMeta(e);
    r.hidden = !n;
  }
  toggleDataVisibility(e) {
    this._hiddenIndices[e] = !this._hiddenIndices[e];
  }
  getDataVisibility(e) {
    return !this._hiddenIndices[e];
  }
  _updateVisibility(e, n, r) {
    const s = r ? "show" : "hide", i = this.getDatasetMeta(e), o = i.controller._resolveAnimations(void 0, s);
    Jc(n) ? (i.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(e, r), o.update(i, {
      visible: r
    }), this.update((a) => a.datasetIndex === e ? s : void 0));
  }
  hide(e, n) {
    this._updateVisibility(e, n, !1);
  }
  show(e, n) {
    this._updateVisibility(e, n, !0);
  }
  _destroyDatasetMeta(e) {
    const n = this._metasets[e];
    n && n.controller && n.controller._destroy(), delete this._metasets[e];
  }
  _stop() {
    let e, n;
    for (this.stop(), Hr.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)
      this._destroyDatasetMeta(e);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: e, ctx: n } = this;
    this._stop(), this.config.clearCache(), e && (this.unbindEvents(), Vx(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete $u[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...e) {
    return this.canvas.toDataURL(...e);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const e = this._listeners, n = this.platform, r = (i, o) => {
      n.addEventListener(this, i, o), e[i] = o;
    }, s = (i, o, a) => {
      i.offsetX = o, i.offsetY = a, this._eventHandler(i);
    };
    Xe(this.options.events, (i) => r(i, s));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const e = this._responsiveListeners, n = this.platform, r = (c, l) => {
      n.addEventListener(this, c, l), e[c] = l;
    }, s = (c, l) => {
      e[c] && (n.removeEventListener(this, c, l), delete e[c]);
    }, i = (c, l) => {
      this.canvas && this.resize(c, l);
    };
    let o;
    const a = () => {
      s("attach", a), this.attached = !0, this.resize(), r("resize", i), r("detach", o);
    };
    o = () => {
      this.attached = !1, s("resize", i), this._stop(), this._resize(0, 0), r("attach", a);
    }, n.isAttached(this.canvas) ? a() : o();
  }
  unbindEvents() {
    Xe(this._listeners, (e, n) => {
      this.platform.removeEventListener(this, n, e);
    }), this._listeners = {}, Xe(this._responsiveListeners, (e, n) => {
      this.platform.removeEventListener(this, n, e);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(e, n, r) {
    const s = r ? "set" : "remove";
    let i, o, a, c;
    for (n === "dataset" && (i = this.getDatasetMeta(e[0].datasetIndex), i.controller["_" + s + "DatasetHoverStyle"]()), a = 0, c = e.length; a < c; ++a) {
      o = e[a];
      const l = o && this.getDatasetMeta(o.datasetIndex).controller;
      l && l[s + "HoverStyle"](o.element, o.datasetIndex, o.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e) {
    const n = this._active || [], r = e.map(({ datasetIndex: i, index: o }) => {
      const a = this.getDatasetMeta(i);
      if (!a)
        throw new Error("No dataset found at index " + i);
      return {
        datasetIndex: i,
        element: a.data[o],
        index: o
      };
    });
    !Ld(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n));
  }
  notifyPlugins(e, n, r) {
    return this._plugins.notify(this, e, n, r);
  }
  isPluginEnabled(e) {
    return this._plugins._cache.filter((n) => n.plugin.id === e).length === 1;
  }
  _updateHoverStyles(e, n, r) {
    const s = this.options.hover, i = (c, l) => c.filter((u) => !l.some((d) => u.datasetIndex === d.datasetIndex && u.index === d.index)), o = i(n, e), a = r ? e : i(e, n);
    o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0);
  }
  _eventHandler(e, n) {
    const r = {
      event: e,
      replay: n,
      cancelable: !0,
      inChartArea: this.isPointInArea(e)
    }, s = (o) => (o.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", r, s) === !1)
      return;
    const i = this._handleEvent(e, n, r.inChartArea);
    return r.cancelable = !1, this.notifyPlugins("afterEvent", r, s), (i || r.changed) && this.render(), this;
  }
  _handleEvent(e, n, r) {
    const { _active: s = [], options: i } = this, o = n, a = this._getActiveElements(e, s, r, o), c = sV(e), l = $W(e, this._lastEvent, r, c);
    r && (this._lastEvent = null, ut(i.onHover, [
      e,
      a,
      this
    ], this), c && ut(i.onClick, [
      e,
      a,
      this
    ], this));
    const u = !Ld(a, s);
    return (u || n) && (this._active = a, this._updateHoverStyles(a, s, n)), this._lastEvent = l, u;
  }
  _getActiveElements(e, n, r, s) {
    if (e.type === "mouseout")
      return [];
    if (!r)
      return n;
    const i = this.options.hover;
    return this.getElementsAtEventForMode(e, i.mode, i, s);
  }
}
K(Zr, "defaults", _t), K(Zr, "instances", $u), K(Zr, "overrides", Gi), K(Zr, "registry", br), K(Zr, "version", HW), K(Zr, "getChart", Aw);
function Sw() {
  return Xe(Zr.instances, (t) => t._plugins.invalidate());
}
function QW(t, e, n) {
  const { startAngle: r, pixelMargin: s, x: i, y: o, outerRadius: a, innerRadius: c } = e;
  let l = s / a;
  t.beginPath(), t.arc(i, o, a, r - l, n + l), c > s ? (l = s / c, t.arc(i, o, c, n + l, r - l, !0)) : t.arc(i, o, s, n + It, r - It), t.closePath(), t.clip();
}
function XW(t) {
  return Uy(t, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function JW(t, e, n, r) {
  const s = XW(t.options.borderRadius), i = (n - e) / 2, o = Math.min(i, r * e / 2), a = (c) => {
    const l = (n - Math.min(i, c)) * r / 2;
    return Yt(c, 0, Math.min(i, l));
  };
  return {
    outerStart: a(s.outerStart),
    outerEnd: a(s.outerEnd),
    innerStart: Yt(s.innerStart, 0, o),
    innerEnd: Yt(s.innerEnd, 0, o)
  };
}
function po(t, e, n, r) {
  return {
    x: n + t * Math.cos(e),
    y: r + t * Math.sin(e)
  };
}
function Wd(t, e, n, r, s, i) {
  const { x: o, y: a, startAngle: c, pixelMargin: l, innerRadius: u } = e, d = Math.max(e.outerRadius + r + n - l, 0), f = u > 0 ? u + r + n + l : 0;
  let h = 0;
  const p = s - c;
  if (r) {
    const O = u > 0 ? u - r : 0, q = d > 0 ? d - r : 0, L = (O + q) / 2, N = L !== 0 ? p * L / (L + r) : p;
    h = (p - N) / 2;
  }
  const m = Math.max(1e-3, p * d - n / ht) / d, y = (p - m) / 2, b = c + y + h, v = s - y - h, { outerStart: w, outerEnd: x, innerStart: A, innerEnd: C } = JW(e, f, d, v - b), S = d - w, _ = d - x, T = b + w / S, k = v - x / _, R = f + A, P = f + C, M = b + A / R, D = v - C / P;
  if (t.beginPath(), i) {
    const O = (T + k) / 2;
    if (t.arc(o, a, d, T, O), t.arc(o, a, d, O, k), x > 0) {
      const j = po(_, k, o, a);
      t.arc(j.x, j.y, x, k, v + It);
    }
    const q = po(P, v, o, a);
    if (t.lineTo(q.x, q.y), C > 0) {
      const j = po(P, D, o, a);
      t.arc(j.x, j.y, C, v + It, D + Math.PI);
    }
    const L = (v - C / f + (b + A / f)) / 2;
    if (t.arc(o, a, f, v - C / f, L, !0), t.arc(o, a, f, L, b + A / f, !0), A > 0) {
      const j = po(R, M, o, a);
      t.arc(j.x, j.y, A, M + Math.PI, b - It);
    }
    const N = po(S, b, o, a);
    if (t.lineTo(N.x, N.y), w > 0) {
      const j = po(S, T, o, a);
      t.arc(j.x, j.y, w, b - It, T);
    }
  } else {
    t.moveTo(o, a);
    const O = Math.cos(T) * d + o, q = Math.sin(T) * d + a;
    t.lineTo(O, q);
    const L = Math.cos(k) * d + o, N = Math.sin(k) * d + a;
    t.lineTo(L, N);
  }
  t.closePath();
}
function ez(t, e, n, r, s) {
  const { fullCircles: i, startAngle: o, circumference: a } = e;
  let c = e.endAngle;
  if (i) {
    Wd(t, e, n, r, c, s);
    for (let l = 0; l < i; ++l)
      t.fill();
    isNaN(a) || (c = o + (a % ft || ft));
  }
  return Wd(t, e, n, r, c, s), t.fill(), c;
}
function tz(t, e, n, r, s) {
  const { fullCircles: i, startAngle: o, circumference: a, options: c } = e, { borderWidth: l, borderJoinStyle: u, borderDash: d, borderDashOffset: f } = c, h = c.borderAlign === "inner";
  if (!l)
    return;
  t.setLineDash(d || []), t.lineDashOffset = f, h ? (t.lineWidth = l * 2, t.lineJoin = u || "round") : (t.lineWidth = l, t.lineJoin = u || "bevel");
  let p = e.endAngle;
  if (i) {
    Wd(t, e, n, r, p, s);
    for (let m = 0; m < i; ++m)
      t.stroke();
    isNaN(a) || (p = o + (a % ft || ft));
  }
  h && QW(t, e, p), i || (Wd(t, e, n, r, p, s), t.stroke());
}
class lc extends ws {
  constructor(n) {
    super();
    K(this, "circumference");
    K(this, "endAngle");
    K(this, "fullCircles");
    K(this, "innerRadius");
    K(this, "outerRadius");
    K(this, "pixelMargin");
    K(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, n && Object.assign(this, n);
  }
  inRange(n, r, s) {
    const i = this.getProps([
      "x",
      "y"
    ], s), { angle: o, distance: a } = U_(i, {
      x: n,
      y: r
    }), { startAngle: c, endAngle: l, innerRadius: u, outerRadius: d, circumference: f } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], s), h = (this.options.spacing + this.options.borderWidth) / 2, p = Ae(f, l - c), m = el(o, c, l) && c !== l, y = p >= ft || m, b = Jr(a, u + h, d + h);
    return y && b;
  }
  getCenterPoint(n) {
    const { x: r, y: s, startAngle: i, endAngle: o, innerRadius: a, outerRadius: c } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], n), { offset: l, spacing: u } = this.options, d = (i + o) / 2, f = (a + c + u + l) / 2;
    return {
      x: r + Math.cos(d) * f,
      y: s + Math.sin(d) * f
    };
  }
  tooltipPosition(n) {
    return this.getCenterPoint(n);
  }
  draw(n) {
    const { options: r, circumference: s } = this, i = (r.offset || 0) / 4, o = (r.spacing || 0) / 2, a = r.circular;
    if (this.pixelMargin = r.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = s > ft ? Math.floor(s / ft) : 0, s === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    n.save();
    const c = (this.startAngle + this.endAngle) / 2;
    n.translate(Math.cos(c) * i, Math.sin(c) * i);
    const l = 1 - Math.sin(Math.min(ht, s || 0)), u = i * l;
    n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, ez(n, this, u, o, a), tz(n, this, u, o, a), n.restore();
  }
}
K(lc, "id", "arc"), K(lc, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), K(lc, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), K(lc, "descriptors", {
  _scriptable: !0,
  _indexable: (n) => n !== "borderDash"
});
function wT(t, e, n = e) {
  t.lineCap = Ae(n.borderCapStyle, e.borderCapStyle), t.setLineDash(Ae(n.borderDash, e.borderDash)), t.lineDashOffset = Ae(n.borderDashOffset, e.borderDashOffset), t.lineJoin = Ae(n.borderJoinStyle, e.borderJoinStyle), t.lineWidth = Ae(n.borderWidth, e.borderWidth), t.strokeStyle = Ae(n.borderColor, e.borderColor);
}
function nz(t, e, n) {
  t.lineTo(n.x, n.y);
}
function rz(t) {
  return t.stepped ? _V : t.tension || t.cubicInterpolationMode === "monotone" ? TV : nz;
}
function AT(t, e, n = {}) {
  const r = t.length, { start: s = 0, end: i = r - 1 } = n, { start: o, end: a } = e, c = Math.max(s, o), l = Math.min(i, a), u = s < o && i < o || s > a && i > a;
  return {
    count: r,
    start: c,
    loop: e.loop,
    ilen: l < c && !u ? r + l - c : l - c
  };
}
function sz(t, e, n, r) {
  const { points: s, options: i } = e, { count: o, start: a, loop: c, ilen: l } = AT(s, n, r), u = rz(i);
  let { move: d = !0, reverse: f } = r || {}, h, p, m;
  for (h = 0; h <= l; ++h)
    p = s[(a + (f ? l - h : h)) % o], !p.skip && (d ? (t.moveTo(p.x, p.y), d = !1) : u(t, m, p, f, i.stepped), m = p);
  return c && (p = s[(a + (f ? l : 0)) % o], u(t, m, p, f, i.stepped)), !!c;
}
function iz(t, e, n, r) {
  const s = e.points, { count: i, start: o, ilen: a } = AT(s, n, r), { move: c = !0, reverse: l } = r || {};
  let u = 0, d = 0, f, h, p, m, y, b;
  const v = (x) => (o + (l ? a - x : x)) % i, w = () => {
    m !== y && (t.lineTo(u, y), t.lineTo(u, m), t.lineTo(u, b));
  };
  for (c && (h = s[v(0)], t.moveTo(h.x, h.y)), f = 0; f <= a; ++f) {
    if (h = s[v(f)], h.skip)
      continue;
    const x = h.x, A = h.y, C = x | 0;
    C === p ? (A < m ? m = A : A > y && (y = A), u = (d * u + x) / ++d) : (w(), t.lineTo(x, A), p = C, d = 0, m = y = A), b = A;
  }
  w();
}
function Om(t) {
  const e = t.options, n = e.borderDash && e.borderDash.length;
  return !t._decimated && !t._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !n ? iz : sz;
}
function oz(t) {
  return t.stepped ? iU : t.tension || t.cubicInterpolationMode === "monotone" ? oU : Ci;
}
function az(t, e, n, r) {
  let s = e._path;
  s || (s = e._path = new Path2D(), e.path(s, n, r) && s.closePath()), wT(t, e.options), t.stroke(s);
}
function cz(t, e, n, r) {
  const { segments: s, options: i } = e, o = Om(e);
  for (const a of s)
    wT(t, i, a.style), t.beginPath(), o(t, e, a, {
      start: n,
      end: n + r - 1
    }) && t.closePath(), t.stroke();
}
const lz = typeof Path2D == "function";
function uz(t, e, n, r) {
  lz && !e.options.segment ? az(t, e, n, r) : cz(t, e, n, r);
}
class Bs extends ws {
  constructor(e) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e);
  }
  updateControlPoints(e, n) {
    const r = this.options;
    if ((r.tension || r.cubicInterpolationMode === "monotone") && !r.stepped && !this._pointsUpdated) {
      const s = r.spanGaps ? this._loop : this._fullLoop;
      QV(this._points, r, e, s, n), this._pointsUpdated = !0;
    }
  }
  set points(e) {
    this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = fU(this, this.options.segment));
  }
  first() {
    const e = this.segments, n = this.points;
    return e.length && n[e[0].start];
  }
  last() {
    const e = this.segments, n = this.points, r = e.length;
    return r && n[e[r - 1].end];
  }
  interpolate(e, n) {
    const r = this.options, s = e[n], i = this.points, o = cT(this, {
      property: n,
      start: s,
      end: s
    });
    if (!o.length)
      return;
    const a = [], c = oz(r);
    let l, u;
    for (l = 0, u = o.length; l < u; ++l) {
      const { start: d, end: f } = o[l], h = i[d], p = i[f];
      if (h === p) {
        a.push(h);
        continue;
      }
      const m = Math.abs((s - h[n]) / (p[n] - h[n])), y = c(h, p, m, r.stepped);
      y[n] = e[n], a.push(y);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(e, n, r) {
    return Om(this)(e, this, n, r);
  }
  path(e, n, r) {
    const s = this.segments, i = Om(this);
    let o = this._loop;
    n = n || 0, r = r || this.points.length - n;
    for (const a of s)
      o &= i(e, this, a, {
        start: n,
        end: n + r - 1
      });
    return !!o;
  }
  draw(e, n, r, s) {
    const i = this.options || {};
    (this.points || []).length && i.borderWidth && (e.save(), uz(e, this, r, s), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
K(Bs, "id", "line"), K(Bs, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), K(Bs, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), K(Bs, "descriptors", {
  _scriptable: !0,
  _indexable: (e) => e !== "borderDash" && e !== "fill"
});
function Ew(t, e, n, r) {
  const s = t.options, { [n]: i } = t.getProps([
    n
  ], r);
  return Math.abs(e - i) < s.radius + s.hitRadius;
}
class Zu extends ws {
  constructor(n) {
    super();
    K(this, "parsed");
    K(this, "skip");
    K(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, n && Object.assign(this, n);
  }
  inRange(n, r, s) {
    const i = this.options, { x: o, y: a } = this.getProps([
      "x",
      "y"
    ], s);
    return Math.pow(n - o, 2) + Math.pow(r - a, 2) < Math.pow(i.hitRadius + i.radius, 2);
  }
  inXRange(n, r) {
    return Ew(this, n, "x", r);
  }
  inYRange(n, r) {
    return Ew(this, n, "y", r);
  }
  getCenterPoint(n) {
    const { x: r, y: s } = this.getProps([
      "x",
      "y"
    ], n);
    return {
      x: r,
      y: s
    };
  }
  size(n) {
    n = n || this.options || {};
    let r = n.radius || 0;
    r = Math.max(r, r && n.hoverRadius || 0);
    const s = r && n.borderWidth || 0;
    return (r + s) * 2;
  }
  draw(n, r) {
    const s = this.options;
    this.skip || s.radius < 0.1 || !ts(this, r, this.size(s) / 2) || (n.strokeStyle = s.borderColor, n.lineWidth = s.borderWidth, n.fillStyle = s.backgroundColor, Mm(n, s, this.x, this.y));
  }
  getRange() {
    const n = this.options || {};
    return n.radius + n.hitRadius;
  }
}
K(Zu, "id", "point"), /**
* @type {any}
*/
K(Zu, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
K(Zu, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function ST(t, e) {
  const { x: n, y: r, base: s, width: i, height: o } = t.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], e);
  let a, c, l, u, d;
  return t.horizontal ? (d = o / 2, a = Math.min(n, s), c = Math.max(n, s), l = r - d, u = r + d) : (d = i / 2, a = n - d, c = n + d, l = Math.min(r, s), u = Math.max(r, s)), {
    left: a,
    top: l,
    right: c,
    bottom: u
  };
}
function Fs(t, e, n, r) {
  return t ? 0 : Yt(e, n, r);
}
function dz(t, e, n) {
  const r = t.options.borderWidth, s = t.borderSkipped, i = Q_(r);
  return {
    t: Fs(s.top, i.top, 0, n),
    r: Fs(s.right, i.right, 0, e),
    b: Fs(s.bottom, i.bottom, 0, n),
    l: Fs(s.left, i.left, 0, e)
  };
}
function fz(t, e, n) {
  const { enableBorderRadius: r } = t.getProps([
    "enableBorderRadius"
  ]), s = t.options.borderRadius, i = Oi(s), o = Math.min(e, n), a = t.borderSkipped, c = r || Pe(s);
  return {
    topLeft: Fs(!c || a.top || a.left, i.topLeft, 0, o),
    topRight: Fs(!c || a.top || a.right, i.topRight, 0, o),
    bottomLeft: Fs(!c || a.bottom || a.left, i.bottomLeft, 0, o),
    bottomRight: Fs(!c || a.bottom || a.right, i.bottomRight, 0, o)
  };
}
function hz(t) {
  const e = ST(t), n = e.right - e.left, r = e.bottom - e.top, s = dz(t, n / 2, r / 2), i = fz(t, n / 2, r / 2);
  return {
    outer: {
      x: e.left,
      y: e.top,
      w: n,
      h: r,
      radius: i
    },
    inner: {
      x: e.left + s.l,
      y: e.top + s.t,
      w: n - s.l - s.r,
      h: r - s.t - s.b,
      radius: {
        topLeft: Math.max(0, i.topLeft - Math.max(s.t, s.l)),
        topRight: Math.max(0, i.topRight - Math.max(s.t, s.r)),
        bottomLeft: Math.max(0, i.bottomLeft - Math.max(s.b, s.l)),
        bottomRight: Math.max(0, i.bottomRight - Math.max(s.b, s.r))
      }
    }
  };
}
function lp(t, e, n, r) {
  const s = e === null, i = n === null, a = t && !(s && i) && ST(t, r);
  return a && (s || Jr(e, a.left, a.right)) && (i || Jr(n, a.top, a.bottom));
}
function pz(t) {
  return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight;
}
function mz(t, e) {
  t.rect(e.x, e.y, e.w, e.h);
}
function up(t, e, n = {}) {
  const r = t.x !== n.x ? -e : 0, s = t.y !== n.y ? -e : 0, i = (t.x + t.w !== n.x + n.w ? e : 0) - r, o = (t.y + t.h !== n.y + n.h ? e : 0) - s;
  return {
    x: t.x + r,
    y: t.y + s,
    w: t.w + i,
    h: t.h + o,
    radius: t.radius
  };
}
class Qu extends ws {
  constructor(e) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
  }
  draw(e) {
    const { inflateAmount: n, options: { borderColor: r, backgroundColor: s } } = this, { inner: i, outer: o } = hz(this), a = pz(o.radius) ? tl : mz;
    e.save(), (o.w !== i.w || o.h !== i.h) && (e.beginPath(), a(e, up(o, n, i)), e.clip(), a(e, up(i, -n, o)), e.fillStyle = r, e.fill("evenodd")), e.beginPath(), a(e, up(i, n)), e.fillStyle = s, e.fill(), e.restore();
  }
  inRange(e, n, r) {
    return lp(this, e, n, r);
  }
  inXRange(e, n) {
    return lp(this, e, null, n);
  }
  inYRange(e, n) {
    return lp(this, null, e, n);
  }
  getCenterPoint(e) {
    const { x: n, y: r, base: s, horizontal: i } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], e);
    return {
      x: i ? (n + s) / 2 : n,
      y: i ? r : (r + s) / 2
    };
  }
  getRange(e) {
    return e === "x" ? this.width / 2 : this.height / 2;
  }
}
K(Qu, "id", "bar"), K(Qu, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), K(Qu, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var gz = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: lc,
  BarElement: Qu,
  LineElement: Bs,
  PointElement: Zu
});
const qm = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], Cw = /* @__PURE__ */ qm.map((t) => t.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function ET(t) {
  return qm[t % qm.length];
}
function CT(t) {
  return Cw[t % Cw.length];
}
function yz(t, e) {
  return t.borderColor = ET(e), t.backgroundColor = CT(e), ++e;
}
function bz(t, e) {
  return t.backgroundColor = t.data.map(() => ET(e++)), e;
}
function vz(t, e) {
  return t.backgroundColor = t.data.map(() => CT(e++)), e;
}
function xz(t) {
  let e = 0;
  return (n, r) => {
    const s = t.getDatasetMeta(r).controller;
    s instanceof ki ? e = bz(n, e) : s instanceof Ac ? e = vz(n, e) : s && (e = yz(n, e));
  };
}
function _w(t) {
  let e;
  for (e in t)
    if (t[e].borderColor || t[e].backgroundColor)
      return !0;
  return !1;
}
function wz(t) {
  return t && (t.borderColor || t.backgroundColor);
}
var Az = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(t, e, n) {
    if (!n.enabled)
      return;
    const { data: { datasets: r }, options: s } = t.config, { elements: i } = s;
    if (!n.forceOverride && (_w(r) || wz(s) || i && _w(i)))
      return;
    const o = xz(t);
    r.forEach(o);
  }
};
function Sz(t, e, n, r, s) {
  const i = s.samples || r;
  if (i >= n)
    return t.slice(e, e + n);
  const o = [], a = (n - 2) / (i - 2);
  let c = 0;
  const l = e + n - 1;
  let u = e, d, f, h, p, m;
  for (o[c++] = t[u], d = 0; d < i - 2; d++) {
    let y = 0, b = 0, v;
    const w = Math.floor((d + 1) * a) + 1 + e, x = Math.min(Math.floor((d + 2) * a) + 1, n) + e, A = x - w;
    for (v = w; v < x; v++)
      y += t[v].x, b += t[v].y;
    y /= A, b /= A;
    const C = Math.floor(d * a) + 1 + e, S = Math.min(Math.floor((d + 1) * a) + 1, n) + e, { x: _, y: T } = t[u];
    for (h = p = -1, v = C; v < S; v++)
      p = 0.5 * Math.abs((_ - y) * (t[v].y - T) - (_ - t[v].x) * (b - T)), p > h && (h = p, f = t[v], m = v);
    o[c++] = f, u = m;
  }
  return o[c++] = t[l], o;
}
function Ez(t, e, n, r) {
  let s = 0, i = 0, o, a, c, l, u, d, f, h, p, m;
  const y = [], b = e + n - 1, v = t[e].x, x = t[b].x - v;
  for (o = e; o < e + n; ++o) {
    a = t[o], c = (a.x - v) / x * r, l = a.y;
    const A = c | 0;
    if (A === u)
      l < p ? (p = l, d = o) : l > m && (m = l, f = o), s = (i * s + a.x) / ++i;
    else {
      const C = o - 1;
      if (!je(d) && !je(f)) {
        const S = Math.min(d, f), _ = Math.max(d, f);
        S !== h && S !== C && y.push({
          ...t[S],
          x: s
        }), _ !== h && _ !== C && y.push({
          ...t[_],
          x: s
        });
      }
      o > 0 && C !== h && y.push(t[C]), y.push(a), u = A, i = 0, p = m = l, d = f = h = o;
    }
  }
  return y;
}
function _T(t) {
  if (t._decimated) {
    const e = t._data;
    delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: e
    });
  }
}
function Tw(t) {
  t.data.datasets.forEach((e) => {
    _T(e);
  });
}
function Cz(t, e) {
  const n = e.length;
  let r = 0, s;
  const { iScale: i } = t, { min: o, max: a, minDefined: c, maxDefined: l } = i.getUserBounds();
  return c && (r = Yt(es(e, i.axis, o).lo, 0, n - 1)), l ? s = Yt(es(e, i.axis, a).hi + 1, r, n) - r : s = n - r, {
    start: r,
    count: s
  };
}
var _z = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (t, e, n) => {
    if (!n.enabled) {
      Tw(t);
      return;
    }
    const r = t.width;
    t.data.datasets.forEach((s, i) => {
      const { _data: o, indexAxis: a } = s, c = t.getDatasetMeta(i), l = o || s.data;
      if (ac([
        a,
        t.options.indexAxis
      ]) === "y" || !c.controller.supportsDecimation)
        return;
      const u = t.scales[c.xAxisID];
      if (u.type !== "linear" && u.type !== "time" || t.options.parsing)
        return;
      let { start: d, count: f } = Cz(c, l);
      const h = n.threshold || 4 * r;
      if (f <= h) {
        _T(s);
        return;
      }
      je(o) && (s._data = l, delete s.data, Object.defineProperty(s, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(m) {
          this._data = m;
        }
      }));
      let p;
      switch (n.algorithm) {
        case "lttb":
          p = Sz(l, d, f, r, n);
          break;
        case "min-max":
          p = Ez(l, d, f, r);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`);
      }
      s._decimated = p;
    });
  },
  destroy(t) {
    Tw(t);
  }
};
function Tz(t, e, n) {
  const r = t.segments, s = t.points, i = e.points, o = [];
  for (const a of r) {
    let { start: c, end: l } = a;
    l = $y(c, l, s);
    const u = Nm(n, s[c], s[l], a.loop);
    if (!e.segments) {
      o.push({
        source: a,
        target: u,
        start: s[c],
        end: s[l]
      });
      continue;
    }
    const d = cT(e, u);
    for (const f of d) {
      const h = Nm(n, i[f.start], i[f.end], f.loop), p = aT(a, s, h);
      for (const m of p)
        o.push({
          source: m,
          target: f,
          start: {
            [n]: kw(u, h, "start", Math.max)
          },
          end: {
            [n]: kw(u, h, "end", Math.min)
          }
        });
    }
  }
  return o;
}
function Nm(t, e, n, r) {
  if (r)
    return;
  let s = e[t], i = n[t];
  return t === "angle" && (s = Nn(s), i = Nn(i)), {
    property: t,
    start: s,
    end: i
  };
}
function kz(t, e) {
  const { x: n = null, y: r = null } = t || {}, s = e.points, i = [];
  return e.segments.forEach(({ start: o, end: a }) => {
    a = $y(o, a, s);
    const c = s[o], l = s[a];
    r !== null ? (i.push({
      x: c.x,
      y: r
    }), i.push({
      x: l.x,
      y: r
    })) : n !== null && (i.push({
      x: n,
      y: c.y
    }), i.push({
      x: n,
      y: l.y
    }));
  }), i;
}
function $y(t, e, n) {
  for (; e > t; e--) {
    const r = n[e];
    if (!isNaN(r.x) && !isNaN(r.y))
      break;
  }
  return e;
}
function kw(t, e, n, r) {
  return t && e ? r(t[n], e[n]) : t ? t[n] : e ? e[n] : 0;
}
function TT(t, e) {
  let n = [], r = !1;
  return mt(t) ? (r = !0, n = t) : n = kz(t, e), n.length ? new Bs({
    points: n,
    options: {
      tension: 0
    },
    _loop: r,
    _fullLoop: r
  }) : null;
}
function Rw(t) {
  return t && t.fill !== !1;
}
function Rz(t, e, n) {
  let s = t[e].fill;
  const i = [
    e
  ];
  let o;
  if (!n)
    return s;
  for (; s !== !1 && i.indexOf(s) === -1; ) {
    if (!Ct(s))
      return s;
    if (o = t[s], !o)
      return !1;
    if (o.visible)
      return s;
    i.push(s), s = o.fill;
  }
  return !1;
}
function Mz(t, e, n) {
  const r = Oz(t);
  if (Pe(r))
    return isNaN(r.value) ? !1 : r;
  let s = parseFloat(r);
  return Ct(s) && Math.floor(s) === s ? Pz(r[0], e, s, n) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(r) >= 0 && r;
}
function Pz(t, e, n, r) {
  return (t === "-" || t === "+") && (n = e + n), n === e || n < 0 || n >= r ? !1 : n;
}
function Iz(t, e) {
  let n = null;
  return t === "start" ? n = e.bottom : t === "end" ? n = e.top : Pe(t) ? n = e.getPixelForValue(t.value) : e.getBasePixel && (n = e.getBasePixel()), n;
}
function Dz(t, e, n) {
  let r;
  return t === "start" ? r = n : t === "end" ? r = e.options.reverse ? e.min : e.max : Pe(t) ? r = t.value : r = e.getBaseValue(), r;
}
function Oz(t) {
  const e = t.options, n = e.fill;
  let r = Ae(n && n.target, n);
  return r === void 0 && (r = !!e.backgroundColor), r === !1 || r === null ? !1 : r === !0 ? "origin" : r;
}
function qz(t) {
  const { scale: e, index: n, line: r } = t, s = [], i = r.segments, o = r.points, a = Nz(e, n);
  a.push(TT({
    x: null,
    y: e.bottom
  }, r));
  for (let c = 0; c < i.length; c++) {
    const l = i[c];
    for (let u = l.start; u <= l.end; u++)
      Lz(s, o[u], a);
  }
  return new Bs({
    points: s,
    options: {}
  });
}
function Nz(t, e) {
  const n = [], r = t.getMatchingVisibleMetas("line");
  for (let s = 0; s < r.length; s++) {
    const i = r[s];
    if (i.index === e)
      break;
    i.hidden || n.unshift(i.dataset);
  }
  return n;
}
function Lz(t, e, n) {
  const r = [];
  for (let s = 0; s < n.length; s++) {
    const i = n[s], { first: o, last: a, point: c } = jz(i, e, "x");
    if (!(!c || o && a)) {
      if (o)
        r.unshift(c);
      else if (t.push(c), !a)
        break;
    }
  }
  t.push(...r);
}
function jz(t, e, n) {
  const r = t.interpolate(e, n);
  if (!r)
    return {};
  const s = r[n], i = t.segments, o = t.points;
  let a = !1, c = !1;
  for (let l = 0; l < i.length; l++) {
    const u = i[l], d = o[u.start][n], f = o[u.end][n];
    if (Jr(s, d, f)) {
      a = s === d, c = s === f;
      break;
    }
  }
  return {
    first: a,
    last: c,
    point: r
  };
}
class kT {
  constructor(e) {
    this.x = e.x, this.y = e.y, this.radius = e.radius;
  }
  pathSegment(e, n, r) {
    const { x: s, y: i, radius: o } = this;
    return n = n || {
      start: 0,
      end: ft
    }, e.arc(s, i, o, n.end, n.start, !0), !r.bounds;
  }
  interpolate(e) {
    const { x: n, y: r, radius: s } = this, i = e.angle;
    return {
      x: n + Math.cos(i) * s,
      y: r + Math.sin(i) * s,
      angle: i
    };
  }
}
function Bz(t) {
  const { chart: e, fill: n, line: r } = t;
  if (Ct(n))
    return Fz(e, n);
  if (n === "stack")
    return qz(t);
  if (n === "shape")
    return !0;
  const s = Vz(t);
  return s instanceof kT ? s : TT(s, r);
}
function Fz(t, e) {
  const n = t.getDatasetMeta(e);
  return n && t.isDatasetVisible(e) ? n.dataset : null;
}
function Vz(t) {
  return (t.scale || {}).getPointPositionForValue ? Wz(t) : Uz(t);
}
function Uz(t) {
  const { scale: e = {}, fill: n } = t, r = Iz(n, e);
  if (Ct(r)) {
    const s = e.isHorizontal();
    return {
      x: s ? r : null,
      y: s ? null : r
    };
  }
  return null;
}
function Wz(t) {
  const { scale: e, fill: n } = t, r = e.options, s = e.getLabels().length, i = r.reverse ? e.max : e.min, o = Dz(n, e, i), a = [];
  if (r.grid.circular) {
    const c = e.getPointPositionForValue(0, i);
    return new kT({
      x: c.x,
      y: c.y,
      radius: e.getDistanceFromCenterForValue(o)
    });
  }
  for (let c = 0; c < s; ++c)
    a.push(e.getPointPositionForValue(c, o));
  return a;
}
function dp(t, e, n) {
  const r = Bz(e), { line: s, scale: i, axis: o } = e, a = s.options, c = a.fill, l = a.backgroundColor, { above: u = l, below: d = l } = c || {};
  r && s.points.length && (Ff(t, n), zz(t, {
    line: s,
    target: r,
    above: u,
    below: d,
    area: n,
    scale: i,
    axis: o
  }), Vf(t));
}
function zz(t, e) {
  const { line: n, target: r, above: s, below: i, area: o, scale: a } = e, c = n._loop ? "angle" : e.axis;
  t.save(), c === "x" && i !== s && (Mw(t, r, o.top), Pw(t, {
    line: n,
    target: r,
    color: s,
    scale: a,
    property: c
  }), t.restore(), t.save(), Mw(t, r, o.bottom)), Pw(t, {
    line: n,
    target: r,
    color: i,
    scale: a,
    property: c
  }), t.restore();
}
function Mw(t, e, n) {
  const { segments: r, points: s } = e;
  let i = !0, o = !1;
  t.beginPath();
  for (const a of r) {
    const { start: c, end: l } = a, u = s[c], d = s[$y(c, l, s)];
    i ? (t.moveTo(u.x, u.y), i = !1) : (t.lineTo(u.x, n), t.lineTo(u.x, u.y)), o = !!e.pathSegment(t, a, {
      move: o
    }), o ? t.closePath() : t.lineTo(d.x, n);
  }
  t.lineTo(e.first().x, n), t.closePath(), t.clip();
}
function Pw(t, e) {
  const { line: n, target: r, property: s, color: i, scale: o } = e, a = Tz(n, r, s);
  for (const { source: c, target: l, start: u, end: d } of a) {
    const { style: { backgroundColor: f = i } = {} } = c, h = r !== !0;
    t.save(), t.fillStyle = f, Hz(t, o, h && Nm(s, u, d)), t.beginPath();
    const p = !!n.pathSegment(t, c);
    let m;
    if (h) {
      p ? t.closePath() : Iw(t, r, d, s);
      const y = !!r.pathSegment(t, l, {
        move: p,
        reverse: !0
      });
      m = p && y, m || Iw(t, r, u, s);
    }
    t.closePath(), t.fill(m ? "evenodd" : "nonzero"), t.restore();
  }
}
function Hz(t, e, n) {
  const { top: r, bottom: s } = e.chart.chartArea, { property: i, start: o, end: a } = n || {};
  i === "x" && (t.beginPath(), t.rect(o, r, a - o, s - r), t.clip());
}
function Iw(t, e, n, r) {
  const s = e.interpolate(n, r);
  s && t.lineTo(s.x, s.y);
}
var Yz = {
  id: "filler",
  afterDatasetsUpdate(t, e, n) {
    const r = (t.data.datasets || []).length, s = [];
    let i, o, a, c;
    for (o = 0; o < r; ++o)
      i = t.getDatasetMeta(o), a = i.dataset, c = null, a && a.options && a instanceof Bs && (c = {
        visible: t.isDatasetVisible(o),
        index: o,
        fill: Mz(a, o, r),
        chart: t,
        axis: i.controller.options.indexAxis,
        scale: i.vScale,
        line: a
      }), i.$filler = c, s.push(c);
    for (o = 0; o < r; ++o)
      c = s[o], !(!c || c.fill === !1) && (c.fill = Rz(s, o, n.propagate));
  },
  beforeDraw(t, e, n) {
    const r = n.drawTime === "beforeDraw", s = t.getSortedVisibleDatasetMetas(), i = t.chartArea;
    for (let o = s.length - 1; o >= 0; --o) {
      const a = s[o].$filler;
      a && (a.line.updateControlPoints(i, a.axis), r && a.fill && dp(t.ctx, a, i));
    }
  },
  beforeDatasetsDraw(t, e, n) {
    if (n.drawTime !== "beforeDatasetsDraw")
      return;
    const r = t.getSortedVisibleDatasetMetas();
    for (let s = r.length - 1; s >= 0; --s) {
      const i = r[s].$filler;
      Rw(i) && dp(t.ctx, i, t.chartArea);
    }
  },
  beforeDatasetDraw(t, e, n) {
    const r = e.meta.$filler;
    !Rw(r) || n.drawTime !== "beforeDatasetDraw" || dp(t.ctx, r, t.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const Dw = (t, e) => {
  let { boxHeight: n = e, boxWidth: r = e } = t;
  return t.usePointStyle && (n = Math.min(n, e), r = t.pointStyleWidth || Math.min(r, e)), {
    boxWidth: r,
    boxHeight: n,
    itemHeight: Math.max(e, n)
  };
}, Gz = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index;
class Ow extends ws {
  constructor(e) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, n, r) {
    this.maxWidth = e, this.maxHeight = n, this._margins = r, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const e = this.options.labels || {};
    let n = ut(e.generateLabels, [
      this.chart
    ], this) || [];
    e.filter && (n = n.filter((r) => e.filter(r, this.chart.data))), e.sort && (n = n.sort((r, s) => e.sort(r, s, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n;
  }
  fit() {
    const { options: e, ctx: n } = this;
    if (!e.display) {
      this.width = this.height = 0;
      return;
    }
    const r = e.labels, s = Ft(r.font), i = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: c } = Dw(r, i);
    let l, u;
    n.font = s.string, this.isHorizontal() ? (l = this.maxWidth, u = this._fitRows(o, i, a, c) + 10) : (u = this.maxHeight, l = this._fitCols(o, s, a, c) + 10), this.width = Math.min(l, e.maxWidth || this.maxWidth), this.height = Math.min(u, e.maxHeight || this.maxHeight);
  }
  _fitRows(e, n, r, s) {
    const { ctx: i, maxWidth: o, options: { labels: { padding: a } } } = this, c = this.legendHitBoxes = [], l = this.lineWidths = [
      0
    ], u = s + a;
    let d = e;
    i.textAlign = "left", i.textBaseline = "middle";
    let f = -1, h = -u;
    return this.legendItems.forEach((p, m) => {
      const y = r + n / 2 + i.measureText(p.text).width;
      (m === 0 || l[l.length - 1] + y + 2 * a > o) && (d += u, l[l.length - (m > 0 ? 0 : 1)] = 0, h += u, f++), c[m] = {
        left: 0,
        top: h,
        row: f,
        width: y,
        height: s
      }, l[l.length - 1] += y + a;
    }), d;
  }
  _fitCols(e, n, r, s) {
    const { ctx: i, maxHeight: o, options: { labels: { padding: a } } } = this, c = this.legendHitBoxes = [], l = this.columnSizes = [], u = o - e;
    let d = a, f = 0, h = 0, p = 0, m = 0;
    return this.legendItems.forEach((y, b) => {
      const { itemWidth: v, itemHeight: w } = Kz(r, n, i, y, s);
      b > 0 && h + w + 2 * a > u && (d += f + a, l.push({
        width: f,
        height: h
      }), p += f + a, m++, f = h = 0), c[b] = {
        left: p,
        top: h,
        col: m,
        width: v,
        height: w
      }, f = Math.max(f, v), h += w + a;
    }), d += f, l.push({
      width: f,
      height: h
    }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: r, labels: { padding: s }, rtl: i } } = this, o = Fo(i, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, c = rn(r, this.left + s, this.right - this.lineWidths[a]);
      for (const l of n)
        a !== l.row && (a = l.row, c = rn(r, this.left + s, this.right - this.lineWidths[a])), l.top += this.top + e + s, l.left = o.leftForLtr(o.x(c), l.width), c += l.width + s;
    } else {
      let a = 0, c = rn(r, this.top + e + s, this.bottom - this.columnSizes[a].height);
      for (const l of n)
        l.col !== a && (a = l.col, c = rn(r, this.top + e + s, this.bottom - this.columnSizes[a].height)), l.top = c, l.left += this.left + s, l.left = o.leftForLtr(o.x(l.left), l.width), c += l.height + s;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx;
      Ff(e, this), this._draw(), Vf(e);
    }
  }
  _draw() {
    const { options: e, columnSizes: n, lineWidths: r, ctx: s } = this, { align: i, labels: o } = e, a = _t.color, c = Fo(e.rtl, this.left, this.width), l = Ft(o.font), { padding: u } = o, d = l.size, f = d / 2;
    let h;
    this.drawTitle(), s.textAlign = c.textAlign("left"), s.textBaseline = "middle", s.lineWidth = 0.5, s.font = l.string;
    const { boxWidth: p, boxHeight: m, itemHeight: y } = Dw(o, d), b = function(C, S, _) {
      if (isNaN(p) || p <= 0 || isNaN(m) || m < 0)
        return;
      s.save();
      const T = Ae(_.lineWidth, 1);
      if (s.fillStyle = Ae(_.fillStyle, a), s.lineCap = Ae(_.lineCap, "butt"), s.lineDashOffset = Ae(_.lineDashOffset, 0), s.lineJoin = Ae(_.lineJoin, "miter"), s.lineWidth = T, s.strokeStyle = Ae(_.strokeStyle, a), s.setLineDash(Ae(_.lineDash, [])), o.usePointStyle) {
        const k = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: _.pointStyle,
          rotation: _.rotation,
          borderWidth: T
        }, R = c.xPlus(C, p / 2), P = S + f;
        Z_(s, k, R, P, o.pointStyleWidth && p);
      } else {
        const k = S + Math.max((d - m) / 2, 0), R = c.leftForLtr(C, p), P = Oi(_.borderRadius);
        s.beginPath(), Object.values(P).some((M) => M !== 0) ? tl(s, {
          x: R,
          y: k,
          w: p,
          h: m,
          radius: P
        }) : s.rect(R, k, p, m), s.fill(), T !== 0 && s.stroke();
      }
      s.restore();
    }, v = function(C, S, _) {
      Ki(s, _.text, C, S + y / 2, l, {
        strikethrough: _.hidden,
        textAlign: c.textAlign(_.textAlign)
      });
    }, w = this.isHorizontal(), x = this._computeTitleHeight();
    w ? h = {
      x: rn(i, this.left + u, this.right - r[0]),
      y: this.top + u + x,
      line: 0
    } : h = {
      x: this.left + u,
      y: rn(i, this.top + x + u, this.bottom - n[0].height),
      line: 0
    }, sT(this.ctx, e.textDirection);
    const A = y + u;
    this.legendItems.forEach((C, S) => {
      s.strokeStyle = C.fontColor, s.fillStyle = C.fontColor;
      const _ = s.measureText(C.text).width, T = c.textAlign(C.textAlign || (C.textAlign = o.textAlign)), k = p + f + _;
      let R = h.x, P = h.y;
      c.setWidth(this.width), w ? S > 0 && R + k + u > this.right && (P = h.y += A, h.line++, R = h.x = rn(i, this.left + u, this.right - r[h.line])) : S > 0 && P + A > this.bottom && (R = h.x = R + n[h.line].width + u, h.line++, P = h.y = rn(i, this.top + x + u, this.bottom - n[h.line].height));
      const M = c.x(R);
      if (b(M, P, C), R = mV(T, R + p + f, w ? R + k : this.right, e.rtl), v(c.x(R), P, C), w)
        h.x += k + u;
      else if (typeof C.text != "string") {
        const D = l.lineHeight;
        h.y += RT(C, D) + u;
      } else
        h.y += A;
    }), iT(this.ctx, e.textDirection);
  }
  drawTitle() {
    const e = this.options, n = e.title, r = Ft(n.font), s = ln(n.padding);
    if (!n.display)
      return;
    const i = Fo(e.rtl, this.left, this.width), o = this.ctx, a = n.position, c = r.size / 2, l = s.top + c;
    let u, d = this.left, f = this.width;
    if (this.isHorizontal())
      f = Math.max(...this.lineWidths), u = this.top + l, d = rn(e.align, d, this.right - f);
    else {
      const p = this.columnSizes.reduce((m, y) => Math.max(m, y.height), 0);
      u = l + rn(e.align, this.top, this.bottom - p - e.labels.padding - this._computeTitleHeight());
    }
    const h = rn(a, d, d + f);
    o.textAlign = i.textAlign(Fy(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = r.string, Ki(o, n.text, h, u, r);
  }
  _computeTitleHeight() {
    const e = this.options.title, n = Ft(e.font), r = ln(e.padding);
    return e.display ? n.lineHeight + r.height : 0;
  }
  _getLegendItemAt(e, n) {
    let r, s, i;
    if (Jr(e, this.left, this.right) && Jr(n, this.top, this.bottom)) {
      for (i = this.legendHitBoxes, r = 0; r < i.length; ++r)
        if (s = i[r], Jr(e, s.left, s.left + s.width) && Jr(n, s.top, s.top + s.height))
          return this.legendItems[r];
    }
    return null;
  }
  handleEvent(e) {
    const n = this.options;
    if (!Qz(e.type, n))
      return;
    const r = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const s = this._hoveredItem, i = Gz(s, r);
      s && !i && ut(n.onLeave, [
        e,
        s,
        this
      ], this), this._hoveredItem = r, r && !i && ut(n.onHover, [
        e,
        r,
        this
      ], this);
    } else r && ut(n.onClick, [
      e,
      r,
      this
    ], this);
  }
}
function Kz(t, e, n, r, s) {
  const i = $z(r, t, e, n), o = Zz(s, r, e.lineHeight);
  return {
    itemWidth: i,
    itemHeight: o
  };
}
function $z(t, e, n, r) {
  let s = t.text;
  return s && typeof s != "string" && (s = s.reduce((i, o) => i.length > o.length ? i : o)), e + n.size / 2 + r.measureText(s).width;
}
function Zz(t, e, n) {
  let r = t;
  return typeof e.text != "string" && (r = RT(e, n)), r;
}
function RT(t, e) {
  const n = t.text ? t.text.length : 0;
  return e * n;
}
function Qz(t, e) {
  return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup"));
}
var Xz = {
  id: "legend",
  _element: Ow,
  start(t, e, n) {
    const r = t.legend = new Ow({
      ctx: t.ctx,
      options: n,
      chart: t
    });
    an.configure(t, r, n), an.addBox(t, r);
  },
  stop(t) {
    an.removeBox(t, t.legend), delete t.legend;
  },
  beforeUpdate(t, e, n) {
    const r = t.legend;
    an.configure(t, r, n), r.options = n;
  },
  afterUpdate(t) {
    const e = t.legend;
    e.buildLabels(), e.adjustHitBoxes();
  },
  afterEvent(t, e) {
    e.replay || t.legend.handleEvent(e.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(t, e, n) {
      const r = e.datasetIndex, s = n.chart;
      s.isDatasetVisible(r) ? (s.hide(r), e.hidden = !0) : (s.show(r), e.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (t) => t.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(t) {
        const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: r, textAlign: s, color: i, useBorderRadius: o, borderRadius: a } } = t.legend.options;
        return t._getSortedDatasetMetas().map((c) => {
          const l = c.controller.getStyle(n ? 0 : void 0), u = ln(l.borderWidth);
          return {
            text: e[c.index].label,
            fillStyle: l.backgroundColor,
            fontColor: i,
            hidden: !c.visible,
            lineCap: l.borderCapStyle,
            lineDash: l.borderDash,
            lineDashOffset: l.borderDashOffset,
            lineJoin: l.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: l.borderColor,
            pointStyle: r || l.pointStyle,
            rotation: l.rotation,
            textAlign: s || l.textAlign,
            borderRadius: o && (a || l.borderRadius),
            datasetIndex: c.index
          };
        }, this);
      }
    },
    title: {
      color: (t) => t.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (t) => !t.startsWith("on"),
    labels: {
      _scriptable: (t) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(t)
    }
  }
};
let Zy = class extends ws {
  constructor(e) {
    super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, n) {
    const r = this.options;
    if (this.left = 0, this.top = 0, !r.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = e, this.height = this.bottom = n;
    const s = mt(r.text) ? r.text.length : 1;
    this._padding = ln(r.padding);
    const i = s * Ft(r.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = i : this.width = i;
  }
  isHorizontal() {
    const e = this.options.position;
    return e === "top" || e === "bottom";
  }
  _drawArgs(e) {
    const { top: n, left: r, bottom: s, right: i, options: o } = this, a = o.align;
    let c = 0, l, u, d;
    return this.isHorizontal() ? (u = rn(a, r, i), d = n + e, l = i - r) : (o.position === "left" ? (u = r + e, d = rn(a, s, n), c = ht * -0.5) : (u = i - e, d = rn(a, n, s), c = ht * 0.5), l = s - n), {
      titleX: u,
      titleY: d,
      maxWidth: l,
      rotation: c
    };
  }
  draw() {
    const e = this.ctx, n = this.options;
    if (!n.display)
      return;
    const r = Ft(n.font), i = r.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: c, rotation: l } = this._drawArgs(i);
    Ki(e, n.text, 0, 0, r, {
      color: n.color,
      maxWidth: c,
      rotation: l,
      textAlign: Fy(n.align),
      textBaseline: "middle",
      translation: [
        o,
        a
      ]
    });
  }
};
function Jz(t, e) {
  const n = new Zy({
    ctx: t.ctx,
    options: e,
    chart: t
  });
  an.configure(t, n, e), an.addBox(t, n), t.titleBlock = n;
}
var e9 = {
  id: "title",
  _element: Zy,
  start(t, e, n) {
    Jz(t, n);
  },
  stop(t) {
    const e = t.titleBlock;
    an.removeBox(t, e), delete t.titleBlock;
  },
  beforeUpdate(t, e, n) {
    const r = t.titleBlock;
    an.configure(t, r, n), r.options = n;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const iu = /* @__PURE__ */ new WeakMap();
var t9 = {
  id: "subtitle",
  start(t, e, n) {
    const r = new Zy({
      ctx: t.ctx,
      options: n,
      chart: t
    });
    an.configure(t, r, n), an.addBox(t, r), iu.set(t, r);
  },
  stop(t) {
    an.removeBox(t, iu.get(t)), iu.delete(t);
  },
  beforeUpdate(t, e, n) {
    const r = iu.get(t);
    an.configure(t, r, n), r.options = n;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const uc = {
  average(t) {
    if (!t.length)
      return !1;
    let e, n, r = /* @__PURE__ */ new Set(), s = 0, i = 0;
    for (e = 0, n = t.length; e < n; ++e) {
      const a = t[e].element;
      if (a && a.hasValue()) {
        const c = a.tooltipPosition();
        r.add(c.x), s += c.y, ++i;
      }
    }
    return i === 0 || r.size === 0 ? !1 : {
      x: [
        ...r
      ].reduce((a, c) => a + c) / r.size,
      y: s / i
    };
  },
  nearest(t, e) {
    if (!t.length)
      return !1;
    let n = e.x, r = e.y, s = Number.POSITIVE_INFINITY, i, o, a;
    for (i = 0, o = t.length; i < o; ++i) {
      const c = t[i].element;
      if (c && c.hasValue()) {
        const l = c.getCenterPoint(), u = km(e, l);
        u < s && (s = u, a = c);
      }
    }
    if (a) {
      const c = a.tooltipPosition();
      n = c.x, r = c.y;
    }
    return {
      x: n,
      y: r
    };
  }
};
function yr(t, e) {
  return e && (mt(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
}
function Yr(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t;
}
function n9(t, e) {
  const { element: n, datasetIndex: r, index: s } = e, i = t.getDatasetMeta(r).controller, { label: o, value: a } = i.getLabelAndValue(s);
  return {
    chart: t,
    label: o,
    parsed: i.getParsed(s),
    raw: t.data.datasets[r].data[s],
    formattedValue: a,
    dataset: i.getDataset(),
    dataIndex: s,
    datasetIndex: r,
    element: n
  };
}
function qw(t, e) {
  const n = t.chart.ctx, { body: r, footer: s, title: i } = t, { boxWidth: o, boxHeight: a } = e, c = Ft(e.bodyFont), l = Ft(e.titleFont), u = Ft(e.footerFont), d = i.length, f = s.length, h = r.length, p = ln(e.padding);
  let m = p.height, y = 0, b = r.reduce((x, A) => x + A.before.length + A.lines.length + A.after.length, 0);
  if (b += t.beforeBody.length + t.afterBody.length, d && (m += d * l.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), b) {
    const x = e.displayColors ? Math.max(a, c.lineHeight) : c.lineHeight;
    m += h * x + (b - h) * c.lineHeight + (b - 1) * e.bodySpacing;
  }
  f && (m += e.footerMarginTop + f * u.lineHeight + (f - 1) * e.footerSpacing);
  let v = 0;
  const w = function(x) {
    y = Math.max(y, n.measureText(x).width + v);
  };
  return n.save(), n.font = l.string, Xe(t.title, w), n.font = c.string, Xe(t.beforeBody.concat(t.afterBody), w), v = e.displayColors ? o + 2 + e.boxPadding : 0, Xe(r, (x) => {
    Xe(x.before, w), Xe(x.lines, w), Xe(x.after, w);
  }), v = 0, n.font = u.string, Xe(t.footer, w), n.restore(), y += p.width, {
    width: y,
    height: m
  };
}
function r9(t, e) {
  const { y: n, height: r } = e;
  return n < r / 2 ? "top" : n > t.height - r / 2 ? "bottom" : "center";
}
function s9(t, e, n, r) {
  const { x: s, width: i } = r, o = n.caretSize + n.caretPadding;
  if (t === "left" && s + i + o > e.width || t === "right" && s - i - o < 0)
    return !0;
}
function i9(t, e, n, r) {
  const { x: s, width: i } = n, { width: o, chartArea: { left: a, right: c } } = t;
  let l = "center";
  return r === "center" ? l = s <= (a + c) / 2 ? "left" : "right" : s <= i / 2 ? l = "left" : s >= o - i / 2 && (l = "right"), s9(l, t, e, n) && (l = "center"), l;
}
function Nw(t, e, n) {
  const r = n.yAlign || e.yAlign || r9(t, n);
  return {
    xAlign: n.xAlign || e.xAlign || i9(t, e, n, r),
    yAlign: r
  };
}
function o9(t, e) {
  let { x: n, width: r } = t;
  return e === "right" ? n -= r : e === "center" && (n -= r / 2), n;
}
function a9(t, e, n) {
  let { y: r, height: s } = t;
  return e === "top" ? r += n : e === "bottom" ? r -= s + n : r -= s / 2, r;
}
function Lw(t, e, n, r) {
  const { caretSize: s, caretPadding: i, cornerRadius: o } = t, { xAlign: a, yAlign: c } = n, l = s + i, { topLeft: u, topRight: d, bottomLeft: f, bottomRight: h } = Oi(o);
  let p = o9(e, a);
  const m = a9(e, c, l);
  return c === "center" ? a === "left" ? p += l : a === "right" && (p -= l) : a === "left" ? p -= Math.max(u, f) + s : a === "right" && (p += Math.max(d, h) + s), {
    x: Yt(p, 0, r.width - e.width),
    y: Yt(m, 0, r.height - e.height)
  };
}
function ou(t, e, n) {
  const r = ln(n.padding);
  return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - r.right : t.x + r.left;
}
function jw(t) {
  return yr([], Yr(t));
}
function c9(t, e, n) {
  return ui(t, {
    tooltip: e,
    tooltipItems: n,
    type: "tooltip"
  });
}
function Bw(t, e) {
  const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
  return n ? t.override(n) : t;
}
const MT = {
  beforeTitle: Wr,
  title(t) {
    if (t.length > 0) {
      const e = t[0], n = e.chart.data.labels, r = n ? n.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return e.dataset.label || "";
      if (e.label)
        return e.label;
      if (r > 0 && e.dataIndex < r)
        return n[e.dataIndex];
    }
    return "";
  },
  afterTitle: Wr,
  beforeBody: Wr,
  beforeLabel: Wr,
  label(t) {
    if (this && this.options && this.options.mode === "dataset")
      return t.label + ": " + t.formattedValue || t.formattedValue;
    let e = t.dataset.label || "";
    e && (e += ": ");
    const n = t.formattedValue;
    return je(n) || (e += n), e;
  },
  labelColor(t) {
    const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(t) {
    const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
    return {
      pointStyle: n.pointStyle,
      rotation: n.rotation
    };
  },
  afterLabel: Wr,
  afterBody: Wr,
  beforeFooter: Wr,
  footer: Wr,
  afterFooter: Wr
};
function Sn(t, e, n, r) {
  const s = t[e].call(n, r);
  return typeof s > "u" ? MT[e].call(n, r) : s;
}
class Lm extends ws {
  constructor(e) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(e) {
    this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const e = this._cachedAnimations;
    if (e)
      return e;
    const n = this.chart, r = this.options.setContext(this.getContext()), s = r.enabled && n.options.animation && r.animations, i = new lT(this.chart, s);
    return s._cacheable && (this._cachedAnimations = Object.freeze(i)), i;
  }
  getContext() {
    return this.$context || (this.$context = c9(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(e, n) {
    const { callbacks: r } = n, s = Sn(r, "beforeTitle", this, e), i = Sn(r, "title", this, e), o = Sn(r, "afterTitle", this, e);
    let a = [];
    return a = yr(a, Yr(s)), a = yr(a, Yr(i)), a = yr(a, Yr(o)), a;
  }
  getBeforeBody(e, n) {
    return jw(Sn(n.callbacks, "beforeBody", this, e));
  }
  getBody(e, n) {
    const { callbacks: r } = n, s = [];
    return Xe(e, (i) => {
      const o = {
        before: [],
        lines: [],
        after: []
      }, a = Bw(r, i);
      yr(o.before, Yr(Sn(a, "beforeLabel", this, i))), yr(o.lines, Sn(a, "label", this, i)), yr(o.after, Yr(Sn(a, "afterLabel", this, i))), s.push(o);
    }), s;
  }
  getAfterBody(e, n) {
    return jw(Sn(n.callbacks, "afterBody", this, e));
  }
  getFooter(e, n) {
    const { callbacks: r } = n, s = Sn(r, "beforeFooter", this, e), i = Sn(r, "footer", this, e), o = Sn(r, "afterFooter", this, e);
    let a = [];
    return a = yr(a, Yr(s)), a = yr(a, Yr(i)), a = yr(a, Yr(o)), a;
  }
  _createItems(e) {
    const n = this._active, r = this.chart.data, s = [], i = [], o = [];
    let a = [], c, l;
    for (c = 0, l = n.length; c < l; ++c)
      a.push(n9(this.chart, n[c]));
    return e.filter && (a = a.filter((u, d, f) => e.filter(u, d, f, r))), e.itemSort && (a = a.sort((u, d) => e.itemSort(u, d, r))), Xe(a, (u) => {
      const d = Bw(e.callbacks, u);
      s.push(Sn(d, "labelColor", this, u)), i.push(Sn(d, "labelPointStyle", this, u)), o.push(Sn(d, "labelTextColor", this, u));
    }), this.labelColors = s, this.labelPointStyles = i, this.labelTextColors = o, this.dataPoints = a, a;
  }
  update(e, n) {
    const r = this.options.setContext(this.getContext()), s = this._active;
    let i, o = [];
    if (!s.length)
      this.opacity !== 0 && (i = {
        opacity: 0
      });
    else {
      const a = uc[r.position].call(this, s, this._eventPosition);
      o = this._createItems(r), this.title = this.getTitle(o, r), this.beforeBody = this.getBeforeBody(o, r), this.body = this.getBody(o, r), this.afterBody = this.getAfterBody(o, r), this.footer = this.getFooter(o, r);
      const c = this._size = qw(this, r), l = Object.assign({}, a, c), u = Nw(this.chart, r, l), d = Lw(r, l, u, this.chart);
      this.xAlign = u.xAlign, this.yAlign = u.yAlign, i = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: c.width,
        height: c.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = o, this.$context = void 0, i && this._resolveAnimations().update(this, i), e && r.external && r.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: n
    });
  }
  drawCaret(e, n, r, s) {
    const i = this.getCaretPosition(e, r, s);
    n.lineTo(i.x1, i.y1), n.lineTo(i.x2, i.y2), n.lineTo(i.x3, i.y3);
  }
  getCaretPosition(e, n, r) {
    const { xAlign: s, yAlign: i } = this, { caretSize: o, cornerRadius: a } = r, { topLeft: c, topRight: l, bottomLeft: u, bottomRight: d } = Oi(a), { x: f, y: h } = e, { width: p, height: m } = n;
    let y, b, v, w, x, A;
    return i === "center" ? (x = h + m / 2, s === "left" ? (y = f, b = y - o, w = x + o, A = x - o) : (y = f + p, b = y + o, w = x - o, A = x + o), v = y) : (s === "left" ? b = f + Math.max(c, u) + o : s === "right" ? b = f + p - Math.max(l, d) - o : b = this.caretX, i === "top" ? (w = h, x = w - o, y = b - o, v = b + o) : (w = h + m, x = w + o, y = b + o, v = b - o), A = w), {
      x1: y,
      x2: b,
      x3: v,
      y1: w,
      y2: x,
      y3: A
    };
  }
  drawTitle(e, n, r) {
    const s = this.title, i = s.length;
    let o, a, c;
    if (i) {
      const l = Fo(r.rtl, this.x, this.width);
      for (e.x = ou(this, r.titleAlign, r), n.textAlign = l.textAlign(r.titleAlign), n.textBaseline = "middle", o = Ft(r.titleFont), a = r.titleSpacing, n.fillStyle = r.titleColor, n.font = o.string, c = 0; c < i; ++c)
        n.fillText(s[c], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, c + 1 === i && (e.y += r.titleMarginBottom - a);
    }
  }
  _drawColorBox(e, n, r, s, i) {
    const o = this.labelColors[r], a = this.labelPointStyles[r], { boxHeight: c, boxWidth: l } = i, u = Ft(i.bodyFont), d = ou(this, "left", i), f = s.x(d), h = c < u.lineHeight ? (u.lineHeight - c) / 2 : 0, p = n.y + h;
    if (i.usePointStyle) {
      const m = {
        radius: Math.min(l, c) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, y = s.leftForLtr(f, l) + l / 2, b = p + c / 2;
      e.strokeStyle = i.multiKeyBackground, e.fillStyle = i.multiKeyBackground, Mm(e, m, y, b), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, Mm(e, m, y, b);
    } else {
      e.lineWidth = Pe(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0;
      const m = s.leftForLtr(f, l), y = s.leftForLtr(s.xPlus(f, 1), l - 2), b = Oi(o.borderRadius);
      Object.values(b).some((v) => v !== 0) ? (e.beginPath(), e.fillStyle = i.multiKeyBackground, tl(e, {
        x: m,
        y: p,
        w: l,
        h: c,
        radius: b
      }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), tl(e, {
        x: y,
        y: p + 1,
        w: l - 2,
        h: c - 2,
        radius: b
      }), e.fill()) : (e.fillStyle = i.multiKeyBackground, e.fillRect(m, p, l, c), e.strokeRect(m, p, l, c), e.fillStyle = o.backgroundColor, e.fillRect(y, p + 1, l - 2, c - 2));
    }
    e.fillStyle = this.labelTextColors[r];
  }
  drawBody(e, n, r) {
    const { body: s } = this, { bodySpacing: i, bodyAlign: o, displayColors: a, boxHeight: c, boxWidth: l, boxPadding: u } = r, d = Ft(r.bodyFont);
    let f = d.lineHeight, h = 0;
    const p = Fo(r.rtl, this.x, this.width), m = function(_) {
      n.fillText(_, p.x(e.x + h), e.y + f / 2), e.y += f + i;
    }, y = p.textAlign(o);
    let b, v, w, x, A, C, S;
    for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, e.x = ou(this, y, r), n.fillStyle = r.bodyColor, Xe(this.beforeBody, m), h = a && y !== "right" ? o === "center" ? l / 2 + u : l + 2 + u : 0, x = 0, C = s.length; x < C; ++x) {
      for (b = s[x], v = this.labelTextColors[x], n.fillStyle = v, Xe(b.before, m), w = b.lines, a && w.length && (this._drawColorBox(n, e, x, p, r), f = Math.max(d.lineHeight, c)), A = 0, S = w.length; A < S; ++A)
        m(w[A]), f = d.lineHeight;
      Xe(b.after, m);
    }
    h = 0, f = d.lineHeight, Xe(this.afterBody, m), e.y -= i;
  }
  drawFooter(e, n, r) {
    const s = this.footer, i = s.length;
    let o, a;
    if (i) {
      const c = Fo(r.rtl, this.x, this.width);
      for (e.x = ou(this, r.footerAlign, r), e.y += r.footerMarginTop, n.textAlign = c.textAlign(r.footerAlign), n.textBaseline = "middle", o = Ft(r.footerFont), n.fillStyle = r.footerColor, n.font = o.string, a = 0; a < i; ++a)
        n.fillText(s[a], c.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + r.footerSpacing;
    }
  }
  drawBackground(e, n, r, s) {
    const { xAlign: i, yAlign: o } = this, { x: a, y: c } = e, { width: l, height: u } = r, { topLeft: d, topRight: f, bottomLeft: h, bottomRight: p } = Oi(s.cornerRadius);
    n.fillStyle = s.backgroundColor, n.strokeStyle = s.borderColor, n.lineWidth = s.borderWidth, n.beginPath(), n.moveTo(a + d, c), o === "top" && this.drawCaret(e, n, r, s), n.lineTo(a + l - f, c), n.quadraticCurveTo(a + l, c, a + l, c + f), o === "center" && i === "right" && this.drawCaret(e, n, r, s), n.lineTo(a + l, c + u - p), n.quadraticCurveTo(a + l, c + u, a + l - p, c + u), o === "bottom" && this.drawCaret(e, n, r, s), n.lineTo(a + h, c + u), n.quadraticCurveTo(a, c + u, a, c + u - h), o === "center" && i === "left" && this.drawCaret(e, n, r, s), n.lineTo(a, c + d), n.quadraticCurveTo(a, c, a + d, c), n.closePath(), n.fill(), s.borderWidth > 0 && n.stroke();
  }
  _updateAnimationTarget(e) {
    const n = this.chart, r = this.$animations, s = r && r.x, i = r && r.y;
    if (s || i) {
      const o = uc[e.position].call(this, this._active, this._eventPosition);
      if (!o)
        return;
      const a = this._size = qw(this, e), c = Object.assign({}, o, this._size), l = Nw(n, e, c), u = Lw(e, c, l, n);
      (s._to !== u.x || i._to !== u.y) && (this.xAlign = l.xAlign, this.yAlign = l.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, u));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(e) {
    const n = this.options.setContext(this.getContext());
    let r = this.opacity;
    if (!r)
      return;
    this._updateAnimationTarget(n);
    const s = {
      width: this.width,
      height: this.height
    }, i = {
      x: this.x,
      y: this.y
    };
    r = Math.abs(r) < 1e-3 ? 0 : r;
    const o = ln(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && a && (e.save(), e.globalAlpha = r, this.drawBackground(i, e, s, n), sT(e, n.textDirection), i.y += o.top, this.drawTitle(i, e, n), this.drawBody(i, e, n), this.drawFooter(i, e, n), iT(e, n.textDirection), e.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e, n) {
    const r = this._active, s = e.map(({ datasetIndex: a, index: c }) => {
      const l = this.chart.getDatasetMeta(a);
      if (!l)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: l.data[c],
        index: c
      };
    }), i = !Ld(r, s), o = this._positionChanged(s, n);
    (i || o) && (this._active = s, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(e, n, r = !0) {
    if (n && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const s = this.options, i = this._active || [], o = this._getActiveElements(e, i, n, r), a = this._positionChanged(o, e), c = n || !Ld(o, i) || a;
    return c && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {
      x: e.x,
      y: e.y
    }, this.update(!0, n))), c;
  }
  _getActiveElements(e, n, r, s) {
    const i = this.options;
    if (e.type === "mouseout")
      return [];
    if (!s)
      return n.filter((a) => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
    const o = this.chart.getElementsAtEventForMode(e, i.mode, i, r);
    return i.reverse && o.reverse(), o;
  }
  _positionChanged(e, n) {
    const { caretX: r, caretY: s, options: i } = this, o = uc[i.position].call(this, e, n);
    return o !== !1 && (r !== o.x || s !== o.y);
  }
}
K(Lm, "positioners", uc);
var l9 = {
  id: "tooltip",
  _element: Lm,
  positioners: uc,
  afterInit(t, e, n) {
    n && (t.tooltip = new Lm({
      chart: t,
      options: n
    }));
  },
  beforeUpdate(t, e, n) {
    t.tooltip && t.tooltip.initialize(n);
  },
  reset(t, e, n) {
    t.tooltip && t.tooltip.initialize(n);
  },
  afterDraw(t) {
    const e = t.tooltip;
    if (e && e._willRender()) {
      const n = {
        tooltip: e
      };
      if (t.notifyPlugins("beforeTooltipDraw", {
        ...n,
        cancelable: !0
      }) === !1)
        return;
      e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n);
    }
  },
  afterEvent(t, e) {
    if (t.tooltip) {
      const n = e.replay;
      t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (t, e) => e.bodyFont.size,
    boxWidth: (t, e) => e.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: MT
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (t) => t !== "filter" && t !== "itemSort" && t !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, u9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: Az,
  Decimation: _z,
  Filler: Yz,
  Legend: Xz,
  SubTitle: t9,
  Title: e9,
  Tooltip: l9
});
const d9 = (t, e, n, r) => (typeof e == "string" ? (n = t.push(e) - 1, r.unshift({
  index: n,
  label: e
})) : isNaN(e) && (n = null), n);
function f9(t, e, n, r) {
  const s = t.indexOf(e);
  if (s === -1)
    return d9(t, e, n, r);
  const i = t.lastIndexOf(e);
  return s !== i ? n : s;
}
const h9 = (t, e) => t === null ? null : Yt(Math.round(t), 0, e);
function Fw(t) {
  const e = this.getLabels();
  return t >= 0 && t < e.length ? e[t] : t;
}
class jm extends no {
  constructor(e) {
    super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(e) {
    const n = this._addedLabels;
    if (n.length) {
      const r = this.getLabels();
      for (const { index: s, label: i } of n)
        r[s] === i && r.splice(s, 1);
      this._addedLabels = [];
    }
    super.init(e);
  }
  parse(e, n) {
    if (je(e))
      return null;
    const r = this.getLabels();
    return n = isFinite(n) && r[n] === e ? n : f9(r, e, Ae(n, e), this._addedLabels), h9(n, r.length - 1);
  }
  determineDataLimits() {
    const { minDefined: e, maxDefined: n } = this.getUserBounds();
    let { min: r, max: s } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (e || (r = 0), n || (s = this.getLabels().length - 1)), this.min = r, this.max = s;
  }
  buildTicks() {
    const e = this.min, n = this.max, r = this.options.offset, s = [];
    let i = this.getLabels();
    i = e === 0 && n === i.length - 1 ? i : i.slice(e, n + 1), this._valueRange = Math.max(i.length - (r ? 0 : 1), 1), this._startValue = this.min - (r ? 0.5 : 0);
    for (let o = e; o <= n; o++)
      s.push({
        value: o
      });
    return s;
  }
  getLabelForValue(e) {
    return Fw.call(this, e);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(e) {
    return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getPixelForTick(e) {
    const n = this.ticks;
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value);
  }
  getValueForPixel(e) {
    return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
K(jm, "id", "category"), K(jm, "defaults", {
  ticks: {
    callback: Fw
  }
});
function p9(t, e) {
  const n = [], { bounds: s, step: i, min: o, max: a, precision: c, count: l, maxTicks: u, maxDigits: d, includeBounds: f } = t, h = i || 1, p = u - 1, { min: m, max: y } = e, b = !je(o), v = !je(a), w = !je(l), x = (y - m) / (d + 1);
  let A = Ox((y - m) / p / h) * h, C, S, _, T;
  if (A < 1e-14 && !b && !v)
    return [
      {
        value: m
      },
      {
        value: y
      }
    ];
  T = Math.ceil(y / A) - Math.floor(m / A), T > p && (A = Ox(T * A / p / h) * h), je(c) || (C = Math.pow(10, c), A = Math.ceil(A * C) / C), s === "ticks" ? (S = Math.floor(m / A) * A, _ = Math.ceil(y / A) * A) : (S = m, _ = y), b && v && i && cV((a - o) / i, A / 1e3) ? (T = Math.round(Math.min((a - o) / A, u)), A = (a - o) / T, S = o, _ = a) : w ? (S = b ? o : S, _ = v ? a : _, T = l - 1, A = (_ - S) / T) : (T = (_ - S) / A, vc(T, Math.round(T), A / 1e3) ? T = Math.round(T) : T = Math.ceil(T));
  const k = Math.max(qx(A), qx(S));
  C = Math.pow(10, je(c) ? k : c), S = Math.round(S * C) / C, _ = Math.round(_ * C) / C;
  let R = 0;
  for (b && (f && S !== o ? (n.push({
    value: o
  }), S < o && R++, vc(Math.round((S + R * A) * C) / C, o, Vw(o, x, t)) && R++) : S < o && R++); R < T; ++R) {
    const P = Math.round((S + R * A) * C) / C;
    if (v && P > a)
      break;
    n.push({
      value: P
    });
  }
  return v && f && _ !== a ? n.length && vc(n[n.length - 1].value, a, Vw(a, x, t)) ? n[n.length - 1].value = a : n.push({
    value: a
  }) : (!v || _ === a) && n.push({
    value: _
  }), n;
}
function Vw(t, e, { horizontal: n, minRotation: r }) {
  const s = or(r), i = (n ? Math.sin(s) : Math.cos(s)) || 1e-3, o = 0.75 * e * ("" + t).length;
  return Math.min(e / i, o);
}
class zd extends no {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(e, n) {
    return je(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
  }
  handleTickRangeOptions() {
    const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: r } = this.getUserBounds();
    let { min: s, max: i } = this;
    const o = (c) => s = n ? s : c, a = (c) => i = r ? i : c;
    if (e) {
      const c = Mr(s), l = Mr(i);
      c < 0 && l < 0 ? a(0) : c > 0 && l > 0 && o(0);
    }
    if (s === i) {
      let c = i === 0 ? 1 : Math.abs(i * 0.05);
      a(i + c), e || o(s - c);
    }
    this.min = s, this.max = i;
  }
  getTickLimit() {
    const e = this.options.ticks;
    let { maxTicksLimit: n, stepSize: r } = e, s;
    return r ? (s = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${s} ticks. Limiting to 1000.`), s = 1e3)) : (s = this.computeTickLimit(), n = n || 11), n && (s = Math.min(n, s)), s;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const e = this.options, n = e.ticks;
    let r = this.getTickLimit();
    r = Math.max(2, r);
    const s = {
      maxTicks: r,
      bounds: e.bounds,
      min: e.min,
      max: e.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== !1
    }, i = this._range || this, o = p9(s, i);
    return e.bounds === "ticks" && V_(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
  }
  configure() {
    const e = this.ticks;
    let n = this.min, r = this.max;
    if (super.configure(), this.options.offset && e.length) {
      const s = (r - n) / Math.max(e.length - 1, 1) / 2;
      n -= s, r += s;
    }
    this._startValue = n, this._endValue = r, this._valueRange = r - n;
  }
  getLabelForValue(e) {
    return Cl(e, this.chart.options.locale, this.options.ticks.format);
  }
}
class Bm extends zd {
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!0);
    this.min = Ct(e) ? e : 0, this.max = Ct(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const e = this.isHorizontal(), n = e ? this.width : this.height, r = or(this.options.ticks.minRotation), s = (e ? Math.sin(r) : Math.cos(r)) || 1e-3, i = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, i.lineHeight / s));
  }
  getPixelForValue(e) {
    return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
  }
}
K(Bm, "id", "linear"), K(Bm, "defaults", {
  ticks: {
    callback: Bf.formatters.numeric
  }
});
const rl = (t) => Math.floor(js(t)), xi = (t, e) => Math.pow(10, rl(t) + e);
function Uw(t) {
  return t / Math.pow(10, rl(t)) === 1;
}
function Ww(t, e, n) {
  const r = Math.pow(10, n), s = Math.floor(t / r);
  return Math.ceil(e / r) - s;
}
function m9(t, e) {
  const n = e - t;
  let r = rl(n);
  for (; Ww(t, e, r) > 10; )
    r++;
  for (; Ww(t, e, r) < 10; )
    r--;
  return Math.min(r, rl(t));
}
function g9(t, { min: e, max: n }) {
  e = On(t.min, e);
  const r = [], s = rl(e);
  let i = m9(e, n), o = i < 0 ? Math.pow(10, Math.abs(i)) : 1;
  const a = Math.pow(10, i), c = s > i ? Math.pow(10, s) : 0, l = Math.round((e - c) * o) / o, u = Math.floor((e - c) / a / 10) * a * 10;
  let d = Math.floor((l - u) / Math.pow(10, i)), f = On(t.min, Math.round((c + u + d * Math.pow(10, i)) * o) / o);
  for (; f < n; )
    r.push({
      value: f,
      major: Uw(f),
      significand: d
    }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (i++, d = 2, o = i >= 0 ? 1 : o), f = Math.round((c + u + d * Math.pow(10, i)) * o) / o;
  const h = On(t.max, f);
  return r.push({
    value: h,
    major: Uw(h),
    significand: d
  }), r;
}
class Fm extends no {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(e, n) {
    const r = zd.prototype.parse.apply(this, [
      e,
      n
    ]);
    if (r === 0) {
      this._zero = !0;
      return;
    }
    return Ct(r) && r > 0 ? r : null;
  }
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!0);
    this.min = Ct(e) ? Math.max(0, e) : null, this.max = Ct(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Ct(this._userMin) && (this.min = e === xi(this.min, 0) ? xi(this.min, -1) : xi(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: e, maxDefined: n } = this.getUserBounds();
    let r = this.min, s = this.max;
    const i = (a) => r = e ? r : a, o = (a) => s = n ? s : a;
    r === s && (r <= 0 ? (i(1), o(10)) : (i(xi(r, -1)), o(xi(s, 1)))), r <= 0 && i(xi(s, -1)), s <= 0 && o(xi(r, 1)), this.min = r, this.max = s;
  }
  buildTicks() {
    const e = this.options, n = {
      min: this._userMin,
      max: this._userMax
    }, r = g9(n, this);
    return e.bounds === "ticks" && V_(r, this, "value"), e.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;
  }
  getLabelForValue(e) {
    return e === void 0 ? "0" : Cl(e, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const e = this.min;
    super.configure(), this._startValue = js(e), this._valueRange = js(this.max) - js(e);
  }
  getPixelForValue(e) {
    return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (js(e) - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    const n = this.getDecimalForPixel(e);
    return Math.pow(10, this._startValue + n * this._valueRange);
  }
}
K(Fm, "id", "logarithmic"), K(Fm, "defaults", {
  ticks: {
    callback: Bf.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function Vm(t) {
  const e = t.ticks;
  if (e.display && t.display) {
    const n = ln(e.backdropPadding);
    return Ae(e.font && e.font.size, _t.font.size) + n.height;
  }
  return 0;
}
function y9(t, e, n) {
  return n = mt(n) ? n : [
    n
  ], {
    w: CV(t, e.string, n),
    h: n.length * e.lineHeight
  };
}
function zw(t, e, n, r, s) {
  return t === r || t === s ? {
    start: e - n / 2,
    end: e + n / 2
  } : t < r || t > s ? {
    start: e - n,
    end: e
  } : {
    start: e,
    end: e + n
  };
}
function b9(t) {
  const e = {
    l: t.left + t._padding.left,
    r: t.right - t._padding.right,
    t: t.top + t._padding.top,
    b: t.bottom - t._padding.bottom
  }, n = Object.assign({}, e), r = [], s = [], i = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? ht / i : 0;
  for (let c = 0; c < i; c++) {
    const l = o.setContext(t.getPointLabelContext(c));
    s[c] = l.padding;
    const u = t.getPointPosition(c, t.drawingArea + s[c], a), d = Ft(l.font), f = y9(t.ctx, d, t._pointLabels[c]);
    r[c] = f;
    const h = Nn(t.getIndexAngle(c) + a), p = Math.round(jy(h)), m = zw(p, u.x, f.w, 0, 180), y = zw(p, u.y, f.h, 90, 270);
    v9(n, e, h, m, y);
  }
  t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = A9(t, r, s);
}
function v9(t, e, n, r, s) {
  const i = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n));
  let a = 0, c = 0;
  r.start < e.l ? (a = (e.l - r.start) / i, t.l = Math.min(t.l, e.l - a)) : r.end > e.r && (a = (r.end - e.r) / i, t.r = Math.max(t.r, e.r + a)), s.start < e.t ? (c = (e.t - s.start) / o, t.t = Math.min(t.t, e.t - c)) : s.end > e.b && (c = (s.end - e.b) / o, t.b = Math.max(t.b, e.b + c));
}
function x9(t, e, n) {
  const r = t.drawingArea, { extra: s, additionalAngle: i, padding: o, size: a } = n, c = t.getPointPosition(e, r + s + o, i), l = Math.round(jy(Nn(c.angle + It))), u = C9(c.y, a.h, l), d = S9(l), f = E9(c.x, a.w, d);
  return {
    visible: !0,
    x: c.x,
    y: u,
    textAlign: d,
    left: f,
    top: u,
    right: f + a.w,
    bottom: u + a.h
  };
}
function w9(t, e) {
  if (!e)
    return !0;
  const { left: n, top: r, right: s, bottom: i } = t;
  return !(ts({
    x: n,
    y: r
  }, e) || ts({
    x: n,
    y: i
  }, e) || ts({
    x: s,
    y: r
  }, e) || ts({
    x: s,
    y: i
  }, e));
}
function A9(t, e, n) {
  const r = [], s = t._pointLabels.length, i = t.options, { centerPointLabels: o, display: a } = i.pointLabels, c = {
    extra: Vm(i) / 2,
    additionalAngle: o ? ht / s : 0
  };
  let l;
  for (let u = 0; u < s; u++) {
    c.padding = n[u], c.size = e[u];
    const d = x9(t, u, c);
    r.push(d), a === "auto" && (d.visible = w9(d, l), d.visible && (l = d));
  }
  return r;
}
function S9(t) {
  return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right";
}
function E9(t, e, n) {
  return n === "right" ? t -= e : n === "center" && (t -= e / 2), t;
}
function C9(t, e, n) {
  return n === 90 || n === 270 ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t;
}
function _9(t, e, n) {
  const { left: r, top: s, right: i, bottom: o } = n, { backdropColor: a } = e;
  if (!je(a)) {
    const c = Oi(e.borderRadius), l = ln(e.backdropPadding);
    t.fillStyle = a;
    const u = r - l.left, d = s - l.top, f = i - r + l.width, h = o - s + l.height;
    Object.values(c).some((p) => p !== 0) ? (t.beginPath(), tl(t, {
      x: u,
      y: d,
      w: f,
      h,
      radius: c
    }), t.fill()) : t.fillRect(u, d, f, h);
  }
}
function T9(t, e) {
  const { ctx: n, options: { pointLabels: r } } = t;
  for (let s = e - 1; s >= 0; s--) {
    const i = t._pointLabelItems[s];
    if (!i.visible)
      continue;
    const o = r.setContext(t.getPointLabelContext(s));
    _9(n, o, i);
    const a = Ft(o.font), { x: c, y: l, textAlign: u } = i;
    Ki(n, t._pointLabels[s], c, l + a.lineHeight / 2, a, {
      color: o.color,
      textAlign: u,
      textBaseline: "middle"
    });
  }
}
function PT(t, e, n, r) {
  const { ctx: s } = t;
  if (n)
    s.arc(t.xCenter, t.yCenter, e, 0, ft);
  else {
    let i = t.getPointPosition(0, e);
    s.moveTo(i.x, i.y);
    for (let o = 1; o < r; o++)
      i = t.getPointPosition(o, e), s.lineTo(i.x, i.y);
  }
}
function k9(t, e, n, r, s) {
  const i = t.ctx, o = e.circular, { color: a, lineWidth: c } = e;
  !o && !r || !a || !c || n < 0 || (i.save(), i.strokeStyle = a, i.lineWidth = c, i.setLineDash(s.dash), i.lineDashOffset = s.dashOffset, i.beginPath(), PT(t, n, o, r), i.closePath(), i.stroke(), i.restore());
}
function R9(t, e, n) {
  return ui(t, {
    label: n,
    index: e,
    type: "pointLabel"
  });
}
class dc extends zd {
  constructor(e) {
    super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const e = this._padding = ln(Vm(this.options) / 2), n = this.width = this.maxWidth - e.width, r = this.height = this.maxHeight - e.height;
    this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + r / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, r) / 2);
  }
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(!1);
    this.min = Ct(e) && !isNaN(e) ? e : 0, this.max = Ct(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / Vm(this.options));
  }
  generateTickLabels(e) {
    zd.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, r) => {
      const s = ut(this.options.pointLabels.callback, [
        n,
        r
      ], this);
      return s || s === 0 ? s : "";
    }).filter((n, r) => this.chart.getDataVisibility(r));
  }
  fit() {
    const e = this.options;
    e.display && e.pointLabels.display ? b9(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(e, n, r, s) {
    this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((r - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, r, s));
  }
  getIndexAngle(e) {
    const n = ft / (this._pointLabels.length || 1), r = this.options.startAngle || 0;
    return Nn(e * n + or(r));
  }
  getDistanceFromCenterForValue(e) {
    if (je(e))
      return NaN;
    const n = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - e) * n : (e - this.min) * n;
  }
  getValueForDistanceFromCenter(e) {
    if (je(e))
      return NaN;
    const n = e / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - n : this.min + n;
  }
  getPointLabelContext(e) {
    const n = this._pointLabels || [];
    if (e >= 0 && e < n.length) {
      const r = n[e];
      return R9(this.getContext(), e, r);
    }
  }
  getPointPosition(e, n, r = 0) {
    const s = this.getIndexAngle(e) - It + r;
    return {
      x: Math.cos(s) * n + this.xCenter,
      y: Math.sin(s) * n + this.yCenter,
      angle: s
    };
  }
  getPointPositionForValue(e, n) {
    return this.getPointPosition(e, this.getDistanceFromCenterForValue(n));
  }
  getBasePosition(e) {
    return this.getPointPositionForValue(e || 0, this.getBaseValue());
  }
  getPointLabelPosition(e) {
    const { left: n, top: r, right: s, bottom: i } = this._pointLabelItems[e];
    return {
      left: n,
      top: r,
      right: s,
      bottom: i
    };
  }
  drawBackground() {
    const { backgroundColor: e, grid: { circular: n } } = this.options;
    if (e) {
      const r = this.ctx;
      r.save(), r.beginPath(), PT(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), r.closePath(), r.fillStyle = e, r.fill(), r.restore();
    }
  }
  drawGrid() {
    const e = this.ctx, n = this.options, { angleLines: r, grid: s, border: i } = n, o = this._pointLabels.length;
    let a, c, l;
    if (n.pointLabels.display && T9(this, o), s.display && this.ticks.forEach((u, d) => {
      if (d !== 0 || d === 0 && this.min < 0) {
        c = this.getDistanceFromCenterForValue(u.value);
        const f = this.getContext(d), h = s.setContext(f), p = i.setContext(f);
        k9(this, h, c, o, p);
      }
    }), r.display) {
      for (e.save(), a = o - 1; a >= 0; a--) {
        const u = r.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: f } = u;
        !f || !d || (e.lineWidth = f, e.strokeStyle = d, e.setLineDash(u.borderDash), e.lineDashOffset = u.borderDashOffset, c = this.getDistanceFromCenterForValue(n.reverse ? this.min : this.max), l = this.getPointPosition(a, c), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(l.x, l.y), e.stroke());
      }
      e.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const e = this.ctx, n = this.options, r = n.ticks;
    if (!r.display)
      return;
    const s = this.getIndexAngle(0);
    let i, o;
    e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(s), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, c) => {
      if (c === 0 && this.min >= 0 && !n.reverse)
        return;
      const l = r.setContext(this.getContext(c)), u = Ft(l.font);
      if (i = this.getDistanceFromCenterForValue(this.ticks[c].value), l.showLabelBackdrop) {
        e.font = u.string, o = e.measureText(a.label).width, e.fillStyle = l.backdropColor;
        const d = ln(l.backdropPadding);
        e.fillRect(-o / 2 - d.left, -i - u.size / 2 - d.top, o + d.width, u.size + d.height);
      }
      Ki(e, a.label, 0, -i, u, {
        color: l.color,
        strokeColor: l.textStrokeColor,
        strokeWidth: l.textStrokeWidth
      });
    }), e.restore();
  }
  drawTitle() {
  }
}
K(dc, "id", "radialLinear"), K(dc, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: Bf.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(e) {
      return e;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), K(dc, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), K(dc, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const Wf = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Cn = /* @__PURE__ */ Object.keys(Wf);
function Hw(t, e) {
  return t - e;
}
function Yw(t, e) {
  if (je(e))
    return null;
  const n = t._adapter, { parser: r, round: s, isoWeekday: i } = t._parseOpts;
  let o = e;
  return typeof r == "function" && (o = r(o)), Ct(o) || (o = typeof r == "string" ? n.parse(o, r) : n.parse(o)), o === null ? null : (s && (o = s === "week" && (ta(i) || i === !0) ? n.startOf(o, "isoWeek", i) : n.startOf(o, s)), +o);
}
function Gw(t, e, n, r) {
  const s = Cn.length;
  for (let i = Cn.indexOf(t); i < s - 1; ++i) {
    const o = Wf[Cn[i]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
    if (o.common && Math.ceil((n - e) / (a * o.size)) <= r)
      return Cn[i];
  }
  return Cn[s - 1];
}
function M9(t, e, n, r, s) {
  for (let i = Cn.length - 1; i >= Cn.indexOf(n); i--) {
    const o = Cn[i];
    if (Wf[o].common && t._adapter.diff(s, r, o) >= e - 1)
      return o;
  }
  return Cn[n ? Cn.indexOf(n) : 0];
}
function P9(t) {
  for (let e = Cn.indexOf(t) + 1, n = Cn.length; e < n; ++e)
    if (Wf[Cn[e]].common)
      return Cn[e];
}
function Kw(t, e, n) {
  if (!n)
    t[e] = !0;
  else if (n.length) {
    const { lo: r, hi: s } = By(n, e), i = n[r] >= e ? n[r] : n[s];
    t[i] = !0;
  }
}
function I9(t, e, n, r) {
  const s = t._adapter, i = +s.startOf(e[0].value, r), o = e[e.length - 1].value;
  let a, c;
  for (a = i; a <= o; a = +s.add(a, 1, r))
    c = n[a], c >= 0 && (e[c].major = !0);
  return e;
}
function $w(t, e, n) {
  const r = [], s = {}, i = e.length;
  let o, a;
  for (o = 0; o < i; ++o)
    a = e[o], s[a] = o, r.push({
      value: a,
      major: !1
    });
  return i === 0 || !n ? r : I9(t, r, s, n);
}
class sl extends no {
  constructor(e) {
    super(e), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(e, n = {}) {
    const r = e.time || (e.time = {}), s = this._adapter = new VU._date(e.adapters.date);
    s.init(n), bc(r.displayFormats, s.formats()), this._parseOpts = {
      parser: r.parser,
      round: r.round,
      isoWeekday: r.isoWeekday
    }, super.init(e), this._normalized = n.normalized;
  }
  parse(e, n) {
    return e === void 0 ? null : Yw(this, e);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const e = this.options, n = this._adapter, r = e.time.unit || "day";
    let { min: s, max: i, minDefined: o, maxDefined: a } = this.getUserBounds();
    function c(l) {
      !o && !isNaN(l.min) && (s = Math.min(s, l.min)), !a && !isNaN(l.max) && (i = Math.max(i, l.max));
    }
    (!o || !a) && (c(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && c(this.getMinMax(!1))), s = Ct(s) && !isNaN(s) ? s : +n.startOf(Date.now(), r), i = Ct(i) && !isNaN(i) ? i : +n.endOf(Date.now(), r) + 1, this.min = Math.min(s, i - 1), this.max = Math.max(s + 1, i);
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY;
    return e.length && (n = e[0], r = e[e.length - 1]), {
      min: n,
      max: r
    };
  }
  buildTicks() {
    const e = this.options, n = e.time, r = e.ticks, s = r.source === "labels" ? this.getLabelTimestamps() : this._generate();
    e.bounds === "ticks" && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);
    const i = this.min, o = this.max, a = fV(s, i, o);
    return this._unit = n.unit || (r.autoSkip ? Gw(n.minUnit, this.min, this.max, this._getLabelCapacity(i)) : M9(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : P9(this._unit), this.initOffsets(s), e.reverse && a.reverse(), $w(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
  }
  initOffsets(e = []) {
    let n = 0, r = 0, s, i;
    this.options.offset && e.length && (s = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - s : n = (this.getDecimalForValue(e[1]) - s) / 2, i = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? r = i : r = (i - this.getDecimalForValue(e[e.length - 2])) / 2);
    const o = e.length < 3 ? 0.5 : 0.25;
    n = Yt(n, 0, o), r = Yt(r, 0, o), this._offsets = {
      start: n,
      end: r,
      factor: 1 / (n + 1 + r)
    };
  }
  _generate() {
    const e = this._adapter, n = this.min, r = this.max, s = this.options, i = s.time, o = i.unit || Gw(i.minUnit, n, r, this._getLabelCapacity(n)), a = Ae(s.ticks.stepSize, 1), c = o === "week" ? i.isoWeekday : !1, l = ta(c) || c === !0, u = {};
    let d = n, f, h;
    if (l && (d = +e.startOf(d, "isoWeek", c)), d = +e.startOf(d, l ? "day" : o), e.diff(r, n, o) > 1e5 * a)
      throw new Error(n + " and " + r + " are too far apart with stepSize of " + a + " " + o);
    const p = s.ticks.source === "data" && this.getDataTimestamps();
    for (f = d, h = 0; f < r; f = +e.add(f, a, o), h++)
      Kw(u, f, p);
    return (f === r || s.bounds === "ticks" || h === 1) && Kw(u, f, p), Object.keys(u).sort(Hw).map((m) => +m);
  }
  getLabelForValue(e) {
    const n = this._adapter, r = this.options.time;
    return r.tooltipFormat ? n.format(e, r.tooltipFormat) : n.format(e, r.displayFormats.datetime);
  }
  format(e, n) {
    const s = this.options.time.displayFormats, i = this._unit, o = n || s[i];
    return this._adapter.format(e, o);
  }
  _tickFormatFunction(e, n, r, s) {
    const i = this.options, o = i.ticks.callback;
    if (o)
      return ut(o, [
        e,
        n,
        r
      ], this);
    const a = i.time.displayFormats, c = this._unit, l = this._majorUnit, u = c && a[c], d = l && a[l], f = r[n], h = l && d && f && f.major;
    return this._adapter.format(e, s || (h ? d : u));
  }
  generateTickLabels(e) {
    let n, r, s;
    for (n = 0, r = e.length; n < r; ++n)
      s = e[n], s.label = this._tickFormatFunction(s.value, n, e);
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min);
  }
  getPixelForValue(e) {
    const n = this._offsets, r = this.getDecimalForValue(e);
    return this.getPixelForDecimal((n.start + r) * n.factor);
  }
  getValueForPixel(e) {
    const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end;
    return this.min + r * (this.max - this.min);
  }
  _getLabelSize(e) {
    const n = this.options.ticks, r = this.ctx.measureText(e).width, s = or(this.isHorizontal() ? n.maxRotation : n.minRotation), i = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;
    return {
      w: r * i + a * o,
      h: r * o + a * i
    };
  }
  _getLabelCapacity(e) {
    const n = this.options.time, r = n.displayFormats, s = r[n.unit] || r.millisecond, i = this._tickFormatFunction(e, 0, $w(this, [
      e
    ], this._majorUnit), s), o = this._getLabelSize(i), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let e = this._cache.data || [], n, r;
    if (e.length)
      return e;
    const s = this.getMatchingVisibleMetas();
    if (this._normalized && s.length)
      return this._cache.data = s[0].controller.getAllParsedValues(this);
    for (n = 0, r = s.length; n < r; ++n)
      e = e.concat(s[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(e);
  }
  getLabelTimestamps() {
    const e = this._cache.labels || [];
    let n, r;
    if (e.length)
      return e;
    const s = this.getLabels();
    for (n = 0, r = s.length; n < r; ++n)
      e.push(Yw(this, s[n]));
    return this._cache.labels = this._normalized ? e : this.normalize(e);
  }
  normalize(e) {
    return z_(e.sort(Hw));
  }
}
K(sl, "id", "time"), K(sl, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function au(t, e, n) {
  let r = 0, s = t.length - 1, i, o, a, c;
  n ? (e >= t[r].pos && e <= t[s].pos && ({ lo: r, hi: s } = es(t, "pos", e)), { pos: i, time: a } = t[r], { pos: o, time: c } = t[s]) : (e >= t[r].time && e <= t[s].time && ({ lo: r, hi: s } = es(t, "time", e)), { time: i, pos: a } = t[r], { time: o, pos: c } = t[s]);
  const l = o - i;
  return l ? a + (c - a) * (e - i) / l : a;
}
class Um extends sl {
  constructor(e) {
    super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e);
    this._minPos = au(n, this.min), this._tableRange = au(n, this.max) - this._minPos, super.initOffsets(e);
  }
  buildLookupTable(e) {
    const { min: n, max: r } = this, s = [], i = [];
    let o, a, c, l, u;
    for (o = 0, a = e.length; o < a; ++o)
      l = e[o], l >= n && l <= r && s.push(l);
    if (s.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: r,
          pos: 1
        }
      ];
    for (o = 0, a = s.length; o < a; ++o)
      u = s[o + 1], c = s[o - 1], l = s[o], Math.round((u + c) / 2) !== l && i.push({
        time: l,
        pos: o / (a - 1)
      });
    return i;
  }
  _generate() {
    const e = this.min, n = this.max;
    let r = super.getDataTimestamps();
    return (!r.includes(e) || !r.length) && r.splice(0, 0, e), (!r.includes(n) || r.length === 1) && r.push(n), r.sort((s, i) => s - i);
  }
  _getTimestampsForTable() {
    let e = this._cache.all || [];
    if (e.length)
      return e;
    const n = this.getDataTimestamps(), r = this.getLabelTimestamps();
    return n.length && r.length ? e = this.normalize(n.concat(r)) : e = n.length ? n : r, e = this._cache.all = e, e;
  }
  getDecimalForValue(e) {
    return (au(this._table, e) - this._minPos) / this._tableRange;
  }
  getValueForPixel(e) {
    const n = this._offsets, r = this.getDecimalForPixel(e) / n.factor - n.end;
    return au(this._table, r * this._tableRange + this._minPos, !0);
  }
}
K(Um, "id", "timeseries"), K(Um, "defaults", sl.defaults);
var D9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: jm,
  LinearScale: Bm,
  LogarithmicScale: Fm,
  RadialLinearScale: dc,
  TimeScale: sl,
  TimeSeriesScale: Um
});
const O9 = [
  FU,
  gz,
  u9,
  D9
];
Zr.register(...O9);
var zf = { exports: {} }, IT = {}, DT = { exports: {} }, OT = { exports: {} }, Ze = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function() {
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, s = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, o = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, l = t ? Symbol.for("react.concurrent_mode") : 60111, u = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, h = t ? Symbol.for("react.memo") : 60115, p = t ? Symbol.for("react.lazy") : 60116, m = t ? Symbol.for("react.block") : 60121, y = t ? Symbol.for("react.fundamental") : 60117, b = t ? Symbol.for("react.responder") : 60118, v = t ? Symbol.for("react.scope") : 60119;
  function w(F) {
    return typeof F == "string" || typeof F == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
    F === r || F === l || F === i || F === s || F === d || F === f || typeof F == "object" && F !== null && (F.$$typeof === p || F.$$typeof === h || F.$$typeof === o || F.$$typeof === a || F.$$typeof === u || F.$$typeof === y || F.$$typeof === b || F.$$typeof === v || F.$$typeof === m);
  }
  function x(F) {
    if (typeof F == "object" && F !== null) {
      var ee = F.$$typeof;
      switch (ee) {
        case e:
          var re = F.type;
          switch (re) {
            case c:
            case l:
            case r:
            case i:
            case s:
            case d:
              return re;
            default:
              var nt = re && re.$$typeof;
              switch (nt) {
                case a:
                case u:
                case p:
                case h:
                case o:
                  return nt;
                default:
                  return ee;
              }
          }
        case n:
          return ee;
      }
    }
  }
  var A = c, C = l, S = a, _ = o, T = e, k = u, R = r, P = p, M = h, D = n, O = i, q = s, L = d, N = !1;
  function j(F) {
    return N || (N = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), V(F) || x(F) === c;
  }
  function V(F) {
    return x(F) === l;
  }
  function Z(F) {
    return x(F) === a;
  }
  function G(F) {
    return x(F) === o;
  }
  function $(F) {
    return typeof F == "object" && F !== null && F.$$typeof === e;
  }
  function fe(F) {
    return x(F) === u;
  }
  function he(F) {
    return x(F) === r;
  }
  function be(F) {
    return x(F) === p;
  }
  function He(F) {
    return x(F) === h;
  }
  function at(F) {
    return x(F) === n;
  }
  function xt(F) {
    return x(F) === i;
  }
  function tt(F) {
    return x(F) === s;
  }
  function wt(F) {
    return x(F) === d;
  }
  Ze.AsyncMode = A, Ze.ConcurrentMode = C, Ze.ContextConsumer = S, Ze.ContextProvider = _, Ze.Element = T, Ze.ForwardRef = k, Ze.Fragment = R, Ze.Lazy = P, Ze.Memo = M, Ze.Portal = D, Ze.Profiler = O, Ze.StrictMode = q, Ze.Suspense = L, Ze.isAsyncMode = j, Ze.isConcurrentMode = V, Ze.isContextConsumer = Z, Ze.isContextProvider = G, Ze.isElement = $, Ze.isForwardRef = fe, Ze.isFragment = he, Ze.isLazy = be, Ze.isMemo = He, Ze.isPortal = at, Ze.isProfiler = xt, Ze.isStrictMode = tt, Ze.isSuspense = wt, Ze.isValidElementType = w, Ze.typeOf = x;
})();
OT.exports = Ze;
var qT = OT.exports;
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Zw = Object.getOwnPropertySymbols, q9 = Object.prototype.hasOwnProperty, N9 = Object.prototype.propertyIsEnumerable;
function L9(t) {
  if (t == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(t);
}
function j9() {
  try {
    if (!Object.assign)
      return !1;
    var t = new String("abc");
    if (t[5] = "de", Object.getOwnPropertyNames(t)[0] === "5")
      return !1;
    for (var e = {}, n = 0; n < 10; n++)
      e["_" + String.fromCharCode(n)] = n;
    var r = Object.getOwnPropertyNames(e).map(function(i) {
      return e[i];
    });
    if (r.join("") !== "0123456789")
      return !1;
    var s = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(i) {
      s[i] = i;
    }), Object.keys(Object.assign({}, s)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var B9 = j9() ? Object.assign : function(t, e) {
  for (var n, r = L9(t), s, i = 1; i < arguments.length; i++) {
    n = Object(arguments[i]);
    for (var o in n)
      q9.call(n, o) && (r[o] = n[o]);
    if (Zw) {
      s = Zw(n);
      for (var a = 0; a < s.length; a++)
        N9.call(n, s[a]) && (r[s[a]] = n[s[a]]);
    }
  }
  return r;
}, F9 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", NT = F9, LT = Function.call.bind(Object.prototype.hasOwnProperty), Wm = function() {
};
{
  var V9 = NT, zm = {}, U9 = LT;
  Wm = function(t) {
    var e = "Warning: " + t;
    typeof console < "u" && console.error(e);
    try {
      throw new Error(e);
    } catch {
    }
  };
}
function jT(t, e, n, r, s) {
  for (var i in t)
    if (U9(t, i)) {
      var o;
      try {
        if (typeof t[i] != "function") {
          var a = Error(
            (r || "React class") + ": " + n + " type `" + i + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof t[i] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
          );
          throw a.name = "Invariant Violation", a;
        }
        o = t[i](e, i, r, n, null, V9);
      } catch (l) {
        o = l;
      }
      if (o && !(o instanceof Error) && Wm(
        (r || "React class") + ": type specification of " + n + " `" + i + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof o + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
      ), o instanceof Error && !(o.message in zm)) {
        zm[o.message] = !0;
        var c = s ? s() : "";
        Wm(
          "Failed " + n + " type: " + o.message + (c ?? "")
        );
      }
    }
}
jT.resetWarningCache = function() {
  zm = {};
};
var W9 = jT, z9 = qT, H9 = B9, mo = NT, fp = LT, Qw = W9, wo = function() {
};
wo = function(t) {
  var e = "Warning: " + t;
  typeof console < "u" && console.error(e);
  try {
    throw new Error(e);
  } catch {
  }
};
function cu() {
  return null;
}
var Y9 = function(t, e) {
  var n = typeof Symbol == "function" && Symbol.iterator, r = "@@iterator";
  function s(M) {
    var D = M && (n && M[n] || M[r]);
    if (typeof D == "function")
      return D;
  }
  var i = "<<anonymous>>", o = {
    array: u("array"),
    bigint: u("bigint"),
    bool: u("boolean"),
    func: u("function"),
    number: u("number"),
    object: u("object"),
    string: u("string"),
    symbol: u("symbol"),
    any: d(),
    arrayOf: f,
    element: h(),
    elementType: p(),
    instanceOf: m,
    node: w(),
    objectOf: b,
    oneOf: y,
    oneOfType: v,
    shape: A,
    exact: C
  };
  function a(M, D) {
    return M === D ? M !== 0 || 1 / M === 1 / D : M !== M && D !== D;
  }
  function c(M, D) {
    this.message = M, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
  }
  c.prototype = Error.prototype;
  function l(M) {
    var D = {}, O = 0;
    function q(N, j, V, Z, G, $, fe) {
      if (Z = Z || i, $ = $ || V, fe !== mo) {
        if (e) {
          var he = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw he.name = "Invariant Violation", he;
        } else if (typeof console < "u") {
          var be = Z + ":" + V;
          !D[be] && // Avoid spamming the console because they are often not actionable except for lib authors
          O < 3 && (wo(
            "You are manually calling a React.PropTypes validation function for the `" + $ + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
          ), D[be] = !0, O++);
        }
      }
      return j[V] == null ? N ? j[V] === null ? new c("The " + G + " `" + $ + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new c("The " + G + " `" + $ + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : M(j, V, Z, G, $);
    }
    var L = q.bind(null, !1);
    return L.isRequired = q.bind(null, !0), L;
  }
  function u(M) {
    function D(O, q, L, N, j, V) {
      var Z = O[q], G = T(Z);
      if (G !== M) {
        var $ = k(Z);
        return new c(
          "Invalid " + N + " `" + j + "` of type " + ("`" + $ + "` supplied to `" + L + "`, expected ") + ("`" + M + "`."),
          { expectedType: M }
        );
      }
      return null;
    }
    return l(D);
  }
  function d() {
    return l(cu);
  }
  function f(M) {
    function D(O, q, L, N, j) {
      if (typeof M != "function")
        return new c("Property `" + j + "` of component `" + L + "` has invalid PropType notation inside arrayOf.");
      var V = O[q];
      if (!Array.isArray(V)) {
        var Z = T(V);
        return new c("Invalid " + N + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + L + "`, expected an array."));
      }
      for (var G = 0; G < V.length; G++) {
        var $ = M(V, G, L, N, j + "[" + G + "]", mo);
        if ($ instanceof Error)
          return $;
      }
      return null;
    }
    return l(D);
  }
  function h() {
    function M(D, O, q, L, N) {
      var j = D[O];
      if (!t(j)) {
        var V = T(j);
        return new c("Invalid " + L + " `" + N + "` of type " + ("`" + V + "` supplied to `" + q + "`, expected a single ReactElement."));
      }
      return null;
    }
    return l(M);
  }
  function p() {
    function M(D, O, q, L, N) {
      var j = D[O];
      if (!z9.isValidElementType(j)) {
        var V = T(j);
        return new c("Invalid " + L + " `" + N + "` of type " + ("`" + V + "` supplied to `" + q + "`, expected a single ReactElement type."));
      }
      return null;
    }
    return l(M);
  }
  function m(M) {
    function D(O, q, L, N, j) {
      if (!(O[q] instanceof M)) {
        var V = M.name || i, Z = P(O[q]);
        return new c("Invalid " + N + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + L + "`, expected ") + ("instance of `" + V + "`."));
      }
      return null;
    }
    return l(D);
  }
  function y(M) {
    if (!Array.isArray(M))
      return arguments.length > 1 ? wo(
        "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
      ) : wo("Invalid argument supplied to oneOf, expected an array."), cu;
    function D(O, q, L, N, j) {
      for (var V = O[q], Z = 0; Z < M.length; Z++)
        if (a(V, M[Z]))
          return null;
      var G = JSON.stringify(M, function(fe, he) {
        var be = k(he);
        return be === "symbol" ? String(he) : he;
      });
      return new c("Invalid " + N + " `" + j + "` of value `" + String(V) + "` " + ("supplied to `" + L + "`, expected one of " + G + "."));
    }
    return l(D);
  }
  function b(M) {
    function D(O, q, L, N, j) {
      if (typeof M != "function")
        return new c("Property `" + j + "` of component `" + L + "` has invalid PropType notation inside objectOf.");
      var V = O[q], Z = T(V);
      if (Z !== "object")
        return new c("Invalid " + N + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + L + "`, expected an object."));
      for (var G in V)
        if (fp(V, G)) {
          var $ = M(V, G, L, N, j + "." + G, mo);
          if ($ instanceof Error)
            return $;
        }
      return null;
    }
    return l(D);
  }
  function v(M) {
    if (!Array.isArray(M))
      return wo("Invalid argument supplied to oneOfType, expected an instance of array."), cu;
    for (var D = 0; D < M.length; D++) {
      var O = M[D];
      if (typeof O != "function")
        return wo(
          "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + R(O) + " at index " + D + "."
        ), cu;
    }
    function q(L, N, j, V, Z) {
      for (var G = [], $ = 0; $ < M.length; $++) {
        var fe = M[$], he = fe(L, N, j, V, Z, mo);
        if (he == null)
          return null;
        he.data && fp(he.data, "expectedType") && G.push(he.data.expectedType);
      }
      var be = G.length > 0 ? ", expected one of type [" + G.join(", ") + "]" : "";
      return new c("Invalid " + V + " `" + Z + "` supplied to " + ("`" + j + "`" + be + "."));
    }
    return l(q);
  }
  function w() {
    function M(D, O, q, L, N) {
      return S(D[O]) ? null : new c("Invalid " + L + " `" + N + "` supplied to " + ("`" + q + "`, expected a ReactNode."));
    }
    return l(M);
  }
  function x(M, D, O, q, L) {
    return new c(
      (M || "React class") + ": " + D + " type `" + O + "." + q + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + L + "`."
    );
  }
  function A(M) {
    function D(O, q, L, N, j) {
      var V = O[q], Z = T(V);
      if (Z !== "object")
        return new c("Invalid " + N + " `" + j + "` of type `" + Z + "` " + ("supplied to `" + L + "`, expected `object`."));
      for (var G in M) {
        var $ = M[G];
        if (typeof $ != "function")
          return x(L, N, j, G, k($));
        var fe = $(V, G, L, N, j + "." + G, mo);
        if (fe)
          return fe;
      }
      return null;
    }
    return l(D);
  }
  function C(M) {
    function D(O, q, L, N, j) {
      var V = O[q], Z = T(V);
      if (Z !== "object")
        return new c("Invalid " + N + " `" + j + "` of type `" + Z + "` " + ("supplied to `" + L + "`, expected `object`."));
      var G = H9({}, O[q], M);
      for (var $ in G) {
        var fe = M[$];
        if (fp(M, $) && typeof fe != "function")
          return x(L, N, j, $, k(fe));
        if (!fe)
          return new c(
            "Invalid " + N + " `" + j + "` key `" + $ + "` supplied to `" + L + "`.\nBad object: " + JSON.stringify(O[q], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(M), null, "  ")
          );
        var he = fe(V, $, L, N, j + "." + $, mo);
        if (he)
          return he;
      }
      return null;
    }
    return l(D);
  }
  function S(M) {
    switch (typeof M) {
      case "number":
      case "string":
      case "undefined":
        return !0;
      case "boolean":
        return !M;
      case "object":
        if (Array.isArray(M))
          return M.every(S);
        if (M === null || t(M))
          return !0;
        var D = s(M);
        if (D) {
          var O = D.call(M), q;
          if (D !== M.entries) {
            for (; !(q = O.next()).done; )
              if (!S(q.value))
                return !1;
          } else
            for (; !(q = O.next()).done; ) {
              var L = q.value;
              if (L && !S(L[1]))
                return !1;
            }
        } else
          return !1;
        return !0;
      default:
        return !1;
    }
  }
  function _(M, D) {
    return M === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
  }
  function T(M) {
    var D = typeof M;
    return Array.isArray(M) ? "array" : M instanceof RegExp ? "object" : _(D, M) ? "symbol" : D;
  }
  function k(M) {
    if (typeof M > "u" || M === null)
      return "" + M;
    var D = T(M);
    if (D === "object") {
      if (M instanceof Date)
        return "date";
      if (M instanceof RegExp)
        return "regexp";
    }
    return D;
  }
  function R(M) {
    var D = k(M);
    switch (D) {
      case "array":
      case "object":
        return "an " + D;
      case "boolean":
      case "date":
      case "regexp":
        return "a " + D;
      default:
        return D;
    }
  }
  function P(M) {
    return !M.constructor || !M.constructor.name ? i : M.constructor.name;
  }
  return o.checkPropTypes = Qw, o.resetWarningCache = Qw.resetWarningCache, o.PropTypes = o, o;
};
{
  var G9 = qT, K9 = !0;
  DT.exports = Y9(G9.isElement, K9);
}
var BT = DT.exports;
function FT(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (n = FT(t[e])) && (r && (r += " "), r += n);
  else for (e in t) t[e] && (r && (r += " "), r += e);
  return r;
}
function Xw() {
  for (var t, e, n = 0, r = ""; n < arguments.length; ) (t = arguments[n++]) && (e = FT(t)) && (r && (r += " "), r += e);
  return r;
}
const $9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: Xw,
  default: Xw
}, Symbol.toStringTag, { value: "Module" })), Z9 = /* @__PURE__ */ c2($9);
var Tt = {}, Nr = {};
Object.defineProperty(Nr, "__esModule", {
  value: !0
});
Nr.dontSetMe = t6;
Nr.findInArray = Q9;
Nr.int = e6;
Nr.isFunction = X9;
Nr.isNum = J9;
function Q9(t, e) {
  for (let n = 0, r = t.length; n < r; n++)
    if (e.apply(e, [t[n], n, t])) return t[n];
}
function X9(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Function]";
}
function J9(t) {
  return typeof t == "number" && !isNaN(t);
}
function e6(t) {
  return parseInt(t, 10);
}
function t6(t, e, n) {
  if (t[e])
    return new Error("Invalid prop ".concat(e, " passed to ").concat(n, " - do not set this, set it on the child."));
}
var ro = {};
Object.defineProperty(ro, "__esModule", {
  value: !0
});
ro.browserPrefixToKey = UT;
ro.browserPrefixToStyle = n6;
ro.default = void 0;
ro.getPrefix = VT;
const hp = ["Moz", "Webkit", "O", "ms"];
function VT() {
  var t;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
  if (typeof window > "u") return "";
  const n = (t = window.document) === null || t === void 0 || (t = t.documentElement) === null || t === void 0 ? void 0 : t.style;
  if (!n || e in n) return "";
  for (let r = 0; r < hp.length; r++)
    if (UT(e, hp[r]) in n) return hp[r];
  return "";
}
function UT(t, e) {
  return e ? "".concat(e).concat(r6(t)) : t;
}
function n6(t, e) {
  return e ? "-".concat(e.toLowerCase(), "-").concat(t) : t;
}
function r6(t) {
  let e = "", n = !0;
  for (let r = 0; r < t.length; r++)
    n ? (e += t[r].toUpperCase(), n = !1) : t[r] === "-" ? n = !0 : e += t[r];
  return e;
}
ro.default = VT();
Object.defineProperty(Tt, "__esModule", {
  value: !0
});
Tt.addClassName = HT;
Tt.addEvent = o6;
Tt.addUserSelectStyles = y6;
Tt.createCSSTransform = h6;
Tt.createSVGTransform = p6;
Tt.getTouch = m6;
Tt.getTouchIdentifier = g6;
Tt.getTranslation = Qy;
Tt.innerHeight = u6;
Tt.innerWidth = d6;
Tt.matchesSelector = zT;
Tt.matchesSelectorAndParentsTo = i6;
Tt.offsetXYFromParent = f6;
Tt.outerHeight = c6;
Tt.outerWidth = l6;
Tt.removeClassName = YT;
Tt.removeEvent = a6;
Tt.removeUserSelectStyles = b6;
var Wn = Nr, Jw = s6(ro);
function WT(t) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (WT = function(r) {
    return r ? n : e;
  })(t);
}
function s6(t, e) {
  if (t && t.__esModule)
    return t;
  if (t === null || typeof t != "object" && typeof t != "function")
    return { default: t };
  var n = WT(e);
  if (n && n.has(t))
    return n.get(t);
  var r = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t)
    if (i !== "default" && Object.prototype.hasOwnProperty.call(t, i)) {
      var o = s ? Object.getOwnPropertyDescriptor(t, i) : null;
      o && (o.get || o.set) ? Object.defineProperty(r, i, o) : r[i] = t[i];
    }
  return r.default = t, n && n.set(t, r), r;
}
let lu = "";
function zT(t, e) {
  return lu || (lu = (0, Wn.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(n) {
    return (0, Wn.isFunction)(t[n]);
  })), (0, Wn.isFunction)(t[lu]) ? t[lu](e) : !1;
}
function i6(t, e, n) {
  let r = t;
  do {
    if (zT(r, e)) return !0;
    if (r === n) return !1;
    r = r.parentNode;
  } while (r);
  return !1;
}
function o6(t, e, n, r) {
  if (!t) return;
  const s = {
    capture: !0,
    ...r
  };
  t.addEventListener ? t.addEventListener(e, n, s) : t.attachEvent ? t.attachEvent("on" + e, n) : t["on" + e] = n;
}
function a6(t, e, n, r) {
  if (!t) return;
  const s = {
    capture: !0,
    ...r
  };
  t.removeEventListener ? t.removeEventListener(e, n, s) : t.detachEvent ? t.detachEvent("on" + e, n) : t["on" + e] = null;
}
function c6(t) {
  let e = t.clientHeight;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e += (0, Wn.int)(n.borderTopWidth), e += (0, Wn.int)(n.borderBottomWidth), e;
}
function l6(t) {
  let e = t.clientWidth;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e += (0, Wn.int)(n.borderLeftWidth), e += (0, Wn.int)(n.borderRightWidth), e;
}
function u6(t) {
  let e = t.clientHeight;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e -= (0, Wn.int)(n.paddingTop), e -= (0, Wn.int)(n.paddingBottom), e;
}
function d6(t) {
  let e = t.clientWidth;
  const n = t.ownerDocument.defaultView.getComputedStyle(t);
  return e -= (0, Wn.int)(n.paddingLeft), e -= (0, Wn.int)(n.paddingRight), e;
}
function f6(t, e, n) {
  const s = e === e.ownerDocument.body ? {
    left: 0,
    top: 0
  } : e.getBoundingClientRect(), i = (t.clientX + e.scrollLeft - s.left) / n, o = (t.clientY + e.scrollTop - s.top) / n;
  return {
    x: i,
    y: o
  };
}
function h6(t, e) {
  const n = Qy(t, e, "px");
  return {
    [(0, Jw.browserPrefixToKey)("transform", Jw.default)]: n
  };
}
function p6(t, e) {
  return Qy(t, e, "");
}
function Qy(t, e, n) {
  let {
    x: r,
    y: s
  } = t, i = "translate(".concat(r).concat(n, ",").concat(s).concat(n, ")");
  if (e) {
    const o = "".concat(typeof e.x == "string" ? e.x : e.x + n), a = "".concat(typeof e.y == "string" ? e.y : e.y + n);
    i = "translate(".concat(o, ", ").concat(a, ")") + i;
  }
  return i;
}
function m6(t, e) {
  return t.targetTouches && (0, Wn.findInArray)(t.targetTouches, (n) => e === n.identifier) || t.changedTouches && (0, Wn.findInArray)(t.changedTouches, (n) => e === n.identifier);
}
function g6(t) {
  if (t.targetTouches && t.targetTouches[0]) return t.targetTouches[0].identifier;
  if (t.changedTouches && t.changedTouches[0]) return t.changedTouches[0].identifier;
}
function y6(t) {
  if (!t) return;
  let e = t.getElementById("react-draggable-style-el");
  e || (e = t.createElement("style"), e.type = "text/css", e.id = "react-draggable-style-el", e.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, e.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, t.getElementsByTagName("head")[0].appendChild(e)), t.body && HT(t.body, "react-draggable-transparent-selection");
}
function b6(t) {
  if (t)
    try {
      if (t.body && YT(t.body, "react-draggable-transparent-selection"), t.selection)
        t.selection.empty();
      else {
        const e = (t.defaultView || window).getSelection();
        e && e.type !== "Caret" && e.removeAllRanges();
      }
    } catch {
    }
}
function HT(t, e) {
  t.classList ? t.classList.add(e) : t.className.match(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"))) || (t.className += " ".concat(e));
}
function YT(t, e) {
  t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"), "g"), "");
}
var Lr = {};
Object.defineProperty(Lr, "__esModule", {
  value: !0
});
Lr.canDragX = w6;
Lr.canDragY = A6;
Lr.createCoreData = E6;
Lr.createDraggableData = C6;
Lr.getBoundPosition = v6;
Lr.getControlPosition = S6;
Lr.snapToGrid = x6;
var Dn = Nr, Mo = Tt;
function v6(t, e, n) {
  if (!t.props.bounds) return [e, n];
  let {
    bounds: r
  } = t.props;
  r = typeof r == "string" ? r : _6(r);
  const s = Xy(t);
  if (typeof r == "string") {
    const {
      ownerDocument: i
    } = s, o = i.defaultView;
    let a;
    if (r === "parent" ? a = s.parentNode : a = i.querySelector(r), !(a instanceof o.HTMLElement))
      throw new Error('Bounds selector "' + r + '" could not find an element.');
    const c = a, l = o.getComputedStyle(s), u = o.getComputedStyle(c);
    r = {
      left: -s.offsetLeft + (0, Dn.int)(u.paddingLeft) + (0, Dn.int)(l.marginLeft),
      top: -s.offsetTop + (0, Dn.int)(u.paddingTop) + (0, Dn.int)(l.marginTop),
      right: (0, Mo.innerWidth)(c) - (0, Mo.outerWidth)(s) - s.offsetLeft + (0, Dn.int)(u.paddingRight) - (0, Dn.int)(l.marginRight),
      bottom: (0, Mo.innerHeight)(c) - (0, Mo.outerHeight)(s) - s.offsetTop + (0, Dn.int)(u.paddingBottom) - (0, Dn.int)(l.marginBottom)
    };
  }
  return (0, Dn.isNum)(r.right) && (e = Math.min(e, r.right)), (0, Dn.isNum)(r.bottom) && (n = Math.min(n, r.bottom)), (0, Dn.isNum)(r.left) && (e = Math.max(e, r.left)), (0, Dn.isNum)(r.top) && (n = Math.max(n, r.top)), [e, n];
}
function x6(t, e, n) {
  const r = Math.round(e / t[0]) * t[0], s = Math.round(n / t[1]) * t[1];
  return [r, s];
}
function w6(t) {
  return t.props.axis === "both" || t.props.axis === "x";
}
function A6(t) {
  return t.props.axis === "both" || t.props.axis === "y";
}
function S6(t, e, n) {
  const r = typeof e == "number" ? (0, Mo.getTouch)(t, e) : null;
  if (typeof e == "number" && !r) return null;
  const s = Xy(n), i = n.props.offsetParent || s.offsetParent || s.ownerDocument.body;
  return (0, Mo.offsetXYFromParent)(r || t, i, n.props.scale);
}
function E6(t, e, n) {
  const r = !(0, Dn.isNum)(t.lastX), s = Xy(t);
  return r ? {
    node: s,
    deltaX: 0,
    deltaY: 0,
    lastX: e,
    lastY: n,
    x: e,
    y: n
  } : {
    node: s,
    deltaX: e - t.lastX,
    deltaY: n - t.lastY,
    lastX: t.lastX,
    lastY: t.lastY,
    x: e,
    y: n
  };
}
function C6(t, e) {
  const n = t.props.scale;
  return {
    node: e.node,
    x: t.state.x + e.deltaX / n,
    y: t.state.y + e.deltaY / n,
    deltaX: e.deltaX / n,
    deltaY: e.deltaY / n,
    lastX: t.state.x,
    lastY: t.state.y
  };
}
function _6(t) {
  return {
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom
  };
}
function Xy(t) {
  const e = t.findDOMNode();
  if (!e)
    throw new Error("<DraggableCore>: Unmounted during event!");
  return e;
}
var Hf = {}, Yf = {};
Object.defineProperty(Yf, "__esModule", {
  value: !0
});
Yf.default = T6;
function T6() {
}
Object.defineProperty(Hf, "__esModule", {
  value: !0
});
Hf.default = void 0;
var pp = R6(z), En = Jy(BT), k6 = Jy(pf), nn = Tt, _s = Lr, mp = Nr, Qa = Jy(Yf);
function Jy(t) {
  return t && t.__esModule ? t : { default: t };
}
function GT(t) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (GT = function(r) {
    return r ? n : e;
  })(t);
}
function R6(t, e) {
  if (t && t.__esModule)
    return t;
  if (t === null || typeof t != "object" && typeof t != "function")
    return { default: t };
  var n = GT(e);
  if (n && n.has(t))
    return n.get(t);
  var r = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t)
    if (i !== "default" && Object.prototype.hasOwnProperty.call(t, i)) {
      var o = s ? Object.getOwnPropertyDescriptor(t, i) : null;
      o && (o.get || o.set) ? Object.defineProperty(r, i, o) : r[i] = t[i];
    }
  return r.default = t, n && n.set(t, r), r;
}
function pn(t, e, n) {
  return e = M6(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function M6(t) {
  var e = P6(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function P6(t, e) {
  if (typeof t != "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
const nr = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
let Ts = nr.mouse, Gf = class extends pp.Component {
  constructor() {
    super(...arguments), pn(this, "dragging", !1), pn(this, "lastX", NaN), pn(this, "lastY", NaN), pn(this, "touchIdentifier", null), pn(this, "mounted", !1), pn(this, "handleDragStart", (e) => {
      if (this.props.onMouseDown(e), !this.props.allowAnyClick && typeof e.button == "number" && e.button !== 0) return !1;
      const n = this.findDOMNode();
      if (!n || !n.ownerDocument || !n.ownerDocument.body)
        throw new Error("<DraggableCore> not mounted on DragStart!");
      const {
        ownerDocument: r
      } = n;
      if (this.props.disabled || !(e.target instanceof r.defaultView.Node) || this.props.handle && !(0, nn.matchesSelectorAndParentsTo)(e.target, this.props.handle, n) || this.props.cancel && (0, nn.matchesSelectorAndParentsTo)(e.target, this.props.cancel, n))
        return;
      e.type === "touchstart" && e.preventDefault();
      const s = (0, nn.getTouchIdentifier)(e);
      this.touchIdentifier = s;
      const i = (0, _s.getControlPosition)(e, s, this);
      if (i == null) return;
      const {
        x: o,
        y: a
      } = i, c = (0, _s.createCoreData)(this, o, a);
      (0, Qa.default)("DraggableCore: handleDragStart: %j", c), (0, Qa.default)("calling", this.props.onStart), !(this.props.onStart(e, c) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, nn.addUserSelectStyles)(r), this.dragging = !0, this.lastX = o, this.lastY = a, (0, nn.addEvent)(r, Ts.move, this.handleDrag), (0, nn.addEvent)(r, Ts.stop, this.handleDragStop));
    }), pn(this, "handleDrag", (e) => {
      const n = (0, _s.getControlPosition)(e, this.touchIdentifier, this);
      if (n == null) return;
      let {
        x: r,
        y: s
      } = n;
      if (Array.isArray(this.props.grid)) {
        let a = r - this.lastX, c = s - this.lastY;
        if ([a, c] = (0, _s.snapToGrid)(this.props.grid, a, c), !a && !c) return;
        r = this.lastX + a, s = this.lastY + c;
      }
      const i = (0, _s.createCoreData)(this, r, s);
      if ((0, Qa.default)("DraggableCore: handleDrag: %j", i), this.props.onDrag(e, i) === !1 || this.mounted === !1) {
        try {
          this.handleDragStop(new MouseEvent("mouseup"));
        } catch {
          const c = document.createEvent("MouseEvents");
          c.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(c);
        }
        return;
      }
      this.lastX = r, this.lastY = s;
    }), pn(this, "handleDragStop", (e) => {
      if (!this.dragging) return;
      const n = (0, _s.getControlPosition)(e, this.touchIdentifier, this);
      if (n == null) return;
      let {
        x: r,
        y: s
      } = n;
      if (Array.isArray(this.props.grid)) {
        let c = r - this.lastX || 0, l = s - this.lastY || 0;
        [c, l] = (0, _s.snapToGrid)(this.props.grid, c, l), r = this.lastX + c, s = this.lastY + l;
      }
      const i = (0, _s.createCoreData)(this, r, s);
      if (this.props.onStop(e, i) === !1 || this.mounted === !1) return !1;
      const a = this.findDOMNode();
      a && this.props.enableUserSelectHack && (0, nn.removeUserSelectStyles)(a.ownerDocument), (0, Qa.default)("DraggableCore: handleDragStop: %j", i), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, a && ((0, Qa.default)("DraggableCore: Removing handlers"), (0, nn.removeEvent)(a.ownerDocument, Ts.move, this.handleDrag), (0, nn.removeEvent)(a.ownerDocument, Ts.stop, this.handleDragStop));
    }), pn(this, "onMouseDown", (e) => (Ts = nr.mouse, this.handleDragStart(e))), pn(this, "onMouseUp", (e) => (Ts = nr.mouse, this.handleDragStop(e))), pn(this, "onTouchStart", (e) => (Ts = nr.touch, this.handleDragStart(e))), pn(this, "onTouchEnd", (e) => (Ts = nr.touch, this.handleDragStop(e)));
  }
  componentDidMount() {
    this.mounted = !0;
    const e = this.findDOMNode();
    e && (0, nn.addEvent)(e, nr.touch.start, this.onTouchStart, {
      passive: !1
    });
  }
  componentWillUnmount() {
    this.mounted = !1;
    const e = this.findDOMNode();
    if (e) {
      const {
        ownerDocument: n
      } = e;
      (0, nn.removeEvent)(n, nr.mouse.move, this.handleDrag), (0, nn.removeEvent)(n, nr.touch.move, this.handleDrag), (0, nn.removeEvent)(n, nr.mouse.stop, this.handleDragStop), (0, nn.removeEvent)(n, nr.touch.stop, this.handleDragStop), (0, nn.removeEvent)(e, nr.touch.start, this.onTouchStart, {
        passive: !1
      }), this.props.enableUserSelectHack && (0, nn.removeUserSelectStyles)(n);
    }
  }
  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
  // the underlying DOM node ourselves. See the README for more information.
  findDOMNode() {
    var e, n;
    return (e = this.props) !== null && e !== void 0 && e.nodeRef ? (n = this.props) === null || n === void 0 || (n = n.nodeRef) === null || n === void 0 ? void 0 : n.current : k6.default.findDOMNode(this);
  }
  render() {
    return /* @__PURE__ */ pp.cloneElement(pp.Children.only(this.props.children), {
      // Note: mouseMove handler is attached to document so it will still function
      // when the user drags quickly and leaves the bounds of the element.
      onMouseDown: this.onMouseDown,
      onMouseUp: this.onMouseUp,
      // onTouchStart is added on `componentDidMount` so they can be added with
      // {passive: false}, which allows it to cancel. See
      // https://developers.google.com/web/updates/2017/01/scrolling-intervention
      onTouchEnd: this.onTouchEnd
    });
  }
};
Hf.default = Gf;
pn(Gf, "displayName", "DraggableCore");
pn(Gf, "propTypes", {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: En.default.bool,
  children: En.default.node.isRequired,
  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: En.default.bool,
  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: En.default.bool,
  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function(t, e) {
    if (t[e] && t[e].nodeType !== 1)
      throw new Error("Draggable's offsetParent must be a DOM Node.");
  },
  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: En.default.arrayOf(En.default.number),
  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: En.default.string,
  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: En.default.string,
  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: En.default.object,
  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: En.default.func,
  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: En.default.func,
  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: En.default.func,
  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: En.default.func,
  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: En.default.number,
  /**
   * These properties should be defined on the child, not here.
   */
  className: mp.dontSetMe,
  style: mp.dontSetMe,
  transform: mp.dontSetMe
});
pn(Gf, "defaultProps", {
  allowAnyClick: !1,
  // by default only accept left click
  disabled: !1,
  enableUserSelectHack: !0,
  onStart: function() {
  },
  onDrag: function() {
  },
  onStop: function() {
  },
  onMouseDown: function() {
  },
  scale: 1
});
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "DraggableCore", {
    enumerable: !0,
    get: function() {
      return c.default;
    }
  }), t.default = void 0;
  var e = f(z), n = u(BT), r = u(pf), s = u(Z9), i = Tt, o = Lr, a = Nr, c = u(Hf), l = u(Yf);
  function u(v) {
    return v && v.__esModule ? v : { default: v };
  }
  function d(v) {
    if (typeof WeakMap != "function") return null;
    var w = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap();
    return (d = function(A) {
      return A ? x : w;
    })(v);
  }
  function f(v, w) {
    if (v && v.__esModule)
      return v;
    if (v === null || typeof v != "object" && typeof v != "function")
      return { default: v };
    var x = d(w);
    if (x && x.has(v))
      return x.get(v);
    var A = {}, C = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var S in v)
      if (S !== "default" && Object.prototype.hasOwnProperty.call(v, S)) {
        var _ = C ? Object.getOwnPropertyDescriptor(v, S) : null;
        _ && (_.get || _.set) ? Object.defineProperty(A, S, _) : A[S] = v[S];
      }
    return A.default = v, x && x.set(v, A), A;
  }
  function h() {
    return h = Object.assign ? Object.assign.bind() : function(v) {
      for (var w = 1; w < arguments.length; w++) {
        var x = arguments[w];
        for (var A in x)
          Object.prototype.hasOwnProperty.call(x, A) && (v[A] = x[A]);
      }
      return v;
    }, h.apply(this, arguments);
  }
  function p(v, w, x) {
    return w = m(w), w in v ? Object.defineProperty(v, w, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : v[w] = x, v;
  }
  function m(v) {
    var w = y(v, "string");
    return typeof w == "symbol" ? w : String(w);
  }
  function y(v, w) {
    if (typeof v != "object" || v === null) return v;
    var x = v[Symbol.toPrimitive];
    if (x !== void 0) {
      var A = x.call(v, w || "default");
      if (typeof A != "object") return A;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (w === "string" ? String : Number)(v);
  }
  class b extends e.Component {
    // React 16.3+
    // Arity (props, state)
    static getDerivedStateFromProps(w, x) {
      let {
        position: A
      } = w, {
        prevPropsPosition: C
      } = x;
      return A && (!C || A.x !== C.x || A.y !== C.y) ? ((0, l.default)("Draggable: getDerivedStateFromProps %j", {
        position: A,
        prevPropsPosition: C
      }), {
        x: A.x,
        y: A.y,
        prevPropsPosition: {
          ...A
        }
      }) : null;
    }
    constructor(w) {
      super(w), p(this, "onDragStart", (x, A) => {
        if ((0, l.default)("Draggable: onDragStart: %j", A), this.props.onStart(x, (0, o.createDraggableData)(this, A)) === !1) return !1;
        this.setState({
          dragging: !0,
          dragged: !0
        });
      }), p(this, "onDrag", (x, A) => {
        if (!this.state.dragging) return !1;
        (0, l.default)("Draggable: onDrag: %j", A);
        const C = (0, o.createDraggableData)(this, A), S = {
          x: C.x,
          y: C.y,
          slackX: 0,
          slackY: 0
        };
        if (this.props.bounds) {
          const {
            x: T,
            y: k
          } = S;
          S.x += this.state.slackX, S.y += this.state.slackY;
          const [R, P] = (0, o.getBoundPosition)(this, S.x, S.y);
          S.x = R, S.y = P, S.slackX = this.state.slackX + (T - S.x), S.slackY = this.state.slackY + (k - S.y), C.x = S.x, C.y = S.y, C.deltaX = S.x - this.state.x, C.deltaY = S.y - this.state.y;
        }
        if (this.props.onDrag(x, C) === !1) return !1;
        this.setState(S);
      }), p(this, "onDragStop", (x, A) => {
        if (!this.state.dragging || this.props.onStop(x, (0, o.createDraggableData)(this, A)) === !1) return !1;
        (0, l.default)("Draggable: onDragStop: %j", A);
        const S = {
          dragging: !1,
          slackX: 0,
          slackY: 0
        };
        if (!!this.props.position) {
          const {
            x: T,
            y: k
          } = this.props.position;
          S.x = T, S.y = k;
        }
        this.setState(S);
      }), this.state = {
        // Whether or not we are currently dragging.
        dragging: !1,
        // Whether or not we have been dragged before.
        dragged: !1,
        // Current transform x and y.
        x: w.position ? w.position.x : w.defaultPosition.x,
        y: w.position ? w.position.y : w.defaultPosition.y,
        prevPropsPosition: {
          ...w.position
        },
        // Used for compensating for out-of-bounds drags
        slackX: 0,
        slackY: 0,
        // Can only determine if SVG after mounting
        isElementSVG: !1
      }, w.position && !(w.onDrag || w.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
    }
    componentDidMount() {
      typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
        isElementSVG: !0
      });
    }
    componentWillUnmount() {
      this.setState({
        dragging: !1
      });
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var w, x;
      return (w = (x = this.props) === null || x === void 0 || (x = x.nodeRef) === null || x === void 0 ? void 0 : x.current) !== null && w !== void 0 ? w : r.default.findDOMNode(this);
    }
    render() {
      const {
        axis: w,
        bounds: x,
        children: A,
        defaultPosition: C,
        defaultClassName: S,
        defaultClassNameDragging: _,
        defaultClassNameDragged: T,
        position: k,
        positionOffset: R,
        scale: P,
        ...M
      } = this.props;
      let D = {}, O = null;
      const L = !!!k || this.state.dragging, N = k || C, j = {
        // Set left if horizontal drag is enabled
        x: (0, o.canDragX)(this) && L ? this.state.x : N.x,
        // Set top if vertical drag is enabled
        y: (0, o.canDragY)(this) && L ? this.state.y : N.y
      };
      this.state.isElementSVG ? O = (0, i.createSVGTransform)(j, R) : D = (0, i.createCSSTransform)(j, R);
      const V = (0, s.default)(A.props.className || "", S, {
        [_]: this.state.dragging,
        [T]: this.state.dragged
      });
      return /* @__PURE__ */ e.createElement(c.default, h({}, M, {
        onStart: this.onDragStart,
        onDrag: this.onDrag,
        onStop: this.onDragStop
      }), /* @__PURE__ */ e.cloneElement(e.Children.only(A), {
        className: V,
        style: {
          ...A.props.style,
          ...D
        },
        transform: O
      }));
    }
  }
  t.default = b, p(b, "displayName", "Draggable"), p(b, "propTypes", {
    // Accepts all props <DraggableCore> accepts.
    ...c.default.propTypes,
    /**
     * `axis` determines which axis the draggable can move.
     *
     *  Note that all callbacks will still return data as normal. This only
     *  controls flushing to the DOM.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     * 'none' limits all movement.
     *
     * Defaults to 'both'.
     */
    axis: n.default.oneOf(["both", "x", "y", "none"]),
    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: n.default.oneOfType([n.default.shape({
      left: n.default.number,
      right: n.default.number,
      top: n.default.number,
      bottom: n.default.number
    }), n.default.string, n.default.oneOf([!1])]),
    defaultClassName: n.default.string,
    defaultClassNameDragging: n.default.string,
    defaultClassNameDragged: n.default.string,
    /**
     * `defaultPosition` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable defaultPosition={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    defaultPosition: n.default.shape({
      x: n.default.number,
      y: n.default.number
    }),
    positionOffset: n.default.shape({
      x: n.default.oneOfType([n.default.number, n.default.string]),
      y: n.default.oneOfType([n.default.number, n.default.string])
    }),
    /**
     * `position`, if present, defines the current position of the element.
     *
     *  This is similar to how form elements in React work - if no `position` is supplied, the component
     *  is uncontrolled.
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable position={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    position: n.default.shape({
      x: n.default.number,
      y: n.default.number
    }),
    /**
     * These properties should be defined on the child, not here.
     */
    className: a.dontSetMe,
    style: a.dontSetMe,
    transform: a.dontSetMe
  }), p(b, "defaultProps", {
    ...c.default.defaultProps,
    axis: "both",
    bounds: !1,
    defaultClassName: "react-draggable",
    defaultClassNameDragging: "react-draggable-dragging",
    defaultClassNameDragged: "react-draggable-dragged",
    defaultPosition: {
      x: 0,
      y: 0
    },
    scale: 1
  });
})(IT);
const {
  default: KT,
  DraggableCore: I6
} = IT;
zf.exports = KT;
zf.exports.default = KT;
zf.exports.DraggableCore = I6;
var D6 = zf.exports;
const O6 = /* @__PURE__ */ a2(D6), eA = "rgb(74, 222, 128)", tA = "rgb(248, 113, 113)";
function q6() {
  const { profit: t, wins: e, losses: n } = Sa(), r = wl(), s = t.length > 0 ? t[t.length - 1] : 0;
  return /* @__PURE__ */ g.jsxs("div", { className: "flex rounded-md bg-primary p-4 text-sm", children: [
    /* @__PURE__ */ g.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Profit" }),
      /* @__PURE__ */ g.jsx(
        "p",
        {
          className: `font-semibold tabular-nums ${s >= 0 ? "text-green-400" : "text-red-400"}`,
          children: r(s)
        }
      )
    ] }),
    /* @__PURE__ */ g.jsx("div", { className: "mx-4 w-0.5 bg-slate-600", "aria-hidden": !0 }),
    /* @__PURE__ */ g.jsxs("div", { className: "flex-1 space-y-2", children: [
      /* @__PURE__ */ g.jsxs("div", { children: [
        /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Wins" }),
        /* @__PURE__ */ g.jsx("p", { className: "font-semibold tabular-nums text-green-400", children: e })
      ] }),
      /* @__PURE__ */ g.jsxs("div", { children: [
        /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Losses" }),
        /* @__PURE__ */ g.jsx("p", { className: "font-semibold tabular-nums text-red-400", children: n })
      ] })
    ] })
  ] });
}
function N6() {
  const t = Et(null), e = Et(null), [n, r] = Ge(null), { profit: s } = Sa(), i = wl();
  return _e(() => {
    if (t.current) {
      const o = t.current.getContext("2d");
      o && (e.current && e.current.destroy(), e.current = new Zr(o, {
        type: "line",
        data: {
          labels: s,
          datasets: [
            {
              label: "Profit",
              data: s,
              fill: {
                target: "origin",
                above: "rgba(74, 222, 128, 0.3)",
                below: "rgba(248, 113, 113, 0.3)"
              },
              segment: {
                borderColor: (a) => {
                  const c = a.p0.parsed.y, l = a.p1.parsed.y;
                  return l === 0 ? c < 0 ? tA : eA : l < 0 ? tA : eA;
                }
              },
              tension: 0.1,
              pointRadius: 0,
              pointHoverRadius: 6,
              pointHoverBackgroundColor: "white",
              pointHoverBorderColor: "white",
              pointHoverBorderWidth: 3
            }
          ]
        },
        options: {
          responsive: !0,
          bezierCurve: !0,
          maintainAspectRatio: !1,
          animations: {
            y: {
              duration: 0
            }
          },
          plugins: {
            legend: { display: !1 },
            tooltip: { enabled: !1 }
          },
          scales: {
            x: {
              border: { display: !1 },
              grid: { display: !1 },
              ticks: { display: !1 }
            },
            y: {
              border: { display: !1 },
              grid: { display: !1 },
              ticks: { display: !1 },
              grace: "1%"
            }
          },
          onHover: (a, c) => {
            if (c.length) {
              const l = c[0].index;
              r(s[l]);
            }
          },
          interaction: {
            intersect: !1,
            mode: "index"
          }
        }
      }));
    }
    return () => {
      e.current && e.current.destroy();
    };
  }, [s]), /* @__PURE__ */ g.jsxs("div", { className: "relative mt-4 rounded-md bg-primary p-4 text-sm", children: [
    /* @__PURE__ */ g.jsx("p", { className: "font-medium text-slate-400", children: "Profit History" }),
    n !== null && /* @__PURE__ */ g.jsx(
      "p",
      {
        className: `absolute top-4 right-4 font-semibold tabular-nums ${n >= 0 ? "text-green-400" : "text-red-400"}`,
        children: i(n)
      }
    ),
    /* @__PURE__ */ g.jsx("div", { className: "mt-6 h-44 w-64", children: /* @__PURE__ */ g.jsx("canvas", { ref: t }) }),
    /* @__PURE__ */ g.jsx("div", { id: "chartjs-tooltip", className: "hidden" })
  ] });
}
function L6() {
  const { resetProfitData: t } = Sa(), { isLiveStatsOpen: e, setLiveStatsOpen: n } = st();
  fr();
  const [r, s] = Ge({ left: 0, top: 0, right: 0, bottom: 0 }), [i, o] = Ge({ x: 0, y: 0 });
  _e(() => {
    const c = () => {
      const l = window.innerWidth, u = window.innerHeight, d = 320, f = 400;
      s({
        left: -l / 2 + d / 2,
        top: -u / 2 + f / 2,
        right: l / 2 - d / 2,
        bottom: u / 2 - f / 2
      });
    };
    return c(), window.addEventListener("resize", c), () => window.removeEventListener("resize", c);
  }, []);
  const a = (c, l) => {
    console.log(l.x, l.y);
    const u = { x: l.x, y: l.y };
    o(u);
  };
  return e ? /* @__PURE__ */ g.jsx("div", { className: "fixed inset-0 pointer-events-none z-[1000] select-none", children: /* @__PURE__ */ g.jsx("div", { className: "relative w-full h-full flex items-center justify-center", children: /* @__PURE__ */ g.jsx(
    O6,
    {
      handle: ".drag-handle",
      defaultPosition: i,
      onStop: a,
      bounds: r,
      cancel: "button",
      children: /* @__PURE__ */ g.jsxs("div", { className: "absolute pointer-events-auto w-80 rounded-lg bg-secondary border border-gray-700 shadow-lg", children: [
        /* @__PURE__ */ g.jsxs("div", { className: "drag-handle flex items-center justify-between p-4 text-white cursor-move", children: [
          /* @__PURE__ */ g.jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ g.jsx(aC, { className: "mr-2 h-5 w-5" }),
            /* @__PURE__ */ g.jsx("h2", { className: "text-sm font-medium", children: "Live Stats" })
          ] }),
          /* @__PURE__ */ g.jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ g.jsx(Fu, { children: /* @__PURE__ */ g.jsxs(Vu, { children: [
              /* @__PURE__ */ g.jsx(Uu, { asChild: !0, children: /* @__PURE__ */ g.jsx(
                pt,
                {
                  variant: "ghost",
                  size: "icon",
                  onClick: t,
                  className: "mr-2 text-gray-400 hover:bg-gray-700 hover:text-white",
                  children: /* @__PURE__ */ g.jsx(nB, { className: "h-4 w-4" })
                }
              ) }),
              /* @__PURE__ */ g.jsx(yc, { children: /* @__PURE__ */ g.jsx("p", { children: "Reset Live Stats" }) })
            ] }) }),
            /* @__PURE__ */ g.jsx(
              pt,
              {
                variant: "ghost",
                size: "icon",
                onClick: () => n(!1),
                className: "text-gray-400 hover:bg-gray-700 hover:text-white",
                children: /* @__PURE__ */ g.jsx(uC, { className: "h-4 w-4" })
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ g.jsxs("div", { className: "p-4", children: [
          /* @__PURE__ */ g.jsx(q6, {}),
          /* @__PURE__ */ g.jsx(N6, {})
        ] })
      ] })
    }
  ) }) }) : null;
}
function j6(t, e) {
  const n = E.createContext(e), r = (i) => {
    const { children: o, ...a } = i, c = E.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ g.jsx(n.Provider, { value: c, children: o });
  };
  r.displayName = t + "Provider";
  function s(i) {
    const o = E.useContext(n);
    if (o) return o;
    if (e !== void 0) return e;
    throw new Error(`\`${i}\` must be used within \`${t}\``);
  }
  return [r, s];
}
function B6(t, e = []) {
  let n = [];
  function r(i, o) {
    const a = E.createContext(o), c = n.length;
    n = [...n, o];
    const l = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, m = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[c]) || a, y = E.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ g.jsx(m.Provider, { value: y, children: h });
    };
    l.displayName = i + "Provider";
    function u(d, f) {
      var m;
      const h = ((m = f == null ? void 0 : f[t]) == null ? void 0 : m[c]) || a, p = E.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [l, u];
  }
  const s = () => {
    const i = n.map((o) => E.createContext(o));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || i;
      return E.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: c } }),
        [a, c]
      );
    };
  };
  return s.scopeName = t, [r, F6(s, ...e)];
}
function F6(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const o = r.reduce((a, { useScope: c, scopeName: l }) => {
        const d = c(i)[`__scope${l}`];
        return { ...a, ...d };
      }, {});
      return E.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
var V6 = "DismissableLayer", Hm = "dismissableLayer.update", U6 = "dismissableLayer.pointerDownOutside", W6 = "dismissableLayer.focusOutside", nA, $T = E.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), ZT = E.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: s,
      onFocusOutside: i,
      onInteractOutside: o,
      onDismiss: a,
      ...c
    } = t, l = E.useContext($T), [u, d] = E.useState(null), f = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = E.useState({}), p = Ke(e, (S) => d(S)), m = Array.from(l.layers), [y] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), b = m.indexOf(y), v = u ? m.indexOf(u) : -1, w = l.layersWithOutsidePointerEventsDisabled.size > 0, x = v >= b, A = Y6((S) => {
      const _ = S.target, T = [...l.branches].some((k) => k.contains(_));
      !x || T || (s == null || s(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, f), C = G6((S) => {
      const _ = S.target;
      [...l.branches].some((k) => k.contains(_)) || (i == null || i(S), o == null || o(S), S.defaultPrevented || a == null || a());
    }, f);
    return r_((S) => {
      v === l.layers.size - 1 && (r == null || r(S), !S.defaultPrevented && a && (S.preventDefault(), a()));
    }, f), E.useEffect(() => {
      if (u)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (nA = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(u)), l.layers.add(u), rA(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = nA);
        };
    }, [u, f, n, l]), E.useEffect(() => () => {
      u && (l.layers.delete(u), l.layersWithOutsidePointerEventsDisabled.delete(u), rA());
    }, [u, l]), E.useEffect(() => {
      const S = () => h({});
      return document.addEventListener(Hm, S), () => document.removeEventListener(Hm, S);
    }, []), /* @__PURE__ */ g.jsx(
      ze.div,
      {
        ...c,
        ref: p,
        style: {
          pointerEvents: w ? x ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: We(t.onFocusCapture, C.onFocusCapture),
        onBlurCapture: We(t.onBlurCapture, C.onBlurCapture),
        onPointerDownCapture: We(
          t.onPointerDownCapture,
          A.onPointerDownCapture
        )
      }
    );
  }
);
ZT.displayName = V6;
var z6 = "DismissableLayerBranch", H6 = E.forwardRef((t, e) => {
  const n = E.useContext($T), r = E.useRef(null), s = Ke(e, r);
  return E.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ g.jsx(ze.div, { ...t, ref: s });
});
H6.displayName = z6;
function Y6(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Zt(t), r = E.useRef(!1), s = E.useRef(() => {
  });
  return E.useEffect(() => {
    const i = (a) => {
      if (a.target && !r.current) {
        let c = function() {
          QT(
            U6,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: a };
        a.pointerType === "touch" ? (e.removeEventListener("click", s.current), s.current = c, e.addEventListener("click", s.current, { once: !0 })) : c();
      } else
        e.removeEventListener("click", s.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(o), e.removeEventListener("pointerdown", i), e.removeEventListener("click", s.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function G6(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Zt(t), r = E.useRef(!1);
  return E.useEffect(() => {
    const s = (i) => {
      i.target && !r.current && QT(W6, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", s), () => e.removeEventListener("focusin", s);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function rA() {
  const t = new CustomEvent(Hm);
  document.dispatchEvent(t);
}
function QT(t, e, n, { discrete: r }) {
  const s = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && s.addEventListener(t, e, { once: !0 }), r ? vC(s, i) : s.dispatchEvent(i);
}
var gp = "focusScope.autoFocusOnMount", yp = "focusScope.autoFocusOnUnmount", sA = { bubbles: !1, cancelable: !0 }, K6 = "FocusScope", XT = E.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: s,
    onUnmountAutoFocus: i,
    ...o
  } = t, [a, c] = E.useState(null), l = Zt(s), u = Zt(i), d = E.useRef(null), f = Ke(e, (m) => c(m)), h = E.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  E.useEffect(() => {
    if (r) {
      let m = function(w) {
        if (h.paused || !a) return;
        const x = w.target;
        a.contains(x) ? d.current = x : Rs(d.current, { select: !0 });
      }, y = function(w) {
        if (h.paused || !a) return;
        const x = w.relatedTarget;
        x !== null && (a.contains(x) || Rs(d.current, { select: !0 }));
      }, b = function(w) {
        if (document.activeElement === document.body)
          for (const A of w)
            A.removedNodes.length > 0 && Rs(a);
      };
      document.addEventListener("focusin", m), document.addEventListener("focusout", y);
      const v = new MutationObserver(b);
      return a && v.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", y), v.disconnect();
      };
    }
  }, [r, a, h.paused]), E.useEffect(() => {
    if (a) {
      oA.add(h);
      const m = document.activeElement;
      if (!a.contains(m)) {
        const b = new CustomEvent(gp, sA);
        a.addEventListener(gp, l), a.dispatchEvent(b), b.defaultPrevented || ($6(eH(JT(a)), { select: !0 }), document.activeElement === m && Rs(a));
      }
      return () => {
        a.removeEventListener(gp, l), setTimeout(() => {
          const b = new CustomEvent(yp, sA);
          a.addEventListener(yp, u), a.dispatchEvent(b), b.defaultPrevented || Rs(m ?? document.body, { select: !0 }), a.removeEventListener(yp, u), oA.remove(h);
        }, 0);
      };
    }
  }, [a, l, u, h]);
  const p = E.useCallback(
    (m) => {
      if (!n && !r || h.paused) return;
      const y = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, b = document.activeElement;
      if (y && b) {
        const v = m.currentTarget, [w, x] = Z6(v);
        w && x ? !m.shiftKey && b === x ? (m.preventDefault(), n && Rs(w, { select: !0 })) : m.shiftKey && b === w && (m.preventDefault(), n && Rs(x, { select: !0 })) : b === v && m.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ g.jsx(ze.div, { tabIndex: -1, ...o, ref: f, onKeyDown: p });
});
XT.displayName = K6;
function $6(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (Rs(r, { select: e }), document.activeElement !== n) return;
}
function Z6(t) {
  const e = JT(t), n = iA(e, t), r = iA(e.reverse(), t);
  return [n, r];
}
function JT(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const s = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function iA(t, e) {
  for (const n of t)
    if (!Q6(n, { upTo: e })) return n;
}
function Q6(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function X6(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Rs(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && X6(t) && e && t.select();
  }
}
var oA = J6();
function J6() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), t = aA(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = aA(t, e), (n = t[0]) == null || n.resume();
    }
  };
}
function aA(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function eH(t) {
  return t.filter((e) => e.tagName !== "A");
}
var tH = "Portal", ek = E.forwardRef((t, e) => {
  var a;
  const { container: n, ...r } = t, [s, i] = E.useState(!1);
  bn(() => i(!0), []);
  const o = n || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
  return o ? pf.createPortal(/* @__PURE__ */ g.jsx(ze.div, { ...r, ref: e }), o) : null;
});
ek.displayName = tH;
function nH(t, e) {
  return E.useReducer((n, r) => e[n][r] ?? n, t);
}
var Kf = (t) => {
  const { present: e, children: n } = t, r = rH(e), s = typeof n == "function" ? n({ present: r.isPresent }) : E.Children.only(n), i = Ke(r.ref, sH(s));
  return typeof n == "function" || r.isPresent ? E.cloneElement(s, { ref: i }) : null;
};
Kf.displayName = "Presence";
function rH(t) {
  const [e, n] = E.useState(), r = E.useRef({}), s = E.useRef(t), i = E.useRef("none"), o = t ? "mounted" : "unmounted", [a, c] = nH(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return E.useEffect(() => {
    const l = uu(r.current);
    i.current = a === "mounted" ? l : "none";
  }, [a]), bn(() => {
    const l = r.current, u = s.current;
    if (u !== t) {
      const f = i.current, h = uu(l);
      t ? c("MOUNT") : h === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), s.current = t;
    }
  }, [t, c]), bn(() => {
    if (e) {
      let l;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const m = uu(r.current).includes(h.animationName);
        if (h.target === e && m && (c("ANIMATION_END"), !s.current)) {
          const y = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", l = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = y);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = uu(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(l), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      c("ANIMATION_END");
  }, [e, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: E.useCallback((l) => {
      l && (r.current = getComputedStyle(l)), n(l);
    }, [])
  };
}
function uu(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function sH(t) {
  var r, s;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var bp = 0;
function iH() {
  E.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? cA()), document.body.insertAdjacentElement("beforeend", t[1] ?? cA()), bp++, () => {
      bp === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), bp--;
    };
  }, []);
}
function cA() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var wr = function() {
  return wr = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, wr.apply(this, arguments);
};
function tk(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
      e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (n[r[s]] = t[r[s]]);
  return n;
}
function oH(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, s = e.length, i; r < s; r++)
    (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var Xu = "right-scroll-bar-position", Ju = "width-before-scroll-bar", aH = "with-scroll-bars-hidden", cH = "--removed-body-scroll-bar-size";
function vp(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function lH(t, e) {
  var n = Ge(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var s = n.value;
          s !== r && (n.value = r, n.callback(r, s));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var uH = typeof window < "u" ? E.useLayoutEffect : E.useEffect, lA = /* @__PURE__ */ new WeakMap();
function dH(t, e) {
  var n = lH(null, function(r) {
    return t.forEach(function(s) {
      return vp(s, r);
    });
  });
  return uH(function() {
    var r = lA.get(n);
    if (r) {
      var s = new Set(r), i = new Set(t), o = n.current;
      s.forEach(function(a) {
        i.has(a) || vp(a, null);
      }), i.forEach(function(a) {
        s.has(a) || vp(a, o);
      });
    }
    lA.set(n, t);
  }, [t]), n;
}
function fH(t) {
  return t;
}
function hH(t, e) {
  e === void 0 && (e = fH);
  var n = [], r = !1, s = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(i) {
      var o = e(i, r);
      return n.push(o), function() {
        n = n.filter(function(a) {
          return a !== o;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(i);
      }
      n = {
        push: function(a) {
          return i(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var o = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(i), o = n;
      }
      var c = function() {
        var u = o;
        o = [], u.forEach(i);
      }, l = function() {
        return Promise.resolve().then(c);
      };
      l(), n = {
        push: function(u) {
          o.push(u), l();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return s;
}
function pH(t) {
  t === void 0 && (t = {});
  var e = hH(null);
  return e.options = wr({ async: !0, ssr: !1 }, t), e;
}
var nk = function(t) {
  var e = t.sideCar, n = tk(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return E.createElement(r, wr({}, n));
};
nk.isSideCarExport = !0;
function mH(t, e) {
  return t.useMedium(e), nk;
}
var rk = pH(), xp = function() {
}, $f = E.forwardRef(function(t, e) {
  var n = E.useRef(null), r = E.useState({
    onScrollCapture: xp,
    onWheelCapture: xp,
    onTouchMoveCapture: xp
  }), s = r[0], i = r[1], o = t.forwardProps, a = t.children, c = t.className, l = t.removeScrollBar, u = t.enabled, d = t.shards, f = t.sideCar, h = t.noIsolation, p = t.inert, m = t.allowPinchZoom, y = t.as, b = y === void 0 ? "div" : y, v = t.gapMode, w = tk(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x = f, A = dH([n, e]), C = wr(wr({}, w), s);
  return E.createElement(
    E.Fragment,
    null,
    u && E.createElement(x, { sideCar: rk, removeScrollBar: l, shards: d, noIsolation: h, inert: p, setCallbacks: i, allowPinchZoom: !!m, lockRef: n, gapMode: v }),
    o ? E.cloneElement(E.Children.only(a), wr(wr({}, C), { ref: A })) : E.createElement(b, wr({}, C, { className: c, ref: A }), a)
  );
});
$f.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
$f.classNames = {
  fullWidth: Ju,
  zeroRight: Xu
};
var gH = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function yH() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = gH();
  return e && t.setAttribute("nonce", e), t;
}
function bH(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function vH(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var xH = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = yH()) && (bH(e, n), vH(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, wH = function() {
  var t = xH();
  return function(e, n) {
    E.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, sk = function() {
  var t = wH(), e = function(n) {
    var r = n.styles, s = n.dynamic;
    return t(r, s), null;
  };
  return e;
}, AH = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, wp = function(t) {
  return parseInt(t || "", 10) || 0;
}, SH = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], s = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [wp(n), wp(r), wp(s)];
}, EH = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return AH;
  var e = SH(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, CH = sk(), Vo = "data-scroll-locked", _H = function(t, e, n, r) {
  var s = t.left, i = t.top, o = t.right, a = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(aH, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(Vo, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Xu, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Ju, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Xu, " .").concat(Xu, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Ju, " .").concat(Ju, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Vo, `] {
    `).concat(cH, ": ").concat(a, `px;
  }
`);
}, uA = function() {
  var t = parseInt(document.body.getAttribute(Vo) || "0", 10);
  return isFinite(t) ? t : 0;
}, TH = function() {
  E.useEffect(function() {
    return document.body.setAttribute(Vo, (uA() + 1).toString()), function() {
      var t = uA() - 1;
      t <= 0 ? document.body.removeAttribute(Vo) : document.body.setAttribute(Vo, t.toString());
    };
  }, []);
}, kH = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, s = r === void 0 ? "margin" : r;
  TH();
  var i = E.useMemo(function() {
    return EH(s);
  }, [s]);
  return E.createElement(CH, { styles: _H(i, !e, s, n ? "" : "!important") });
}, Ym = !1;
if (typeof window < "u")
  try {
    var du = Object.defineProperty({}, "passive", {
      get: function() {
        return Ym = !0, !0;
      }
    });
    window.addEventListener("test", du, du), window.removeEventListener("test", du, du);
  } catch {
    Ym = !1;
  }
var go = Ym ? { passive: !1 } : !1, RH = function(t) {
  return t.tagName === "TEXTAREA";
}, ik = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !RH(t) && n[e] === "visible")
  );
}, MH = function(t) {
  return ik(t, "overflowY");
}, PH = function(t) {
  return ik(t, "overflowX");
}, dA = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var s = ok(t, r);
    if (s) {
      var i = ak(t, r), o = i[1], a = i[2];
      if (o > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, IH = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, DH = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, ok = function(t, e) {
  return t === "v" ? MH(e) : PH(e);
}, ak = function(t, e) {
  return t === "v" ? IH(e) : DH(e);
}, OH = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, qH = function(t, e, n, r, s) {
  var i = OH(t, window.getComputedStyle(e).direction), o = i * r, a = n.target, c = e.contains(a), l = !1, u = o > 0, d = 0, f = 0;
  do {
    var h = ak(t, a), p = h[0], m = h[1], y = h[2], b = m - y - i * p;
    (p || b) && ok(t, a) && (d += b, f += p), a instanceof ShadowRoot ? a = a.host : a = a.parentNode;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (e.contains(a) || e === a)
  );
  return (u && (Math.abs(d) < 1 || !s) || !u && (Math.abs(f) < 1 || !s)) && (l = !0), l;
}, fu = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, fA = function(t) {
  return [t.deltaX, t.deltaY];
}, hA = function(t) {
  return t && "current" in t ? t.current : t;
}, NH = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, LH = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, jH = 0, yo = [];
function BH(t) {
  var e = E.useRef([]), n = E.useRef([0, 0]), r = E.useRef(), s = E.useState(jH++)[0], i = E.useState(sk)[0], o = E.useRef(t);
  E.useEffect(function() {
    o.current = t;
  }, [t]), E.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(s));
      var m = oH([t.lockRef.current], (t.shards || []).map(hA), !0).filter(Boolean);
      return m.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(s));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(s)), m.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(s));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = E.useCallback(function(m, y) {
    if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey)
      return !o.current.allowPinchZoom;
    var b = fu(m), v = n.current, w = "deltaX" in m ? m.deltaX : v[0] - b[0], x = "deltaY" in m ? m.deltaY : v[1] - b[1], A, C = m.target, S = Math.abs(w) > Math.abs(x) ? "h" : "v";
    if ("touches" in m && S === "h" && C.type === "range")
      return !1;
    var _ = dA(S, C);
    if (!_)
      return !0;
    if (_ ? A = S : (A = S === "v" ? "h" : "v", _ = dA(S, C)), !_)
      return !1;
    if (!r.current && "changedTouches" in m && (w || x) && (r.current = A), !A)
      return !0;
    var T = r.current || A;
    return qH(T, y, m, T === "h" ? w : x, !0);
  }, []), c = E.useCallback(function(m) {
    var y = m;
    if (!(!yo.length || yo[yo.length - 1] !== i)) {
      var b = "deltaY" in y ? fA(y) : fu(y), v = e.current.filter(function(A) {
        return A.name === y.type && (A.target === y.target || y.target === A.shadowParent) && NH(A.delta, b);
      })[0];
      if (v && v.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!v) {
        var w = (o.current.shards || []).map(hA).filter(Boolean).filter(function(A) {
          return A.contains(y.target);
        }), x = w.length > 0 ? a(y, w[0]) : !o.current.noIsolation;
        x && y.cancelable && y.preventDefault();
      }
    }
  }, []), l = E.useCallback(function(m, y, b, v) {
    var w = { name: m, delta: y, target: b, should: v, shadowParent: FH(b) };
    e.current.push(w), setTimeout(function() {
      e.current = e.current.filter(function(x) {
        return x !== w;
      });
    }, 1);
  }, []), u = E.useCallback(function(m) {
    n.current = fu(m), r.current = void 0;
  }, []), d = E.useCallback(function(m) {
    l(m.type, fA(m), m.target, a(m, t.lockRef.current));
  }, []), f = E.useCallback(function(m) {
    l(m.type, fu(m), m.target, a(m, t.lockRef.current));
  }, []);
  E.useEffect(function() {
    return yo.push(i), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", c, go), document.addEventListener("touchmove", c, go), document.addEventListener("touchstart", u, go), function() {
      yo = yo.filter(function(m) {
        return m !== i;
      }), document.removeEventListener("wheel", c, go), document.removeEventListener("touchmove", c, go), document.removeEventListener("touchstart", u, go);
    };
  }, []);
  var h = t.removeScrollBar, p = t.inert;
  return E.createElement(
    E.Fragment,
    null,
    p ? E.createElement(i, { styles: LH(s) }) : null,
    h ? E.createElement(kH, { gapMode: t.gapMode }) : null
  );
}
function FH(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const VH = mH(rk, BH);
var ck = E.forwardRef(function(t, e) {
  return E.createElement($f, wr({}, t, { ref: e, sideCar: VH }));
});
ck.classNames = $f.classNames;
var UH = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, bo = /* @__PURE__ */ new WeakMap(), hu = /* @__PURE__ */ new WeakMap(), pu = {}, Ap = 0, lk = function(t) {
  return t && (t.host || lk(t.parentNode));
}, WH = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = lk(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, zH = function(t, e, n, r) {
  var s = WH(e, Array.isArray(t) ? t : [t]);
  pu[n] || (pu[n] = /* @__PURE__ */ new WeakMap());
  var i = pu[n], o = [], a = /* @__PURE__ */ new Set(), c = new Set(s), l = function(d) {
    !d || a.has(d) || (a.add(d), l(d.parentNode));
  };
  s.forEach(l);
  var u = function(d) {
    !d || c.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (a.has(f))
        u(f);
      else
        try {
          var h = f.getAttribute(r), p = h !== null && h !== "false", m = (bo.get(f) || 0) + 1, y = (i.get(f) || 0) + 1;
          bo.set(f, m), i.set(f, y), o.push(f), m === 1 && p && hu.set(f, !0), y === 1 && f.setAttribute(n, "true"), p || f.setAttribute(r, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", f, b);
        }
    });
  };
  return u(e), a.clear(), Ap++, function() {
    o.forEach(function(d) {
      var f = bo.get(d) - 1, h = i.get(d) - 1;
      bo.set(d, f), i.set(d, h), f || (hu.has(d) || d.removeAttribute(r), hu.delete(d)), h || d.removeAttribute(n);
    }), Ap--, Ap || (bo = /* @__PURE__ */ new WeakMap(), bo = /* @__PURE__ */ new WeakMap(), hu = /* @__PURE__ */ new WeakMap(), pu = {});
  };
}, HH = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), s = UH(t);
  return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))), zH(r, s, n, "aria-hidden")) : function() {
    return null;
  };
}, eb = "Dialog", [uk, Ate] = B6(eb), [YH, pr] = uk(eb), dk = (t) => {
  const {
    __scopeDialog: e,
    children: n,
    open: r,
    defaultOpen: s,
    onOpenChange: i,
    modal: o = !0
  } = t, a = E.useRef(null), c = E.useRef(null), [l = !1, u] = Ea({
    prop: r,
    defaultProp: s,
    onChange: i
  });
  return /* @__PURE__ */ g.jsx(
    YH,
    {
      scope: e,
      triggerRef: a,
      contentRef: c,
      contentId: jo(),
      titleId: jo(),
      descriptionId: jo(),
      open: l,
      onOpenChange: u,
      onOpenToggle: E.useCallback(() => u((d) => !d), [u]),
      modal: o,
      children: n
    }
  );
};
dk.displayName = eb;
var fk = "DialogTrigger", hk = E.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = pr(fk, n), i = Ke(e, s.triggerRef);
    return /* @__PURE__ */ g.jsx(
      ze.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": s.open,
        "aria-controls": s.contentId,
        "data-state": rb(s.open),
        ...r,
        ref: i,
        onClick: We(t.onClick, s.onOpenToggle)
      }
    );
  }
);
hk.displayName = fk;
var tb = "DialogPortal", [GH, pk] = uk(tb, {
  forceMount: void 0
}), mk = (t) => {
  const { __scopeDialog: e, forceMount: n, children: r, container: s } = t, i = pr(tb, e);
  return /* @__PURE__ */ g.jsx(GH, { scope: e, forceMount: n, children: E.Children.map(r, (o) => /* @__PURE__ */ g.jsx(Kf, { present: n || i.open, children: /* @__PURE__ */ g.jsx(ek, { asChild: !0, container: s, children: o }) })) });
};
mk.displayName = tb;
var Hd = "DialogOverlay", gk = E.forwardRef(
  (t, e) => {
    const n = pk(Hd, t.__scopeDialog), { forceMount: r = n.forceMount, ...s } = t, i = pr(Hd, t.__scopeDialog);
    return i.modal ? /* @__PURE__ */ g.jsx(Kf, { present: r || i.open, children: /* @__PURE__ */ g.jsx(KH, { ...s, ref: e }) }) : null;
  }
);
gk.displayName = Hd;
var KH = E.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = pr(Hd, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ g.jsx(ck, { as: Ko, allowPinchZoom: !0, shards: [s.contentRef], children: /* @__PURE__ */ g.jsx(
        ze.div,
        {
          "data-state": rb(s.open),
          ...r,
          ref: e,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), $i = "DialogContent", yk = E.forwardRef(
  (t, e) => {
    const n = pk($i, t.__scopeDialog), { forceMount: r = n.forceMount, ...s } = t, i = pr($i, t.__scopeDialog);
    return /* @__PURE__ */ g.jsx(Kf, { present: r || i.open, children: i.modal ? /* @__PURE__ */ g.jsx($H, { ...s, ref: e }) : /* @__PURE__ */ g.jsx(ZH, { ...s, ref: e }) });
  }
);
yk.displayName = $i;
var $H = E.forwardRef(
  (t, e) => {
    const n = pr($i, t.__scopeDialog), r = E.useRef(null), s = Ke(e, n.contentRef, r);
    return E.useEffect(() => {
      const i = r.current;
      if (i) return HH(i);
    }, []), /* @__PURE__ */ g.jsx(
      bk,
      {
        ...t,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: We(t.onCloseAutoFocus, (i) => {
          var o;
          i.preventDefault(), (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: We(t.onPointerDownOutside, (i) => {
          const o = i.detail.originalEvent, a = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || a) && i.preventDefault();
        }),
        onFocusOutside: We(
          t.onFocusOutside,
          (i) => i.preventDefault()
        )
      }
    );
  }
), ZH = E.forwardRef(
  (t, e) => {
    const n = pr($i, t.__scopeDialog), r = E.useRef(!1), s = E.useRef(!1);
    return /* @__PURE__ */ g.jsx(
      bk,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var o, a;
          (o = t.onCloseAutoFocus) == null || o.call(t, i), i.defaultPrevented || (r.current || (a = n.triggerRef.current) == null || a.focus(), i.preventDefault()), r.current = !1, s.current = !1;
        },
        onInteractOutside: (i) => {
          var c, l;
          (c = t.onInteractOutside) == null || c.call(t, i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (s.current = !0));
          const o = i.target;
          ((l = n.triggerRef.current) == null ? void 0 : l.contains(o)) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && s.current && i.preventDefault();
        }
      }
    );
  }
), bk = E.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: s, onCloseAutoFocus: i, ...o } = t, a = pr($i, n), c = E.useRef(null), l = Ke(e, c);
    return iH(), /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(
        XT,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: s,
          onUnmountAutoFocus: i,
          children: /* @__PURE__ */ g.jsx(
            ZT,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": rb(a.open),
              ...o,
              ref: l,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
        /* @__PURE__ */ g.jsx(QH, { titleId: a.titleId }),
        /* @__PURE__ */ g.jsx(JH, { contentRef: c, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), nb = "DialogTitle", vk = E.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = pr(nb, n);
    return /* @__PURE__ */ g.jsx(ze.h2, { id: s.titleId, ...r, ref: e });
  }
);
vk.displayName = nb;
var xk = "DialogDescription", wk = E.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = pr(xk, n);
    return /* @__PURE__ */ g.jsx(ze.p, { id: s.descriptionId, ...r, ref: e });
  }
);
wk.displayName = xk;
var Ak = "DialogClose", Sk = E.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = pr(Ak, n);
    return /* @__PURE__ */ g.jsx(
      ze.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: We(t.onClick, () => s.onOpenChange(!1))
      }
    );
  }
);
Sk.displayName = Ak;
function rb(t) {
  return t ? "open" : "closed";
}
var Ek = "DialogTitleWarning", [Ste, Ck] = j6(Ek, {
  contentName: $i,
  titleName: nb,
  docsSlug: "dialog"
}), QH = ({ titleId: t }) => {
  const e = Ck(Ek), n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
  return E.useEffect(() => {
    t && (document.getElementById(t) || console.error(n));
  }, [n, t]), null;
}, XH = "DialogDescriptionWarning", JH = ({ contentRef: t, descriptionId: e }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${Ck(XH).contentName}}.`;
  return E.useEffect(() => {
    var i;
    const s = (i = t.current) == null ? void 0 : i.getAttribute("aria-describedby");
    e && s && (document.getElementById(e) || console.warn(r));
  }, [r, t, e]), null;
}, _k = dk, Tk = hk, e7 = mk, sb = gk, ib = yk, ob = vk, ab = wk, kk = Sk;
const cb = _k, Rk = Tk, Mk = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  sb,
  {
    ref: n,
    className: de(
      "fixed inset-0 z-[1000] bg-none  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      t
    ),
    ...e
  }
));
Mk.displayName = sb.displayName;
const Zf = E.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g.jsx(g.Fragment, { children: /* @__PURE__ */ g.jsx(Mk, { children: /* @__PURE__ */ g.jsxs(
  ib,
  {
    ref: r,
    className: de(
      "fixed left-[50%] top-[50%] grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
      t
    ),
    ...n,
    children: [
      e,
      /* @__PURE__ */ g.jsxs(kk, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
        /* @__PURE__ */ g.jsx(LF, { className: "h-5 w-5 text-white" }),
        /* @__PURE__ */ g.jsx("span", { className: "sr-only", children: "Close" })
      ] })
    ]
  }
) }) }));
Zf.displayName = ib.displayName;
const Qf = ({
  className: t,
  ...e
}) => /* @__PURE__ */ g.jsx(
  "div",
  {
    className: de(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      t
    ),
    ...e
  }
);
Qf.displayName = "DialogHeader";
const Xf = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  ob,
  {
    ref: n,
    className: de(
      "text-lg font-semibold leading-none tracking-tight",
      t
    ),
    ...e
  }
));
Xf.displayName = ob.displayName;
const t7 = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  ab,
  {
    ref: n,
    className: de("text-sm text-muted-foreground", t),
    ...e
  }
));
t7.displayName = ab.displayName;
function n7(t) {
  if (typeof document > "u") return;
  let e = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", e.appendChild(n), n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(document.createTextNode(t));
}
const Pk = z.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: !1,
  isOpen: !1,
  isDragging: !1,
  keyboardIsOpen: {
    current: !1
  },
  snapPointsOffset: null,
  snapPoints: null,
  handleOnly: !1,
  modal: !1,
  shouldFade: !1,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  closeDrawer: () => {
  },
  direction: "bottom",
  shouldScaleBackground: !1,
  setBackgroundColorOnScale: !0,
  noBodyStyles: !1,
  container: null,
  autoFocus: !1
}), ka = () => {
  const t = z.useContext(Pk);
  if (!t)
    throw new Error("useDrawerContext must be used within a Drawer.Root");
  return t;
};
n7(`[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(
[data-state=closed]
){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,100%,0)}}@keyframes slideFromTop{from{transform:translate3d(0,-100%,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,-100%,0)}}@keyframes slideFromLeft{from{transform:translate3d(-100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(-100%,0,0)}}@keyframes slideFromRight{from{transform:translate3d(100%,0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(100%,0,0)}}`);
const r7 = 24, s7 = typeof window < "u" ? Ig : _e;
function pA(...t) {
  return (...e) => {
    for (let n of t)
      typeof n == "function" && n(...e);
  };
}
function i7() {
  return lb(/^Mac/);
}
function o7() {
  return lb(/^iPhone/);
}
function mA() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function a7() {
  return lb(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  i7() && navigator.maxTouchPoints > 1;
}
function Ik() {
  return o7() || a7();
}
function lb(t) {
  return typeof window < "u" && window.navigator != null ? t.test(window.navigator.platform) : void 0;
}
const Sp = typeof document < "u" && window.visualViewport;
function gA(t) {
  let e = window.getComputedStyle(t);
  return /(auto|scroll)/.test(e.overflow + e.overflowX + e.overflowY);
}
function Dk(t) {
  for (gA(t) && (t = t.parentElement); t && !gA(t); )
    t = t.parentElement;
  return t || document.scrollingElement || document.documentElement;
}
const c7 = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let mu = 0, Ep;
function l7(t = {}) {
  let { isDisabled: e } = t;
  s7(() => {
    if (!e)
      return mu++, mu === 1 && Ik() && (Ep = u7()), () => {
        mu--, mu === 0 && (Ep == null || Ep());
      };
  }, [
    e
  ]);
}
function u7() {
  let t, e = 0, n = (d) => {
    t = Dk(d.target), !(t === document.documentElement && t === document.body) && (e = d.changedTouches[0].pageY);
  }, r = (d) => {
    if (!t || t === document.documentElement || t === document.body) {
      d.preventDefault();
      return;
    }
    let f = d.changedTouches[0].pageY, h = t.scrollTop, p = t.scrollHeight - t.clientHeight;
    p !== 0 && ((h <= 0 && f > e || h >= p && f < e) && d.preventDefault(), e = f);
  }, s = (d) => {
    let f = d.target;
    Gm(f) && f !== document.activeElement && (d.preventDefault(), f.style.transform = "translateY(-2000px)", f.focus(), requestAnimationFrame(() => {
      f.style.transform = "";
    }));
  }, i = (d) => {
    let f = d.target;
    Gm(f) && (f.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      f.style.transform = "", Sp && (Sp.height < window.innerHeight ? requestAnimationFrame(() => {
        yA(f);
      }) : Sp.addEventListener("resize", () => yA(f), {
        once: !0
      }));
    }));
  }, o = () => {
    window.scrollTo(0, 0);
  }, a = window.pageXOffset, c = window.pageYOffset, l = pA(d7(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let u = pA(Xa(document, "touchstart", n, {
    passive: !1,
    capture: !0
  }), Xa(document, "touchmove", r, {
    passive: !1,
    capture: !0
  }), Xa(document, "touchend", s, {
    passive: !1,
    capture: !0
  }), Xa(document, "focus", i, !0), Xa(window, "scroll", o));
  return () => {
    l(), u(), window.scrollTo(a, c);
  };
}
function d7(t, e, n) {
  let r = t.style[e];
  return t.style[e] = n, () => {
    t.style[e] = r;
  };
}
function Xa(t, e, n, r) {
  return t.addEventListener(e, n, r), () => {
    t.removeEventListener(e, n, r);
  };
}
function yA(t) {
  let e = document.scrollingElement || document.documentElement;
  for (; t && t !== e; ) {
    let n = Dk(t);
    if (n !== document.documentElement && n !== document.body && n !== t) {
      let r = n.getBoundingClientRect().top, s = t.getBoundingClientRect().top, i = t.getBoundingClientRect().bottom;
      const o = n.getBoundingClientRect().bottom + r7;
      i > o && (n.scrollTop += s - r);
    }
    t = n.parentElement;
  }
}
function Gm(t) {
  return t instanceof HTMLInputElement && !c7.has(t.type) || t instanceof HTMLTextAreaElement || t instanceof HTMLElement && t.isContentEditable;
}
function f7(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function h7(...t) {
  return (e) => t.forEach((n) => f7(n, e));
}
function Ok(...t) {
  return E.useCallback(h7(...t), t);
}
const qk = /* @__PURE__ */ new WeakMap();
function Lt(t, e, n = !1) {
  if (!t || !(t instanceof HTMLElement)) return;
  let r = {};
  Object.entries(e).forEach(([s, i]) => {
    if (s.startsWith("--")) {
      t.style.setProperty(s, i);
      return;
    }
    r[s] = t.style[s], t.style[s] = i;
  }), !n && qk.set(t, r);
}
function p7(t, e) {
  if (!t || !(t instanceof HTMLElement)) return;
  let n = qk.get(t);
  n && (t.style[e] = n[e]);
}
const jt = (t) => {
  switch (t) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return t;
  }
};
function gu(t, e) {
  if (!t)
    return null;
  const n = window.getComputedStyle(t), r = (
    // @ts-ignore
    n.transform || n.webkitTransform || n.mozTransform
  );
  let s = r.match(/^matrix3d\((.+)\)$/);
  return s ? parseFloat(s[1].split(", ")[jt(e) ? 13 : 12]) : (s = r.match(/^matrix\((.+)\)$/), s ? parseFloat(s[1].split(", ")[jt(e) ? 5 : 4]) : null);
}
function m7(t) {
  return 8 * (Math.log(t + 1) - 2);
}
function Cp(t, e) {
  if (!t) return () => {
  };
  const n = t.style.cssText;
  return Object.assign(t.style, e), () => {
    t.style.cssText = n;
  };
}
function g7(...t) {
  return (...e) => {
    for (const n of t)
      typeof n == "function" && n(...e);
  };
}
const yt = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
}, Nk = 0.4, y7 = 0.25, b7 = 100, Lk = 8, wi = 16, Km = 26, _p = "vaul-dragging";
function jk(t) {
  const e = z.useRef(t);
  return z.useEffect(() => {
    e.current = t;
  }), z.useMemo(() => (...n) => e.current == null ? void 0 : e.current.call(e, ...n), []);
}
function v7({ defaultProp: t, onChange: e }) {
  const n = z.useState(t), [r] = n, s = z.useRef(r), i = jk(e);
  return z.useEffect(() => {
    s.current !== r && (i(r), s.current = r);
  }, [
    r,
    s,
    i
  ]), n;
}
function Bk({ prop: t, defaultProp: e, onChange: n = () => {
} }) {
  const [r, s] = v7({
    defaultProp: e,
    onChange: n
  }), i = t !== void 0, o = i ? t : r, a = jk(n), c = z.useCallback((l) => {
    if (i) {
      const d = typeof l == "function" ? l(t) : l;
      d !== t && a(d);
    } else
      s(l);
  }, [
    i,
    t,
    s,
    a
  ]);
  return [
    o,
    c
  ];
}
function x7({ activeSnapPointProp: t, setActiveSnapPointProp: e, snapPoints: n, drawerRef: r, overlayRef: s, fadeFromIndex: i, onSnapPointChange: o, direction: a = "bottom", container: c, snapToSequentialPoint: l }) {
  const [u, d] = Bk({
    prop: t,
    defaultProp: n == null ? void 0 : n[0],
    onChange: e
  }), [f, h] = z.useState(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  z.useEffect(() => {
    function S() {
      h({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }
    return window.addEventListener("resize", S), () => window.removeEventListener("resize", S);
  }, []);
  const p = z.useMemo(() => u === (n == null ? void 0 : n[n.length - 1]) || null, [
    n,
    u
  ]), m = z.useMemo(() => n == null ? void 0 : n.findIndex((S) => S === u), [
    n,
    u
  ]), y = n && n.length > 0 && (i || i === 0) && !Number.isNaN(i) && n[i] === u || !n, b = z.useMemo(() => {
    const S = c ? {
      width: c.getBoundingClientRect().width,
      height: c.getBoundingClientRect().height
    } : typeof window < "u" ? {
      width: window.innerWidth,
      height: window.innerHeight
    } : {
      width: 0,
      height: 0
    };
    var _;
    return (_ = n == null ? void 0 : n.map((T) => {
      const k = typeof T == "string";
      let R = 0;
      if (k && (R = parseInt(T, 10)), jt(a)) {
        const M = k ? R : f ? T * S.height : 0;
        return f ? a === "bottom" ? S.height - M : -S.height + M : M;
      }
      const P = k ? R : f ? T * S.width : 0;
      return f ? a === "right" ? S.width - P : -S.width + P : P;
    })) != null ? _ : [];
  }, [
    n,
    f,
    c
  ]), v = z.useMemo(() => m !== null ? b == null ? void 0 : b[m] : null, [
    b,
    m
  ]), w = z.useCallback((S) => {
    var _;
    const T = (_ = b == null ? void 0 : b.findIndex((k) => k === S)) != null ? _ : null;
    o(T), Lt(r.current, {
      transition: `transform ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`,
      transform: jt(a) ? `translate3d(0, ${S}px, 0)` : `translate3d(${S}px, 0, 0)`
    }), b && T !== b.length - 1 && T !== i && T < i ? Lt(s.current, {
      transition: `opacity ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`,
      opacity: "0"
    }) : Lt(s.current, {
      transition: `opacity ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`,
      opacity: "1"
    }), d(n == null ? void 0 : n[Math.max(T, 0)]);
  }, [
    r.current,
    n,
    b,
    i,
    s,
    d
  ]);
  z.useEffect(() => {
    if (u || t) {
      var S;
      const _ = (S = n == null ? void 0 : n.findIndex((T) => T === t || T === u)) != null ? S : -1;
      b && _ !== -1 && typeof b[_] == "number" && w(b[_]);
    }
  }, [
    u,
    t,
    n,
    b,
    w
  ]);
  function x({ draggedDistance: S, closeDrawer: _, velocity: T, dismissible: k }) {
    if (i === void 0) return;
    const R = a === "bottom" || a === "right" ? (v ?? 0) - S : (v ?? 0) + S, P = m === i - 1, M = m === 0, D = S > 0;
    if (P && Lt(s.current, {
      transition: `opacity ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`
    }), !l && T > 2 && !D) {
      k ? _() : w(b[0]);
      return;
    }
    if (!l && T > 2 && D && b && n) {
      w(b[n.length - 1]);
      return;
    }
    const O = b == null ? void 0 : b.reduce((L, N) => typeof L != "number" || typeof N != "number" ? L : Math.abs(N - R) < Math.abs(L - R) ? N : L), q = jt(a) ? window.innerHeight : window.innerWidth;
    if (T > Nk && Math.abs(S) < q * 0.4) {
      const L = D ? 1 : -1;
      if (L > 0 && p) {
        w(b[n.length - 1]);
        return;
      }
      if (M && L < 0 && k && _(), m === null) return;
      w(b[m + L]);
      return;
    }
    w(O);
  }
  function A({ draggedDistance: S }) {
    if (v === null) return;
    const _ = a === "bottom" || a === "right" ? v - S : v + S;
    (a === "bottom" || a === "right") && _ < b[b.length - 1] || (a === "top" || a === "left") && _ > b[b.length - 1] || Lt(r.current, {
      transform: jt(a) ? `translate3d(0, ${_}px, 0)` : `translate3d(${_}px, 0, 0)`
    });
  }
  function C(S, _) {
    if (!n || typeof m != "number" || !b || i === void 0) return null;
    const T = m === i - 1;
    if (m >= i && _)
      return 0;
    if (T && !_) return 1;
    if (!y && !T) return null;
    const R = T ? m + 1 : m - 1, P = T ? b[R] - b[R - 1] : b[R + 1] - b[R], M = S / Math.abs(P);
    return T ? 1 - M : M;
  }
  return {
    isLastSnapPoint: p,
    activeSnapPoint: u,
    shouldFade: y,
    getPercentageDragged: C,
    setActiveSnapPoint: d,
    activeSnapPointIndex: m,
    onRelease: x,
    onDrag: A,
    snapPointsOffset: b
  };
}
const w7 = () => () => {
};
function A7() {
  const { direction: t, isOpen: e, shouldScaleBackground: n, setBackgroundColorOnScale: r, noBodyStyles: s } = ka(), i = z.useRef(null), o = Pr(() => document.body.style.backgroundColor, []);
  function a() {
    return (window.innerWidth - Km) / window.innerWidth;
  }
  z.useEffect(() => {
    if (e && n) {
      i.current && clearTimeout(i.current);
      const c = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!c) return;
      g7(r && !s ? Cp(document.body, {
        background: "black"
      }) : w7, Cp(c, {
        transformOrigin: jt(t) ? "top" : "left",
        transitionProperty: "transform, border-radius",
        transitionDuration: `${yt.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${yt.EASE.join(",")})`
      }));
      const l = Cp(c, {
        borderRadius: `${Lk}px`,
        overflow: "hidden",
        ...jt(t) ? {
          transform: `scale(${a()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${a()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      return () => {
        l(), i.current = window.setTimeout(() => {
          o ? document.body.style.background = o : document.body.style.removeProperty("background");
        }, yt.DURATION * 1e3);
      };
    }
  }, [
    e,
    n,
    o
  ]);
}
let Ja = null;
function S7({ isOpen: t, modal: e, nested: n, hasBeenOpened: r, preventScrollRestoration: s, noBodyStyles: i }) {
  const [o, a] = z.useState(() => typeof window < "u" ? window.location.href : ""), c = z.useRef(0), l = z.useCallback(() => {
    if (mA() && Ja === null && t && !i) {
      Ja = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX: d, innerHeight: f } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-c.current}px`,
        left: `${-d}px`,
        right: "0px",
        height: "auto"
      }), window.setTimeout(() => window.requestAnimationFrame(() => {
        const h = f - window.innerHeight;
        h && c.current >= f && (document.body.style.top = `${-(c.current + h)}px`);
      }), 300);
    }
  }, [
    t
  ]), u = z.useCallback(() => {
    if (mA() && Ja !== null && !i) {
      const d = -parseInt(document.body.style.top, 10), f = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, Ja), window.requestAnimationFrame(() => {
        if (s && o !== window.location.href) {
          a(window.location.href);
          return;
        }
        window.scrollTo(f, d);
      }), Ja = null;
    }
  }, [
    o
  ]);
  return z.useEffect(() => {
    function d() {
      c.current = window.scrollY;
    }
    return d(), window.addEventListener("scroll", d), () => {
      window.removeEventListener("scroll", d);
    };
  }, []), z.useEffect(() => {
    n || !r || (t ? (!window.matchMedia("(display-mode: standalone)").matches && l(), e || window.setTimeout(() => {
      u();
    }, 500)) : u());
  }, [
    t,
    r,
    o,
    e,
    n,
    l,
    u
  ]), {
    restorePositionSetting: u
  };
}
function Fk({ open: t, onOpenChange: e, children: n, onDrag: r, onRelease: s, snapPoints: i, shouldScaleBackground: o = !1, setBackgroundColorOnScale: a = !0, closeThreshold: c = y7, scrollLockTimeout: l = b7, dismissible: u = !0, handleOnly: d = !1, fadeFromIndex: f = i && i.length - 1, activeSnapPoint: h, setActiveSnapPoint: p, fixed: m, modal: y = !0, onClose: b, nested: v, noBodyStyles: w, direction: x = "bottom", defaultOpen: A = !1, disablePreventScroll: C = !0, snapToSequentialPoint: S = !1, preventScrollRestoration: _ = !1, repositionInputs: T = !0, onAnimationEnd: k, container: R, autoFocus: P = !1 }) {
  var M, D;
  const [O = !1, q] = Bk({
    defaultProp: A,
    prop: t,
    onChange: (ce) => {
      e == null || e(ce), !ce && !v && ao(), setTimeout(() => {
        k == null || k(ce);
      }, yt.DURATION * 1e3), ce && !y && typeof window < "u" && window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      }), ce || (document.body.style.pointerEvents = "auto");
    }
  }), [L, N] = z.useState(!1), [j, V] = z.useState(!1), [Z, G] = z.useState(!1), $ = z.useRef(null), fe = z.useRef(null), he = z.useRef(null), be = z.useRef(null), He = z.useRef(null), at = z.useRef(!1), xt = z.useRef(null), tt = z.useRef(0), wt = z.useRef(!1), F = z.useRef(0), ee = z.useRef(null), re = z.useRef(((M = ee.current) == null ? void 0 : M.getBoundingClientRect().height) || 0), nt = z.useRef(((D = ee.current) == null ? void 0 : D.getBoundingClientRect().width) || 0), kt = z.useRef(0), Yn = z.useCallback((ce) => {
    i && ce === te.length - 1 && (fe.current = /* @__PURE__ */ new Date());
  }, []), { activeSnapPoint: Pn, activeSnapPointIndex: Rt, setActiveSnapPoint: Y, onRelease: ye, snapPointsOffset: te, onDrag: ve, shouldFade: Ee, getPercentageDragged: xn } = x7({
    snapPoints: i,
    activeSnapPointProp: h,
    setActiveSnapPointProp: p,
    drawerRef: ee,
    fadeFromIndex: f,
    overlayRef: $,
    onSnapPointChange: Yn,
    direction: x,
    container: R,
    snapToSequentialPoint: S
  });
  l7({
    isDisabled: !O || j || !y || Z || !L || !T || !C
  });
  const { restorePositionSetting: ao } = S7({
    isOpen: O,
    modal: y,
    nested: v,
    hasBeenOpened: L,
    preventScrollRestoration: _,
    noBodyStyles: w
  });
  function mr() {
    return (window.innerWidth - Km) / window.innerWidth;
  }
  function wh(ce) {
    var Ve, rt;
    !u && !i || ee.current && !ee.current.contains(ce.target) || (re.current = ((Ve = ee.current) == null ? void 0 : Ve.getBoundingClientRect().height) || 0, nt.current = ((rt = ee.current) == null ? void 0 : rt.getBoundingClientRect().width) || 0, V(!0), he.current = /* @__PURE__ */ new Date(), Ik() && window.addEventListener("touchend", () => at.current = !1, {
      once: !0
    }), ce.target.setPointerCapture(ce.pointerId), tt.current = jt(x) ? ce.pageY : ce.pageX);
  }
  function Ba(ce, Ve) {
    var rt, Ye;
    let Ue = ce;
    const tn = (rt = window.getSelection()) == null ? void 0 : rt.toString(), Wt = ee.current ? gu(ee.current, x) : null, dn = /* @__PURE__ */ new Date();
    if (Ue.hasAttribute("data-vaul-no-drag") || Ue.closest("[data-vaul-no-drag]"))
      return !1;
    if (x === "right" || x === "left")
      return !0;
    if (fe.current && dn.getTime() - fe.current.getTime() < 500)
      return !1;
    if (Wt !== null && (x === "bottom" ? Wt > 0 : Wt < 0))
      return !0;
    if (tn && tn.length > 0)
      return !1;
    if (dn.getTime() - ((Ye = He.current) == null ? void 0 : Ye.getTime()) < l && Wt === 0 || Ve)
      return He.current = dn, !1;
    for (; Ue; ) {
      if (Ue.scrollHeight > Ue.clientHeight) {
        if (Ue.scrollTop !== 0)
          return He.current = /* @__PURE__ */ new Date(), !1;
        if (Ue.getAttribute("role") === "dialog")
          return !0;
      }
      Ue = Ue.parentNode;
    }
    return !0;
  }
  function Ll(ce) {
    if (ee.current && j) {
      const Ve = x === "bottom" || x === "right" ? 1 : -1, rt = (tt.current - (jt(x) ? ce.pageY : ce.pageX)) * Ve, Ye = rt > 0, Ue = i && !u && !Ye;
      if (Ue && Rt === 0) return;
      const tn = Math.abs(rt), Wt = document.querySelector("[data-vaul-drawer-wrapper]"), dn = x === "bottom" || x === "top" ? re.current : nt.current;
      let wn = tn / dn;
      const Vr = xn(tn, Ye);
      if (Vr !== null && (wn = Vr), Ue && wn >= 1 || !at.current && !Ba(ce.target, Ye)) return;
      if (ee.current.classList.add(_p), at.current = !0, Lt(ee.current, {
        transition: "none"
      }), Lt($.current, {
        transition: "none"
      }), i && ve({
        draggedDistance: rt
      }), Ye && !i) {
        const In = m7(rt), co = Math.min(In * -1, 0) * Ve;
        Lt(ee.current, {
          transform: jt(x) ? `translate3d(0, ${co}px, 0)` : `translate3d(${co}px, 0, 0)`
        });
        return;
      }
      const tr = 1 - wn;
      if ((Ee || f && Rt === f - 1) && (r == null || r(ce, wn), Lt($.current, {
        opacity: `${tr}`,
        transition: "none"
      }, !0)), Wt && $.current && o) {
        const In = Math.min(mr() + wn * (1 - mr()), 1), co = 8 - wn * 8, Bl = Math.max(0, 14 - wn * 14);
        Lt(Wt, {
          borderRadius: `${co}px`,
          transform: jt(x) ? `scale(${In}) translate3d(0, ${Bl}px, 0)` : `scale(${In}) translate3d(${Bl}px, 0, 0)`,
          transition: "none"
        }, !0);
      }
      if (!i) {
        const In = tn * Ve;
        Lt(ee.current, {
          transform: jt(x) ? `translate3d(0, ${In}px, 0)` : `translate3d(${In}px, 0, 0)`
        });
      }
    }
  }
  z.useEffect(() => {
    var ce;
    function Ve() {
      if (!ee.current || !T) return;
      const rt = document.activeElement;
      if (Gm(rt) || wt.current) {
        var Ye;
        const Ue = ((Ye = window.visualViewport) == null ? void 0 : Ye.height) || 0, tn = window.innerHeight;
        let Wt = tn - Ue;
        const dn = ee.current.getBoundingClientRect().height || 0, wn = dn > tn * 0.8;
        kt.current || (kt.current = dn);
        const Vr = ee.current.getBoundingClientRect().top;
        if (Math.abs(F.current - Wt) > 60 && (wt.current = !wt.current), i && i.length > 0 && te && Rt) {
          const tr = te[Rt] || 0;
          Wt += tr;
        }
        if (F.current = Wt, dn > Ue || wt.current) {
          const tr = ee.current.getBoundingClientRect().height;
          let In = tr;
          tr > Ue && (In = Ue - (wn ? Vr : Km)), m ? ee.current.style.height = `${tr - Math.max(Wt, 0)}px` : ee.current.style.height = `${Math.max(In, Ue - Vr)}px`;
        } else
          ee.current.style.height = `${kt.current}px`;
        i && i.length > 0 && !wt.current ? ee.current.style.bottom = "0px" : ee.current.style.bottom = `${Math.max(Wt, 0)}px`;
      }
    }
    return (ce = window.visualViewport) == null || ce.addEventListener("resize", Ve), () => {
      var rt;
      return (rt = window.visualViewport) == null ? void 0 : rt.removeEventListener("resize", Ve);
    };
  }, [
    Rt,
    i,
    te
  ]);
  function Fr(ce) {
    Ah(), b == null || b(), ce || q(!1), setTimeout(() => {
      i && Y(i[0]);
    }, yt.DURATION * 1e3);
  }
  function jl() {
    if (!ee.current) return;
    const ce = document.querySelector("[data-vaul-drawer-wrapper]"), Ve = gu(ee.current, x);
    Lt(ee.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`
    }), Lt($.current, {
      transition: `opacity ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`,
      opacity: "1"
    }), o && Ve && Ve > 0 && O && Lt(ce, {
      borderRadius: `${Lk}px`,
      overflow: "hidden",
      ...jt(x) ? {
        transform: `scale(${mr()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
        transformOrigin: "top"
      } : {
        transform: `scale(${mr()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
        transformOrigin: "left"
      },
      transitionProperty: "transform, border-radius",
      transitionDuration: `${yt.DURATION}s`,
      transitionTimingFunction: `cubic-bezier(${yt.EASE.join(",")})`
    }, !0);
  }
  function Ah() {
    !j || !ee.current || (ee.current.classList.remove(_p), at.current = !1, V(!1), be.current = /* @__PURE__ */ new Date());
  }
  function Sh(ce) {
    if (!j || !ee.current) return;
    ee.current.classList.remove(_p), at.current = !1, V(!1), be.current = /* @__PURE__ */ new Date();
    const Ve = gu(ee.current, x);
    if (!Ba(ce.target, !1) || !Ve || Number.isNaN(Ve) || he.current === null) return;
    const rt = be.current.getTime() - he.current.getTime(), Ye = tt.current - (jt(x) ? ce.pageY : ce.pageX), Ue = Math.abs(Ye) / rt;
    if (Ue > 0.05 && (G(!0), setTimeout(() => {
      G(!1);
    }, 200)), i) {
      ye({
        draggedDistance: Ye * (x === "bottom" || x === "right" ? 1 : -1),
        closeDrawer: Fr,
        velocity: Ue,
        dismissible: u
      }), s == null || s(ce, !0);
      return;
    }
    if (x === "bottom" || x === "right" ? Ye > 0 : Ye < 0) {
      jl(), s == null || s(ce, !0);
      return;
    }
    if (Ue > Nk) {
      Fr(), s == null || s(ce, !1);
      return;
    }
    var tn;
    const Wt = Math.min((tn = ee.current.getBoundingClientRect().height) != null ? tn : 0, window.innerHeight);
    var dn;
    const wn = Math.min((dn = ee.current.getBoundingClientRect().width) != null ? dn : 0, window.innerWidth), Vr = x === "left" || x === "right";
    if (Math.abs(Ve) >= (Vr ? wn : Wt) * c) {
      Fr(), s == null || s(ce, !1);
      return;
    }
    s == null || s(ce, !0), jl();
  }
  z.useEffect(() => (O && (Lt(document.documentElement, {
    scrollBehavior: "auto"
  }), fe.current = /* @__PURE__ */ new Date()), () => {
    p7(document.documentElement, "scrollBehavior");
  }), [
    O
  ]);
  function Eh(ce) {
    const Ve = ce ? (window.innerWidth - wi) / window.innerWidth : 1, rt = ce ? -wi : 0;
    xt.current && window.clearTimeout(xt.current), Lt(ee.current, {
      transition: `transform ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`,
      transform: `scale(${Ve}) translate3d(0, ${rt}px, 0)`
    }), !ce && ee.current && (xt.current = setTimeout(() => {
      const Ye = gu(ee.current, x);
      Lt(ee.current, {
        transition: "none",
        transform: jt(x) ? `translate3d(0, ${Ye}px, 0)` : `translate3d(${Ye}px, 0, 0)`
      });
    }, 500));
  }
  function Ch(ce, Ve) {
    if (Ve < 0) return;
    const rt = (window.innerWidth - wi) / window.innerWidth, Ye = rt + Ve * (1 - rt), Ue = -wi + Ve * wi;
    Lt(ee.current, {
      transform: jt(x) ? `scale(${Ye}) translate3d(0, ${Ue}px, 0)` : `scale(${Ye}) translate3d(${Ue}px, 0, 0)`,
      transition: "none"
    });
  }
  function _h(ce, Ve) {
    const rt = jt(x) ? window.innerHeight : window.innerWidth, Ye = Ve ? (rt - wi) / rt : 1, Ue = Ve ? -wi : 0;
    Ve && Lt(ee.current, {
      transition: `transform ${yt.DURATION}s cubic-bezier(${yt.EASE.join(",")})`,
      transform: jt(x) ? `scale(${Ye}) translate3d(0, ${Ue}px, 0)` : `scale(${Ye}) translate3d(${Ue}px, 0, 0)`
    });
  }
  return /* @__PURE__ */ z.createElement(_k, {
    defaultOpen: A,
    onOpenChange: (ce) => {
      !u && !ce || (ce ? N(!0) : Fr(!0), q(ce));
    },
    open: O
  }, /* @__PURE__ */ z.createElement(Pk.Provider, {
    value: {
      activeSnapPoint: Pn,
      snapPoints: i,
      setActiveSnapPoint: Y,
      drawerRef: ee,
      overlayRef: $,
      onOpenChange: e,
      onPress: wh,
      onRelease: Sh,
      onDrag: Ll,
      dismissible: u,
      handleOnly: d,
      isOpen: O,
      isDragging: j,
      shouldFade: Ee,
      closeDrawer: Fr,
      onNestedDrag: Ch,
      onNestedOpenChange: Eh,
      onNestedRelease: _h,
      keyboardIsOpen: wt,
      modal: y,
      snapPointsOffset: te,
      direction: x,
      shouldScaleBackground: o,
      setBackgroundColorOnScale: a,
      noBodyStyles: w,
      container: R,
      autoFocus: P
    }
  }, n));
}
const Vk = /* @__PURE__ */ z.forwardRef(function({ ...t }, e) {
  const { overlayRef: n, snapPoints: r, onRelease: s, shouldFade: i, isOpen: o, modal: a } = ka(), c = Ok(e, n), l = r && r.length > 0;
  return a ? /* @__PURE__ */ z.createElement(sb, {
    onMouseUp: s,
    ref: c,
    "data-vaul-overlay": "",
    "data-vaul-snap-points": o && l ? "true" : "false",
    "data-vaul-snap-points-overlay": o && i ? "true" : "false",
    ...t
  }) : (typeof window < "u" && window.requestAnimationFrame(() => {
    document.body.style.pointerEvents = "auto";
  }), null);
});
Vk.displayName = "Drawer.Overlay";
const Uk = /* @__PURE__ */ z.forwardRef(function({ onPointerDownOutside: t, style: e, onOpenAutoFocus: n, ...r }, s) {
  const { drawerRef: i, onPress: o, onRelease: a, onDrag: c, keyboardIsOpen: l, snapPointsOffset: u, modal: d, isOpen: f, direction: h, snapPoints: p, container: m, handleOnly: y, autoFocus: b } = ka(), [v, w] = z.useState(!1), x = Ok(s, i), A = z.useRef(null), C = z.useRef(null), S = z.useRef(!1), _ = p && p.length > 0;
  A7();
  const T = (R, P, M = 0) => {
    if (S.current) return !0;
    const D = Math.abs(R.y), O = Math.abs(R.x), q = O > D, L = [
      "bottom",
      "right"
    ].includes(P) ? 1 : -1;
    if (P === "left" || P === "right") {
      if (!(R.x * L < 0) && O >= 0 && O <= M)
        return q;
    } else if (!(R.y * L < 0) && D >= 0 && D <= M)
      return !q;
    return S.current = !0, !0;
  };
  z.useEffect(() => {
    _ && window.requestAnimationFrame(() => {
      w(!0);
    });
  }, []);
  function k(R) {
    A.current = null, S.current = !1, a(R);
  }
  return /* @__PURE__ */ z.createElement(ib, {
    "data-vaul-drawer-direction": h,
    "data-vaul-drawer": "",
    "data-vaul-delayed-snap-points": v ? "true" : "false",
    "data-vaul-snap-points": f && _ ? "true" : "false",
    "data-vaul-custom-container": m ? "true" : "false",
    ...r,
    ref: x,
    style: u && u.length > 0 ? {
      "--snap-point-height": `${u[0]}px`,
      ...e
    } : e,
    onPointerDown: (R) => {
      y || (r.onPointerDown == null || r.onPointerDown.call(r, R), A.current = {
        x: R.pageX,
        y: R.pageY
      }, o(R));
    },
    onOpenAutoFocus: (R) => {
      n == null || n(R), b || R.preventDefault();
    },
    onPointerDownOutside: (R) => {
      if (t == null || t(R), !d || R.defaultPrevented) {
        R.preventDefault();
        return;
      }
      l.current && (l.current = !1);
    },
    onFocusOutside: (R) => {
      if (!d) {
        R.preventDefault();
        return;
      }
    },
    onPointerMove: (R) => {
      if (C.current = R, y || (r.onPointerMove == null || r.onPointerMove.call(r, R), !A.current)) return;
      const P = R.pageY - A.current.y, M = R.pageX - A.current.x, D = R.pointerType === "touch" ? 10 : 2;
      T({
        x: M,
        y: P
      }, h, D) ? c(R) : (Math.abs(M) > D || Math.abs(P) > D) && (A.current = null);
    },
    onPointerUp: (R) => {
      r.onPointerUp == null || r.onPointerUp.call(r, R), A.current = null, S.current = !1, a(R);
    },
    onPointerOut: (R) => {
      r.onPointerOut == null || r.onPointerOut.call(r, R), k(C.current);
    },
    onContextMenu: (R) => {
      r.onContextMenu == null || r.onContextMenu.call(r, R), k(C.current);
    }
  });
});
Uk.displayName = "Drawer.Content";
const E7 = 250, C7 = 120, Wk = /* @__PURE__ */ z.forwardRef(function({ preventCycle: t = !1, children: e, ...n }, r) {
  const { closeDrawer: s, isDragging: i, snapPoints: o, activeSnapPoint: a, setActiveSnapPoint: c, dismissible: l, handleOnly: u, isOpen: d, onPress: f, onDrag: h } = ka(), p = z.useRef(null), m = z.useRef(!1);
  function y() {
    if (m.current) {
      w();
      return;
    }
    window.setTimeout(() => {
      b();
    }, C7);
  }
  function b() {
    if (i || t || m.current) {
      w();
      return;
    }
    if (w(), (!o || o.length === 0) && l) {
      s();
      return;
    }
    if (a === o[o.length - 1] && l) {
      s();
      return;
    }
    const A = o.findIndex((S) => S === a);
    if (A === -1) return;
    const C = o[A + 1];
    c(C);
  }
  function v() {
    p.current = window.setTimeout(() => {
      m.current = !0;
    }, E7);
  }
  function w() {
    window.clearTimeout(p.current), m.current = !1;
  }
  return /* @__PURE__ */ z.createElement("div", {
    onClick: y,
    onPointerCancel: w,
    onPointerDown: (x) => {
      u && f(x), v();
    },
    onPointerMove: (x) => {
      u && h(x);
    },
    // onPointerUp is already handled by the content component
    ref: r,
    "data-vaul-drawer-visible": d ? "true" : "false",
    "data-vaul-handle": "",
    "aria-hidden": "true",
    ...n
  }, /* @__PURE__ */ z.createElement("span", {
    "data-vaul-handle-hitarea": "",
    "aria-hidden": "true"
  }, e));
});
Wk.displayName = "Drawer.Handle";
function _7({ onDrag: t, onOpenChange: e, ...n }) {
  const { onNestedDrag: r, onNestedOpenChange: s, onNestedRelease: i } = ka();
  if (!r)
    throw new Error("Drawer.NestedRoot must be placed in another drawer");
  return /* @__PURE__ */ z.createElement(Fk, {
    nested: !0,
    onClose: () => {
      s(!1);
    },
    onDrag: (o, a) => {
      r(o, a), t == null || t(o, a);
    },
    onOpenChange: (o) => {
      o && s(o);
    },
    onRelease: i,
    ...n
  });
}
function T7(t) {
  const e = ka(), { container: n = e.container, ...r } = t;
  return /* @__PURE__ */ z.createElement(e7, {
    container: n,
    ...r
  });
}
const jr = {
  Root: Fk,
  NestedRoot: _7,
  Content: Uk,
  Overlay: Vk,
  Trigger: Tk,
  Portal: T7,
  Handle: Wk,
  Close: kk,
  Title: ob,
  Description: ab
}, ub = ({
  shouldScaleBackground: t = !0,
  ...e
}) => /* @__PURE__ */ g.jsx(
  jr.Root,
  {
    shouldScaleBackground: t,
    ...e
  }
);
ub.displayName = "Drawer";
const zk = jr.Trigger, Hk = jr.Close, Yk = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  jr.Overlay,
  {
    ref: n,
    className: de("fixed inset-0 z-50 bg-black/80", t),
    ...e
  }
));
Yk.displayName = jr.Overlay.displayName;
const db = E.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g.jsx(g.Fragment, { children: /* @__PURE__ */ g.jsx(Yk, { children: /* @__PURE__ */ g.jsxs(
  jr.Content,
  {
    ref: r,
    className: de(
      "fixed inset-x-0 bottom-0 max-h-[90%] z-50 mt-24 flex flex-col rounded-t-[10px] border bg-background",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ g.jsx("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
      e
    ]
  }
) }) }));
db.displayName = "DrawerContent";
const fb = ({
  className: t,
  ...e
}) => /* @__PURE__ */ g.jsx(
  "div",
  {
    className: de("grid gap-1.5 p-4 text-center sm:text-left", t),
    ...e
  }
);
fb.displayName = "DrawerHeader";
const hb = ({
  className: t,
  ...e
}) => /* @__PURE__ */ g.jsx(
  "div",
  {
    className: de("mt-auto flex flex-col gap-2 p-4", t),
    ...e
  }
);
hb.displayName = "DrawerFooter";
const pb = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  jr.Title,
  {
    ref: n,
    className: de(
      "text-lg font-semibold leading-none tracking-tight",
      t
    ),
    ...e
  }
));
pb.displayName = jr.Title.displayName;
const k7 = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  jr.Description,
  {
    ref: n,
    className: de("text-sm text-muted-foreground", t),
    ...e
  }
));
k7.displayName = jr.Description.displayName;
function R7(t, e) {
  return E.useReducer((n, r) => e[n][r] ?? n, t);
}
var Tl = (t) => {
  const { present: e, children: n } = t, r = M7(e), s = typeof n == "function" ? n({ present: r.isPresent }) : E.Children.only(n), i = Ke(r.ref, P7(s));
  return typeof n == "function" || r.isPresent ? E.cloneElement(s, { ref: i }) : null;
};
Tl.displayName = "Presence";
function M7(t) {
  const [e, n] = E.useState(), r = E.useRef({}), s = E.useRef(t), i = E.useRef("none"), o = t ? "mounted" : "unmounted", [a, c] = R7(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return E.useEffect(() => {
    const l = yu(r.current);
    i.current = a === "mounted" ? l : "none";
  }, [a]), bn(() => {
    const l = r.current, u = s.current;
    if (u !== t) {
      const f = i.current, h = yu(l);
      t ? c("MOUNT") : h === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), s.current = t;
    }
  }, [t, c]), bn(() => {
    if (e) {
      let l;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const m = yu(r.current).includes(h.animationName);
        if (h.target === e && m && (c("ANIMATION_END"), !s.current)) {
          const y = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", l = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = y);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = yu(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(l), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      c("ANIMATION_END");
  }, [e, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: E.useCallback((l) => {
      l && (r.current = getComputedStyle(l)), n(l);
    }, [])
  };
}
function yu(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function P7(t) {
  var r, s;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
function I7(t, e = []) {
  let n = [];
  function r(i, o) {
    const a = E.createContext(o), c = n.length;
    n = [...n, o];
    const l = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, m = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[c]) || a, y = E.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ g.jsx(m.Provider, { value: y, children: h });
    };
    l.displayName = i + "Provider";
    function u(d, f) {
      var m;
      const h = ((m = f == null ? void 0 : f[t]) == null ? void 0 : m[c]) || a, p = E.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [l, u];
  }
  const s = () => {
    const i = n.map((o) => E.createContext(o));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || i;
      return E.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: c } }),
        [a, c]
      );
    };
  };
  return s.scopeName = t, [r, D7(s, ...e)];
}
function D7(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const o = r.reduce((a, { useScope: c, scopeName: l }) => {
        const d = c(i)[`__scope${l}`];
        return { ...a, ...d };
      }, {});
      return E.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function O7(t, e) {
  return E.useReducer((n, r) => e[n][r] ?? n, t);
}
var mb = "ScrollArea", [Gk, Ete] = I7(mb), [q7, er] = Gk(mb), Kk = E.forwardRef(
  (t, e) => {
    const {
      __scopeScrollArea: n,
      type: r = "hover",
      dir: s,
      scrollHideDelay: i = 600,
      ...o
    } = t, [a, c] = E.useState(null), [l, u] = E.useState(null), [d, f] = E.useState(null), [h, p] = E.useState(null), [m, y] = E.useState(null), [b, v] = E.useState(0), [w, x] = E.useState(0), [A, C] = E.useState(!1), [S, _] = E.useState(!1), T = Ke(e, (R) => c(R)), k = Ay(s);
    return /* @__PURE__ */ g.jsx(
      q7,
      {
        scope: n,
        type: r,
        dir: k,
        scrollHideDelay: i,
        scrollArea: a,
        viewport: l,
        onViewportChange: u,
        content: d,
        onContentChange: f,
        scrollbarX: h,
        onScrollbarXChange: p,
        scrollbarXEnabled: A,
        onScrollbarXEnabledChange: C,
        scrollbarY: m,
        onScrollbarYChange: y,
        scrollbarYEnabled: S,
        onScrollbarYEnabledChange: _,
        onCornerWidthChange: v,
        onCornerHeightChange: x,
        children: /* @__PURE__ */ g.jsx(
          ze.div,
          {
            dir: k,
            ...o,
            ref: T,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": b + "px",
              "--radix-scroll-area-corner-height": w + "px",
              ...t.style
            }
          }
        )
      }
    );
  }
);
Kk.displayName = mb;
var $k = "ScrollAreaViewport", Zk = E.forwardRef(
  (t, e) => {
    const { __scopeScrollArea: n, children: r, asChild: s, nonce: i, ...o } = t, a = er($k, n), c = E.useRef(null), l = Ke(e, c, a.onViewportChange);
    return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
      /* @__PURE__ */ g.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `
[data-radix-scroll-area-viewport] {
  scrollbar-width: none;
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
}
[data-radix-scroll-area-viewport]::-webkit-scrollbar {
  display: none;
}
:where([data-radix-scroll-area-viewport]) {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
:where([data-radix-scroll-area-content]) {
  flex-grow: 1;
}
`
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ g.jsx(
        ze.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o,
          asChild: s,
          ref: l,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
            ...t.style
          },
          children: H7({ asChild: s, children: r }, (u) => /* @__PURE__ */ g.jsx(
            "div",
            {
              "data-radix-scroll-area-content": "",
              ref: a.onContentChange,
              style: { minWidth: a.scrollbarXEnabled ? "fit-content" : void 0 },
              children: u
            }
          ))
        }
      )
    ] });
  }
);
Zk.displayName = $k;
var Br = "ScrollAreaScrollbar", gb = E.forwardRef(
  (t, e) => {
    const { forceMount: n, ...r } = t, s = er(Br, t.__scopeScrollArea), { onScrollbarXEnabledChange: i, onScrollbarYEnabledChange: o } = s, a = t.orientation === "horizontal";
    return E.useEffect(() => (a ? i(!0) : o(!0), () => {
      a ? i(!1) : o(!1);
    }), [a, i, o]), s.type === "hover" ? /* @__PURE__ */ g.jsx(N7, { ...r, ref: e, forceMount: n }) : s.type === "scroll" ? /* @__PURE__ */ g.jsx(L7, { ...r, ref: e, forceMount: n }) : s.type === "auto" ? /* @__PURE__ */ g.jsx(Qk, { ...r, ref: e, forceMount: n }) : s.type === "always" ? /* @__PURE__ */ g.jsx(yb, { ...r, ref: e }) : null;
  }
);
gb.displayName = Br;
var N7 = E.forwardRef((t, e) => {
  const { forceMount: n, ...r } = t, s = er(Br, t.__scopeScrollArea), [i, o] = E.useState(!1);
  return E.useEffect(() => {
    const a = s.scrollArea;
    let c = 0;
    if (a) {
      const l = () => {
        window.clearTimeout(c), o(!0);
      }, u = () => {
        c = window.setTimeout(() => o(!1), s.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", l), a.addEventListener("pointerleave", u), () => {
        window.clearTimeout(c), a.removeEventListener("pointerenter", l), a.removeEventListener("pointerleave", u);
      };
    }
  }, [s.scrollArea, s.scrollHideDelay]), /* @__PURE__ */ g.jsx(Tl, { present: n || i, children: /* @__PURE__ */ g.jsx(
    Qk,
    {
      "data-state": i ? "visible" : "hidden",
      ...r,
      ref: e
    }
  ) });
}), L7 = E.forwardRef((t, e) => {
  const { forceMount: n, ...r } = t, s = er(Br, t.__scopeScrollArea), i = t.orientation === "horizontal", o = eh(() => c("SCROLL_END"), 100), [a, c] = O7("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return E.useEffect(() => {
    if (a === "idle") {
      const l = window.setTimeout(() => c("HIDE"), s.scrollHideDelay);
      return () => window.clearTimeout(l);
    }
  }, [a, s.scrollHideDelay, c]), E.useEffect(() => {
    const l = s.viewport, u = i ? "scrollLeft" : "scrollTop";
    if (l) {
      let d = l[u];
      const f = () => {
        const h = l[u];
        d !== h && (c("SCROLL"), o()), d = h;
      };
      return l.addEventListener("scroll", f), () => l.removeEventListener("scroll", f);
    }
  }, [s.viewport, i, c, o]), /* @__PURE__ */ g.jsx(Tl, { present: n || a !== "hidden", children: /* @__PURE__ */ g.jsx(
    yb,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...r,
      ref: e,
      onPointerEnter: We(t.onPointerEnter, () => c("POINTER_ENTER")),
      onPointerLeave: We(t.onPointerLeave, () => c("POINTER_LEAVE"))
    }
  ) });
}), Qk = E.forwardRef((t, e) => {
  const n = er(Br, t.__scopeScrollArea), { forceMount: r, ...s } = t, [i, o] = E.useState(!1), a = t.orientation === "horizontal", c = eh(() => {
    if (n.viewport) {
      const l = n.viewport.offsetWidth < n.viewport.scrollWidth, u = n.viewport.offsetHeight < n.viewport.scrollHeight;
      o(a ? l : u);
    }
  }, 10);
  return sa(n.viewport, c), sa(n.content, c), /* @__PURE__ */ g.jsx(Tl, { present: r || i, children: /* @__PURE__ */ g.jsx(
    yb,
    {
      "data-state": i ? "visible" : "hidden",
      ...s,
      ref: e
    }
  ) });
}), yb = E.forwardRef((t, e) => {
  const { orientation: n = "vertical", ...r } = t, s = er(Br, t.__scopeScrollArea), i = E.useRef(null), o = E.useRef(0), [a, c] = E.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), l = nR(a.viewport, a.content), u = {
    ...r,
    sizes: a,
    onSizesChange: c,
    hasThumb: l > 0 && l < 1,
    onThumbChange: (f) => i.current = f,
    onThumbPointerUp: () => o.current = 0,
    onThumbPointerDown: (f) => o.current = f
  };
  function d(f, h) {
    return W7(f, o.current, a, h);
  }
  return n === "horizontal" ? /* @__PURE__ */ g.jsx(
    j7,
    {
      ...u,
      ref: e,
      onThumbPositionChange: () => {
        if (s.viewport && i.current) {
          const f = s.viewport.scrollLeft, h = bA(f, a, s.dir);
          i.current.style.transform = `translate3d(${h}px, 0, 0)`;
        }
      },
      onWheelScroll: (f) => {
        s.viewport && (s.viewport.scrollLeft = f);
      },
      onDragScroll: (f) => {
        s.viewport && (s.viewport.scrollLeft = d(f, s.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ g.jsx(
    B7,
    {
      ...u,
      ref: e,
      onThumbPositionChange: () => {
        if (s.viewport && i.current) {
          const f = s.viewport.scrollTop, h = bA(f, a);
          i.current.style.transform = `translate3d(0, ${h}px, 0)`;
        }
      },
      onWheelScroll: (f) => {
        s.viewport && (s.viewport.scrollTop = f);
      },
      onDragScroll: (f) => {
        s.viewport && (s.viewport.scrollTop = d(f));
      }
    }
  ) : null;
}), j7 = E.forwardRef((t, e) => {
  const { sizes: n, onSizesChange: r, ...s } = t, i = er(Br, t.__scopeScrollArea), [o, a] = E.useState(), c = E.useRef(null), l = Ke(e, c, i.onScrollbarXChange);
  return E.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ g.jsx(
    Jk,
    {
      "data-orientation": "horizontal",
      ...s,
      ref: l,
      sizes: n,
      style: {
        bottom: 0,
        left: i.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: i.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Jf(n) + "px",
        ...t.style
      },
      onThumbPointerDown: (u) => t.onThumbPointerDown(u.x),
      onDragScroll: (u) => t.onDragScroll(u.x),
      onWheelScroll: (u, d) => {
        if (i.viewport) {
          const f = i.viewport.scrollLeft + u.deltaX;
          t.onWheelScroll(f), sR(f, d) && u.preventDefault();
        }
      },
      onResize: () => {
        c.current && i.viewport && o && r({
          content: i.viewport.scrollWidth,
          viewport: i.viewport.offsetWidth,
          scrollbar: {
            size: c.current.clientWidth,
            paddingStart: Gd(o.paddingLeft),
            paddingEnd: Gd(o.paddingRight)
          }
        });
      }
    }
  );
}), B7 = E.forwardRef((t, e) => {
  const { sizes: n, onSizesChange: r, ...s } = t, i = er(Br, t.__scopeScrollArea), [o, a] = E.useState(), c = E.useRef(null), l = Ke(e, c, i.onScrollbarYChange);
  return E.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ g.jsx(
    Jk,
    {
      "data-orientation": "vertical",
      ...s,
      ref: l,
      sizes: n,
      style: {
        top: 0,
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Jf(n) + "px",
        ...t.style
      },
      onThumbPointerDown: (u) => t.onThumbPointerDown(u.y),
      onDragScroll: (u) => t.onDragScroll(u.y),
      onWheelScroll: (u, d) => {
        if (i.viewport) {
          const f = i.viewport.scrollTop + u.deltaY;
          t.onWheelScroll(f), sR(f, d) && u.preventDefault();
        }
      },
      onResize: () => {
        c.current && i.viewport && o && r({
          content: i.viewport.scrollHeight,
          viewport: i.viewport.offsetHeight,
          scrollbar: {
            size: c.current.clientHeight,
            paddingStart: Gd(o.paddingTop),
            paddingEnd: Gd(o.paddingBottom)
          }
        });
      }
    }
  );
}), [F7, Xk] = Gk(Br), Jk = E.forwardRef((t, e) => {
  const {
    __scopeScrollArea: n,
    sizes: r,
    hasThumb: s,
    onThumbChange: i,
    onThumbPointerUp: o,
    onThumbPointerDown: a,
    onThumbPositionChange: c,
    onDragScroll: l,
    onWheelScroll: u,
    onResize: d,
    ...f
  } = t, h = er(Br, n), [p, m] = E.useState(null), y = Ke(e, (T) => m(T)), b = E.useRef(null), v = E.useRef(""), w = h.viewport, x = r.content - r.viewport, A = Zt(u), C = Zt(c), S = eh(d, 10);
  function _(T) {
    if (b.current) {
      const k = T.clientX - b.current.left, R = T.clientY - b.current.top;
      l({ x: k, y: R });
    }
  }
  return E.useEffect(() => {
    const T = (k) => {
      const R = k.target;
      (p == null ? void 0 : p.contains(R)) && A(k, x);
    };
    return document.addEventListener("wheel", T, { passive: !1 }), () => document.removeEventListener("wheel", T, { passive: !1 });
  }, [w, p, x, A]), E.useEffect(C, [r, C]), sa(p, S), sa(h.content, S), /* @__PURE__ */ g.jsx(
    F7,
    {
      scope: n,
      scrollbar: p,
      hasThumb: s,
      onThumbChange: Zt(i),
      onThumbPointerUp: Zt(o),
      onThumbPositionChange: C,
      onThumbPointerDown: Zt(a),
      children: /* @__PURE__ */ g.jsx(
        ze.div,
        {
          ...f,
          ref: y,
          style: { position: "absolute", ...f.style },
          onPointerDown: We(t.onPointerDown, (T) => {
            T.button === 0 && (T.target.setPointerCapture(T.pointerId), b.current = p.getBoundingClientRect(), v.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", h.viewport && (h.viewport.style.scrollBehavior = "auto"), _(T));
          }),
          onPointerMove: We(t.onPointerMove, _),
          onPointerUp: We(t.onPointerUp, (T) => {
            const k = T.target;
            k.hasPointerCapture(T.pointerId) && k.releasePointerCapture(T.pointerId), document.body.style.webkitUserSelect = v.current, h.viewport && (h.viewport.style.scrollBehavior = ""), b.current = null;
          })
        }
      )
    }
  );
}), Yd = "ScrollAreaThumb", eR = E.forwardRef(
  (t, e) => {
    const { forceMount: n, ...r } = t, s = Xk(Yd, t.__scopeScrollArea);
    return /* @__PURE__ */ g.jsx(Tl, { present: n || s.hasThumb, children: /* @__PURE__ */ g.jsx(V7, { ref: e, ...r }) });
  }
), V7 = E.forwardRef(
  (t, e) => {
    const { __scopeScrollArea: n, style: r, ...s } = t, i = er(Yd, n), o = Xk(Yd, n), { onThumbPositionChange: a } = o, c = Ke(
      e,
      (d) => o.onThumbChange(d)
    ), l = E.useRef(), u = eh(() => {
      l.current && (l.current(), l.current = void 0);
    }, 100);
    return E.useEffect(() => {
      const d = i.viewport;
      if (d) {
        const f = () => {
          if (u(), !l.current) {
            const h = z7(d, a);
            l.current = h, a();
          }
        };
        return a(), d.addEventListener("scroll", f), () => d.removeEventListener("scroll", f);
      }
    }, [i.viewport, u, a]), /* @__PURE__ */ g.jsx(
      ze.div,
      {
        "data-state": o.hasThumb ? "visible" : "hidden",
        ...s,
        ref: c,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...r
        },
        onPointerDownCapture: We(t.onPointerDownCapture, (d) => {
          const h = d.target.getBoundingClientRect(), p = d.clientX - h.left, m = d.clientY - h.top;
          o.onThumbPointerDown({ x: p, y: m });
        }),
        onPointerUp: We(t.onPointerUp, o.onThumbPointerUp)
      }
    );
  }
);
eR.displayName = Yd;
var bb = "ScrollAreaCorner", tR = E.forwardRef(
  (t, e) => {
    const n = er(bb, t.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && r ? /* @__PURE__ */ g.jsx(U7, { ...t, ref: e }) : null;
  }
);
tR.displayName = bb;
var U7 = E.forwardRef((t, e) => {
  const { __scopeScrollArea: n, ...r } = t, s = er(bb, n), [i, o] = E.useState(0), [a, c] = E.useState(0), l = !!(i && a);
  return sa(s.scrollbarX, () => {
    var d;
    const u = ((d = s.scrollbarX) == null ? void 0 : d.offsetHeight) || 0;
    s.onCornerHeightChange(u), c(u);
  }), sa(s.scrollbarY, () => {
    var d;
    const u = ((d = s.scrollbarY) == null ? void 0 : d.offsetWidth) || 0;
    s.onCornerWidthChange(u), o(u);
  }), l ? /* @__PURE__ */ g.jsx(
    ze.div,
    {
      ...r,
      ref: e,
      style: {
        width: i,
        height: a,
        position: "absolute",
        right: s.dir === "ltr" ? 0 : void 0,
        left: s.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...t.style
      }
    }
  ) : null;
});
function Gd(t) {
  return t ? parseInt(t, 10) : 0;
}
function nR(t, e) {
  const n = t / e;
  return isNaN(n) ? 0 : n;
}
function Jf(t) {
  const e = nR(t.viewport, t.content), n = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = (t.scrollbar.size - n) * e;
  return Math.max(r, 18);
}
function W7(t, e, n, r = "ltr") {
  const s = Jf(n), i = s / 2, o = e || i, a = s - o, c = n.scrollbar.paddingStart + o, l = n.scrollbar.size - n.scrollbar.paddingEnd - a, u = n.content - n.viewport, d = r === "ltr" ? [0, u] : [u * -1, 0];
  return rR([c, l], d)(t);
}
function bA(t, e, n = "ltr") {
  const r = Jf(e), s = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, i = e.scrollbar.size - s, o = e.content - e.viewport, a = i - r, c = n === "ltr" ? [0, o] : [o * -1, 0], l = wy(t, c);
  return rR([0, o], [0, a])(l);
}
function rR(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0]);
  };
}
function sR(t, e) {
  return t > 0 && t < e;
}
var z7 = (t, e = () => {
}) => {
  let n = { left: t.scrollLeft, top: t.scrollTop }, r = 0;
  return function s() {
    const i = { left: t.scrollLeft, top: t.scrollTop }, o = n.left !== i.left, a = n.top !== i.top;
    (o || a) && e(), n = i, r = window.requestAnimationFrame(s);
  }(), () => window.cancelAnimationFrame(r);
};
function eh(t, e) {
  const n = Zt(t), r = E.useRef(0);
  return E.useEffect(() => () => window.clearTimeout(r.current), []), E.useCallback(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, e);
  }, [n, e]);
}
function sa(t, e) {
  const n = Zt(e);
  bn(() => {
    let r = 0;
    if (t) {
      const s = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return s.observe(t), () => {
        window.cancelAnimationFrame(r), s.unobserve(t);
      };
    }
  }, [t, n]);
}
function H7(t, e) {
  const { asChild: n, children: r } = t;
  if (!n) return typeof e == "function" ? e(r) : e;
  const s = E.Children.only(r);
  return E.cloneElement(s, {
    children: typeof e == "function" ? e(s.props.children) : e
  });
}
var iR = Kk, Y7 = Zk, G7 = tR;
const Zi = E.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g.jsxs(
  iR,
  {
    ref: r,
    className: de("relative overflow-hidden", t),
    ...n,
    children: [
      /* @__PURE__ */ g.jsx(Y7, { className: "h-full w-full rounded-[inherit]", children: e }),
      /* @__PURE__ */ g.jsx(oR, {}),
      /* @__PURE__ */ g.jsx(G7, {})
    ]
  }
));
Zi.displayName = iR.displayName;
const oR = E.forwardRef(({ className: t, orientation: e = "vertical", ...n }, r) => /* @__PURE__ */ g.jsx(
  gb,
  {
    ref: r,
    orientation: e,
    className: de(
      "flex touch-none select-none transition-colors",
      e === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      e === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      t
    ),
    ...n,
    children: /* @__PURE__ */ g.jsx(eR, { className: "relative flex-1 rounded-full bg-border" })
  }
));
oR.displayName = gb.displayName;
function K7() {
  const {
    currentServerSeed: t,
    currentClientSeed: e,
    currentNonce: n,
    newServerSeed: r,
    newClientSeed: s,
    setNewClientSeed: i,
    useNewSeeds: o,
    isProvablyFairDialogOpen: a,
    setIsProvablyFairDialogOpen: c,
    isLoadingCurrentSeed: l,
    fetchCurrentSeed: u,
    isGameActive: d
  } = st(), { authToken: f } = ma(), h = fr(), [p, m] = Ge(null), [y, b] = Ge(null), v = Et(null), { addToast: w } = Aa();
  _e(() => {
    a && f && u(f);
  }, [a, f, u]);
  const x = Je(() => {
    const O = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    i(O);
  }, []), A = Je(async () => {
    if (d) {
      w({
        variant: "warning",
        message: "Can't change seeds while you have a game active.",
        duration: 2e3
      });
      return;
    }
    f && (i(s), await o(f), await u(f));
  }, [
    f,
    o,
    c,
    i,
    s,
    d
  ]), C = Je(
    (O) => {
      i(O.target.value);
    },
    []
  );
  _e(() => {
    a && setTimeout(() => {
      var O;
      (O = v.current) == null || O.focus();
    }, 100);
  }, [a]);
  const S = (O, q) => {
    navigator.clipboard.writeText(O).then(
      () => {
        b(q), setTimeout(() => b(null), 2e3);
      },
      (L) => {
        console.error("Could not copy text: ", L);
      }
    );
  }, _ = "flex items-center space-x-2 bg-primary rounded-md p-1 h-11", T = "flex-grow bg-transparent border-none text-white text-base h-9 outline-none focus-visible:ring-0 focus-visible:ring-offset-0", k = "text-xs text-gray-400", R = (O) => `
    flex items-center space-x-2 bg-primary rounded-md p-1 h-11 transition-all duration-200
    ${p === O ? "ring-1 ring-brand" : ""}`, P = /* @__PURE__ */ g.jsxs("div", { className: "space-y-6 p-2", children: [
    /* @__PURE__ */ g.jsx("p", { className: "text-gray-400 text-sm", children: "You may use this function to set a new server seed + a new client seed. They can be randomly generated or customized (at least 10 characters), and the number of bets will be reset to zero." }),
    /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ g.jsxs("div", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ g.jsx("div", { className: "h-px bg-gray-700 flex-grow" }),
        /* @__PURE__ */ g.jsx("h3", { className: "text-sm font-semibold text-gray-400", children: "Current seeds" }),
        /* @__PURE__ */ g.jsx("div", { className: "h-px bg-gray-700 flex-grow" })
      ] }),
      l ? /* @__PURE__ */ g.jsx("div", { className: "absolute inset-0 flex items-center justify-center opacity-100", children: /* @__PURE__ */ g.jsx("div", { className: "w-16 h-16 border-4 border-border border-t-brand rounded-full animate-spin" }) }) : /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
        /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ g.jsx(St, { htmlFor: "current-server-seed", className: k, children: "Server Seed (hash)" }),
          /* @__PURE__ */ g.jsxs("div", { className: _, children: [
            /* @__PURE__ */ g.jsx(
              qt,
              {
                id: "current-server-seed",
                value: t,
                readOnly: !0,
                disabled: !0,
                className: T
              }
            ),
            /* @__PURE__ */ g.jsx(Fu, { children: /* @__PURE__ */ g.jsxs(Vu, { open: y === "current-server", children: [
              /* @__PURE__ */ g.jsx(Uu, { asChild: !0, children: /* @__PURE__ */ g.jsxs(
                pt,
                {
                  type: "button",
                  variant: "secondary",
                  size: "icon",
                  className: "h-9 w-12 px-2 text-sm bg-transparent text-white hover:bg-opacity-80 font-bold",
                  onClick: () => S(t, "current-server"),
                  children: [
                    /* @__PURE__ */ g.jsx(No, { className: "h-4 w-4 text-white transition-colors duration-200 group-hover:text-white" }),
                    /* @__PURE__ */ g.jsx("span", { className: "sr-only", children: "Copy server seed" })
                  ]
                }
              ) }),
              /* @__PURE__ */ g.jsx(yc, { className: "bg-primary text-white border-slate-600/50", side: "top", children: /* @__PURE__ */ g.jsx("p", { children: "Copied!" }) })
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ g.jsxs("div", { className: "flex space-x-2", children: [
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2 w-[70%]", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "current-client-seed", className: k, children: "Client Seed" }),
            /* @__PURE__ */ g.jsxs("div", { className: _, children: [
              /* @__PURE__ */ g.jsx(
                qt,
                {
                  id: "current-client-seed",
                  value: e,
                  readOnly: !0,
                  disabled: !0,
                  className: T
                }
              ),
              /* @__PURE__ */ g.jsx(Fu, { children: /* @__PURE__ */ g.jsxs(Vu, { open: y === "current-client", children: [
                /* @__PURE__ */ g.jsx(Uu, { asChild: !0, children: /* @__PURE__ */ g.jsxs(
                  pt,
                  {
                    type: "button",
                    variant: "secondary",
                    size: "icon",
                    className: "h-9 w-12 px-2 text-sm bg-transparent text-white hover:bg-opacity-80 font-bold",
                    onClick: () => S(e, "current-client"),
                    children: [
                      /* @__PURE__ */ g.jsx(No, { className: "h-4 w-4 text-white transition-colors duration-200 group-hover:text-white" }),
                      /* @__PURE__ */ g.jsx("span", { className: "sr-only", children: "Copy client seed" })
                    ]
                  }
                ) }),
                /* @__PURE__ */ g.jsx(yc, { className: "bg-primary text-white border-slate-600/50", side: "top", children: /* @__PURE__ */ g.jsx("p", { children: "Copied!" }) })
              ] }) })
            ] })
          ] }),
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2 w-[30%]", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "current-nonce", className: k, children: "Nonce" }),
            /* @__PURE__ */ g.jsx("div", { className: _, children: /* @__PURE__ */ g.jsx(
              qt,
              {
                id: "current-nonce",
                value: n,
                readOnly: !0,
                disabled: !0,
                className: T
              }
            ) })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ g.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ g.jsxs("div", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ g.jsx("div", { className: "h-px bg-gray-700 flex-grow" }),
        /* @__PURE__ */ g.jsx("h3", { className: "text-sm font-semibold text-gray-400", children: "Rotate seeds" }),
        /* @__PURE__ */ g.jsx("div", { className: "h-px bg-gray-700 flex-grow" })
      ] }),
      /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ g.jsx(St, { htmlFor: "new-server-seed", className: k, children: "Server Seed (hash)" }),
        /* @__PURE__ */ g.jsxs("div", { className: _, children: [
          /* @__PURE__ */ g.jsx(
            qt,
            {
              id: "new-server-seed",
              value: r,
              readOnly: !0,
              disabled: !0,
              className: T,
              placeholder: "Enter new server seed"
            }
          ),
          /* @__PURE__ */ g.jsx(Fu, { children: /* @__PURE__ */ g.jsxs(Vu, { open: y === "new-server", children: [
            /* @__PURE__ */ g.jsx(Uu, { asChild: !0, children: /* @__PURE__ */ g.jsxs(
              pt,
              {
                type: "button",
                variant: "secondary",
                size: "icon",
                className: "h-9 w-12 px-2 text-sm bg-transparent text-white hover:bg-opacity-80 font-bold",
                onClick: () => S(r, "new-server"),
                children: [
                  /* @__PURE__ */ g.jsx(No, { className: "h-4 w-4 text-white transition-colors duration-200 group-hover:text-white" }),
                  /* @__PURE__ */ g.jsx("span", { className: "sr-only", children: "Copy new server seed" })
                ]
              }
            ) }),
            /* @__PURE__ */ g.jsx(yc, { className: "bg-primary text-white border-slate-600/50", side: "top", children: /* @__PURE__ */ g.jsx("p", { children: "Copied!" }) })
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ g.jsx("div", { className: "flex", children: /* @__PURE__ */ g.jsxs("div", { className: "space-y-2 w-full", children: [
        /* @__PURE__ */ g.jsx(
          St,
          {
            htmlFor: "new-client-seed",
            className: `${k} text-white`,
            children: "Client Seed"
          }
        ),
        /* @__PURE__ */ g.jsxs("div", { className: `${R("newClientSeed")} relative`, children: [
          /* @__PURE__ */ g.jsx(
            qt,
            {
              id: "new-client-seed",
              value: s,
              spellCheck: "false",
              type: "text",
              ref: v,
              onChange: C,
              onFocus: () => m("newClientSeed"),
              onBlur: () => m(null),
              className: `${T} pr-8`,
              autoComplete: "off",
              placeholder: "Enter new client seed"
            }
          ),
          /* @__PURE__ */ g.jsxs(
            pt,
            {
              type: "button",
              variant: "secondary",
              size: "icon",
              className: "h-9 w-12 px-2 text-sm bg-pills text-white hover:bg-opacity-80 font-bold",
              onClick: x,
              children: [
                /* @__PURE__ */ g.jsx(lC, { className: "h-4 w-4 text-white transition-colors duration-200 group-hover:text-white" }),
                /* @__PURE__ */ g.jsx("span", { className: "sr-only", children: "Generate random seed" })
              ]
            }
          )
        ] })
      ] }) })
    ] })
  ] }), M = /* @__PURE__ */ g.jsxs(Zf, { className: "sm:max-w-[425px] max-h-[98vh] p-4 pt-6 bg-secondary border-slate-600/30 overflow-y-auto", children: [
    /* @__PURE__ */ g.jsx(Qf, { className: "absolute  top-0 left-0 right-0 bg-pills px-6 py-3 flex justify-between items-left", children: /* @__PURE__ */ g.jsxs(Xf, { className: "text-white text-left text-base flex items-center gap-2", children: [
      /* @__PURE__ */ g.jsx($h, { size: 20 }),
      " Provably Fair"
    ] }) }),
    /* @__PURE__ */ g.jsx("div", { className: "mt-10", children: /* @__PURE__ */ g.jsxs(Zi, { className: "", children: [
      P,
      /* @__PURE__ */ g.jsx("div", { className: "mt-6 space-y-2 px-2", children: /* @__PURE__ */ g.jsx(
        pt,
        {
          className: "w-full bg-brand hover:bg-brand/80 text-brand-cta-text text-sm font-bold py-3 rounded-md",
          onClick: A,
          children: "Use New Seeds"
        }
      ) })
    ] }) })
  ] }), D = /* @__PURE__ */ g.jsxs(db, { className: "bg-secondary p-2 border-secondary", children: [
    /* @__PURE__ */ g.jsx(fb, { className: "text-center text-white ", children: /* @__PURE__ */ g.jsx(pb, { children: "Provably Fair" }) }),
    /* @__PURE__ */ g.jsx(Zi, { className: "overflow-y-auto no-scrollbar mb-4", children: P }),
    /* @__PURE__ */ g.jsxs(hb, { className: "mt-2 p-2 space-y-2", children: [
      /* @__PURE__ */ g.jsx(
        pt,
        {
          className: "w-full bg-brand hover:bg-brand/80 text-sm text-brand-cta-text",
          onClick: A,
          children: "Use New Seeds"
        }
      ),
      /* @__PURE__ */ g.jsx(Hk, { asChild: !0, children: /* @__PURE__ */ g.jsx(pt, { variant: "outline", className: "w-full", children: "Close" }) })
    ] })
  ] });
  return h ? /* @__PURE__ */ g.jsxs(
    ub,
    {
      open: a,
      onOpenChange: c,
      children: [
        /* @__PURE__ */ g.jsx(zk, { asChild: !0, children: /* @__PURE__ */ g.jsx("button", { className: "text-gray-400 hover:text-white px-1", children: /* @__PURE__ */ g.jsx($h, { size: 20 }) }) }),
        D
      ]
    }
  ) : /* @__PURE__ */ g.jsxs(
    cb,
    {
      open: a,
      onOpenChange: c,
      modal: !0,
      children: [
        /* @__PURE__ */ g.jsx(Rk, { asChild: !0, children: /* @__PURE__ */ g.jsx("button", { className: "text-gray-400 hover:text-white px-1", children: /* @__PURE__ */ g.jsx($h, { size: 20 }) }) }),
        M
      ]
    }
  );
}
function $7(t, e = []) {
  let n = [];
  function r(i, o) {
    const a = E.createContext(o), c = n.length;
    n = [...n, o];
    const l = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, m = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[c]) || a, y = E.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ g.jsx(m.Provider, { value: y, children: h });
    };
    l.displayName = i + "Provider";
    function u(d, f) {
      var m;
      const h = ((m = f == null ? void 0 : f[t]) == null ? void 0 : m[c]) || a, p = E.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [l, u];
  }
  const s = () => {
    const i = n.map((o) => E.createContext(o));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || i;
      return E.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: c } }),
        [a, c]
      );
    };
  };
  return s.scopeName = t, [r, Z7(s, ...e)];
}
function Z7(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const o = r.reduce((a, { useScope: c, scopeName: l }) => {
        const d = c(i)[`__scope${l}`];
        return { ...a, ...d };
      }, {});
      return E.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function Q7(t, e = []) {
  let n = [];
  function r(i, o) {
    const a = E.createContext(o), c = n.length;
    n = [...n, o];
    const l = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d, m = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[c]) || a, y = E.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ g.jsx(m.Provider, { value: y, children: h });
    };
    l.displayName = i + "Provider";
    function u(d, f) {
      var m;
      const h = ((m = f == null ? void 0 : f[t]) == null ? void 0 : m[c]) || a, p = E.useContext(h);
      if (p) return p;
      if (o !== void 0) return o;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [l, u];
  }
  const s = () => {
    const i = n.map((o) => E.createContext(o));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || i;
      return E.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: c } }),
        [a, c]
      );
    };
  };
  return s.scopeName = t, [r, X7(s, ...e)];
}
function X7(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(i) {
      const o = r.reduce((a, { useScope: c, scopeName: l }) => {
        const d = c(i)[`__scope${l}`];
        return { ...a, ...d };
      }, {});
      return E.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function J7(t, e) {
  return E.useReducer((n, r) => e[n][r] ?? n, t);
}
var aR = (t) => {
  const { present: e, children: n } = t, r = e8(e), s = typeof n == "function" ? n({ present: r.isPresent }) : E.Children.only(n), i = Ke(r.ref, t8(s));
  return typeof n == "function" || r.isPresent ? E.cloneElement(s, { ref: i }) : null;
};
aR.displayName = "Presence";
function e8(t) {
  const [e, n] = E.useState(), r = E.useRef({}), s = E.useRef(t), i = E.useRef("none"), o = t ? "mounted" : "unmounted", [a, c] = J7(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return E.useEffect(() => {
    const l = bu(r.current);
    i.current = a === "mounted" ? l : "none";
  }, [a]), bn(() => {
    const l = r.current, u = s.current;
    if (u !== t) {
      const f = i.current, h = bu(l);
      t ? c("MOUNT") : h === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), s.current = t;
    }
  }, [t, c]), bn(() => {
    if (e) {
      let l;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const m = bu(r.current).includes(h.animationName);
        if (h.target === e && m && (c("ANIMATION_END"), !s.current)) {
          const y = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", l = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = y);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = bu(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(l), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      c("ANIMATION_END");
  }, [e, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: E.useCallback((l) => {
      l && (r.current = getComputedStyle(l)), n(l);
    }, [])
  };
}
function bu(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function t8(t) {
  var r, s;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var vb = "Collapsible", [n8, cR] = Q7(vb), [r8, xb] = n8(vb), lR = E.forwardRef(
  (t, e) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: s,
      disabled: i,
      onOpenChange: o,
      ...a
    } = t, [c = !1, l] = Ea({
      prop: r,
      defaultProp: s,
      onChange: o
    });
    return /* @__PURE__ */ g.jsx(
      r8,
      {
        scope: n,
        disabled: i,
        contentId: jo(),
        open: c,
        onOpenToggle: E.useCallback(() => l((u) => !u), [l]),
        children: /* @__PURE__ */ g.jsx(
          ze.div,
          {
            "data-state": Ab(c),
            "data-disabled": i ? "" : void 0,
            ...a,
            ref: e
          }
        )
      }
    );
  }
);
lR.displayName = vb;
var uR = "CollapsibleTrigger", dR = E.forwardRef(
  (t, e) => {
    const { __scopeCollapsible: n, ...r } = t, s = xb(uR, n);
    return /* @__PURE__ */ g.jsx(
      ze.button,
      {
        type: "button",
        "aria-controls": s.contentId,
        "aria-expanded": s.open || !1,
        "data-state": Ab(s.open),
        "data-disabled": s.disabled ? "" : void 0,
        disabled: s.disabled,
        ...r,
        ref: e,
        onClick: We(t.onClick, s.onOpenToggle)
      }
    );
  }
);
dR.displayName = uR;
var wb = "CollapsibleContent", fR = E.forwardRef(
  (t, e) => {
    const { forceMount: n, ...r } = t, s = xb(wb, t.__scopeCollapsible);
    return /* @__PURE__ */ g.jsx(aR, { present: n || s.open, children: ({ present: i }) => /* @__PURE__ */ g.jsx(s8, { ...r, ref: e, present: i }) });
  }
);
fR.displayName = wb;
var s8 = E.forwardRef((t, e) => {
  const { __scopeCollapsible: n, present: r, children: s, ...i } = t, o = xb(wb, n), [a, c] = E.useState(r), l = E.useRef(null), u = Ke(e, l), d = E.useRef(0), f = d.current, h = E.useRef(0), p = h.current, m = o.open || a, y = E.useRef(m), b = E.useRef();
  return E.useEffect(() => {
    const v = requestAnimationFrame(() => y.current = !1);
    return () => cancelAnimationFrame(v);
  }, []), bn(() => {
    const v = l.current;
    if (v) {
      b.current = b.current || {
        transitionDuration: v.style.transitionDuration,
        animationName: v.style.animationName
      }, v.style.transitionDuration = "0s", v.style.animationName = "none";
      const w = v.getBoundingClientRect();
      d.current = w.height, h.current = w.width, y.current || (v.style.transitionDuration = b.current.transitionDuration, v.style.animationName = b.current.animationName), c(r);
    }
  }, [o.open, r]), /* @__PURE__ */ g.jsx(
    ze.div,
    {
      "data-state": Ab(o.open),
      "data-disabled": o.disabled ? "" : void 0,
      id: o.contentId,
      hidden: !m,
      ...i,
      ref: u,
      style: {
        "--radix-collapsible-content-height": f ? `${f}px` : void 0,
        "--radix-collapsible-content-width": p ? `${p}px` : void 0,
        ...t.style
      },
      children: m && s
    }
  );
});
function Ab(t) {
  return t ? "open" : "closed";
}
var i8 = lR, o8 = dR, a8 = fR, As = "Accordion", c8 = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [Sb, l8, u8] = VC(As), [th, Cte] = $7(As, [
  u8,
  cR
]), Eb = cR(), hR = z.forwardRef(
  (t, e) => {
    const { type: n, ...r } = t, s = r, i = r;
    return /* @__PURE__ */ g.jsx(Sb.Provider, { scope: t.__scopeAccordion, children: n === "multiple" ? /* @__PURE__ */ g.jsx(p8, { ...i, ref: e }) : /* @__PURE__ */ g.jsx(h8, { ...s, ref: e }) });
  }
);
hR.displayName = As;
var [pR, d8] = th(As), [mR, f8] = th(
  As,
  { collapsible: !1 }
), h8 = z.forwardRef(
  (t, e) => {
    const {
      value: n,
      defaultValue: r,
      onValueChange: s = () => {
      },
      collapsible: i = !1,
      ...o
    } = t, [a, c] = Ea({
      prop: n,
      defaultProp: r,
      onChange: s
    });
    return /* @__PURE__ */ g.jsx(
      pR,
      {
        scope: t.__scopeAccordion,
        value: a ? [a] : [],
        onItemOpen: c,
        onItemClose: z.useCallback(() => i && c(""), [i, c]),
        children: /* @__PURE__ */ g.jsx(mR, { scope: t.__scopeAccordion, collapsible: i, children: /* @__PURE__ */ g.jsx(gR, { ...o, ref: e }) })
      }
    );
  }
), p8 = z.forwardRef((t, e) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: s = () => {
    },
    ...i
  } = t, [o = [], a] = Ea({
    prop: n,
    defaultProp: r,
    onChange: s
  }), c = z.useCallback(
    (u) => a((d = []) => [...d, u]),
    [a]
  ), l = z.useCallback(
    (u) => a((d = []) => d.filter((f) => f !== u)),
    [a]
  );
  return /* @__PURE__ */ g.jsx(
    pR,
    {
      scope: t.__scopeAccordion,
      value: o,
      onItemOpen: c,
      onItemClose: l,
      children: /* @__PURE__ */ g.jsx(mR, { scope: t.__scopeAccordion, collapsible: !0, children: /* @__PURE__ */ g.jsx(gR, { ...i, ref: e }) })
    }
  );
}), [m8, nh] = th(As), gR = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, disabled: r, dir: s, orientation: i = "vertical", ...o } = t, a = z.useRef(null), c = Ke(a, e), l = l8(n), d = Ay(s) === "ltr", f = We(t.onKeyDown, (h) => {
      var _;
      if (!c8.includes(h.key)) return;
      const p = h.target, m = l().filter((T) => {
        var k;
        return !((k = T.ref.current) != null && k.disabled);
      }), y = m.findIndex((T) => T.ref.current === p), b = m.length;
      if (y === -1) return;
      h.preventDefault();
      let v = y;
      const w = 0, x = b - 1, A = () => {
        v = y + 1, v > x && (v = w);
      }, C = () => {
        v = y - 1, v < w && (v = x);
      };
      switch (h.key) {
        case "Home":
          v = w;
          break;
        case "End":
          v = x;
          break;
        case "ArrowRight":
          i === "horizontal" && (d ? A() : C());
          break;
        case "ArrowDown":
          i === "vertical" && A();
          break;
        case "ArrowLeft":
          i === "horizontal" && (d ? C() : A());
          break;
        case "ArrowUp":
          i === "vertical" && C();
          break;
      }
      const S = v % b;
      (_ = m[S].ref.current) == null || _.focus();
    });
    return /* @__PURE__ */ g.jsx(
      m8,
      {
        scope: n,
        disabled: r,
        direction: s,
        orientation: i,
        children: /* @__PURE__ */ g.jsx(Sb.Slot, { scope: n, children: /* @__PURE__ */ g.jsx(
          ze.div,
          {
            ...o,
            "data-orientation": i,
            ref: c,
            onKeyDown: r ? void 0 : f
          }
        ) })
      }
    );
  }
), Kd = "AccordionItem", [g8, Cb] = th(Kd), yR = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, value: r, ...s } = t, i = nh(Kd, n), o = d8(Kd, n), a = Eb(n), c = jo(), l = r && o.value.includes(r) || !1, u = i.disabled || t.disabled;
    return /* @__PURE__ */ g.jsx(
      g8,
      {
        scope: n,
        open: l,
        disabled: u,
        triggerId: c,
        children: /* @__PURE__ */ g.jsx(
          i8,
          {
            "data-orientation": i.orientation,
            "data-state": SR(l),
            ...a,
            ...s,
            ref: e,
            disabled: u,
            open: l,
            onOpenChange: (d) => {
              d ? o.onItemOpen(r) : o.onItemClose(r);
            }
          }
        )
      }
    );
  }
);
yR.displayName = Kd;
var bR = "AccordionHeader", vR = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, ...r } = t, s = nh(As, n), i = Cb(bR, n);
    return /* @__PURE__ */ g.jsx(
      ze.h3,
      {
        "data-orientation": s.orientation,
        "data-state": SR(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: e
      }
    );
  }
);
vR.displayName = bR;
var $m = "AccordionTrigger", xR = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, ...r } = t, s = nh(As, n), i = Cb($m, n), o = f8($m, n), a = Eb(n);
    return /* @__PURE__ */ g.jsx(Sb.ItemSlot, { scope: n, children: /* @__PURE__ */ g.jsx(
      o8,
      {
        "aria-disabled": i.open && !o.collapsible || void 0,
        "data-orientation": s.orientation,
        id: i.triggerId,
        ...a,
        ...r,
        ref: e
      }
    ) });
  }
);
xR.displayName = $m;
var wR = "AccordionContent", AR = z.forwardRef(
  (t, e) => {
    const { __scopeAccordion: n, ...r } = t, s = nh(As, n), i = Cb(wR, n), o = Eb(n);
    return /* @__PURE__ */ g.jsx(
      a8,
      {
        role: "region",
        "aria-labelledby": i.triggerId,
        "data-orientation": s.orientation,
        ...o,
        ...r,
        ref: e,
        style: {
          "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
          "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
          ...t.style
        }
      }
    );
  }
);
AR.displayName = wR;
function SR(t) {
  return t ? "open" : "closed";
}
var y8 = hR, b8 = yR, v8 = vR, ER = xR, CR = AR;
const x8 = y8, ed = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  b8,
  {
    ref: n,
    className: de("border-b", t),
    ...e
  }
));
ed.displayName = "AccordionItem";
const td = E.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g.jsx(v8, { className: "flex", children: /* @__PURE__ */ g.jsxs(
  ER,
  {
    ref: r,
    className: de(
      "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
      t
    ),
    ...n,
    children: [
      e,
      /* @__PURE__ */ g.jsx(PF, { className: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
    ]
  }
) }));
td.displayName = ER.displayName;
const nd = E.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g.jsx(
  CR,
  {
    ref: r,
    className: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
    ...n,
    children: /* @__PURE__ */ g.jsx("div", { className: de("pb-4 pt-0", t), children: e })
  }
));
nd.displayName = CR.displayName;
function w8() {
  const {
    isHelpDialogOpen: t,
    setIsHelpDialogOpen: e,
    selectedCurrency: n
  } = st(), r = fr(), s = /* @__PURE__ */ g.jsxs(x8, { type: "single", collapsible: !0, defaultValue: "how-to-play", className: "w-full text-white p-2", children: [
    /* @__PURE__ */ g.jsxs(ed, { value: "how-to-play", children: [
      /* @__PURE__ */ g.jsx(td, { className: "font-bold", children: "How to Play" }),
      /* @__PURE__ */ g.jsxs(nd, { children: [
        /* @__PURE__ */ g.jsx("p", { children: "Here's how to play the game:" }),
        /* @__PURE__ */ g.jsxs("ul", { className: "list-disc pl-5 mt-2", children: [
          /* @__PURE__ */ g.jsx("li", { children: "Select your bet amount" }),
          /* @__PURE__ */ g.jsx("li", { children: "Click the 'Play' button to start the game" }),
          /* @__PURE__ */ g.jsx("li", { children: "Watch as the multiplier increases" }),
          /* @__PURE__ */ g.jsx("li", { children: "Cash out before the game crashes to win!" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ g.jsxs(ed, { value: "rules", children: [
      /* @__PURE__ */ g.jsx(td, { className: "font-bold", children: "Rules" }),
      /* @__PURE__ */ g.jsxs(nd, { children: [
        /* @__PURE__ */ g.jsx("p", { children: "Game rules and regulations:" }),
        /* @__PURE__ */ g.jsxs("ul", { className: "list-disc pl-5 mt-2", children: [
          /* @__PURE__ */ g.jsxs("li", { children: [
            "Minimum bet: ",
            n.prefixSymbol,
            n.fractionalDigits
          ] }),
          /* @__PURE__ */ g.jsxs("li", { children: [
            "Maximum bet: ",
            n.prefixSymbol,
            "1000"
          ] }),
          /* @__PURE__ */ g.jsx("li", { children: "The game can crash at any moment" }),
          /* @__PURE__ */ g.jsx("li", { children: "Your potential winnings increase as the multiplier grows" }),
          /* @__PURE__ */ g.jsx("li", { children: "If you don't cash out before the crash, you lose your bet" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ g.jsxs(ed, { value: "faq", children: [
      /* @__PURE__ */ g.jsx(td, { className: "font-bold", children: "FAQ" }),
      /* @__PURE__ */ g.jsx(nd, { children: /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ g.jsxs("div", { children: [
          /* @__PURE__ */ g.jsx("h4", { className: "font-semibold", children: "Q: Is the game fair?" }),
          /* @__PURE__ */ g.jsx("p", { children: "A: Yes, the game uses a provably fair algorithm." })
        ] }),
        /* @__PURE__ */ g.jsxs("div", { children: [
          /* @__PURE__ */ g.jsx("h4", { className: "font-semibold", children: "Q: Can I play on mobile?" }),
          /* @__PURE__ */ g.jsx("p", { children: "A: Yes, the game is fully responsive and works on all devices." })
        ] }),
        /* @__PURE__ */ g.jsxs("div", { children: [
          /* @__PURE__ */ g.jsx("h4", { className: "font-semibold", children: "Q: How do I deposit?" }),
          /* @__PURE__ */ g.jsx("p", { children: "A: You can deposit using various cryptocurrencies or traditional payment methods." })
        ] })
      ] }) })
    ] })
  ] }), i = /* @__PURE__ */ g.jsxs(Zf, { className: "sm:max-w-[425px] max-h-[98vh] p-4 pt-6 bg-secondary border-slate-600/30 overflow-y-auto", children: [
    /* @__PURE__ */ g.jsx(Qf, { className: "absolute  top-0 left-0 right-0 bg-pills px-6 py-3 flex justify-between items-left", children: /* @__PURE__ */ g.jsxs(Xf, { className: "text-white text-left text-base flex items-center gap-2", children: [
      /* @__PURE__ */ g.jsx(Kh, { size: 20 }),
      " Game Information"
    ] }) }),
    /* @__PURE__ */ g.jsx("div", { className: "mt-10", children: /* @__PURE__ */ g.jsx(Zi, { className: "", children: s }) })
  ] }), o = /* @__PURE__ */ g.jsxs(db, { className: "bg-secondary p-2 border-secondary", children: [
    /* @__PURE__ */ g.jsx(fb, { className: "text-center text-white ", children: /* @__PURE__ */ g.jsx(pb, { children: "Provably Fair" }) }),
    /* @__PURE__ */ g.jsx(Zi, { className: "overflow-y-auto no-scrollbar mb-4", children: s }),
    /* @__PURE__ */ g.jsx(hb, { className: "mt-2 p-2 space-y-2", children: /* @__PURE__ */ g.jsx(Hk, { asChild: !0, children: /* @__PURE__ */ g.jsx(pt, { variant: "outline", className: "w-full", children: "Close" }) }) })
  ] });
  return r ? /* @__PURE__ */ g.jsxs(
    ub,
    {
      open: t,
      onOpenChange: e,
      children: [
        /* @__PURE__ */ g.jsx(zk, { asChild: !0, children: /* @__PURE__ */ g.jsx("button", { className: "text-gray-400 hover:text-white px-1", children: /* @__PURE__ */ g.jsx(Kh, { size: 20 }) }) }),
        o
      ]
    }
  ) : /* @__PURE__ */ g.jsxs(
    cb,
    {
      open: t,
      onOpenChange: e,
      modal: !0,
      children: [
        /* @__PURE__ */ g.jsx(Rk, { asChild: !0, children: /* @__PURE__ */ g.jsx("button", { className: "text-gray-400 hover:text-white px-1", children: /* @__PURE__ */ g.jsx(Kh, { size: 20 }) }) }),
        i
      ]
    }
  );
}
function A8() {
  const {
    balance: t,
    selectedCurrency: e,
    initializing: n,
    isSoundMuted: r,
    setIsSoundMuted: s,
    setLiveStatsOpen: i,
    isLiveStatsOpen: o
  } = st();
  let a;
  t && (a = t.toFixed(e.fractionalDigits));
  const c = () => {
    s(!r);
  };
  return /* @__PURE__ */ g.jsxs("div", { className: "h-[55px] bg-[#152538] border-t border-gray-700 flex items-center justify-between px-4", children: [
    /* @__PURE__ */ g.jsx("div", { className: "flex items-center space-x-4 text-gray-400", children: n ? /* @__PURE__ */ g.jsxs("div", { className: "h-8 w-[110px] flex items-center w-full space-x-2", children: [
      /* @__PURE__ */ g.jsx(gc, { className: "h-8 w-20 bg-gray-700" }),
      /* @__PURE__ */ g.jsx(gc, { className: "h-8 w-5 bg-gray-700 rounded-full" })
    ] }) : /* @__PURE__ */ g.jsxs("span", { className: "text-xl font-bold text-white w-full justify-between", children: [
      e.prefixSymbol,
      a
    ] }) }),
    /* @__PURE__ */ g.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ g.jsx(
        "button",
        {
          className: `hover:text-white px-2 ${r ? "text-gray-400" : "text-green-400"}`,
          onClick: c,
          children: r ? /* @__PURE__ */ g.jsx(oB, { size: 20 }) : /* @__PURE__ */ g.jsx(iB, { size: 20 })
        }
      ),
      /* @__PURE__ */ g.jsx(
        "button",
        {
          className: "text-gray-400 px-2 hover:text-white",
          onClick: () => i(!o),
          children: /* @__PURE__ */ g.jsx(aC, { size: 20 })
        }
      ),
      /* @__PURE__ */ g.jsx(w8, {}),
      /* @__PURE__ */ g.jsx(K7, {})
    ] })
  ] });
}
const _R = Object.prototype.toString;
function rh(t) {
  switch (_R.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return !0;
    default:
      return hs(t, Error);
  }
}
function Ra(t, e) {
  return _R.call(t) === `[object ${e}]`;
}
function TR(t) {
  return Ra(t, "ErrorEvent");
}
function vA(t) {
  return Ra(t, "DOMError");
}
function S8(t) {
  return Ra(t, "DOMException");
}
function as(t) {
  return Ra(t, "String");
}
function _b(t) {
  return typeof t == "object" && t !== null && "__sentry_template_string__" in t && "__sentry_template_values__" in t;
}
function Tb(t) {
  return t === null || _b(t) || typeof t != "object" && typeof t != "function";
}
function ia(t) {
  return Ra(t, "Object");
}
function sh(t) {
  return typeof Event < "u" && hs(t, Event);
}
function E8(t) {
  return typeof Element < "u" && hs(t, Element);
}
function C8(t) {
  return Ra(t, "RegExp");
}
function ih(t) {
  return !!(t && t.then && typeof t.then == "function");
}
function _8(t) {
  return ia(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t;
}
function hs(t, e) {
  try {
    return t instanceof e;
  } catch {
    return !1;
  }
}
function kR(t) {
  return !!(typeof t == "object" && t !== null && (t.__isVue || t._isVue));
}
function Uo(t, e = 0) {
  return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0, e)}...`;
}
function xA(t, e) {
  if (!Array.isArray(t))
    return "";
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    try {
      kR(s) ? n.push("[VueViewModel]") : n.push(String(s));
    } catch {
      n.push("[value cannot be serialized]");
    }
  }
  return n.join(e);
}
function T8(t, e, n = !1) {
  return as(t) ? C8(e) ? e.test(t) : as(e) ? n ? t === e : t.includes(e) : !1 : !1;
}
function zs(t, e = [], n = !1) {
  return e.some((r) => T8(t, r, n));
}
function k8(t, e, n = 250, r, s, i, o) {
  if (!i.exception || !i.exception.values || !o || !hs(o.originalException, Error))
    return;
  const a = i.exception.values.length > 0 ? i.exception.values[i.exception.values.length - 1] : void 0;
  a && (i.exception.values = R8(
    Zm(
      t,
      e,
      s,
      o.originalException,
      r,
      i.exception.values,
      a,
      0
    ),
    n
  ));
}
function Zm(t, e, n, r, s, i, o, a) {
  if (i.length >= n + 1)
    return i;
  let c = [...i];
  if (hs(r[s], Error)) {
    wA(o, a);
    const l = t(e, r[s]), u = c.length;
    AA(l, s, u, a), c = Zm(
      t,
      e,
      n,
      r[s],
      s,
      [l, ...c],
      l,
      u
    );
  }
  return Array.isArray(r.errors) && r.errors.forEach((l, u) => {
    if (hs(l, Error)) {
      wA(o, a);
      const d = t(e, l), f = c.length;
      AA(d, `errors[${u}]`, f, a), c = Zm(
        t,
        e,
        n,
        l,
        s,
        [d, ...c],
        d,
        f
      );
    }
  }), c;
}
function wA(t, e) {
  t.mechanism = t.mechanism || { type: "generic", handled: !0 }, t.mechanism = {
    ...t.mechanism,
    ...t.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: e
  };
}
function AA(t, e, n, r) {
  t.mechanism = t.mechanism || { type: "generic", handled: !0 }, t.mechanism = {
    ...t.mechanism,
    type: "chained",
    source: e,
    exception_id: n,
    parent_id: r
  };
}
function R8(t, e) {
  return t.map((n) => (n.value && (n.value = Uo(n.value, e)), n));
}
function RR(t) {
  if (t !== void 0)
    return t >= 400 && t < 500 ? "warning" : t >= 500 ? "error" : void 0;
}
const Ni = "8.35.0", Oe = globalThis;
function oh(t, e, n) {
  const r = n || Oe, s = r.__SENTRY__ = r.__SENTRY__ || {}, i = s[Ni] = s[Ni] || {};
  return i[t] || (i[t] = e());
}
const Wo = Oe, M8 = 80;
function ps(t, e = {}) {
  if (!t)
    return "<unknown>";
  try {
    let n = t;
    const r = 5, s = [];
    let i = 0, o = 0;
    const a = " > ", c = a.length;
    let l;
    const u = Array.isArray(e) ? e : e.keyAttrs, d = !Array.isArray(e) && e.maxStringLength || M8;
    for (; n && i++ < r && (l = P8(n, u), !(l === "html" || i > 1 && o + s.length * c + l.length >= d)); )
      s.push(l), o += l.length, n = n.parentNode;
    return s.reverse().join(a);
  } catch {
    return "<unknown>";
  }
}
function P8(t, e) {
  const n = t, r = [];
  if (!n || !n.tagName)
    return "";
  if (Wo.HTMLElement && n instanceof HTMLElement && n.dataset) {
    if (n.dataset.sentryComponent)
      return n.dataset.sentryComponent;
    if (n.dataset.sentryElement)
      return n.dataset.sentryElement;
  }
  r.push(n.tagName.toLowerCase());
  const s = e && e.length ? e.filter((o) => n.getAttribute(o)).map((o) => [o, n.getAttribute(o)]) : null;
  if (s && s.length)
    s.forEach((o) => {
      r.push(`[${o[0]}="${o[1]}"]`);
    });
  else {
    n.id && r.push(`#${n.id}`);
    const o = n.className;
    if (o && as(o)) {
      const a = o.split(/\s+/);
      for (const c of a)
        r.push(`.${c}`);
    }
  }
  const i = ["aria-label", "type", "name", "title", "alt"];
  for (const o of i) {
    const a = n.getAttribute(o);
    a && r.push(`[${o}="${a}"]`);
  }
  return r.join("");
}
function MR() {
  try {
    return Wo.document.location.href;
  } catch {
    return "";
  }
}
function I8(t) {
  return Wo.document && Wo.document.querySelector ? Wo.document.querySelector(t) : null;
}
function PR(t) {
  if (!Wo.HTMLElement)
    return null;
  let e = t;
  const n = 5;
  for (let r = 0; r < n; r++) {
    if (!e)
      return null;
    if (e instanceof HTMLElement) {
      if (e.dataset.sentryComponent)
        return e.dataset.sentryComponent;
      if (e.dataset.sentryElement)
        return e.dataset.sentryElement;
    }
    e = e.parentNode;
  }
  return null;
}
const Ma = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, D8 = "Sentry Logger ", Qm = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
], $d = {};
function Pa(t) {
  if (!("console" in Oe))
    return t();
  const e = Oe.console, n = {}, r = Object.keys($d);
  r.forEach((s) => {
    const i = $d[s];
    n[s] = e[s], e[s] = i;
  });
  try {
    return t();
  } finally {
    r.forEach((s) => {
      e[s] = n[s];
    });
  }
}
function O8() {
  let t = !1;
  const e = {
    enable: () => {
      t = !0;
    },
    disable: () => {
      t = !1;
    },
    isEnabled: () => t
  };
  return Ma ? Qm.forEach((n) => {
    e[n] = (...r) => {
      t && Pa(() => {
        Oe.console[n](`${D8}[${n}]:`, ...r);
      });
    };
  }) : Qm.forEach((n) => {
    e[n] = () => {
    };
  }), e;
}
const H = oh("logger", O8), q8 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function N8(t) {
  return t === "http" || t === "https";
}
function Ia(t, e = !1) {
  const { host: n, path: r, pass: s, port: i, projectId: o, protocol: a, publicKey: c } = t;
  return `${a}://${c}${e && s ? `:${s}` : ""}@${n}${i ? `:${i}` : ""}/${r && `${r}/`}${o}`;
}
function L8(t) {
  const e = q8.exec(t);
  if (!e) {
    Pa(() => {
      console.error(`Invalid Sentry Dsn: ${t}`);
    });
    return;
  }
  const [n, r, s = "", i = "", o = "", a = ""] = e.slice(1);
  let c = "", l = a;
  const u = l.split("/");
  if (u.length > 1 && (c = u.slice(0, -1).join("/"), l = u.pop()), l) {
    const d = l.match(/^\d+/);
    d && (l = d[0]);
  }
  return IR({ host: i, pass: s, path: c, projectId: l, port: o, protocol: n, publicKey: r });
}
function IR(t) {
  return {
    protocol: t.protocol,
    publicKey: t.publicKey || "",
    pass: t.pass || "",
    host: t.host,
    port: t.port || "",
    path: t.path || "",
    projectId: t.projectId
  };
}
function j8(t) {
  if (!Ma)
    return !0;
  const { port: e, projectId: n, protocol: r } = t;
  return ["protocol", "publicKey", "host", "projectId"].find((o) => t[o] ? !1 : (H.error(`Invalid Sentry Dsn: ${o} missing`), !0)) ? !1 : n.match(/^\d+$/) ? N8(r) ? e && isNaN(parseInt(e, 10)) ? (H.error(`Invalid Sentry Dsn: Invalid port ${e}`), !1) : !0 : (H.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1) : (H.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1);
}
function DR(t) {
  const e = typeof t == "string" ? L8(t) : IR(t);
  if (!(!e || !j8(e)))
    return e;
}
class Ar extends Error {
  /** Display name of this error instance. */
  constructor(e, n = "warn") {
    super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n;
  }
}
function _n(t, e, n) {
  if (!(e in t))
    return;
  const r = t[e], s = n(r);
  typeof s == "function" && OR(s, r), t[e] = s;
}
function Jn(t, e, n) {
  try {
    Object.defineProperty(t, e, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value: n,
      writable: !0,
      configurable: !0
    });
  } catch {
    Ma && H.log(`Failed to add non-enumerable property "${e}" to object`, t);
  }
}
function OR(t, e) {
  try {
    const n = e.prototype || {};
    t.prototype = e.prototype = n, Jn(t, "__sentry_original__", e);
  } catch {
  }
}
function kb(t) {
  return t.__sentry_original__;
}
function B8(t) {
  return Object.keys(t).map((e) => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&");
}
function qR(t) {
  if (rh(t))
    return {
      message: t.message,
      name: t.name,
      stack: t.stack,
      ...EA(t)
    };
  if (sh(t)) {
    const e = {
      type: t.type,
      target: SA(t.target),
      currentTarget: SA(t.currentTarget),
      ...EA(t)
    };
    return typeof CustomEvent < "u" && hs(t, CustomEvent) && (e.detail = t.detail), e;
  } else
    return t;
}
function SA(t) {
  try {
    return E8(t) ? ps(t) : Object.prototype.toString.call(t);
  } catch {
    return "<unknown>";
  }
}
function EA(t) {
  if (typeof t == "object" && t !== null) {
    const e = {};
    for (const n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e;
  } else
    return {};
}
function F8(t, e = 40) {
  const n = Object.keys(qR(t));
  n.sort();
  const r = n[0];
  if (!r)
    return "[object has no keys]";
  if (r.length >= e)
    return Uo(r, e);
  for (let s = n.length; s > 0; s--) {
    const i = n.slice(0, s).join(", ");
    if (!(i.length > e))
      return s === n.length ? i : Uo(i, e);
  }
  return "";
}
function Vt(t) {
  return Xm(t, /* @__PURE__ */ new Map());
}
function Xm(t, e) {
  if (V8(t)) {
    const n = e.get(t);
    if (n !== void 0)
      return n;
    const r = {};
    e.set(t, r);
    for (const s of Object.getOwnPropertyNames(t))
      typeof t[s] < "u" && (r[s] = Xm(t[s], e));
    return r;
  }
  if (Array.isArray(t)) {
    const n = e.get(t);
    if (n !== void 0)
      return n;
    const r = [];
    return e.set(t, r), t.forEach((s) => {
      r.push(Xm(s, e));
    }), r;
  }
  return t;
}
function V8(t) {
  if (!ia(t))
    return !1;
  try {
    const e = Object.getPrototypeOf(t).constructor.name;
    return !e || e === "Object";
  } catch {
    return !0;
  }
}
const NR = 50, Qi = "?", CA = /\(error: (.*)\)/, _A = /captureMessage|captureException/;
function LR(...t) {
  const e = t.sort((n, r) => n[0] - r[0]).map((n) => n[1]);
  return (n, r = 0, s = 0) => {
    const i = [], o = n.split(`
`);
    for (let a = r; a < o.length; a++) {
      const c = o[a];
      if (c.length > 1024)
        continue;
      const l = CA.test(c) ? c.replace(CA, "$1") : c;
      if (!l.match(/\S*Error: /)) {
        for (const u of e) {
          const d = u(l);
          if (d) {
            i.push(d);
            break;
          }
        }
        if (i.length >= NR + s)
          break;
      }
    }
    return W8(i.slice(s));
  };
}
function U8(t) {
  return Array.isArray(t) ? LR(...t) : t;
}
function W8(t) {
  if (!t.length)
    return [];
  const e = Array.from(t);
  return /sentryWrapped/.test(vu(e).function || "") && e.pop(), e.reverse(), _A.test(vu(e).function || "") && (e.pop(), _A.test(vu(e).function || "") && e.pop()), e.slice(0, NR).map((n) => ({
    ...n,
    filename: n.filename || vu(e).filename,
    function: n.function || Qi
  }));
}
function vu(t) {
  return t[t.length - 1] || {};
}
const Tp = "<anonymous>";
function ms(t) {
  try {
    return !t || typeof t != "function" ? Tp : t.name || Tp;
  } catch {
    return Tp;
  }
}
function TA(t) {
  const e = t.exception;
  if (e) {
    const n = [];
    try {
      return e.values.forEach((r) => {
        r.stacktrace.frames && n.push(...r.stacktrace.frames);
      }), n;
    } catch {
      return;
    }
  }
}
const rd = {}, kA = {};
function di(t, e) {
  rd[t] = rd[t] || [], rd[t].push(e);
}
function fi(t, e) {
  kA[t] || (e(), kA[t] = !0);
}
function Xn(t, e) {
  const n = t && rd[t];
  if (n)
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        Ma && H.error(
          `Error while triggering instrumentation handler.
Type: ${t}
Name: ${ms(r)}
Error:`,
          s
        );
      }
}
function z8(t) {
  const e = "console";
  di(e, t), fi(e, H8);
}
function H8() {
  "console" in Oe && Qm.forEach(function(t) {
    t in Oe.console && _n(Oe.console, t, function(e) {
      return $d[t] = e, function(...n) {
        Xn("console", { args: n, level: t });
        const s = $d[t];
        s && s.apply(Oe.console, n);
      };
    });
  });
}
const Jm = Oe;
function jR() {
  if (!("fetch" in Jm))
    return !1;
  try {
    return new Headers(), new Request("http://www.example.com"), new Response(), !0;
  } catch {
    return !1;
  }
}
function eg(t) {
  return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString());
}
function Y8() {
  if (typeof EdgeRuntime == "string")
    return !0;
  if (!jR())
    return !1;
  if (eg(Jm.fetch))
    return !0;
  let t = !1;
  const e = Jm.document;
  if (e && typeof e.createElement == "function")
    try {
      const n = e.createElement("iframe");
      n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = eg(n.contentWindow.fetch)), e.head.removeChild(n);
    } catch (n) {
      Ma && H.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n);
    }
  return t;
}
const BR = 1e3;
function kl() {
  return Date.now() / BR;
}
function G8() {
  const { performance: t } = Oe;
  if (!t || !t.now)
    return kl;
  const e = Date.now() - t.now(), n = t.timeOrigin == null ? e : t.timeOrigin;
  return () => (n + t.now()) / BR;
}
const gn = G8(), vn = (() => {
  const { performance: t } = Oe;
  if (!t || !t.now)
    return;
  const e = 3600 * 1e3, n = t.now(), r = Date.now(), s = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e, i = s < e, o = t.timing && t.timing.navigationStart, c = typeof o == "number" ? Math.abs(o + n - r) : e, l = c < e;
  return i || l ? s <= c ? t.timeOrigin : o : r;
})();
function FR(t, e) {
  const n = "fetch";
  di(n, t), fi(n, () => VR(void 0, e));
}
function K8(t) {
  const e = "fetch-body-resolved";
  di(e, t), fi(e, () => VR(Z8));
}
function VR(t, e = !1) {
  e && !Y8() || _n(Oe, "fetch", function(n) {
    return function(...r) {
      const { method: s, url: i } = Q8(r), o = {
        args: r,
        fetchData: {
          method: s,
          url: i
        },
        startTimestamp: gn() * 1e3
      };
      t || Xn("fetch", {
        ...o
      });
      const a = new Error().stack;
      return n.apply(Oe, r).then(
        async (c) => (t ? t(c) : Xn("fetch", {
          ...o,
          endTimestamp: gn() * 1e3,
          response: c
        }), c),
        (c) => {
          throw Xn("fetch", {
            ...o,
            endTimestamp: gn() * 1e3,
            error: c
          }), rh(c) && c.stack === void 0 && (c.stack = a, Jn(c, "framesToPop", 1)), c;
        }
      );
    };
  });
}
async function $8(t, e) {
  if (t && t.body) {
    const n = t.body, r = n.getReader(), s = setTimeout(
      () => {
        n.cancel().then(null, () => {
        });
      },
      90 * 1e3
      // 90s
    );
    let i = !0;
    for (; i; ) {
      let o;
      try {
        o = setTimeout(() => {
          n.cancel().then(null, () => {
          });
        }, 5e3);
        const { done: a } = await r.read();
        clearTimeout(o), a && (e(), i = !1);
      } catch {
        i = !1;
      } finally {
        clearTimeout(o);
      }
    }
    clearTimeout(s), r.releaseLock(), n.cancel().then(null, () => {
    });
  }
}
function Z8(t) {
  let e;
  try {
    e = t.clone();
  } catch {
    return;
  }
  $8(e, () => {
    Xn("fetch-body-resolved", {
      endTimestamp: gn() * 1e3,
      response: t
    });
  });
}
function tg(t, e) {
  return !!t && typeof t == "object" && !!t[e];
}
function RA(t) {
  return typeof t == "string" ? t : t ? tg(t, "url") ? t.url : t.toString ? t.toString() : "" : "";
}
function Q8(t) {
  if (t.length === 0)
    return { method: "GET", url: "" };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: RA(n),
      method: tg(r, "method") ? String(r.method).toUpperCase() : "GET"
    };
  }
  const e = t[0];
  return {
    url: RA(e),
    method: tg(e, "method") ? String(e.method).toUpperCase() : "GET"
  };
}
let xu = null;
function UR(t) {
  const e = "error";
  di(e, t), fi(e, X8);
}
function X8() {
  xu = Oe.onerror, Oe.onerror = function(t, e, n, r, s) {
    return Xn("error", {
      column: r,
      error: s,
      line: n,
      msg: t,
      url: e
    }), xu && !xu.__SENTRY_LOADER__ ? xu.apply(this, arguments) : !1;
  }, Oe.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let wu = null;
function WR(t) {
  const e = "unhandledrejection";
  di(e, t), fi(e, J8);
}
function J8() {
  wu = Oe.onunhandledrejection, Oe.onunhandledrejection = function(t) {
    return Xn("unhandledrejection", t), wu && !wu.__SENTRY_LOADER__ ? wu.apply(this, arguments) : !0;
  }, Oe.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
function eY() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__;
}
function tY() {
  return "npm";
}
function nY() {
  return !eY() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
}
function MA() {
  return typeof window < "u" && (!nY() || rY());
}
function rY() {
  return (
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    Oe.process !== void 0 && Oe.process.type === "renderer"
  );
}
function sY() {
  const t = typeof WeakSet == "function", e = t ? /* @__PURE__ */ new WeakSet() : [];
  function n(s) {
    if (t)
      return e.has(s) ? !0 : (e.add(s), !1);
    for (let i = 0; i < e.length; i++)
      if (e[i] === s)
        return !0;
    return e.push(s), !1;
  }
  function r(s) {
    if (t)
      e.delete(s);
    else
      for (let i = 0; i < e.length; i++)
        if (e[i] === s) {
          e.splice(i, 1);
          break;
        }
  }
  return [n, r];
}
function gt() {
  const t = Oe, e = t.crypto || t.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (e && e.randomUUID)
      return e.randomUUID().replace(/-/g, "");
    e && e.getRandomValues && (n = () => {
      const r = new Uint8Array(1);
      return e.getRandomValues(r), r[0];
    });
  } catch {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (r) => (
      // eslint-disable-next-line no-bitwise
      (r ^ (n() & 15) >> r / 4).toString(16)
    )
  );
}
function zR(t) {
  return t.exception && t.exception.values ? t.exception.values[0] : void 0;
}
function Ms(t) {
  const { message: e, event_id: n } = t;
  if (e)
    return e;
  const r = zR(t);
  return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>";
}
function ng(t, e, n) {
  const r = t.exception = t.exception || {}, s = r.values = r.values || [], i = s[0] = s[0] || {};
  i.value || (i.value = e || ""), i.type || (i.type = "Error");
}
function il(t, e) {
  const n = zR(t);
  if (!n)
    return;
  const r = { type: "generic", handled: !0 }, s = n.mechanism;
  if (n.mechanism = { ...r, ...s, ...e }, e && "data" in e) {
    const i = { ...s && s.data, ...e.data };
    n.mechanism.data = i;
  }
}
function PA(t) {
  if (t && t.__sentry_captured__)
    return !0;
  try {
    Jn(t, "__sentry_captured__", !0);
  } catch {
  }
  return !1;
}
function HR(t) {
  return Array.isArray(t) ? t : [t];
}
function xr(t, e = 100, n = 1 / 0) {
  try {
    return rg("", t, e, n);
  } catch (r) {
    return { ERROR: `**non-serializable** (${r})` };
  }
}
function YR(t, e = 3, n = 100 * 1024) {
  const r = xr(t, e);
  return cY(r) > n ? YR(t, e - 1, n) : r;
}
function rg(t, e, n = 1 / 0, r = 1 / 0, s = sY()) {
  const [i, o] = s;
  if (e == null || // this matches null and undefined -> eqeq not eqeqeq
  ["boolean", "string"].includes(typeof e) || typeof e == "number" && Number.isFinite(e))
    return e;
  const a = iY(t, e);
  if (!a.startsWith("[object "))
    return a;
  if (e.__sentry_skip_normalization__)
    return e;
  const c = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
  if (c === 0)
    return a.replace("object ", "");
  if (i(e))
    return "[Circular ~]";
  const l = e;
  if (l && typeof l.toJSON == "function")
    try {
      const h = l.toJSON();
      return rg("", h, c - 1, r, s);
    } catch {
    }
  const u = Array.isArray(e) ? [] : {};
  let d = 0;
  const f = qR(e);
  for (const h in f) {
    if (!Object.prototype.hasOwnProperty.call(f, h))
      continue;
    if (d >= r) {
      u[h] = "[MaxProperties ~]";
      break;
    }
    const p = f[h];
    u[h] = rg(h, p, c - 1, r, s), d++;
  }
  return o(e), u;
}
function iY(t, e) {
  try {
    if (t === "domain" && e && typeof e == "object" && e._events)
      return "[Domain]";
    if (t === "domainEmitter")
      return "[DomainEmitter]";
    if (typeof global < "u" && e === global)
      return "[Global]";
    if (typeof window < "u" && e === window)
      return "[Window]";
    if (typeof document < "u" && e === document)
      return "[Document]";
    if (kR(e))
      return "[VueViewModel]";
    if (_8(e))
      return "[SyntheticEvent]";
    if (typeof e == "number" && !Number.isFinite(e))
      return `[${e}]`;
    if (typeof e == "function")
      return `[Function: ${ms(e)}]`;
    if (typeof e == "symbol")
      return `[${String(e)}]`;
    if (typeof e == "bigint")
      return `[BigInt: ${String(e)}]`;
    const n = oY(e);
    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`;
  } catch (n) {
    return `**non-serializable** (${n})`;
  }
}
function oY(t) {
  const e = Object.getPrototypeOf(t);
  return e ? e.constructor.name : "null prototype";
}
function aY(t) {
  return ~-encodeURI(t).split(/%..|./).length;
}
function cY(t) {
  return aY(JSON.stringify(t));
}
var Kr;
(function(t) {
  t[t.PENDING = 0] = "PENDING";
  const n = 1;
  t[t.RESOLVED = n] = "RESOLVED";
  const r = 2;
  t[t.REJECTED = r] = "REJECTED";
})(Kr || (Kr = {}));
function gs(t) {
  return new Qn((e) => {
    e(t);
  });
}
function Zd(t) {
  return new Qn((e, n) => {
    n(t);
  });
}
class Qn {
  constructor(e) {
    Qn.prototype.__init.call(this), Qn.prototype.__init2.call(this), Qn.prototype.__init3.call(this), Qn.prototype.__init4.call(this), this._state = Kr.PENDING, this._handlers = [];
    try {
      e(this._resolve, this._reject);
    } catch (n) {
      this._reject(n);
    }
  }
  /** JSDoc */
  then(e, n) {
    return new Qn((r, s) => {
      this._handlers.push([
        !1,
        (i) => {
          if (!e)
            r(i);
          else
            try {
              r(e(i));
            } catch (o) {
              s(o);
            }
        },
        (i) => {
          if (!n)
            s(i);
          else
            try {
              r(n(i));
            } catch (o) {
              s(o);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(e) {
    return this.then((n) => n, e);
  }
  /** JSDoc */
  finally(e) {
    return new Qn((n, r) => {
      let s, i;
      return this.then(
        (o) => {
          i = !1, s = o, e && e();
        },
        (o) => {
          i = !0, s = o, e && e();
        }
      ).then(() => {
        if (i) {
          r(s);
          return;
        }
        n(s);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (e) => {
      this._setResult(Kr.RESOLVED, e);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (e) => {
      this._setResult(Kr.REJECTED, e);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (e, n) => {
      if (this._state === Kr.PENDING) {
        if (ih(n)) {
          n.then(this._resolve, this._reject);
          return;
        }
        this._state = e, this._value = n, this._executeHandlers();
      }
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === Kr.PENDING)
        return;
      const e = this._handlers.slice();
      this._handlers = [], e.forEach((n) => {
        n[0] || (this._state === Kr.RESOLVED && n[1](this._value), this._state === Kr.REJECTED && n[2](this._value), n[0] = !0);
      });
    };
  }
}
function lY(t) {
  const e = [];
  function n() {
    return t === void 0 || e.length < t;
  }
  function r(o) {
    return e.splice(e.indexOf(o), 1)[0] || Promise.resolve(void 0);
  }
  function s(o) {
    if (!n())
      return Zd(new Ar("Not adding Promise because buffer limit was reached."));
    const a = o();
    return e.indexOf(a) === -1 && e.push(a), a.then(() => r(a)).then(
      null,
      () => r(a).then(null, () => {
      })
    ), a;
  }
  function i(o) {
    return new Qn((a, c) => {
      let l = e.length;
      if (!l)
        return a(!0);
      const u = setTimeout(() => {
        o && o > 0 && a(!1);
      }, o);
      e.forEach((d) => {
        gs(d).then(() => {
          --l || (clearTimeout(u), a(!0));
        }, c);
      });
    });
  }
  return {
    $: e,
    add: s,
    drain: i
  };
}
function Li(t) {
  if (!t)
    return {};
  const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!e)
    return {};
  const n = e[6] || "", r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r
    // everything minus origin
  };
}
const uY = ["fatal", "error", "warning", "log", "info", "debug"];
function GR(t) {
  return t === "warn" ? "warning" : uY.includes(t) ? t : "log";
}
const Ao = "baggage", Rb = "sentry-", dY = /^sentry-/, fY = 8192;
function KR(t) {
  const e = hY(t);
  if (!e)
    return;
  const n = Object.entries(e).reduce((r, [s, i]) => {
    if (s.match(dY)) {
      const o = s.slice(Rb.length);
      r[o] = i;
    }
    return r;
  }, {});
  if (Object.keys(n).length > 0)
    return n;
}
function $R(t) {
  if (!t)
    return;
  const e = Object.entries(t).reduce(
    (n, [r, s]) => (s && (n[`${Rb}${r}`] = s), n),
    {}
  );
  return pY(e);
}
function hY(t) {
  if (!(!t || !as(t) && !Array.isArray(t)))
    return Array.isArray(t) ? t.reduce((e, n) => {
      const r = IA(n);
      return Object.entries(r).forEach(([s, i]) => {
        e[s] = i;
      }), e;
    }, {}) : IA(t);
}
function IA(t) {
  return t.split(",").map((e) => e.split("=").map((n) => decodeURIComponent(n.trim()))).reduce((e, [n, r]) => (n && r && (e[n] = r), e), {});
}
function pY(t) {
  if (Object.keys(t).length !== 0)
    return Object.entries(t).reduce((e, [n, r], s) => {
      const i = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`, o = s === 0 ? i : `${e},${i}`;
      return o.length > fY ? (Ma && H.warn(
        `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`
      ), e) : o;
    }, "");
}
const mY = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
  // whitespace
);
function gY(t) {
  if (!t)
    return;
  const e = t.match(mY);
  if (!e)
    return;
  let n;
  return e[3] === "1" ? n = !0 : e[3] === "0" && (n = !1), {
    traceId: e[1],
    parentSampled: n,
    parentSpanId: e[2]
  };
}
function yY(t, e) {
  const n = gY(t), r = KR(e), { traceId: s, parentSpanId: i, parentSampled: o } = n || {};
  return n ? {
    traceId: s || gt(),
    parentSpanId: i || gt().substring(16),
    spanId: gt().substring(16),
    sampled: o,
    dsc: r || {}
    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
  } : {
    traceId: s || gt(),
    spanId: gt().substring(16)
  };
}
function Mb(t = gt(), e = gt().substring(16), n) {
  let r = "";
  return n !== void 0 && (r = n ? "-1" : "-0"), `${t}-${e}${r}`;
}
function so(t, e = []) {
  return [t, e];
}
function bY(t, e) {
  const [n, r] = t;
  return [n, [...r, e]];
}
function DA(t, e) {
  const n = t[1];
  for (const r of n) {
    const s = r[0].type;
    if (e(r, s))
      return !0;
  }
  return !1;
}
function sg(t) {
  return Oe.__SENTRY__ && Oe.__SENTRY__.encodePolyfill ? Oe.__SENTRY__.encodePolyfill(t) : new TextEncoder().encode(t);
}
function vY(t) {
  const [e, n] = t;
  let r = JSON.stringify(e);
  function s(i) {
    typeof r == "string" ? r = typeof i == "string" ? r + i : [sg(r), i] : r.push(typeof i == "string" ? sg(i) : i);
  }
  for (const i of n) {
    const [o, a] = i;
    if (s(`
${JSON.stringify(o)}
`), typeof a == "string" || a instanceof Uint8Array)
      s(a);
    else {
      let c;
      try {
        c = JSON.stringify(a);
      } catch {
        c = JSON.stringify(xr(a));
      }
      s(c);
    }
  }
  return typeof r == "string" ? r : xY(r);
}
function xY(t) {
  const e = t.reduce((s, i) => s + i.length, 0), n = new Uint8Array(e);
  let r = 0;
  for (const s of t)
    n.set(s, r), r += s.length;
  return n;
}
function wY(t) {
  return [{
    type: "span"
  }, t];
}
function AY(t) {
  const e = typeof t.data == "string" ? sg(t.data) : t.data;
  return [
    Vt({
      type: "attachment",
      length: e.length,
      filename: t.filename,
      content_type: t.contentType,
      attachment_type: t.attachmentType
    }),
    e
  ];
}
const SY = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket"
};
function OA(t) {
  return SY[t];
}
function Pb(t) {
  if (!t || !t.sdk)
    return;
  const { name: e, version: n } = t.sdk;
  return { name: e, version: n };
}
function ZR(t, e, n, r) {
  const s = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...e && { sdk: e },
    ...!!n && r && { dsn: Ia(r) },
    ...s && {
      trace: Vt({ ...s })
    }
  };
}
function EY(t, e, n) {
  const r = [
    { type: "client_report" },
    {
      timestamp: kl(),
      discarded_events: t
    }
  ];
  return so(e ? { dsn: e } : {}, [r]);
}
const CY = 60 * 1e3;
function _Y(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n))
    return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? CY : r - e;
}
function TY(t, e) {
  return t[e] || t.all || 0;
}
function QR(t, e, n = Date.now()) {
  return TY(t, e) > n;
}
function XR(t, { statusCode: e, headers: n }, r = Date.now()) {
  const s = {
    ...t
  }, i = n && n["x-sentry-rate-limits"], o = n && n["retry-after"];
  if (i)
    for (const a of i.trim().split(",")) {
      const [c, l, , , u] = a.split(":", 5), d = parseInt(c, 10), f = (isNaN(d) ? 60 : d) * 1e3;
      if (!l)
        s.all = r + f;
      else
        for (const h of l.split(";"))
          h === "metric_bucket" ? (!u || u.split(";").includes("custom")) && (s[h] = r + f) : s[h] = r + f;
    }
  else o ? s.all = r + _Y(o, r) : e === 429 && (s.all = r + 60 * 1e3);
  return s;
}
function kY(t, e) {
  return t ?? e();
}
function Bn(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], i = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = i(n)) : (s === "call" || s === "optionalCall") && (n = i((...o) => n.call(e, ...o)), e = void 0);
  }
  return n;
}
function Qd() {
  return {
    traceId: gt(),
    spanId: gt().substring(16)
  };
}
const Au = Oe;
function RY() {
  const t = Au.chrome, e = t && t.app && t.app.runtime, n = "history" in Au && !!Au.history.pushState && !!Au.history.replaceState;
  return !e && n;
}
const xe = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function Da() {
  return Ib(Oe), Oe;
}
function Ib(t) {
  const e = t.__SENTRY__ = t.__SENTRY__ || {};
  return e.version = e.version || Ni, e[Ni] = e[Ni] || {};
}
function MY(t) {
  const e = gn(), n = {
    sid: gt(),
    init: !0,
    timestamp: e,
    started: e,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: !1,
    toJSON: () => IY(n)
  };
  return t && oa(n, t), n;
}
function oa(t, e = {}) {
  if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || gn(), e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : gt()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration)
    t.duration = void 0;
  else if (typeof e.duration == "number")
    t.duration = e.duration;
  else {
    const n = t.timestamp - t.started;
    t.duration = n >= 0 ? n : 0;
  }
  e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status);
}
function PY(t, e) {
  let n = {};
  t.status === "ok" && (n = { status: "exited" }), oa(t, n);
}
function IY(t) {
  return Vt({
    sid: `${t.sid}`,
    init: t.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(t.started * 1e3).toISOString(),
    timestamp: new Date(t.timestamp * 1e3).toISOString(),
    status: t.status,
    errors: t.errors,
    did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
    duration: t.duration,
    abnormal_mechanism: t.abnormal_mechanism,
    attrs: {
      release: t.release,
      environment: t.environment,
      ip_address: t.ipAddress,
      user_agent: t.userAgent
    }
  });
}
const ig = "_sentrySpan";
function ol(t, e) {
  e ? Jn(t, ig, e) : delete t[ig];
}
function Xd(t) {
  return t[ig];
}
const DY = 100;
class Db {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = Qd();
  }
  /**
   * @inheritDoc
   */
  clone() {
    const e = new Db();
    return e._breadcrumbs = [...this._breadcrumbs], e._tags = { ...this._tags }, e._extra = { ...this._extra }, e._contexts = { ...this._contexts }, e._user = this._user, e._level = this._level, e._session = this._session, e._transactionName = this._transactionName, e._fingerprint = this._fingerprint, e._eventProcessors = [...this._eventProcessors], e._requestSession = this._requestSession, e._attachments = [...this._attachments], e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, e._propagationContext = { ...this._propagationContext }, e._client = this._client, e._lastEventId = this._lastEventId, ol(e, Xd(this)), e;
  }
  /**
   * @inheritDoc
   */
  setClient(e) {
    this._client = e;
  }
  /**
   * @inheritDoc
   */
  setLastEventId(e) {
    this._lastEventId = e;
  }
  /**
   * @inheritDoc
   */
  getClient() {
    return this._client;
  }
  /**
   * @inheritDoc
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(e) {
    this._scopeListeners.push(e);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(e) {
    return this._eventProcessors.push(e), this;
  }
  /**
   * @inheritDoc
   */
  setUser(e) {
    return this._user = e || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    }, this._session && oa(this._session, { user: e }), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(e) {
    return this._requestSession = e, this;
  }
  /**
   * @inheritDoc
   */
  setTags(e) {
    return this._tags = {
      ...this._tags,
      ...e
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTag(e, n) {
    return this._tags = { ...this._tags, [e]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtras(e) {
    return this._extra = {
      ...this._extra,
      ...e
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtra(e, n) {
    return this._extra = { ...this._extra, [e]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(e) {
    return this._fingerprint = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setLevel(e) {
    return this._level = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTransactionName(e) {
    return this._transactionName = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setContext(e, n) {
    return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setSession(e) {
    return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(e) {
    if (!e)
      return this;
    const n = typeof e == "function" ? e(this) : e, [r, s] = n instanceof ii ? [n.getScopeData(), n.getRequestSession()] : ia(n) ? [e, e.requestSession] : [], { tags: i, extra: o, user: a, contexts: c, level: l, fingerprint: u = [], propagationContext: d } = r || {};
    return this._tags = { ...this._tags, ...i }, this._extra = { ...this._extra, ...o }, this._contexts = { ...this._contexts, ...c }, a && Object.keys(a).length && (this._user = a), l && (this._level = l), u.length && (this._fingerprint = u), d && (this._propagationContext = d), s && (this._requestSession = s), this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, ol(this, void 0), this._attachments = [], this._propagationContext = Qd(), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(e, n) {
    const r = typeof n == "number" ? n : DY;
    if (r <= 0)
      return this;
    const s = {
      timestamp: kl(),
      ...e
    }, i = this._breadcrumbs;
    return i.push(s), this._breadcrumbs = i.length > r ? i.slice(-r) : i, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(e) {
    return this._attachments.push(e), this;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    return this._attachments = [], this;
  }
  /** @inheritDoc */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: Xd(this)
    };
  }
  /**
   * @inheritDoc
   */
  setSDKProcessingMetadata(e) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...e }, this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(e) {
    return this._propagationContext = e, this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * @inheritDoc
   */
  captureException(e, n) {
    const r = n && n.event_id ? n.event_id : gt();
    if (!this._client)
      return H.warn("No client configured on scope - will not capture exception!"), r;
    const s = new Error("Sentry syntheticException");
    return this._client.captureException(
      e,
      {
        originalException: e,
        syntheticException: s,
        ...n,
        event_id: r
      },
      this
    ), r;
  }
  /**
   * @inheritDoc
   */
  captureMessage(e, n, r) {
    const s = r && r.event_id ? r.event_id : gt();
    if (!this._client)
      return H.warn("No client configured on scope - will not capture message!"), s;
    const i = new Error(e);
    return this._client.captureMessage(
      e,
      n,
      {
        originalException: e,
        syntheticException: i,
        ...r,
        event_id: s
      },
      this
    ), s;
  }
  /**
   * @inheritDoc
   */
  captureEvent(e, n) {
    const r = n && n.event_id ? n.event_id : gt();
    return this._client ? (this._client.captureEvent(e, { ...n, event_id: r }, this), r) : (H.warn("No client configured on scope - will not capture event!"), r);
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((e) => {
      e(this);
    }), this._notifyingListeners = !1);
  }
}
const ii = Db;
function OY() {
  return oh("defaultCurrentScope", () => new ii());
}
function qY() {
  return oh("defaultIsolationScope", () => new ii());
}
class NY {
  constructor(e, n) {
    let r;
    e ? r = e : r = new ii();
    let s;
    n ? s = n : s = new ii(), this._stack = [{ scope: r }], this._isolationScope = s;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(e) {
    const n = this._pushScope();
    let r;
    try {
      r = e(n);
    } catch (s) {
      throw this._popScope(), s;
    }
    return ih(r) ? r.then(
      (s) => (this._popScope(), s),
      (s) => {
        throw this._popScope(), s;
      }
    ) : (this._popScope(), r);
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const e = this.getScope().clone();
    return this._stack.push({
      client: this.getClient(),
      scope: e
    }), e;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop();
  }
}
function aa() {
  const t = Da(), e = Ib(t);
  return e.stack = e.stack || new NY(OY(), qY());
}
function LY(t) {
  return aa().withScope(t);
}
function jY(t, e) {
  const n = aa();
  return n.withScope(() => (n.getStackTop().scope = t, e(t)));
}
function qA(t) {
  return aa().withScope(() => t(aa().getIsolationScope()));
}
function BY() {
  return {
    withIsolationScope: qA,
    withScope: LY,
    withSetScope: jY,
    withSetIsolationScope: (t, e) => qA(e),
    getCurrentScope: () => aa().getScope(),
    getIsolationScope: () => aa().getIsolationScope()
  };
}
function Rl(t) {
  const e = Ib(t);
  return e.acs ? e.acs : BY();
}
function Fe() {
  const t = Da();
  return Rl(t).getCurrentScope();
}
function Ut() {
  const t = Da();
  return Rl(t).getIsolationScope();
}
function FY() {
  return oh("globalScope", () => new ii());
}
function Oa(...t) {
  const e = Da(), n = Rl(e);
  if (t.length === 2) {
    const [r, s] = t;
    return r ? n.withSetScope(r, s) : n.withScope(s);
  }
  return n.withScope(t[0]);
}
function ke() {
  return Fe().getClient();
}
const VY = "_sentryMetrics";
function og(t) {
  const e = t[VY];
  if (!e)
    return;
  const n = {};
  for (const [, [r, s]] of e)
    (n[r] || (n[r] = [])).push(Vt(s));
  return n;
}
const ns = "sentry.source", JR = "sentry.sample_rate", Xi = "sentry.op", Gt = "sentry.origin", ag = "sentry.idle_span_finish_reason", ah = "sentry.measurement_unit", ch = "sentry.measurement_value", UY = "sentry.profile_id", Ob = "sentry.exclusive_time", WY = 0, eM = 1, zt = 2;
function zY(t) {
  if (t < 400 && t >= 100)
    return { code: eM };
  if (t >= 400 && t < 500)
    switch (t) {
      case 401:
        return { code: zt, message: "unauthenticated" };
      case 403:
        return { code: zt, message: "permission_denied" };
      case 404:
        return { code: zt, message: "not_found" };
      case 409:
        return { code: zt, message: "already_exists" };
      case 413:
        return { code: zt, message: "failed_precondition" };
      case 429:
        return { code: zt, message: "resource_exhausted" };
      case 499:
        return { code: zt, message: "cancelled" };
      default:
        return { code: zt, message: "invalid_argument" };
    }
  if (t >= 500 && t < 600)
    switch (t) {
      case 501:
        return { code: zt, message: "unimplemented" };
      case 503:
        return { code: zt, message: "unavailable" };
      case 504:
        return { code: zt, message: "deadline_exceeded" };
      default:
        return { code: zt, message: "internal_error" };
    }
  return { code: zt, message: "unknown_error" };
}
function tM(t, e) {
  t.setAttribute("http.response.status_code", e);
  const n = zY(e);
  n.message !== "unknown_error" && t.setStatus(n);
}
const nM = 0, rM = 1;
function HY(t) {
  const { spanId: e, traceId: n } = t.spanContext(), { data: r, op: s, parent_span_id: i, status: o, origin: a } = Be(t);
  return Vt({
    parent_span_id: i,
    span_id: e,
    trace_id: n,
    data: r,
    op: s,
    status: o,
    origin: a
  });
}
function YY(t) {
  const { spanId: e, traceId: n } = t.spanContext(), { parent_span_id: r } = Be(t);
  return Vt({ parent_span_id: r, span_id: e, trace_id: n });
}
function sM(t) {
  const { traceId: e, spanId: n } = t.spanContext(), r = io(t);
  return Mb(e, n, r);
}
function ji(t) {
  return typeof t == "number" ? NA(t) : Array.isArray(t) ? t[0] + t[1] / 1e9 : t instanceof Date ? NA(t.getTime()) : gn();
}
function NA(t) {
  return t > 9999999999 ? t / 1e3 : t;
}
function Be(t) {
  if (KY(t))
    return t.getSpanJSON();
  try {
    const { spanId: e, traceId: n } = t.spanContext();
    if (GY(t)) {
      const { attributes: r, startTime: s, name: i, endTime: o, parentSpanId: a, status: c } = t;
      return Vt({
        span_id: e,
        trace_id: n,
        data: r,
        description: i,
        parent_span_id: a,
        start_timestamp: ji(s),
        // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
        timestamp: ji(o) || void 0,
        status: iM(c),
        op: r[Xi],
        origin: r[Gt],
        _metrics_summary: og(t)
      });
    }
    return {
      span_id: e,
      trace_id: n
    };
  } catch {
    return {};
  }
}
function GY(t) {
  const e = t;
  return !!e.attributes && !!e.startTime && !!e.name && !!e.endTime && !!e.status;
}
function KY(t) {
  return typeof t.getSpanJSON == "function";
}
function io(t) {
  const { traceFlags: e } = t.spanContext();
  return e === rM;
}
function iM(t) {
  if (!(!t || t.code === WY))
    return t.code === eM ? "ok" : t.message || "unknown_error";
}
const Bi = "_sentryChildSpans", cg = "_sentryRootSpan";
function oM(t, e) {
  const n = t[cg] || t;
  Jn(e, cg, n), t[Bi] ? t[Bi].add(e) : Jn(t, Bi, /* @__PURE__ */ new Set([e]));
}
function $Y(t, e) {
  t[Bi] && t[Bi].delete(e);
}
function sd(t) {
  const e = /* @__PURE__ */ new Set();
  function n(r) {
    if (!e.has(r) && io(r)) {
      e.add(r);
      const s = r[Bi] ? Array.from(r[Bi]) : [];
      for (const i of s)
        n(i);
    }
  }
  return n(t), Array.from(e);
}
function Xt(t) {
  return t[cg] || t;
}
function en() {
  const t = Da(), e = Rl(t);
  return e.getActiveSpan ? e.getActiveSpan() : Xd(Fe());
}
let LA = !1;
function ZY() {
  LA || (LA = !0, UR(lg), WR(lg));
}
function lg() {
  const t = en(), e = t && Xt(t);
  if (e) {
    const n = "internal_error";
    xe && H.log(`[Tracing] Root span: ${n} -> Global error occured`), e.setStatus({ code: zt, message: n });
  }
}
lg.tag = "sentry_tracingErrorCallback";
const aM = "_sentryScope", cM = "_sentryIsolationScope";
function QY(t, e, n) {
  t && (Jn(t, cM, n), Jn(t, aM, e));
}
function jA(t) {
  return {
    scope: t[aM],
    isolationScope: t[cM]
  };
}
function ys(t) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
    return !1;
  const e = ke(), n = t || e && e.getOptions();
  return !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n);
}
class qa {
  constructor(e = {}) {
    this._traceId = e.traceId || gt(), this._spanId = e.spanId || gt().substring(16);
  }
  /** @inheritdoc */
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: nM
    };
  }
  /** @inheritdoc */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  end(e) {
  }
  /** @inheritdoc */
  setAttribute(e, n) {
    return this;
  }
  /** @inheritdoc */
  setAttributes(e) {
    return this;
  }
  /** @inheritdoc */
  setStatus(e) {
    return this;
  }
  /** @inheritdoc */
  updateName(e) {
    return this;
  }
  /** @inheritdoc */
  isRecording() {
    return !1;
  }
  /** @inheritdoc */
  addEvent(e, n, r) {
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for being comliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLink(e) {
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for being comliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLinks(e) {
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for being comliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  recordException(e, n) {
  }
}
const qb = "production", lM = "_frozenDsc";
function BA(t, e) {
  Jn(t, lM, e);
}
function lh(t, e) {
  const n = e.getOptions(), { publicKey: r } = e.getDsn() || {}, s = Vt({
    environment: n.environment || qb,
    release: n.release,
    public_key: r,
    trace_id: t
  });
  return e.emit("createDsc", s), s;
}
function hi(t) {
  const e = ke();
  if (!e)
    return {};
  const n = lh(Be(t).trace_id || "", e), r = Xt(t), s = r[lM];
  if (s)
    return s;
  const i = r.spanContext().traceState, o = i && i.get("sentry.dsc"), a = o && KR(o);
  if (a)
    return a;
  const c = Be(r), l = c.data || {}, u = l[JR];
  u != null && (n.sample_rate = `${u}`);
  const d = l[ns], f = c.description;
  return d !== "url" && f && (n.transaction = f), ys() && (n.sampled = String(io(r))), e.emit("createDsc", n, r), n;
}
function XY(t) {
  if (!xe) return;
  const { description: e = "< unknown name >", op: n = "< unknown op >", parent_span_id: r } = Be(t), { spanId: s } = t.spanContext(), i = io(t), o = Xt(t), a = o === t, c = `[Tracing] Starting ${i ? "sampled" : "unsampled"} ${a ? "root " : ""}span`, l = [`op: ${n}`, `name: ${e}`, `ID: ${s}`];
  if (r && l.push(`parent ID: ${r}`), !a) {
    const { op: u, description: d } = Be(o);
    l.push(`root ID: ${o.spanContext().spanId}`), u && l.push(`root op: ${u}`), d && l.push(`root description: ${d}`);
  }
  H.log(`${c}
  ${l.join(`
  `)}`);
}
function JY(t) {
  if (!xe) return;
  const { description: e = "< unknown name >", op: n = "< unknown op >" } = Be(t), { spanId: r } = t.spanContext(), i = Xt(t) === t, o = `[Tracing] Finishing "${n}" ${i ? "root " : ""}span "${e}" with ID ${r}`;
  H.log(o);
}
function Jd(t) {
  if (typeof t == "boolean")
    return Number(t);
  const e = typeof t == "string" ? parseFloat(t) : t;
  if (typeof e != "number" || isNaN(e) || e < 0 || e > 1) {
    xe && H.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        t
      )} of type ${JSON.stringify(typeof t)}.`
    );
    return;
  }
  return e;
}
function eG(t, e) {
  if (!ys(t))
    return [!1];
  let n;
  typeof t.tracesSampler == "function" ? n = t.tracesSampler(e) : e.parentSampled !== void 0 ? n = e.parentSampled : typeof t.tracesSampleRate < "u" ? n = t.tracesSampleRate : n = 1;
  const r = Jd(n);
  return r === void 0 ? (xe && H.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]) : r ? Math.random() < r ? [!0, r] : (xe && H.log(
    `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
      n
    )})`
  ), [!1, r]) : (xe && H.log(
    `[Tracing] Discarding transaction because ${typeof t.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
  ), [!1, r]);
}
function tG(t, e) {
  return e && (t.sdk = t.sdk || {}, t.sdk.name = t.sdk.name || e.name, t.sdk.version = t.sdk.version || e.version, t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []], t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]), t;
}
function nG(t, e, n, r) {
  const s = Pb(n), i = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...s && { sdk: s },
    ...!!r && e && { dsn: Ia(e) }
  }, o = "aggregates" in t ? [{ type: "sessions" }, t] : [{ type: "session" }, t.toJSON()];
  return so(i, [o]);
}
function rG(t, e, n, r) {
  const s = Pb(n), i = t.type && t.type !== "replay_event" ? t.type : "event";
  tG(t, n && n.sdk);
  const o = ZR(t, s, r, e);
  return delete t.sdkProcessingMetadata, so(o, [[{ type: i }, t]]);
}
function sG(t, e) {
  function n(u) {
    return !!u.trace_id && !!u.public_key;
  }
  const r = hi(t[0]), s = e && e.getDsn(), i = e && e.getOptions().tunnel, o = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...n(r) && { trace: r },
    ...!!i && s && { dsn: Ia(s) }
  }, a = e && e.getOptions().beforeSendSpan, c = a ? (u) => a(Be(u)) : (u) => Be(u), l = [];
  for (const u of t) {
    const d = c(u);
    d && l.push(wY(d));
  }
  return so(o, l);
}
function iG(t, e, n, r = en()) {
  const s = r && Xt(r);
  s && s.addEvent(t, {
    [ch]: e,
    [ah]: n
  });
}
function FA(t) {
  if (!t || t.length === 0)
    return;
  const e = {};
  return t.forEach((n) => {
    const r = n.attributes || {}, s = r[ah], i = r[ch];
    typeof s == "string" && typeof i == "number" && (e[n.name] = { value: i, unit: s });
  }), e;
}
const VA = 1e3;
class Nb {
  /** Epoch timestamp in seconds when the span started. */
  /** Epoch timestamp in seconds when the span ended. */
  /** Internal keeper of the status */
  /** The timed events added to this span. */
  /** if true, treat span as a standalone span (not part of a transaction) */
  /**
   * You should never call the constructor manually, always use `Sentry.startSpan()`
   * or other span methods.
   * @internal
   * @hideconstructor
   * @hidden
   */
  constructor(e = {}) {
    this._traceId = e.traceId || gt(), this._spanId = e.spanId || gt().substring(16), this._startTime = e.startTimestamp || gn(), this._attributes = {}, this.setAttributes({
      [Gt]: "manual",
      [Xi]: e.op,
      ...e.attributes
    }), this._name = e.name, e.parentSpanId && (this._parentSpanId = e.parentSpanId), "sampled" in e && (this._sampled = e.sampled), e.endTimestamp && (this._endTime = e.endTimestamp), this._events = [], this._isStandaloneSpan = e.isStandalone, this._endTime && this._onSpanEnded();
  }
  /**
   * This should generally not be used,
   * but it is needed for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLink(e) {
    return this;
  }
  /**
   * This should generally not be used,
   * but it is needed for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLinks(e) {
    return this;
  }
  /**
   * This should generally not be used,
   * but it is needed for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  recordException(e, n) {
  }
  /** @inheritdoc */
  spanContext() {
    const { _spanId: e, _traceId: n, _sampled: r } = this;
    return {
      spanId: e,
      traceId: n,
      traceFlags: r ? rM : nM
    };
  }
  /** @inheritdoc */
  setAttribute(e, n) {
    return n === void 0 ? delete this._attributes[e] : this._attributes[e] = n, this;
  }
  /** @inheritdoc */
  setAttributes(e) {
    return Object.keys(e).forEach((n) => this.setAttribute(n, e[n])), this;
  }
  /**
   * This should generally not be used,
   * but we need it for browser tracing where we want to adjust the start time afterwards.
   * USE THIS WITH CAUTION!
   *
   * @hidden
   * @internal
   */
  updateStartTime(e) {
    this._startTime = ji(e);
  }
  /**
   * @inheritDoc
   */
  setStatus(e) {
    return this._status = e, this;
  }
  /**
   * @inheritDoc
   */
  updateName(e) {
    return this._name = e, this;
  }
  /** @inheritdoc */
  end(e) {
    this._endTime || (this._endTime = ji(e), JY(this), this._onSpanEnded());
  }
  /**
   * Get JSON representation of this span.
   *
   * @hidden
   * @internal This method is purely for internal purposes and should not be used outside
   * of SDK code. If you need to get a JSON representation of a span,
   * use `spanToJSON(span)` instead.
   */
  getSpanJSON() {
    return Vt({
      data: this._attributes,
      description: this._name,
      op: this._attributes[Xi],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: iM(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[Gt],
      _metrics_summary: og(this),
      profile_id: this._attributes[UY],
      exclusive_time: this._attributes[Ob],
      measurements: FA(this._events),
      is_segment: this._isStandaloneSpan && Xt(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? Xt(this).spanContext().spanId : void 0
    });
  }
  /** @inheritdoc */
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  /**
   * @inheritdoc
   */
  addEvent(e, n, r) {
    xe && H.log("[Tracing] Adding an event to span:", e);
    const s = UA(n) ? n : r || gn(), i = UA(n) ? {} : n || {}, o = {
      name: e,
      time: ji(s),
      attributes: i
    };
    return this._events.push(o), this;
  }
  /**
   * This method should generally not be used,
   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.
   * USE THIS WITH CAUTION!
   * @internal
   * @hidden
   * @experimental
   */
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  /** Emit `spanEnd` when the span is ended. */
  _onSpanEnded() {
    const e = ke();
    if (e && e.emit("spanEnd", this), !(this._isStandaloneSpan || this === Xt(this)))
      return;
    if (this._isStandaloneSpan) {
      this._sampled ? aG(sG([this], e)) : (xe && H.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."), e && e.recordDroppedEvent("sample_rate", "span"));
      return;
    }
    const r = this._convertSpanToTransaction();
    r && (jA(this).scope || Fe()).captureEvent(r);
  }
  /**
   * Finish the transaction & prepare the event to send to Sentry.
   */
  _convertSpanToTransaction() {
    if (!WA(Be(this)))
      return;
    this._name || (xe && H.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
    const { scope: e, isolationScope: n } = jA(this), s = (e || Fe()).getClient() || ke();
    if (this._sampled !== !0) {
      xe && H.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), s && s.recordDroppedEvent("sample_rate", "transaction");
      return;
    }
    const o = sd(this).filter((d) => d !== this && !oG(d)).map((d) => Be(d)).filter(WA), a = this._attributes[ns], c = {
      contexts: {
        trace: HY(this)
      },
      spans: (
        // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here
        // we do not use spans anymore after this point
        o.length > VA ? o.sort((d, f) => d.start_timestamp - f.start_timestamp).slice(0, VA) : o
      ),
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope: e,
        capturedSpanIsolationScope: n,
        ...Vt({
          dynamicSamplingContext: hi(this)
        })
      },
      _metrics_summary: og(this),
      ...a && {
        transaction_info: {
          source: a
        }
      }
    }, l = FA(this._events);
    return l && Object.keys(l).length && (xe && H.log(
      "[Measurements] Adding measurements to transaction event",
      JSON.stringify(l, void 0, 2)
    ), c.measurements = l), c;
  }
}
function UA(t) {
  return t && typeof t == "number" || t instanceof Date || Array.isArray(t);
}
function WA(t) {
  return !!t.start_timestamp && !!t.timestamp && !!t.span_id && !!t.trace_id;
}
function oG(t) {
  return t instanceof Nb && t.isStandaloneSpan();
}
function aG(t) {
  const e = ke();
  if (!e)
    return;
  const n = t[1];
  if (!n || n.length === 0) {
    e.recordDroppedEvent("before_send", "span");
    return;
  }
  const r = e.getTransport();
  r && r.send(t).then(null, (s) => {
    xe && H.error("Error while sending span:", s);
  });
}
const uM = "__SENTRY_SUPPRESS_TRACING__";
function pi(t) {
  const e = fM();
  if (e.startInactiveSpan)
    return e.startInactiveSpan(t);
  const n = lG(t), { forceTransaction: r, parentSpan: s } = t;
  return (t.scope ? (o) => Oa(t.scope, o) : s !== void 0 ? (o) => dM(s, o) : (o) => o())(() => {
    const o = Fe(), a = dG(o);
    return t.onlyIfParent && !a ? new qa() : cG({
      parentSpan: a,
      spanArguments: n,
      forceTransaction: r,
      scope: o
    });
  });
}
function dM(t, e) {
  const n = fM();
  return n.withActiveSpan ? n.withActiveSpan(t, e) : Oa((r) => (ol(r, t || void 0), e(r)));
}
function cG({
  parentSpan: t,
  spanArguments: e,
  forceTransaction: n,
  scope: r
}) {
  if (!ys())
    return new qa();
  const s = Ut();
  let i;
  if (t && !n)
    i = uG(t, r, e), oM(t, i);
  else if (t) {
    const o = hi(t), { traceId: a, spanId: c } = t.spanContext(), l = io(t);
    i = zA(
      {
        traceId: a,
        parentSpanId: c,
        ...e
      },
      r,
      l
    ), BA(i, o);
  } else {
    const {
      traceId: o,
      dsc: a,
      parentSpanId: c,
      sampled: l
    } = {
      ...s.getPropagationContext(),
      ...r.getPropagationContext()
    };
    i = zA(
      {
        traceId: o,
        parentSpanId: c,
        ...e
      },
      r,
      l
    ), a && BA(i, a);
  }
  return XY(i), QY(i, r, s), i;
}
function lG(t) {
  const n = {
    isStandalone: (t.experimental || {}).standalone,
    ...t
  };
  if (t.startTime) {
    const r = { ...n };
    return r.startTimestamp = ji(t.startTime), delete r.startTime, r;
  }
  return n;
}
function fM() {
  const t = Da();
  return Rl(t);
}
function zA(t, e, n) {
  const r = ke(), s = r && r.getOptions() || {}, { name: i = "", attributes: o } = t, [a, c] = e.getScopeData().sdkProcessingMetadata[uM] ? [!1] : eG(s, {
    name: i,
    parentSampled: n,
    attributes: o,
    transactionContext: {
      name: i,
      parentSampled: n
    }
  }), l = new Nb({
    ...t,
    attributes: {
      [ns]: "custom",
      ...t.attributes
    },
    sampled: a
  });
  return c !== void 0 && l.setAttribute(JR, c), r && r.emit("spanStart", l), l;
}
function uG(t, e, n) {
  const { spanId: r, traceId: s } = t.spanContext(), i = e.getScopeData().sdkProcessingMetadata[uM] ? !1 : io(t), o = i ? new Nb({
    ...n,
    parentSpanId: r,
    traceId: s,
    sampled: i
  }) : new qa({ traceId: s });
  oM(t, o);
  const a = ke();
  return a && (a.emit("spanStart", o), n.endTimestamp && a.emit("spanEnd", o)), o;
}
function dG(t) {
  const e = Xd(t);
  if (!e)
    return;
  const n = ke();
  return (n ? n.getOptions() : {}).parentSpanIsAlwaysRootSpan ? Xt(e) : e;
}
const id = {
  idleTimeout: 1e3,
  finalTimeout: 3e4,
  childSpanTimeout: 15e3
}, fG = "heartbeatFailed", hG = "idleTimeout", pG = "finalTimeout", mG = "externalFinish";
function hM(t, e = {}) {
  const n = /* @__PURE__ */ new Map();
  let r = !1, s, i = mG, o = !e.disableAutoFinish;
  const a = [], {
    idleTimeout: c = id.idleTimeout,
    finalTimeout: l = id.finalTimeout,
    childSpanTimeout: u = id.childSpanTimeout,
    beforeSpanEnd: d
  } = e, f = ke();
  if (!f || !ys())
    return new qa();
  const h = Fe(), p = en(), m = gG(t);
  m.end = new Proxy(m.end, {
    apply(C, S, _) {
      d && d(m);
      const [T, ...k] = _, R = T || gn(), P = ji(R), M = sd(m).filter((N) => N !== m);
      if (!M.length)
        return A(P), Reflect.apply(C, S, [P, ...k]);
      const D = M.map((N) => Be(N).timestamp).filter((N) => !!N), O = D.length ? Math.max(...D) : void 0, q = Be(m).start_timestamp, L = Math.min(
        q ? q + l / 1e3 : 1 / 0,
        Math.max(q || -1 / 0, Math.min(P, O || 1 / 0))
      );
      return A(L), Reflect.apply(C, S, [L, ...k]);
    }
  });
  function y() {
    s && (clearTimeout(s), s = void 0);
  }
  function b(C) {
    y(), s = setTimeout(() => {
      !r && n.size === 0 && o && (i = hG, m.end(C));
    }, c);
  }
  function v(C) {
    s = setTimeout(() => {
      !r && o && (i = fG, m.end(C));
    }, u);
  }
  function w(C) {
    y(), n.set(C, !0);
    const S = gn();
    v(S + u / 1e3);
  }
  function x(C) {
    if (n.has(C) && n.delete(C), n.size === 0) {
      const S = gn();
      b(S + c / 1e3);
    }
  }
  function A(C) {
    r = !0, n.clear(), a.forEach((P) => P()), ol(h, p);
    const S = Be(m), { start_timestamp: _ } = S;
    if (!_)
      return;
    (S.data || {})[ag] || m.setAttribute(ag, i), H.log(`[Tracing] Idle span "${S.op}" finished`);
    const k = sd(m).filter((P) => P !== m);
    let R = 0;
    k.forEach((P) => {
      P.isRecording() && (P.setStatus({ code: zt, message: "cancelled" }), P.end(C), xe && H.log("[Tracing] Cancelling span since span ended early", JSON.stringify(P, void 0, 2)));
      const M = Be(P), { timestamp: D = 0, start_timestamp: O = 0 } = M, q = O <= C, L = (l + c) / 1e3, N = D - O <= L;
      if (xe) {
        const j = JSON.stringify(P, void 0, 2);
        q ? N || H.log("[Tracing] Discarding span since it finished after idle span final timeout", j) : H.log("[Tracing] Discarding span since it happened after idle span was finished", j);
      }
      (!N || !q) && ($Y(m, P), R++);
    }), R > 0 && m.setAttribute("sentry.idle_span_discarded_spans", R);
  }
  return a.push(
    f.on("spanStart", (C) => {
      if (r || C === m || Be(C).timestamp)
        return;
      sd(m).includes(C) && w(C.spanContext().spanId);
    })
  ), a.push(
    f.on("spanEnd", (C) => {
      r || x(C.spanContext().spanId);
    })
  ), a.push(
    f.on("idleSpanEnableAutoFinish", (C) => {
      C === m && (o = !0, b(), n.size && v());
    })
  ), e.disableAutoFinish || b(), setTimeout(() => {
    r || (m.setStatus({ code: zt, message: "deadline_exceeded" }), i = pG, m.end());
  }, l), m;
}
function gG(t) {
  const e = pi(t);
  return ol(Fe(), e), xe && H.log("[Tracing] Started span is an idle span"), e;
}
function ug(t, e, n, r = 0) {
  return new Qn((s, i) => {
    const o = t[r];
    if (e === null || typeof o != "function")
      s(e);
    else {
      const a = o({ ...e }, n);
      xe && o.id && a === null && H.log(`Event processor "${o.id}" dropped event`), ih(a) ? a.then((c) => ug(t, c, n, r + 1).then(s)).then(null, i) : ug(t, a, n, r + 1).then(s).then(null, i);
    }
  });
}
function yG(t, e) {
  const { fingerprint: n, span: r, breadcrumbs: s, sdkProcessingMetadata: i } = e;
  bG(t, e), r && wG(t, r), AG(t, n), vG(t, s), xG(t, i);
}
function HA(t, e) {
  const {
    extra: n,
    tags: r,
    user: s,
    contexts: i,
    level: o,
    sdkProcessingMetadata: a,
    breadcrumbs: c,
    fingerprint: l,
    eventProcessors: u,
    attachments: d,
    propagationContext: f,
    transactionName: h,
    span: p
  } = e;
  ec(t, "extra", n), ec(t, "tags", r), ec(t, "user", s), ec(t, "contexts", i), ec(t, "sdkProcessingMetadata", a), o && (t.level = o), h && (t.transactionName = h), p && (t.span = p), c.length && (t.breadcrumbs = [...t.breadcrumbs, ...c]), l.length && (t.fingerprint = [...t.fingerprint, ...l]), u.length && (t.eventProcessors = [...t.eventProcessors, ...u]), d.length && (t.attachments = [...t.attachments, ...d]), t.propagationContext = { ...t.propagationContext, ...f };
}
function ec(t, e, n) {
  if (n && Object.keys(n).length) {
    t[e] = { ...t[e] };
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[e][r] = n[r]);
  }
}
function bG(t, e) {
  const { extra: n, tags: r, user: s, contexts: i, level: o, transactionName: a } = e, c = Vt(n);
  c && Object.keys(c).length && (t.extra = { ...c, ...t.extra });
  const l = Vt(r);
  l && Object.keys(l).length && (t.tags = { ...l, ...t.tags });
  const u = Vt(s);
  u && Object.keys(u).length && (t.user = { ...u, ...t.user });
  const d = Vt(i);
  d && Object.keys(d).length && (t.contexts = { ...d, ...t.contexts }), o && (t.level = o), a && t.type !== "transaction" && (t.transaction = a);
}
function vG(t, e) {
  const n = [...t.breadcrumbs || [], ...e];
  t.breadcrumbs = n.length ? n : void 0;
}
function xG(t, e) {
  t.sdkProcessingMetadata = {
    ...t.sdkProcessingMetadata,
    ...e
  };
}
function wG(t, e) {
  t.contexts = {
    trace: YY(e),
    ...t.contexts
  }, t.sdkProcessingMetadata = {
    dynamicSamplingContext: hi(e),
    ...t.sdkProcessingMetadata
  };
  const n = Xt(e), r = Be(n).description;
  r && !t.transaction && t.type === "transaction" && (t.transaction = r);
}
function AG(t, e) {
  t.fingerprint = t.fingerprint ? HR(t.fingerprint) : [], e && (t.fingerprint = t.fingerprint.concat(e)), t.fingerprint && !t.fingerprint.length && delete t.fingerprint;
}
function pM(t, e, n, r, s, i) {
  const { normalizeDepth: o = 3, normalizeMaxBreadth: a = 1e3 } = t, c = {
    ...e,
    event_id: e.event_id || n.event_id || gt(),
    timestamp: e.timestamp || kl()
  }, l = n.integrations || t.integrations.map((y) => y.name);
  SG(c, t), _G(c, l), s && s.emit("applyFrameMetadata", e), e.type === void 0 && EG(c, t.stackParser);
  const u = kG(r, n.captureContext);
  n.mechanism && il(c, n.mechanism);
  const d = s ? s.getEventProcessors() : [], f = FY().getScopeData();
  if (i) {
    const y = i.getScopeData();
    HA(f, y);
  }
  if (u) {
    const y = u.getScopeData();
    HA(f, y);
  }
  const h = [...n.attachments || [], ...f.attachments];
  h.length && (n.attachments = h), yG(c, f);
  const p = [
    ...d,
    // Run scope event processors _after_ all other processors
    ...f.eventProcessors
  ];
  return ug(p, c, n).then((y) => (y && CG(y), typeof o == "number" && o > 0 ? TG(y, o, a) : y));
}
function SG(t, e) {
  const { environment: n, release: r, dist: s, maxValueLength: i = 250 } = e;
  "environment" in t || (t.environment = "environment" in e ? n : qb), t.release === void 0 && r !== void 0 && (t.release = r), t.dist === void 0 && s !== void 0 && (t.dist = s), t.message && (t.message = Uo(t.message, i));
  const o = t.exception && t.exception.values && t.exception.values[0];
  o && o.value && (o.value = Uo(o.value, i));
  const a = t.request;
  a && a.url && (a.url = Uo(a.url, i));
}
const YA = /* @__PURE__ */ new WeakMap();
function EG(t, e) {
  const n = Oe._sentryDebugIds;
  if (!n)
    return;
  let r;
  const s = YA.get(e);
  s ? r = s : (r = /* @__PURE__ */ new Map(), YA.set(e, r));
  const i = Object.entries(n).reduce(
    (o, [a, c]) => {
      let l;
      const u = r.get(a);
      u ? l = u : (l = e(a), r.set(a, l));
      for (let d = l.length - 1; d >= 0; d--) {
        const f = l[d];
        if (f.filename) {
          o[f.filename] = c;
          break;
        }
      }
      return o;
    },
    {}
  );
  try {
    t.exception.values.forEach((o) => {
      o.stacktrace.frames.forEach((a) => {
        a.filename && (a.debug_id = i[a.filename]);
      });
    });
  } catch {
  }
}
function CG(t) {
  const e = {};
  try {
    t.exception.values.forEach((r) => {
      r.stacktrace.frames.forEach((s) => {
        s.debug_id && (s.abs_path ? e[s.abs_path] = s.debug_id : s.filename && (e[s.filename] = s.debug_id), delete s.debug_id);
      });
    });
  } catch {
  }
  if (Object.keys(e).length === 0)
    return;
  t.debug_meta = t.debug_meta || {}, t.debug_meta.images = t.debug_meta.images || [];
  const n = t.debug_meta.images;
  Object.entries(e).forEach(([r, s]) => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: s
    });
  });
}
function _G(t, e) {
  e.length > 0 && (t.sdk = t.sdk || {}, t.sdk.integrations = [...t.sdk.integrations || [], ...e]);
}
function TG(t, e, n) {
  if (!t)
    return null;
  const r = {
    ...t,
    ...t.breadcrumbs && {
      breadcrumbs: t.breadcrumbs.map((s) => ({
        ...s,
        ...s.data && {
          data: xr(s.data, e, n)
        }
      }))
    },
    ...t.user && {
      user: xr(t.user, e, n)
    },
    ...t.contexts && {
      contexts: xr(t.contexts, e, n)
    },
    ...t.extra && {
      extra: xr(t.extra, e, n)
    }
  };
  return t.contexts && t.contexts.trace && r.contexts && (r.contexts.trace = t.contexts.trace, t.contexts.trace.data && (r.contexts.trace.data = xr(t.contexts.trace.data, e, n))), t.spans && (r.spans = t.spans.map((s) => ({
    ...s,
    ...s.data && {
      data: xr(s.data, e, n)
    }
  }))), r;
}
function kG(t, e) {
  if (!e)
    return t;
  const n = t ? t.clone() : new ii();
  return n.update(e), n;
}
function RG(t) {
  if (t)
    return MG(t) ? { captureContext: t } : IG(t) ? {
      captureContext: t
    } : t;
}
function MG(t) {
  return t instanceof ii || typeof t == "function";
}
const PG = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function IG(t) {
  return Object.keys(t).some((e) => PG.includes(e));
}
function uh(t, e) {
  return Fe().captureException(t, RG(e));
}
function DG(t, e) {
  const r = { captureContext: e };
  return Fe().captureMessage(t, void 0, r);
}
function Lb(t, e) {
  return Fe().captureEvent(t, e);
}
function jb(t, e) {
  Ut().setContext(t, e);
}
function OG(t) {
  Ut().setExtras(t);
}
function qG(t, e) {
  Ut().setExtra(t, e);
}
function NG(t) {
  Ut().setTags(t);
}
function LG(t, e) {
  Ut().setTag(t, e);
}
function jG(t) {
  Ut().setUser(t);
}
function BG() {
  return Ut().lastEventId();
}
function FG(t) {
  Ut().addEventProcessor(t);
}
function dg(t) {
  const e = ke(), n = Ut(), r = Fe(), { release: s, environment: i = qb } = e && e.getOptions() || {}, { userAgent: o } = Oe.navigator || {}, a = MY({
    release: s,
    environment: i,
    user: r.getUser() || n.getUser(),
    ...o && { userAgent: o },
    ...t
  }), c = n.getSession();
  return c && c.status === "ok" && oa(c, { status: "exited" }), ef(), n.setSession(a), r.setSession(a), a;
}
function ef() {
  const t = Ut(), e = Fe(), n = e.getSession() || t.getSession();
  n && PY(n), mM(), t.setSession(), e.setSession();
}
function mM() {
  const t = Ut(), e = Fe(), n = ke(), r = e.getSession() || t.getSession();
  r && n && n.captureSession(r);
}
function GA(t = !1) {
  if (t) {
    ef();
    return;
  }
  mM();
}
const VG = "7";
function gM(t) {
  const e = t.protocol ? `${t.protocol}:` : "", n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`;
}
function UG(t) {
  return `${gM(t)}${t.projectId}/envelope/`;
}
function WG(t, e) {
  return B8({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: t.publicKey,
    sentry_version: VG,
    ...e && { sentry_client: `${e.name}/${e.version}` }
  });
}
function zG(t, e, n) {
  return e || `${UG(t)}?${WG(t, n)}`;
}
function HG(t, e) {
  const n = DR(t);
  if (!n)
    return "";
  const r = `${gM(n)}embed/error-page/`;
  let s = `dsn=${Ia(n)}`;
  for (const i in e)
    if (i !== "dsn" && i !== "onClose")
      if (i === "user") {
        const o = e.user;
        if (!o)
          continue;
        o.name && (s += `&name=${encodeURIComponent(o.name)}`), o.email && (s += `&email=${encodeURIComponent(o.email)}`);
      } else
        s += `&${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`;
  return `${r}?${s}`;
}
const KA = [];
function YG(t) {
  const e = {};
  return t.forEach((n) => {
    const { name: r } = n, s = e[r];
    s && !s.isDefaultInstance && n.isDefaultInstance || (e[r] = n);
  }), Object.values(e);
}
function GG(t) {
  const e = t.defaultIntegrations || [], n = t.integrations;
  e.forEach((o) => {
    o.isDefaultInstance = !0;
  });
  let r;
  Array.isArray(n) ? r = [...e, ...n] : typeof n == "function" ? r = HR(n(e)) : r = e;
  const s = YG(r), i = s.findIndex((o) => o.name === "Debug");
  if (i > -1) {
    const [o] = s.splice(i, 1);
    s.push(o);
  }
  return s;
}
function KG(t, e) {
  const n = {};
  return e.forEach((r) => {
    r && yM(t, r, n);
  }), n;
}
function $A(t, e) {
  for (const n of e)
    n && n.afterAllSetup && n.afterAllSetup(t);
}
function yM(t, e, n) {
  if (n[e.name]) {
    xe && H.log(`Integration skipped because it was already installed: ${e.name}`);
    return;
  }
  if (n[e.name] = e, KA.indexOf(e.name) === -1 && typeof e.setupOnce == "function" && (e.setupOnce(), KA.push(e.name)), e.setup && typeof e.setup == "function" && e.setup(t), typeof e.preprocessEvent == "function") {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (s, i) => r(s, i, t));
  }
  if (typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e), s = Object.assign((i, o) => r(i, o, t), {
      id: e.name
    });
    t.addEventProcessor(s);
  }
  xe && H.log(`Integration installed: ${e.name}`);
}
const ZA = "Not capturing exception because it's already been captured.";
class $G {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(e) {
    if (this._options = e, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e.dsn ? this._dsn = DR(e.dsn) : xe && H.warn("No DSN provided, client will not send events."), this._dsn) {
      const n = zG(
        this._dsn,
        e.tunnel,
        e._metadata ? e._metadata.sdk : void 0
      );
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: n
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  captureException(e, n, r) {
    const s = gt();
    if (PA(e))
      return xe && H.log(ZA), s;
    const i = {
      event_id: s,
      ...n
    };
    return this._process(
      this.eventFromException(e, i).then(
        (o) => this._captureEvent(o, i, r)
      )
    ), i.event_id;
  }
  /**
   * @inheritDoc
   */
  captureMessage(e, n, r, s) {
    const i = {
      event_id: gt(),
      ...r
    }, o = _b(e) ? e : String(e), a = Tb(e) ? this.eventFromMessage(o, n, i) : this.eventFromException(e, i);
    return this._process(a.then((c) => this._captureEvent(c, i, s))), i.event_id;
  }
  /**
   * @inheritDoc
   */
  captureEvent(e, n, r) {
    const s = gt();
    if (n && n.originalException && PA(n.originalException))
      return xe && H.log(ZA), s;
    const i = {
      event_id: s,
      ...n
    }, a = (e.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(e, i, a || r)), i.event_id;
  }
  /**
   * @inheritDoc
   */
  captureSession(e) {
    typeof e.release != "string" ? xe && H.warn("Discarded session because of missing or non-string release") : (this.sendSession(e), oa(e, { init: !1 }));
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata in @sentry/types
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(e) {
    const n = this._transport;
    return n ? (this.emit("flush"), this._isClientDoneProcessing(e).then((r) => n.flush(e).then((s) => r && s))) : gs(!0);
  }
  /**
   * @inheritDoc
   */
  close(e) {
    return this.flush(e).then((n) => (this.getOptions().enabled = !1, this.emit("close"), n));
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(e) {
    this._eventProcessors.push(e);
  }
  /** @inheritdoc */
  init() {
    (this._isEnabled() || // Force integrations to be setup even if no DSN was set when we have
    // Spotlight enabled. This is particularly important for browser as we
    // don't support the `spotlight` option there and rely on the users
    // adding the `spotlightBrowserIntegration()` to their integrations which
    // wouldn't get initialized with the check below when there's no DSN set.
    this._options.integrations.some(({ name: e }) => e.startsWith("Spotlight"))) && this._setupIntegrations();
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(e) {
    return this._integrations[e];
  }
  /**
   * @inheritDoc
   */
  addIntegration(e) {
    const n = this._integrations[e.name];
    yM(this, e, this._integrations), n || $A(this, [e]);
  }
  /**
   * @inheritDoc
   */
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = rG(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const i of n.attachments || [])
      r = bY(r, AY(i));
    const s = this.sendEnvelope(r);
    s && s.then((i) => this.emit("afterSendEvent", e, i), null);
  }
  /**
   * @inheritDoc
   */
  sendSession(e) {
    const n = nG(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(e, n, r) {
    if (this._options.sendClientReports) {
      const s = typeof r == "number" ? r : 1, i = `${e}:${n}`;
      xe && H.log(`Recording outcome: "${i}"${s > 1 ? ` (${s} times)` : ""}`), this._outcomes[i] = (this._outcomes[i] || 0) + s;
    }
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(e, n) {
    const r = this._hooks[e] = this._hooks[e] || [];
    return r.push(n), () => {
      const s = r.indexOf(n);
      s > -1 && r.splice(s, 1);
    };
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(e, ...n) {
    const r = this._hooks[e];
    r && r.forEach((s) => s(...n));
  }
  /**
   * @inheritdoc
   */
  sendEnvelope(e) {
    return this.emit("beforeEnvelope", e), this._isEnabled() && this._transport ? this._transport.send(e).then(null, (n) => (xe && H.error("Error while sending event:", n), n)) : (xe && H.error("Transport disabled"), gs({}));
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations: e } = this._options;
    this._integrations = KG(this, e), $A(this, e);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(e, n) {
    let r = !1, s = !1;
    const i = n.exception && n.exception.values;
    if (i) {
      s = !0;
      for (const c of i) {
        const l = c.mechanism;
        if (l && l.handled === !1) {
          r = !0;
          break;
        }
      }
    }
    const o = e.status === "ok";
    (o && e.errors === 0 || o && r) && (oa(e, {
      ...r && { status: "crashed" },
      errors: e.errors || Number(s || r)
    }), this.captureSession(e));
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(e) {
    return new Qn((n) => {
      let r = 0;
      const s = 1, i = setInterval(() => {
        this._numProcessing == 0 ? (clearInterval(i), n(!0)) : (r += s, e && r >= e && (clearInterval(i), n(!1)));
      }, s);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(e, n, r, s = Ut()) {
    const i = this.getOptions(), o = Object.keys(this._integrations);
    return !n.integrations && o.length > 0 && (n.integrations = o), this.emit("preprocessEvent", e, n), e.type || s.setLastEventId(e.event_id || n.event_id), pM(i, e, n, r, this, s).then((a) => {
      if (a === null)
        return a;
      const c = {
        ...s.getPropagationContext(),
        ...r ? r.getPropagationContext() : void 0
      };
      if (!(a.contexts && a.contexts.trace) && c) {
        const { traceId: u, spanId: d, parentSpanId: f, dsc: h } = c;
        a.contexts = {
          trace: Vt({
            trace_id: u,
            span_id: d,
            parent_span_id: f
          }),
          ...a.contexts
        };
        const p = h || lh(u, this);
        a.sdkProcessingMetadata = {
          dynamicSamplingContext: p,
          ...a.sdkProcessingMetadata
        };
      }
      return a;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(e, n = {}, r) {
    return this._processEvent(e, n, r).then(
      (s) => s.event_id,
      (s) => {
        if (xe) {
          const i = s;
          i.logLevel === "log" ? H.log(i.message) : H.warn(i);
        }
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(e, n, r) {
    const s = this.getOptions(), { sampleRate: i } = s, o = vM(e), a = bM(e), c = e.type || "error", l = `before send for type \`${c}\``, u = typeof i > "u" ? void 0 : Jd(i);
    if (a && typeof u == "number" && Math.random() > u)
      return this.recordDroppedEvent("sample_rate", "error", e), Zd(
        new Ar(
          `Discarding event because it's not included in the random sample (sampling rate = ${i})`,
          "log"
        )
      );
    const d = c === "replay_event" ? "replay" : c, h = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(e, n, r, h).then((p) => {
      if (p === null)
        throw this.recordDroppedEvent("event_processor", d, e), new Ar("An event processor returned `null`, will not send event.", "log");
      if (n.data && n.data.__sentry__ === !0)
        return p;
      const y = QG(this, s, p, n);
      return ZG(y, l);
    }).then((p) => {
      if (p === null) {
        if (this.recordDroppedEvent("before_send", d, e), o) {
          const v = 1 + (e.spans || []).length;
          this.recordDroppedEvent("before_send", "span", v);
        }
        throw new Ar(`${l} returned \`null\`, will not send event.`, "log");
      }
      const m = r && r.getSession();
      if (!o && m && this._updateSessionFromEvent(m, p), o) {
        const b = p.sdkProcessingMetadata && p.sdkProcessingMetadata.spanCountBeforeProcessing || 0, v = p.spans ? p.spans.length : 0, w = b - v;
        w > 0 && this.recordDroppedEvent("before_send", "span", w);
      }
      const y = p.transaction_info;
      if (o && y && p.transaction !== e.transaction) {
        const b = "custom";
        p.transaction_info = {
          ...y,
          source: b
        };
      }
      return this.sendEvent(p, n), p;
    }).then(null, (p) => {
      throw p instanceof Ar ? p : (this.captureException(p, {
        data: {
          __sentry__: !0
        },
        originalException: p
      }), new Ar(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${p}`
      ));
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(e) {
    this._numProcessing++, e.then(
      (n) => (this._numProcessing--, n),
      (n) => (this._numProcessing--, n)
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const e = this._outcomes;
    return this._outcomes = {}, Object.entries(e).map(([n, r]) => {
      const [s, i] = n.split(":");
      return {
        reason: s,
        category: i,
        quantity: r
      };
    });
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    xe && H.log("Flushing outcomes...");
    const e = this._clearOutcomes();
    if (e.length === 0) {
      xe && H.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      xe && H.log("No dsn provided, will not send outcomes");
      return;
    }
    xe && H.log("Sending outcomes:", e);
    const n = EY(e, this._options.tunnel && Ia(this._dsn));
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
}
function ZG(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (ih(t))
    return t.then(
      (r) => {
        if (!ia(r) && r !== null)
          throw new Ar(n);
        return r;
      },
      (r) => {
        throw new Ar(`${e} rejected with ${r}`);
      }
    );
  if (!ia(t) && t !== null)
    throw new Ar(n);
  return t;
}
function QG(t, e, n, r) {
  const { beforeSend: s, beforeSendTransaction: i, beforeSendSpan: o } = e;
  if (bM(n) && s)
    return s(n, r);
  if (vM(n)) {
    if (n.spans && o) {
      const a = [];
      for (const c of n.spans) {
        const l = o(c);
        l ? a.push(l) : t.recordDroppedEvent("before_send", "span");
      }
      n.spans = a;
    }
    if (i) {
      if (n.spans) {
        const a = n.spans.length;
        n.sdkProcessingMetadata = {
          ...n.sdkProcessingMetadata,
          spanCountBeforeProcessing: a
        };
      }
      return i(n, r);
    }
  }
  return n;
}
function bM(t) {
  return t.type === void 0;
}
function vM(t) {
  return t.type === "transaction";
}
function XG(t, e) {
  e.debug === !0 && (xe ? H.enable() : Pa(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
  })), Fe().update(e.initialScope);
  const r = new t(e);
  return JG(r), r.init(), r;
}
function JG(t) {
  Fe().setClient(t);
}
const eK = 64;
function tK(t, e, n = lY(
  t.bufferSize || eK
)) {
  let r = {};
  const s = (o) => n.drain(o);
  function i(o) {
    const a = [];
    if (DA(o, (d, f) => {
      const h = OA(f);
      if (QR(r, h)) {
        const p = QA(d, f);
        t.recordDroppedEvent("ratelimit_backoff", h, p);
      } else
        a.push(d);
    }), a.length === 0)
      return gs({});
    const c = so(o[0], a), l = (d) => {
      DA(c, (f, h) => {
        const p = QA(f, h);
        t.recordDroppedEvent(d, OA(h), p);
      });
    }, u = () => e({ body: vY(c) }).then(
      (d) => (d.statusCode !== void 0 && (d.statusCode < 200 || d.statusCode >= 300) && xe && H.warn(`Sentry responded with status code ${d.statusCode} to sent event.`), r = XR(r, d), d),
      (d) => {
        throw l("network_error"), d;
      }
    );
    return n.add(u).then(
      (d) => d,
      (d) => {
        if (d instanceof Ar)
          return xe && H.error("Skipped sending event because buffer is full."), l("queue_overflow"), gs({});
        throw d;
      }
    );
  }
  return {
    send: i,
    flush: s
  };
}
function QA(t, e) {
  if (!(e !== "event" && e !== "transaction"))
    return Array.isArray(t) ? t[1] : void 0;
}
function nK(t, e) {
  const n = e && e.getDsn(), r = e && e.getOptions().tunnel;
  return sK(t, n) || rK(t, r);
}
function rK(t, e) {
  return e ? XA(t) === XA(e) : !1;
}
function sK(t, e) {
  return e ? t.includes(e.host) : !1;
}
function XA(t) {
  return t[t.length - 1] === "/" ? t.slice(0, -1) : t;
}
function xM(t, e, n = [e], r = "npm") {
  const s = t._metadata || {};
  s.sdk || (s.sdk = {
    name: `sentry.javascript.${e}`,
    packages: n.map((i) => ({
      name: `${r}:@sentry/${i}`,
      version: Ni
    })),
    version: Ni
  }), t._metadata = s;
}
const iK = 100;
function bs(t, e) {
  const n = ke(), r = Ut();
  if (!n) return;
  const { beforeBreadcrumb: s = null, maxBreadcrumbs: i = iK } = n.getOptions();
  if (i <= 0) return;
  const a = { timestamp: kl(), ...t }, c = s ? Pa(() => s(a, e)) : a;
  c !== null && (n.emit && n.emit("beforeAddBreadcrumb", c, e), r.addBreadcrumb(c, i));
}
let JA;
const oK = "FunctionToString", eS = /* @__PURE__ */ new WeakMap(), aK = () => ({
  name: oK,
  setupOnce() {
    JA = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...t) {
        const e = kb(this), n = eS.has(ke()) && e !== void 0 ? e : this;
        return JA.apply(n, t);
      };
    } catch {
    }
  },
  setup(t) {
    eS.set(t, !0);
  }
}), cK = aK, lK = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.
  /^Cannot redefine property: googletag$/,
  // This is thrown when google tag manager is used in combination with an ad blocker
  "undefined is not an object (evaluating 'a.L')",
  // Random error that happens but not actionable or noticeable to end-users.
  `can't redefine non-configurable property "solana"`,
  // Probably a browser extension or custom browser (Brave) throwing this error
  "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
  // Error thrown by GTM, seemingly not affecting end-users
  "Can't find variable: _AutofillCallbackHandler"
  // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/
], uK = "InboundFilters", dK = (t = {}) => ({
  name: uK,
  processEvent(e, n, r) {
    const s = r.getOptions(), i = hK(t, s);
    return pK(e, i) ? null : e;
  }
}), fK = dK;
function hK(t = {}, e = {}) {
  return {
    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
    ignoreErrors: [
      ...t.ignoreErrors || [],
      ...e.ignoreErrors || [],
      ...t.disableErrorDefaults ? [] : lK
    ],
    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
    ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
  };
}
function pK(t, e) {
  return e.ignoreInternal && xK(t) ? (xe && H.warn(`Event dropped due to being internal Sentry Error.
Event: ${Ms(t)}`), !0) : mK(t, e.ignoreErrors) ? (xe && H.warn(
    `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Ms(t)}`
  ), !0) : AK(t) ? (xe && H.warn(
    `Event dropped due to not having an error message, error type or stacktrace.
Event: ${Ms(
      t
    )}`
  ), !0) : gK(t, e.ignoreTransactions) ? (xe && H.warn(
    `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Ms(t)}`
  ), !0) : yK(t, e.denyUrls) ? (xe && H.warn(
    `Event dropped due to being matched by \`denyUrls\` option.
Event: ${Ms(
      t
    )}.
Url: ${tf(t)}`
  ), !0) : bK(t, e.allowUrls) ? !1 : (xe && H.warn(
    `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Ms(
      t
    )}.
Url: ${tf(t)}`
  ), !0);
}
function mK(t, e) {
  return t.type || !e || !e.length ? !1 : vK(t).some((n) => zs(n, e));
}
function gK(t, e) {
  if (t.type !== "transaction" || !e || !e.length)
    return !1;
  const n = t.transaction;
  return n ? zs(n, e) : !1;
}
function yK(t, e) {
  if (!e || !e.length)
    return !1;
  const n = tf(t);
  return n ? zs(n, e) : !1;
}
function bK(t, e) {
  if (!e || !e.length)
    return !0;
  const n = tf(t);
  return n ? zs(n, e) : !0;
}
function vK(t) {
  const e = [];
  t.message && e.push(t.message);
  let n;
  try {
    n = t.exception.values[t.exception.values.length - 1];
  } catch {
  }
  return n && n.value && (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`)), e;
}
function xK(t) {
  try {
    return t.exception.values[0].type === "SentryError";
  } catch {
  }
  return !1;
}
function wK(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function tf(t) {
  try {
    let e;
    try {
      e = t.exception.values[0].stacktrace.frames;
    } catch {
    }
    return e ? wK(e) : null;
  } catch {
    return xe && H.error(`Cannot extract url for event ${Ms(t)}`), null;
  }
}
function AK(t) {
  return t.type || !t.exception || !t.exception.values || t.exception.values.length === 0 ? !1 : (
    // No top-level message
    !t.message && // There are no exception values that have a stacktrace, a non-generic-Error type or value
    !t.exception.values.some((e) => e.stacktrace || e.type && e.type !== "Error" || e.value)
  );
}
const SK = "Dedupe", EK = () => {
  let t;
  return {
    name: SK,
    processEvent(e) {
      if (e.type)
        return e;
      try {
        if (_K(e, t))
          return xe && H.warn("Event dropped due to being a duplicate of previously captured event."), null;
      } catch {
      }
      return t = e;
    }
  };
}, CK = EK;
function _K(t, e) {
  return e ? !!(TK(t, e) || kK(t, e)) : !1;
}
function TK(t, e) {
  const n = t.message, r = e.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !AM(t, e) || !wM(t, e));
}
function kK(t, e) {
  const n = tS(e), r = tS(t);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !AM(t, e) || !wM(t, e));
}
function wM(t, e) {
  let n = TA(t), r = TA(e);
  if (!n && !r)
    return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length))
    return !1;
  for (let s = 0; s < r.length; s++) {
    const i = r[s], o = n[s];
    if (i.filename !== o.filename || i.lineno !== o.lineno || i.colno !== o.colno || i.function !== o.function)
      return !1;
  }
  return !0;
}
function AM(t, e) {
  let n = t.fingerprint, r = e.fingerprint;
  if (!n && !r)
    return !0;
  if (n && !r || !n && r)
    return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("");
  } catch {
    return !1;
  }
}
function tS(t) {
  return t.exception && t.exception.values && t.exception.values[0];
}
function RK(t, e, n, r, s = "auto.http.browser") {
  if (!t.fetchData)
    return;
  const i = ys() && e(t.fetchData.url);
  if (t.endTimestamp && i) {
    const p = t.fetchData.__span;
    if (!p) return;
    const m = r[p];
    m && (IK(m, t), delete r[p]);
    return;
  }
  const o = Fe(), a = ke(), { method: c, url: l } = t.fetchData, u = PK(l), d = u ? Li(u).host : void 0, f = !!en(), h = i && f ? pi({
    name: `${c} ${l}`,
    attributes: {
      url: l,
      type: "fetch",
      "http.method": c,
      "http.url": u,
      "server.address": d,
      [Gt]: s,
      [Xi]: "http.client"
    }
  }) : new qa();
  if (t.fetchData.__span = h.spanContext().spanId, r[h.spanContext().spanId] = h, n(t.fetchData.url) && a) {
    const p = t.args[0];
    t.args[1] = t.args[1] || {};
    const m = t.args[1];
    m.headers = MK(
      p,
      a,
      o,
      m,
      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
      // we do not want to use the span as base for the trace headers,
      // which means that the headers will be generated from the scope and the sampling decision is deferred
      ys() && f ? h : void 0
    );
  }
  return h;
}
function MK(t, e, n, r, s) {
  const i = Ut(), { traceId: o, spanId: a, sampled: c, dsc: l } = {
    ...i.getPropagationContext(),
    ...n.getPropagationContext()
  }, u = s ? sM(s) : Mb(o, a, c), d = $R(
    l || (s ? hi(s) : lh(o, e))
  ), f = r.headers || (typeof Request < "u" && hs(t, Request) ? t.headers : void 0);
  if (f)
    if (typeof Headers < "u" && hs(f, Headers)) {
      const h = new Headers(f);
      if (h.set("sentry-trace", u), d) {
        const p = h.get(Ao);
        if (p) {
          const m = Su(p);
          h.set(
            Ao,
            // If there are non-sentry entries (i.e. if the stripped string is non-empty/truthy) combine the stripped header and sentry baggage header
            // otherwise just set the sentry baggage header
            m ? `${m},${d}` : d
          );
        } else
          h.set(Ao, d);
      }
      return h;
    } else if (Array.isArray(f)) {
      const h = [
        ...f.filter((p) => !(Array.isArray(p) && p[0] === "sentry-trace")).map((p) => {
          if (Array.isArray(p) && p[0] === Ao && typeof p[1] == "string") {
            const [m, y, ...b] = p;
            return [m, Su(y), ...b];
          } else
            return p;
        }),
        // Attach the new sentry-trace header
        ["sentry-trace", u]
      ];
      return d && h.push([Ao, d]), h;
    } else {
      const h = "baggage" in f ? f.baggage : void 0;
      let p = [];
      return Array.isArray(h) ? p = h.map(
        (m) => typeof m == "string" ? Su(m) : m
      ).filter((m) => m === "") : h && p.push(Su(h)), d && p.push(d), {
        ...f,
        "sentry-trace": u,
        baggage: p.length > 0 ? p.join(",") : void 0
      };
    }
  else return { "sentry-trace": u, baggage: d };
}
function PK(t) {
  try {
    return new URL(t).href;
  } catch {
    return;
  }
}
function IK(t, e) {
  if (e.response) {
    tM(t, e.response.status);
    const n = e.response && e.response.headers && e.response.headers.get("content-length");
    if (n) {
      const r = parseInt(n);
      r > 0 && t.setAttribute("http.response_content_length", r);
    }
  } else e.error && t.setStatus({ code: zt, message: "internal_error" });
  t.end();
}
function Su(t) {
  return t.split(",").filter((e) => !e.split("=")[0].startsWith(Rb)).join(",");
}
function DK() {
  return {
    bindClient(t) {
      Fe().setClient(t);
    },
    withScope: Oa,
    getClient: () => ke(),
    getScope: Fe,
    getIsolationScope: Ut,
    captureException: (t, e) => Fe().captureException(t, e),
    captureMessage: (t, e, n) => Fe().captureMessage(t, e, n),
    captureEvent: Lb,
    addBreadcrumb: bs,
    setUser: jG,
    setTags: NG,
    setTag: LG,
    setExtra: qG,
    setExtras: OG,
    setContext: jb,
    getIntegration(t) {
      const e = ke();
      return e && e.getIntegrationByName(t.id) || null;
    },
    startSession: dg,
    endSession: ef,
    captureSession(t) {
      if (t)
        return ef();
      qK();
    }
  };
}
const OK = DK;
function qK() {
  const t = Fe(), e = ke(), n = t.getSession();
  e && n && e.captureSession(n);
}
const oe = Oe;
let fg = 0;
function SM() {
  return fg > 0;
}
function NK() {
  fg++, setTimeout(() => {
    fg--;
  });
}
function ca(t, e = {}, n) {
  if (typeof t != "function")
    return t;
  try {
    const s = t.__sentry_wrapped__;
    if (s)
      return typeof s == "function" ? s : t;
    if (kb(t))
      return t;
  } catch {
    return t;
  }
  const r = function() {
    const s = Array.prototype.slice.call(arguments);
    try {
      const i = s.map((o) => ca(o, e));
      return t.apply(this, i);
    } catch (i) {
      throw NK(), Oa((o) => {
        o.addEventProcessor((a) => (e.mechanism && (ng(a, void 0), il(a, e.mechanism)), a.extra = {
          ...a.extra,
          arguments: s
        }, a)), uh(i);
      }), i;
    }
  };
  try {
    for (const s in t)
      Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s]);
  } catch {
  }
  OR(r, t), Jn(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return t.name;
      }
    });
  } catch {
  }
  return r;
}
const Rn = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function Bb(t, e) {
  const n = Fb(t, e), r = {
    type: VK(e),
    value: UK(e)
  };
  return n.length && (r.stacktrace = { frames: n }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r;
}
function LK(t, e, n, r) {
  const s = ke(), i = s && s.getOptions().normalizeDepth, o = GK(e), a = {
    __serialized__: YR(e, i)
  };
  if (o)
    return {
      exception: {
        values: [Bb(t, o)]
      },
      extra: a
    };
  const c = {
    exception: {
      values: [
        {
          type: sh(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
          value: HK(e, { isUnhandledRejection: r })
        }
      ]
    },
    extra: a
  };
  if (n) {
    const l = Fb(t, n);
    l.length && (c.exception.values[0].stacktrace = { frames: l });
  }
  return c;
}
function kp(t, e) {
  return {
    exception: {
      values: [Bb(t, e)]
    }
  };
}
function Fb(t, e) {
  const n = e.stacktrace || e.stack || "", r = BK(e), s = FK(e);
  try {
    return t(n, r, s);
  } catch {
  }
  return [];
}
const jK = /Minified React error #\d+;/i;
function BK(t) {
  return t && jK.test(t.message) ? 1 : 0;
}
function FK(t) {
  return typeof t.framesToPop == "number" ? t.framesToPop : 0;
}
function EM(t) {
  return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? t instanceof WebAssembly.Exception : !1;
}
function VK(t) {
  const e = t && t.name;
  return !e && EM(t) ? t.message && Array.isArray(t.message) && t.message.length == 2 ? t.message[0] : "WebAssembly.Exception" : e;
}
function UK(t) {
  const e = t && t.message;
  return e ? e.error && typeof e.error.message == "string" ? e.error.message : EM(t) && Array.isArray(t.message) && t.message.length == 2 ? t.message[1] : e : "No error message";
}
function WK(t, e, n, r) {
  const s = n && n.syntheticException || void 0, i = Vb(t, e, s, r);
  return il(i), i.level = "error", n && n.event_id && (i.event_id = n.event_id), gs(i);
}
function zK(t, e, n = "info", r, s) {
  const i = r && r.syntheticException || void 0, o = hg(t, e, i, s);
  return o.level = n, r && r.event_id && (o.event_id = r.event_id), gs(o);
}
function Vb(t, e, n, r, s) {
  let i;
  if (TR(e) && e.error)
    return kp(t, e.error);
  if (vA(e) || S8(e)) {
    const o = e;
    if ("stack" in e)
      i = kp(t, e);
    else {
      const a = o.name || (vA(o) ? "DOMError" : "DOMException"), c = o.message ? `${a}: ${o.message}` : a;
      i = hg(t, c, n, r), ng(i, c);
    }
    return "code" in o && (i.tags = { ...i.tags, "DOMException.code": `${o.code}` }), i;
  }
  return rh(e) ? kp(t, e) : ia(e) || sh(e) ? (i = LK(t, e, n, s), il(i, {
    synthetic: !0
  }), i) : (i = hg(t, e, n, r), ng(i, `${e}`), il(i, {
    synthetic: !0
  }), i);
}
function hg(t, e, n, r) {
  const s = {};
  if (r && n) {
    const i = Fb(t, n);
    i.length && (s.exception = {
      values: [{ value: e, stacktrace: { frames: i } }]
    });
  }
  if (_b(e)) {
    const { __sentry_template_string__: i, __sentry_template_values__: o } = e;
    return s.logentry = {
      message: i,
      params: o
    }, s;
  }
  return s.message = e, s;
}
function HK(t, { isUnhandledRejection: e }) {
  const n = F8(t), r = e ? "promise rejection" : "exception";
  return TR(t) ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\`` : sh(t) ? `Event \`${YK(t)}\` (type=${t.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`;
}
function YK(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0;
  } catch {
  }
}
function GK(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const n = t[e];
      if (n instanceof Error)
        return n;
    }
}
function KK(t, {
  metadata: e,
  tunnel: n,
  dsn: r
}) {
  const s = {
    event_id: t.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...e && e.sdk && {
      sdk: {
        name: e.sdk.name,
        version: e.sdk.version
      }
    },
    ...!!n && !!r && { dsn: Ia(r) }
  }, i = $K(t);
  return so(s, [i]);
}
function $K(t) {
  return [{
    type: "user_report"
  }, t];
}
class ZK extends $G {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(e) {
    const n = {
      // We default this to true, as it is the safer scenario
      parentSpanIsAlwaysRootSpan: !0,
      ...e
    }, r = oe.SENTRY_SDK_SOURCE || tY();
    xM(n, "browser", ["browser"], r), super(n), n.sendClientReports && oe.document && oe.document.addEventListener("visibilitychange", () => {
      oe.document.visibilityState === "hidden" && this._flushOutcomes();
    });
  }
  /**
   * @inheritDoc
   */
  eventFromException(e, n) {
    return WK(this._options.stackParser, e, n, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(e, n = "info", r) {
    return zK(this._options.stackParser, e, n, r, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   *
   * @deprecated Use `captureFeedback` instead.
   */
  captureUserFeedback(e) {
    if (!this._isEnabled()) {
      Rn && H.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const n = KK(e, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(e, n, r) {
    return e.platform = e.platform || "javascript", super._prepareEvent(e, n, r);
  }
}
const zn = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, QK = (t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good", Na = (t, e, n, r) => {
  let s, i;
  return (o) => {
    e.value >= 0 && (o || r) && (i = e.value - (s || 0), (i || s === void 0) && (s = e.value, e.delta = i, e.rating = QK(e.value, n), t(e)));
  };
}, me = Oe, XK = () => `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`, Ml = () => me.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], Pl = () => {
  const t = Ml();
  return t && t.activationStart || 0;
}, La = (t, e) => {
  const n = Ml();
  let r = "navigate";
  return n && (me.document && me.document.prerendering || Pl() > 0 ? r = "prerender" : me.document && me.document.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-"))), {
    name: t,
    value: typeof e > "u" ? -1 : e,
    rating: "good",
    // If needed, will be updated when reported. `const` to keep the type from widening to `string`.
    delta: 0,
    entries: [],
    id: XK(),
    navigationType: r
  };
}, oo = (t, e, n) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(t)) {
      const r = new PerformanceObserver((s) => {
        Promise.resolve().then(() => {
          e(s.getEntries());
        });
      });
      return r.observe(
        Object.assign(
          {
            type: t,
            buffered: !0
          },
          n || {}
        )
      ), r;
    }
  } catch {
  }
}, Il = (t) => {
  const e = (n) => {
    (n.type === "pagehide" || me.document && me.document.visibilityState === "hidden") && t(n);
  };
  me.document && (addEventListener("visibilitychange", e, !0), addEventListener("pagehide", e, !0));
}, Ub = (t) => {
  let e = !1;
  return (n) => {
    e || (t(n), e = !0);
  };
};
let al = -1;
const JK = () => {
  al = me.document.visibilityState === "hidden" && !me.document.prerendering ? 0 : 1 / 0;
}, nf = (t) => {
  me.document.visibilityState === "hidden" && al > -1 && (al = t.type === "visibilitychange" ? t.timeStamp : 0, removeEventListener("visibilitychange", nf, !0), removeEventListener("prerenderingchange", nf, !0));
}, e$ = () => {
  addEventListener("visibilitychange", nf, !0), addEventListener("prerenderingchange", nf, !0);
}, dh = () => (me.document && al < 0 && (JK(), e$()), {
  get firstHiddenTime() {
    return al;
  }
}), Dl = (t) => {
  me.document && me.document.prerendering ? addEventListener("prerenderingchange", () => t(), !0) : t();
}, t$ = [1800, 3e3], n$ = (t, e = {}) => {
  Dl(() => {
    const n = dh(), r = La("FCP");
    let s;
    const o = oo("paint", (a) => {
      a.forEach((c) => {
        c.name === "first-contentful-paint" && (o.disconnect(), c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - Pl(), 0), r.entries.push(c), s(!0)));
      });
    });
    o && (s = Na(t, r, t$, e.reportAllChanges));
  });
}, r$ = [0.1, 0.25], s$ = (t, e = {}) => {
  n$(
    Ub(() => {
      const n = La("CLS", 0);
      let r, s = 0, i = [];
      const o = (c) => {
        c.forEach((l) => {
          if (!l.hadRecentInput) {
            const u = i[0], d = i[i.length - 1];
            s && u && d && l.startTime - d.startTime < 1e3 && l.startTime - u.startTime < 5e3 ? (s += l.value, i.push(l)) : (s = l.value, i = [l]);
          }
        }), s > n.value && (n.value = s, n.entries = i, r());
      }, a = oo("layout-shift", o);
      a && (r = Na(t, n, r$, e.reportAllChanges), Il(() => {
        o(a.takeRecords()), r(!0);
      }), setTimeout(r, 0));
    })
  );
}, i$ = [100, 300], o$ = (t, e = {}) => {
  Dl(() => {
    const n = dh(), r = La("FID");
    let s;
    const i = (c) => {
      c.startTime < n.firstHiddenTime && (r.value = c.processingStart - c.startTime, r.entries.push(c), s(!0));
    }, o = (c) => {
      c.forEach(i);
    }, a = oo("first-input", o);
    s = Na(t, r, i$, e.reportAllChanges), a && Il(
      Ub(() => {
        o(a.takeRecords()), a.disconnect();
      })
    );
  });
};
let CM = 0, Rp = 1 / 0, Eu = 0;
const a$ = (t) => {
  t.forEach((e) => {
    e.interactionId && (Rp = Math.min(Rp, e.interactionId), Eu = Math.max(Eu, e.interactionId), CM = Eu ? (Eu - Rp) / 7 + 1 : 0);
  });
};
let pg;
const c$ = () => pg ? CM : performance.interactionCount || 0, l$ = () => {
  "interactionCount" in performance || pg || (pg = oo("event", a$, {
    type: "event",
    buffered: !0,
    durationThreshold: 0
  }));
}, u$ = [200, 500], d$ = 0, _M = () => c$() - d$, nS = 10, Qr = [], Mp = {}, rS = (t) => {
  const e = Qr[Qr.length - 1], n = Mp[t.interactionId];
  if (n || Qr.length < nS || e && t.duration > e.latency) {
    if (n)
      n.entries.push(t), n.latency = Math.max(n.latency, t.duration);
    else {
      const r = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        id: t.interactionId,
        latency: t.duration,
        entries: [t]
      };
      Mp[r.id] = r, Qr.push(r);
    }
    Qr.sort((r, s) => s.latency - r.latency), Qr.splice(nS).forEach((r) => {
      delete Mp[r.id];
    });
  }
}, f$ = () => {
  const t = Math.min(
    Qr.length - 1,
    Math.floor(_M() / 50)
  );
  return Qr[t];
}, h$ = (t, e = {}) => {
  Dl(() => {
    l$();
    const n = La("INP");
    let r;
    const s = (o) => {
      o.forEach((c) => {
        c.interactionId && rS(c), c.entryType === "first-input" && !Qr.some((u) => u.entries.some((d) => c.duration === d.duration && c.startTime === d.startTime)) && rS(c);
      });
      const a = f$();
      a && a.latency !== n.value && (n.value = a.latency, n.entries = a.entries, r());
    }, i = oo("event", s, {
      // Event Timing entries have their durations rounded to the nearest 8ms,
      // so a duration of 40ms would be any event that spans 2.5 or more frames
      // at 60Hz. This threshold is chosen to strike a balance between usefulness
      // and performance. Running this callback for any interaction that spans
      // just one or two frames is likely not worth the insight that could be
      // gained.
      durationThreshold: e.durationThreshold != null ? e.durationThreshold : 40
    });
    r = Na(t, n, u$, e.reportAllChanges), i && ("PerformanceEventTiming" in me && "interactionId" in PerformanceEventTiming.prototype && i.observe({ type: "first-input", buffered: !0 }), Il(() => {
      s(i.takeRecords()), n.value < 0 && _M() > 0 && (n.value = 0, n.entries = []), r(!0);
    }));
  });
}, p$ = [2500, 4e3], sS = {}, m$ = (t, e = {}) => {
  Dl(() => {
    const n = dh(), r = La("LCP");
    let s;
    const i = (a) => {
      const c = a[a.length - 1];
      c && c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - Pl(), 0), r.entries = [c], s());
    }, o = oo("largest-contentful-paint", i);
    if (o) {
      s = Na(t, r, p$, e.reportAllChanges);
      const a = Ub(() => {
        sS[r.id] || (i(o.takeRecords()), o.disconnect(), sS[r.id] = !0, s(!0));
      });
      ["keydown", "click"].forEach((c) => {
        me.document && addEventListener(c, () => setTimeout(a, 0), !0);
      }), Il(a);
    }
  });
}, g$ = [800, 1800], mg = (t) => {
  me.document && me.document.prerendering ? Dl(() => mg(t)) : me.document && me.document.readyState !== "complete" ? addEventListener("load", () => mg(t), !0) : setTimeout(t, 0);
}, y$ = (t, e = {}) => {
  const n = La("TTFB"), r = Na(t, n, g$, e.reportAllChanges);
  mg(() => {
    const s = Ml();
    if (s) {
      const i = s.responseStart;
      if (i <= 0 || i > performance.now()) return;
      n.value = Math.max(i - Pl(), 0), n.entries = [s], r(!0);
    }
  });
}, Sc = {}, rf = {};
let TM, kM, RM, MM, PM;
function Wb(t, e = !1) {
  return Ol("cls", t, v$, TM, e);
}
function IM(t, e = !1) {
  return Ol("lcp", t, w$, RM, e);
}
function DM(t) {
  return Ol("fid", t, x$, kM);
}
function b$(t) {
  return Ol("ttfb", t, A$, MM);
}
function OM(t) {
  return Ol("inp", t, S$, PM);
}
function la(t, e) {
  return qM(t, e), rf[t] || (E$(t), rf[t] = !0), NM(t, e);
}
function ja(t, e) {
  const n = Sc[t];
  if (!(!n || !n.length))
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        zn && H.error(
          `Error while triggering instrumentation handler.
Type: ${t}
Name: ${ms(r)}
Error:`,
          s
        );
      }
}
function v$() {
  return s$(
    (t) => {
      ja("cls", {
        metric: t
      }), TM = t;
    },
    // We want the callback to be called whenever the CLS value updates.
    // By default, the callback is only called when the tab goes to the background.
    { reportAllChanges: !0 }
  );
}
function x$() {
  return o$((t) => {
    ja("fid", {
      metric: t
    }), kM = t;
  });
}
function w$() {
  return m$(
    (t) => {
      ja("lcp", {
        metric: t
      }), RM = t;
    },
    // We want the callback to be called whenever the LCP value updates.
    // By default, the callback is only called when the tab goes to the background.
    { reportAllChanges: !0 }
  );
}
function A$() {
  return y$((t) => {
    ja("ttfb", {
      metric: t
    }), MM = t;
  });
}
function S$() {
  return h$((t) => {
    ja("inp", {
      metric: t
    }), PM = t;
  });
}
function Ol(t, e, n, r, s = !1) {
  qM(t, e);
  let i;
  return rf[t] || (i = n(), rf[t] = !0), r && e({ metric: r }), NM(t, e, s ? i : void 0);
}
function E$(t) {
  const e = {};
  t === "event" && (e.durationThreshold = 0), oo(
    t,
    (n) => {
      ja(t, { entries: n });
    },
    e
  );
}
function qM(t, e) {
  Sc[t] = Sc[t] || [], Sc[t].push(e);
}
function NM(t, e, n) {
  return () => {
    n && n();
    const r = Sc[t];
    if (!r)
      return;
    const s = r.indexOf(e);
    s !== -1 && r.splice(s, 1);
  };
}
function C$(t) {
  return "duration" in t;
}
function Pp(t) {
  return typeof t == "number" && isFinite(t);
}
function ua(t, e, n, { ...r }) {
  const s = Be(t).start_timestamp;
  return s && s > e && typeof t.updateStartTime == "function" && t.updateStartTime(e), dM(t, () => {
    const i = pi({
      startTime: e,
      ...r
    });
    return i && i.end(n), i;
  });
}
function LM(t) {
  const e = ke();
  if (!e)
    return;
  const { name: n, transaction: r, attributes: s, startTime: i } = t, { release: o, environment: a } = e.getOptions(), c = e.getIntegrationByName("Replay"), l = c && c.getReplayId(), u = Fe(), d = u.getUser(), f = d !== void 0 ? d.email || d.id || d.ip_address : void 0;
  let h;
  try {
    h = u.getScopeData().contexts.profile.profile_id;
  } catch {
  }
  const p = {
    release: o,
    environment: a,
    user: f || void 0,
    profile_id: h || void 0,
    replay_id: l || void 0,
    transaction: r,
    // Web vital score calculation relies on the user agent to account for different
    // browsers setting different thresholds for what is considered a good/meh/bad value.
    // For example: Chrome vs. Chrome Mobile
    "user_agent.original": me.navigator && me.navigator.userAgent,
    ...s
  };
  return pi({
    name: n,
    attributes: p,
    startTime: i,
    experimental: {
      standalone: !0
    }
  });
}
function zb() {
  return me && me.addEventListener && me.performance;
}
function Dt(t) {
  return t / 1e3;
}
function _$() {
  let t = 0, e, n;
  if (!k$())
    return;
  let r = !1;
  function s() {
    r || (r = !0, n && T$(t, e, n), i());
  }
  const i = Wb(({ metric: o }) => {
    const a = o.entries[o.entries.length - 1];
    a && (t = o.value, e = a);
  }, !0);
  Il(() => {
    s();
  }), setTimeout(() => {
    const o = ke(), a = Bn([o, "optionalAccess", (d) => d.on, "call", (d) => d("startNavigationSpan", () => {
      s(), a && a();
    })]), c = en(), l = c && Xt(c), u = l && Be(l);
    u && u.op === "pageload" && (n = l.spanContext().spanId);
  }, 0);
}
function T$(t, e, n) {
  zn && H.log(`Sending CLS span (${t})`);
  const r = Dt((vn || 0) + (Bn([e, "optionalAccess", (c) => c.startTime]) || 0)), s = Fe().getScopeData().transactionName, i = e ? ps(Bn([e, "access", (c) => c.sources, "access", (c) => c[0], "optionalAccess", (c) => c.node])) : "Layout shift", o = Vt({
    [Gt]: "auto.http.browser.cls",
    [Xi]: "ui.webvital.cls",
    [Ob]: Bn([e, "optionalAccess", (c) => c.duration]) || 0,
    // attach the pageload span id to the CLS span so that we can link them in the UI
    "sentry.pageload.span_id": n
  }), a = LM({
    name: i,
    transaction: s,
    attributes: o,
    startTime: r
  });
  Bn([a, "optionalAccess", (c) => c.addEvent, "call", (c) => c("cls", {
    [ah]: "",
    [ch]: t
  })]), Bn([a, "optionalAccess", (c) => c.end, "call", (c) => c(r)]);
}
function k$() {
  try {
    return Bn([PerformanceObserver, "access", (t) => t.supportedEntryTypes, "optionalAccess", (t) => t.includes, "call", (t) => t("layout-shift")]);
  } catch {
    return !1;
  }
}
const R$ = 2147483647;
let iS = 0, $t = {}, vr, Ec;
function M$({ recordClsStandaloneSpans: t }) {
  const e = zb();
  if (e && vn) {
    e.mark && me.performance.mark("sentry-tracing-init");
    const n = N$(), r = q$(), s = L$(), i = t ? _$() : O$();
    return () => {
      n(), r(), s(), i && i();
    };
  }
  return () => {
  };
}
function P$() {
  la("longtask", ({ entries: t }) => {
    if (en())
      for (const e of t) {
        const n = Dt(vn + e.startTime), r = Dt(e.duration), s = pi({
          name: "Main UI thread blocked",
          op: "ui.long-task",
          startTime: n,
          attributes: {
            [Gt]: "auto.ui.browser.metrics"
          }
        });
        s && s.end(n + r);
      }
  });
}
function I$() {
  new PerformanceObserver((e) => {
    if (en())
      for (const n of e.getEntries()) {
        if (!n.scripts[0])
          continue;
        const r = Dt(vn + n.startTime), s = Dt(n.duration), i = {
          [Gt]: "auto.ui.browser.metrics"
        }, o = n.scripts[0], { invoker: a, invokerType: c, sourceURL: l, sourceFunctionName: u, sourceCharPosition: d } = o;
        i["browser.script.invoker"] = a, i["browser.script.invoker_type"] = c, l && (i["code.filepath"] = l), u && (i["code.function"] = u), d !== -1 && (i["browser.script.source_char_position"] = d);
        const f = pi({
          name: "Main UI thread blocked",
          op: "ui.long-animation-frame",
          startTime: r,
          attributes: i
        });
        f && f.end(r + s);
      }
  }).observe({ type: "long-animation-frame", buffered: !0 });
}
function D$() {
  la("event", ({ entries: t }) => {
    if (en()) {
      for (const e of t)
        if (e.name === "click") {
          const n = Dt(vn + e.startTime), r = Dt(e.duration), s = {
            name: ps(e.target),
            op: `ui.interaction.${e.name}`,
            startTime: n,
            attributes: {
              [Gt]: "auto.ui.browser.metrics"
            }
          }, i = PR(e.target);
          i && (s.attributes["ui.component_name"] = i);
          const o = pi(s);
          o && o.end(n + r);
        }
    }
  });
}
function O$() {
  return Wb(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && (zn && H.log(`[Measurements] Adding CLS ${t.value}`), $t.cls = { value: t.value, unit: "" }, Ec = e);
  }, !0);
}
function q$() {
  return IM(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && (zn && H.log("[Measurements] Adding LCP"), $t.lcp = { value: t.value, unit: "millisecond" }, vr = e);
  }, !0);
}
function N$() {
  return DM(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    if (!e)
      return;
    const n = Dt(vn), r = Dt(e.startTime);
    zn && H.log("[Measurements] Adding FID"), $t.fid = { value: t.value, unit: "millisecond" }, $t["mark.fid"] = { value: n + r, unit: "second" };
  });
}
function L$() {
  return b$(({ metric: t }) => {
    t.entries[t.entries.length - 1] && (zn && H.log("[Measurements] Adding TTFB"), $t.ttfb = { value: t.value, unit: "millisecond" });
  });
}
function j$(t, e) {
  const n = zb();
  if (!n || !me.performance.getEntries || !vn)
    return;
  zn && H.log("[Tracing] Adding & adjusting spans using Performance API");
  const r = Dt(vn), s = n.getEntries(), { op: i, start_timestamp: o } = Be(t);
  if (s.slice(iS).forEach((a) => {
    const c = Dt(a.startTime), l = Dt(
      // Inexplicably, Chrome sometimes emits a negative duration. We need to work around this.
      // There is a SO post attempting to explain this, but it leaves one with open questions: https://stackoverflow.com/questions/23191918/peformance-getentries-and-negative-duration-display
      // The way we clamp the value is probably not accurate, since we have observed this happen for things that may take a while to load, like for example the replay worker.
      // TODO: Investigate why this happens and how to properly mitigate. For now, this is a workaround to prevent transactions being dropped due to negative duration spans.
      Math.max(0, a.duration)
    );
    if (!(i === "navigation" && o && r + c < o))
      switch (a.entryType) {
        case "navigation": {
          F$(t, a, r);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          B$(t, a, c, l, r);
          const u = dh(), d = a.startTime < u.firstHiddenTime;
          a.name === "first-paint" && d && (zn && H.log("[Measurements] Adding FP"), $t.fp = { value: a.startTime, unit: "millisecond" }), a.name === "first-contentful-paint" && d && (zn && H.log("[Measurements] Adding FCP"), $t.fcp = { value: a.startTime, unit: "millisecond" });
          break;
        }
        case "resource": {
          U$(t, a, a.name, c, l, r);
          break;
        }
      }
  }), iS = Math.max(s.length - 1, 0), W$(t), i === "pageload") {
    H$($t);
    const a = $t["mark.fid"];
    a && $t.fid && (ua(t, a.value, a.value + Dt($t.fid.value), {
      name: "first input delay",
      op: "ui.action",
      attributes: {
        [Gt]: "auto.ui.browser.metrics"
      }
    }), delete $t["mark.fid"]), (!("fcp" in $t) || !e.recordClsOnPageloadSpan) && delete $t.cls, Object.entries($t).forEach(([c, l]) => {
      iG(c, l.value, l.unit);
    }), t.setAttribute("performance.timeOrigin", r), t.setAttribute("performance.activationStart", Pl()), z$(t);
  }
  vr = void 0, Ec = void 0, $t = {};
}
function B$(t, e, n, r, s) {
  const i = Ml(), o = Dt(i ? i.requestStart : 0), a = s + Math.max(n, o), c = s + n, l = c + r, u = {
    [Gt]: "auto.resource.browser.metrics"
  };
  return a !== c && (u["sentry.browser.measure_happened_before_request"] = !0, u["sentry.browser.measure_start_time"] = a), ua(t, a, l, {
    name: e.name,
    op: e.entryType,
    attributes: u
  }), a;
}
function F$(t, e, n) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((r) => {
    Cu(t, e, r, n);
  }), Cu(t, e, "secureConnection", n, "TLS/SSL", "connectEnd"), Cu(t, e, "fetch", n, "cache", "domainLookupStart"), Cu(t, e, "domainLookup", n, "DNS"), V$(t, e, n);
}
function Cu(t, e, n, r, s, i) {
  const o = i ? e[i] : e[`${n}End`], a = e[`${n}Start`];
  !a || !o || ua(t, r + Dt(a), r + Dt(o), {
    op: `browser.${s || n}`,
    name: e.name,
    attributes: {
      [Gt]: "auto.ui.browser.metrics"
    }
  });
}
function V$(t, e, n) {
  const r = n + Dt(e.requestStart), s = n + Dt(e.responseEnd), i = n + Dt(e.responseStart);
  e.responseEnd && (ua(t, r, s, {
    op: "browser.request",
    name: e.name,
    attributes: {
      [Gt]: "auto.ui.browser.metrics"
    }
  }), ua(t, i, s, {
    op: "browser.response",
    name: e.name,
    attributes: {
      [Gt]: "auto.ui.browser.metrics"
    }
  }));
}
function U$(t, e, n, r, s, i) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch")
    return;
  const o = Li(n), a = {
    [Gt]: "auto.resource.browser.metrics"
  };
  Ip(a, e, "transferSize", "http.response_transfer_size"), Ip(a, e, "encodedBodySize", "http.response_content_length"), Ip(a, e, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in e && (a["resource.render_blocking_status"] = e.renderBlockingStatus), o.protocol && (a["url.scheme"] = o.protocol.split(":").pop()), o.host && (a["server.address"] = o.host), a["url.same_origin"] = n.includes(me.location.origin);
  const c = i + r, l = c + s;
  ua(t, c, l, {
    name: n.replace(me.location.origin, ""),
    op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
    attributes: a
  });
}
function W$(t) {
  const e = me.navigator;
  if (!e)
    return;
  const n = e.connection;
  n && (n.effectiveType && t.setAttribute("effectiveConnectionType", n.effectiveType), n.type && t.setAttribute("connectionType", n.type), Pp(n.rtt) && ($t["connection.rtt"] = { value: n.rtt, unit: "millisecond" })), Pp(e.deviceMemory) && t.setAttribute("deviceMemory", `${e.deviceMemory} GB`), Pp(e.hardwareConcurrency) && t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency));
}
function z$(t) {
  vr && (zn && H.log("[Measurements] Adding LCP Data"), vr.element && t.setAttribute("lcp.element", ps(vr.element)), vr.id && t.setAttribute("lcp.id", vr.id), vr.url && t.setAttribute("lcp.url", vr.url.trim().slice(0, 200)), t.setAttribute("lcp.size", vr.size)), Ec && Ec.sources && (zn && H.log("[Measurements] Adding CLS Data"), Ec.sources.forEach(
    (e, n) => t.setAttribute(`cls.source.${n + 1}`, ps(e.node))
  ));
}
function Ip(t, e, n, r) {
  const s = e[n];
  s != null && s < R$ && (t[r] = s);
}
function H$(t) {
  const e = Ml();
  if (!e)
    return;
  const { responseStart: n, requestStart: r } = e;
  r <= n && (zn && H.log("[Measurements] Adding TTFB Request Time"), t["ttfb.requestTime"] = {
    value: n - r,
    unit: "millisecond"
  });
}
const Y$ = 1e3;
let oS, gg, yg;
function jM(t) {
  const e = "dom";
  di(e, t), fi(e, G$);
}
function G$() {
  if (!me.document)
    return;
  const t = Xn.bind(null, "dom"), e = aS(t, !0);
  me.document.addEventListener("click", e, !1), me.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach((n) => {
    const r = me[n] && me[n].prototype;
    !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (_n(r, "addEventListener", function(s) {
      return function(i, o, a) {
        if (i === "click" || i == "keypress")
          try {
            const c = this, l = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {}, u = l[i] = l[i] || { refCount: 0 };
            if (!u.handler) {
              const d = aS(t);
              u.handler = d, s.call(this, i, d, a);
            }
            u.refCount++;
          } catch {
          }
        return s.call(this, i, o, a);
      };
    }), _n(
      r,
      "removeEventListener",
      function(s) {
        return function(i, o, a) {
          if (i === "click" || i == "keypress")
            try {
              const c = this, l = c.__sentry_instrumentation_handlers__ || {}, u = l[i];
              u && (u.refCount--, u.refCount <= 0 && (s.call(this, i, u.handler, a), u.handler = void 0, delete l[i]), Object.keys(l).length === 0 && delete c.__sentry_instrumentation_handlers__);
            } catch {
            }
          return s.call(this, i, o, a);
        };
      }
    ));
  });
}
function K$(t) {
  if (t.type !== gg)
    return !1;
  try {
    if (!t.target || t.target._sentryId !== yg)
      return !1;
  } catch {
  }
  return !0;
}
function $$(t, e) {
  return t !== "keypress" ? !1 : !e || !e.tagName ? !0 : !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable);
}
function aS(t, e = !1) {
  return (n) => {
    if (!n || n._sentryCaptured)
      return;
    const r = Z$(n);
    if ($$(n.type, r))
      return;
    Jn(n, "_sentryCaptured", !0), r && !r._sentryId && Jn(r, "_sentryId", gt());
    const s = n.type === "keypress" ? "input" : n.type;
    K$(n) || (t({ event: n, name: s, global: e }), gg = n.type, yg = r ? r._sentryId : void 0), clearTimeout(oS), oS = me.setTimeout(() => {
      yg = void 0, gg = void 0;
    }, Y$);
  };
}
function Z$(t) {
  try {
    return t.target;
  } catch {
    return null;
  }
}
let _u;
function fh(t) {
  const e = "history";
  di(e, t), fi(e, Q$);
}
function Q$() {
  if (!RY())
    return;
  const t = me.onpopstate;
  me.onpopstate = function(...n) {
    const r = me.location.href, s = _u;
    if (_u = r, Xn("history", { from: s, to: r }), t)
      try {
        return t.apply(this, n);
      } catch {
      }
  };
  function e(n) {
    return function(...r) {
      const s = r.length > 2 ? r[2] : void 0;
      if (s) {
        const i = _u, o = String(s);
        _u = o, Xn("history", { from: i, to: o });
      }
      return n.apply(this, r);
    };
  }
  _n(me.history, "pushState", e), _n(me.history, "replaceState", e);
}
const od = {};
function BM(t) {
  const e = od[t];
  if (e)
    return e;
  let n = me[t];
  if (eg(n))
    return od[t] = n.bind(me);
  const r = me.document;
  if (r && typeof r.createElement == "function")
    try {
      const s = r.createElement("iframe");
      s.hidden = !0, r.head.appendChild(s);
      const i = s.contentWindow;
      i && i[t] && (n = i[t]), r.head.removeChild(s);
    } catch (s) {
      zn && H.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, s);
    }
  return n && (od[t] = n.bind(me));
}
function cS(t) {
  od[t] = void 0;
}
function da(...t) {
  return BM("setTimeout")(...t);
}
const Ri = "__sentry_xhr_v3__";
function FM(t) {
  const e = "xhr";
  di(e, t), fi(e, X$);
}
function X$() {
  if (!me.XMLHttpRequest)
    return;
  const t = XMLHttpRequest.prototype;
  t.open = new Proxy(t.open, {
    apply(e, n, r) {
      const s = gn() * 1e3, i = as(r[0]) ? r[0].toUpperCase() : void 0, o = J$(r[1]);
      if (!i || !o)
        return e.apply(n, r);
      n[Ri] = {
        method: i,
        url: o,
        request_headers: {}
      }, i === "POST" && o.match(/sentry_key/) && (n.__sentry_own_request__ = !0);
      const a = () => {
        const c = n[Ri];
        if (c && n.readyState === 4) {
          try {
            c.status_code = n.status;
          } catch {
          }
          const l = {
            endTimestamp: gn() * 1e3,
            startTimestamp: s,
            xhr: n
          };
          Xn("xhr", l);
        }
      };
      return "onreadystatechange" in n && typeof n.onreadystatechange == "function" ? n.onreadystatechange = new Proxy(n.onreadystatechange, {
        apply(c, l, u) {
          return a(), c.apply(l, u);
        }
      }) : n.addEventListener("readystatechange", a), n.setRequestHeader = new Proxy(n.setRequestHeader, {
        apply(c, l, u) {
          const [d, f] = u, h = l[Ri];
          return h && as(d) && as(f) && (h.request_headers[d.toLowerCase()] = f), c.apply(l, u);
        }
      }), e.apply(n, r);
    }
  }), t.send = new Proxy(t.send, {
    apply(e, n, r) {
      const s = n[Ri];
      if (!s)
        return e.apply(n, r);
      r[0] !== void 0 && (s.body = r[0]);
      const i = {
        startTimestamp: gn() * 1e3,
        xhr: n
      };
      return Xn("xhr", i), e.apply(n, r);
    }
  });
}
function J$(t) {
  if (as(t))
    return t;
  try {
    return t.toString();
  } catch {
  }
}
const Dp = [], ad = /* @__PURE__ */ new Map();
function eZ() {
  if (zb() && vn) {
    const e = tZ();
    return () => {
      e();
    };
  }
  return () => {
  };
}
const lS = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press"
};
function tZ() {
  return OM(({ metric: t }) => {
    if (t.value == null)
      return;
    const e = t.entries.find((p) => p.duration === t.value && lS[p.name]);
    if (!e)
      return;
    const { interactionId: n } = e, r = lS[e.name], s = Dt(vn + e.startTime), i = Dt(t.value), o = en(), a = o ? Xt(o) : void 0, l = (n != null ? ad.get(n) : void 0) || a, u = l ? Be(l).description : Fe().getScopeData().transactionName, d = ps(e.target), f = Vt({
      [Gt]: "auto.http.browser.inp",
      [Xi]: `ui.interaction.${r}`,
      [Ob]: e.duration
    }), h = LM({
      name: d,
      transaction: u,
      attributes: f,
      startTime: s
    });
    Bn([h, "optionalAccess", (p) => p.addEvent, "call", (p) => p("inp", {
      [ah]: "millisecond",
      [ch]: t.value
    })]), Bn([h, "optionalAccess", (p) => p.end, "call", (p) => p(s + i)]);
  });
}
function nZ(t) {
  const e = ({ entries: n }) => {
    const r = en(), s = r && Xt(r);
    n.forEach((i) => {
      if (!C$(i) || !s)
        return;
      const o = i.interactionId;
      if (o != null && !ad.has(o)) {
        if (Dp.length > 10) {
          const a = Dp.shift();
          ad.delete(a);
        }
        Dp.push(o), ad.set(o, s);
      }
    });
  };
  la("event", e), la("first-input", e);
}
function rZ(t, e = BM("fetch")) {
  let n = 0, r = 0;
  function s(i) {
    const o = i.body.length;
    n += o, r++;
    const a = {
      body: i.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: t.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions
    };
    if (!e)
      return cS("fetch"), Zd("No fetch implementation available");
    try {
      return e(t.url, a).then((c) => (n -= o, r--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }));
    } catch (c) {
      return cS("fetch"), n -= o, r--, Zd(c);
    }
  }
  return tK(t, s);
}
const sZ = 30, iZ = 50;
function bg(t, e, n, r) {
  const s = {
    filename: t,
    function: e === "<anonymous>" ? Qi : e,
    in_app: !0
    // All browser frames are considered in_app
  };
  return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s;
}
const oZ = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i, aZ = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, cZ = /\((\S*)(?::(\d+))(?::(\d+))\)/, lZ = (t) => {
  const e = oZ.exec(t);
  if (e) {
    const [, r, s, i] = e;
    return bg(r, Qi, +s, +i);
  }
  const n = aZ.exec(t);
  if (n) {
    if (n[2] && n[2].indexOf("eval") === 0) {
      const o = cZ.exec(n[2]);
      o && (n[2] = o[1], n[3] = o[2], n[4] = o[3]);
    }
    const [s, i] = VM(n[1] || Qi, n[2]);
    return bg(i, s, n[3] ? +n[3] : void 0, n[4] ? +n[4] : void 0);
  }
}, uZ = [sZ, lZ], dZ = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, fZ = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, hZ = (t) => {
  const e = dZ.exec(t);
  if (e) {
    if (e[3] && e[3].indexOf(" > eval") > -1) {
      const i = fZ.exec(e[3]);
      i && (e[1] = e[1] || "eval", e[3] = i[1], e[4] = i[2], e[5] = "");
    }
    let r = e[3], s = e[1] || Qi;
    return [s, r] = VM(s, r), bg(r, s, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0);
  }
}, pZ = [iZ, hZ], mZ = [uZ, pZ], gZ = LR(...mZ), VM = (t, e) => {
  const n = t.indexOf("safari-extension") !== -1, r = t.indexOf("safari-web-extension") !== -1;
  return n || r ? [
    t.indexOf("@") !== -1 ? t.split("@")[0] : Qi,
    n ? `safari-extension:${e}` : `safari-web-extension:${e}`
  ] : [t, e];
}, Tu = 1024, yZ = "Breadcrumbs", bZ = (t = {}) => {
  const e = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...t
  };
  return {
    name: yZ,
    setup(n) {
      e.console && z8(AZ(n)), e.dom && jM(wZ(n, e.dom)), e.xhr && FM(SZ(n)), e.fetch && FR(EZ(n)), e.history && fh(CZ(n)), e.sentry && n.on("beforeSendEvent", xZ(n));
    }
  };
}, vZ = bZ;
function xZ(t) {
  return function(n) {
    ke() === t && bs(
      {
        category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
        event_id: n.event_id,
        level: n.level,
        message: Ms(n)
      },
      {
        event: n
      }
    );
  };
}
function wZ(t, e) {
  return function(r) {
    if (ke() !== t)
      return;
    let s, i, o = typeof e == "object" ? e.serializeAttribute : void 0, a = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
    a && a > Tu && (Rn && H.warn(
      `\`dom.maxStringLength\` cannot exceed ${Tu}, but a value of ${a} was configured. Sentry will use ${Tu} instead.`
    ), a = Tu), typeof o == "string" && (o = [o]);
    try {
      const l = r.event, u = _Z(l) ? l.target : l;
      s = ps(u, { keyAttrs: o, maxStringLength: a }), i = PR(u);
    } catch {
      s = "<unknown>";
    }
    if (s.length === 0)
      return;
    const c = {
      category: `ui.${r.name}`,
      message: s
    };
    i && (c.data = { "ui.component_name": i }), bs(c, {
      event: r.event,
      name: r.name,
      global: r.global
    });
  };
}
function AZ(t) {
  return function(n) {
    if (ke() !== t)
      return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: GR(n.level),
      message: xA(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1)
        r.message = `Assertion failed: ${xA(n.args.slice(1), " ") || "console.assert"}`, r.data.arguments = n.args.slice(1);
      else
        return;
    bs(r, {
      input: n.args,
      level: n.level
    });
  };
}
function SZ(t) {
  return function(n) {
    if (ke() !== t)
      return;
    const { startTimestamp: r, endTimestamp: s } = n, i = n.xhr[Ri];
    if (!r || !s || !i)
      return;
    const { method: o, url: a, status_code: c, body: l } = i, u = {
      method: o,
      url: a,
      status_code: c
    }, d = {
      xhr: n.xhr,
      input: l,
      startTimestamp: r,
      endTimestamp: s
    }, f = RR(c);
    bs(
      {
        category: "xhr",
        data: u,
        type: "http",
        level: f
      },
      d
    );
  };
}
function EZ(t) {
  return function(n) {
    if (ke() !== t)
      return;
    const { startTimestamp: r, endTimestamp: s } = n;
    if (s && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.error) {
        const i = n.fetchData, o = {
          data: n.error,
          input: n.args,
          startTimestamp: r,
          endTimestamp: s
        };
        bs(
          {
            category: "fetch",
            data: i,
            level: "error",
            type: "http"
          },
          o
        );
      } else {
        const i = n.response, o = {
          ...n.fetchData,
          status_code: i && i.status
        }, a = {
          input: n.args,
          response: i,
          startTimestamp: r,
          endTimestamp: s
        }, c = RR(o.status_code);
        bs(
          {
            category: "fetch",
            data: o,
            type: "http",
            level: c
          },
          a
        );
      }
  };
}
function CZ(t) {
  return function(n) {
    if (ke() !== t)
      return;
    let r = n.from, s = n.to;
    const i = Li(oe.location.href);
    let o = r ? Li(r) : void 0;
    const a = Li(s);
    (!o || !o.path) && (o = i), i.protocol === a.protocol && i.host === a.host && (s = a.relative), i.protocol === o.protocol && i.host === o.host && (r = o.relative), bs({
      category: "navigation",
      data: {
        from: r,
        to: s
      }
    });
  };
}
function _Z(t) {
  return !!t && !!t.target;
}
const TZ = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], kZ = "BrowserApiErrors", RZ = (t = {}) => {
  const e = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    ...t
  };
  return {
    name: kZ,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      e.setTimeout && _n(oe, "setTimeout", uS), e.setInterval && _n(oe, "setInterval", uS), e.requestAnimationFrame && _n(oe, "requestAnimationFrame", PZ), e.XMLHttpRequest && "XMLHttpRequest" in oe && _n(XMLHttpRequest.prototype, "send", IZ);
      const n = e.eventTarget;
      n && (Array.isArray(n) ? n : TZ).forEach(DZ);
    }
  };
}, MZ = RZ;
function uS(t) {
  return function(...e) {
    const n = e[0];
    return e[0] = ca(n, {
      mechanism: {
        data: { function: ms(t) },
        handled: !1,
        type: "instrument"
      }
    }), t.apply(this, e);
  };
}
function PZ(t) {
  return function(e) {
    return t.apply(this, [
      ca(e, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: ms(t)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function IZ(t) {
  return function(...e) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((s) => {
      s in n && typeof n[s] == "function" && _n(n, s, function(i) {
        const o = {
          mechanism: {
            data: {
              function: s,
              handler: ms(i)
            },
            handled: !1,
            type: "instrument"
          }
        }, a = kb(i);
        return a && (o.mechanism.data.handler = ms(a)), ca(i, o);
      });
    }), t.apply(this, e);
  };
}
function DZ(t) {
  const e = oe, n = e[t] && e[t].prototype;
  !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (_n(n, "addEventListener", function(r) {
    return function(s, i, o) {
      try {
        typeof i.handleEvent == "function" && (i.handleEvent = ca(i.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: ms(i),
              target: t
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return r.apply(this, [
        s,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ca(i, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: ms(i),
              target: t
            },
            handled: !1,
            type: "instrument"
          }
        }),
        o
      ]);
    };
  }), _n(
    n,
    "removeEventListener",
    function(r) {
      return function(s, i, o) {
        const a = i;
        try {
          const c = a && a.__sentry_wrapped__;
          c && r.call(this, s, c, o);
        } catch {
        }
        return r.call(this, s, a, o);
      };
    }
  ));
}
const OZ = "GlobalHandlers", qZ = (t = {}) => {
  const e = {
    onerror: !0,
    onunhandledrejection: !0,
    ...t
  };
  return {
    name: OZ,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(n) {
      e.onerror && (LZ(n), dS("onerror")), e.onunhandledrejection && (jZ(n), dS("onunhandledrejection"));
    }
  };
}, NZ = qZ;
function LZ(t) {
  UR((e) => {
    const { stackParser: n, attachStacktrace: r } = UM();
    if (ke() !== t || SM())
      return;
    const { msg: s, url: i, line: o, column: a, error: c } = e, l = VZ(
      Vb(n, c || s, void 0, r, !1),
      i,
      o,
      a
    );
    l.level = "error", Lb(l, {
      originalException: c,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    });
  });
}
function jZ(t) {
  WR((e) => {
    const { stackParser: n, attachStacktrace: r } = UM();
    if (ke() !== t || SM())
      return;
    const s = BZ(e), i = Tb(s) ? FZ(s) : Vb(n, s, void 0, r, !0);
    i.level = "error", Lb(i, {
      originalException: s,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    });
  });
}
function BZ(t) {
  if (Tb(t))
    return t;
  try {
    if ("reason" in t)
      return t.reason;
    if ("detail" in t && "reason" in t.detail)
      return t.detail.reason;
  } catch {
  }
  return t;
}
function FZ(t) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(t)}`
        }
      ]
    }
  };
}
function VZ(t, e, n, r) {
  const s = t.exception = t.exception || {}, i = s.values = s.values || [], o = i[0] = i[0] || {}, a = o.stacktrace = o.stacktrace || {}, c = a.frames = a.frames || [], l = isNaN(parseInt(r, 10)) ? void 0 : r, u = isNaN(parseInt(n, 10)) ? void 0 : n, d = as(e) && e.length > 0 ? e : MR();
  return c.length === 0 && c.push({
    colno: l,
    filename: d,
    function: Qi,
    in_app: !0,
    lineno: u
  }), t;
}
function dS(t) {
  Rn && H.log(`Global Handler attached: ${t}`);
}
function UM() {
  const t = ke();
  return t && t.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  };
}
const UZ = () => ({
  name: "HttpContext",
  preprocessEvent(t) {
    if (!oe.navigator && !oe.location && !oe.document)
      return;
    const e = t.request && t.request.url || oe.location && oe.location.href, { referrer: n } = oe.document || {}, { userAgent: r } = oe.navigator || {}, s = {
      ...t.request && t.request.headers,
      ...n && { Referer: n },
      ...r && { "User-Agent": r }
    }, i = { ...t.request, ...e && { url: e }, headers: s };
    t.request = i;
  }
}), WZ = "cause", zZ = 5, HZ = "LinkedErrors", YZ = (t = {}) => {
  const e = t.limit || zZ, n = t.key || WZ;
  return {
    name: HZ,
    preprocessEvent(r, s, i) {
      const o = i.getOptions();
      k8(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        Bb,
        o.stackParser,
        o.maxValueLength,
        n,
        e,
        r,
        s
      );
    }
  };
}, GZ = YZ;
function KZ(t) {
  return [
    fK(),
    cK(),
    MZ(),
    vZ(),
    NZ(),
    GZ(),
    CK(),
    UZ()
  ];
}
function $Z(t = {}) {
  const e = {
    defaultIntegrations: KZ(),
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : oe.SENTRY_RELEASE && oe.SENTRY_RELEASE.id ? oe.SENTRY_RELEASE.id : void 0,
    autoSessionTracking: !0,
    sendClientReports: !0
  };
  return t.defaultIntegrations == null && delete t.defaultIntegrations, { ...e, ...t };
}
function ZZ() {
  const t = typeof oe.window < "u" && oe;
  if (!t)
    return !1;
  const e = t.chrome ? "chrome" : "browser", n = t[e], r = n && n.runtime && n.runtime.id, s = oe.location && oe.location.href || "", i = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"], o = !!r && oe === oe.top && i.some((c) => s.startsWith(`${c}//`)), a = typeof t.nw < "u";
  return !!r && !o && !a;
}
function QZ(t = {}) {
  const e = $Z(t);
  if (ZZ()) {
    Pa(() => {
      console.error(
        "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
      );
    });
    return;
  }
  Rn && (jR() || H.warn(
    "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
  ));
  const n = {
    ...e,
    stackParser: U8(e.stackParser || gZ),
    integrations: GG(e),
    transport: e.transport || rZ
  }, r = XG(ZK, n);
  return e.autoSessionTracking && XZ(), r;
}
function fS(t = {}) {
  if (!oe.document) {
    Rn && H.error("Global document not defined in showReportDialog call");
    return;
  }
  const e = Fe(), n = e.getClient(), r = n && n.getDsn();
  if (!r) {
    Rn && H.error("DSN not configured for showReportDialog call");
    return;
  }
  if (e && (t.user = {
    ...e.getUser(),
    ...t.user
  }), !t.eventId) {
    const a = BG();
    a && (t.eventId = a);
  }
  const s = oe.document.createElement("script");
  s.async = !0, s.crossOrigin = "anonymous", s.src = HG(r, t), t.onLoad && (s.onload = t.onLoad);
  const { onClose: i } = t;
  if (i) {
    const a = (c) => {
      if (c.data === "__sentry_reportdialog_closed__")
        try {
          i();
        } finally {
          oe.removeEventListener("message", a);
        }
    };
    oe.addEventListener("message", a);
  }
  const o = oe.document.head || oe.document.body;
  o ? o.appendChild(s) : Rn && H.error("Not injecting report dialog. No injection point found in HTML");
}
function XZ() {
  if (typeof oe.document > "u") {
    Rn && H.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  dg({ ignoreDuration: !0 }), GA(), fh(({ from: t, to: e }) => {
    t !== void 0 && t !== e && (dg({ ignoreDuration: !0 }), GA());
  });
}
const lt = Oe, Hb = "sentryReplaySession", JZ = "replay_event", Yb = "Unable to send Replay", eQ = 3e5, tQ = 9e5, nQ = 5e3, rQ = 5500, sQ = 6e4, iQ = 5e3, oQ = 3, hS = 15e4, ku = 5e3, aQ = 3e3, cQ = 300, Gb = 2e7, lQ = 4999, uQ = 15e3, pS = 36e5;
function vg(t, e) {
  return t ?? e();
}
function cl(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], i = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = i(n)) : (s === "call" || s === "optionalCall") && (n = i((...o) => n.call(e, ...o)), e = void 0);
  }
  return n;
}
var Bt;
(function(t) {
  t[t.Document = 0] = "Document", t[t.DocumentType = 1] = "DocumentType", t[t.Element = 2] = "Element", t[t.Text = 3] = "Text", t[t.CDATA = 4] = "CDATA", t[t.Comment = 5] = "Comment";
})(Bt || (Bt = {}));
function dQ(t) {
  return t.nodeType === t.ELEMENT_NODE;
}
function Cc(t) {
  const e = cl([t, "optionalAccess", (n) => n.host]);
  return cl([e, "optionalAccess", (n) => n.shadowRoot]) === t;
}
function _c(t) {
  return Object.prototype.toString.call(t) === "[object ShadowRoot]";
}
function fQ(t) {
  return t.includes(" background-clip: text;") && !t.includes(" -webkit-background-clip: text;") && (t = t.replace(/\sbackground-clip:\s*text;/g, " -webkit-background-clip: text; background-clip: text;")), t;
}
function hQ(t) {
  const { cssText: e } = t;
  if (e.split('"').length < 3)
    return e;
  const n = ["@import", `url(${JSON.stringify(t.href)})`];
  return t.layerName === "" ? n.push("layer") : t.layerName && n.push(`layer(${t.layerName})`), t.supportsText && n.push(`supports(${t.supportsText})`), t.media.length && n.push(t.media.mediaText), n.join(" ") + ";";
}
function sf(t) {
  try {
    const e = t.rules || t.cssRules;
    return e ? fQ(Array.from(e, WM).join("")) : null;
  } catch {
    return null;
  }
}
function WM(t) {
  let e;
  if (mQ(t))
    try {
      e = sf(t.styleSheet) || hQ(t);
    } catch {
    }
  else if (gQ(t) && t.selectorText.includes(":"))
    return pQ(t.cssText);
  return e || t.cssText;
}
function pQ(t) {
  const e = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return t.replace(e, "$1\\$2");
}
function mQ(t) {
  return "styleSheet" in t;
}
function gQ(t) {
  return "selectorText" in t;
}
class zM {
  constructor() {
    this.idNodeMap = /* @__PURE__ */ new Map(), this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
  getId(e) {
    if (!e)
      return -1;
    const n = cl([this, "access", (r) => r.getMeta, "call", (r) => r(e), "optionalAccess", (r) => r.id]);
    return vg(n, () => -1);
  }
  getNode(e) {
    return this.idNodeMap.get(e) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(e) {
    return this.nodeMetaMap.get(e) || null;
  }
  removeNodeFromMap(e) {
    const n = this.getId(e);
    this.idNodeMap.delete(n), e.childNodes && e.childNodes.forEach((r) => this.removeNodeFromMap(r));
  }
  has(e) {
    return this.idNodeMap.has(e);
  }
  hasNode(e) {
    return this.nodeMetaMap.has(e);
  }
  add(e, n) {
    const r = n.id;
    this.idNodeMap.set(r, e), this.nodeMetaMap.set(e, n);
  }
  replace(e, n) {
    const r = this.getNode(e);
    if (r) {
      const s = this.nodeMetaMap.get(r);
      s && this.nodeMetaMap.set(n, s);
    }
    this.idNodeMap.set(e, n);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map(), this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function yQ() {
  return new zM();
}
function hh({ maskInputOptions: t, tagName: e, type: n }) {
  return e === "OPTION" && (e = "SELECT"), !!(t[e.toLowerCase()] || n && t[n] || n === "password" || e === "INPUT" && !n && t.text);
}
function ll({ isMasked: t, element: e, value: n, maskInputFn: r }) {
  let s = n || "";
  return t ? (r && (s = r(s, e)), "*".repeat(s.length)) : s;
}
function fa(t) {
  return t.toLowerCase();
}
function xg(t) {
  return t.toUpperCase();
}
const mS = "__rrweb_original__";
function bQ(t) {
  const e = t.getContext("2d");
  if (!e)
    return !0;
  const n = 50;
  for (let r = 0; r < t.width; r += n)
    for (let s = 0; s < t.height; s += n) {
      const i = e.getImageData, o = mS in i ? i[mS] : i;
      if (new Uint32Array(o.call(e, r, s, Math.min(n, t.width - r), Math.min(n, t.height - s)).data.buffer).some((c) => c !== 0))
        return !1;
    }
  return !0;
}
function Kb(t) {
  const e = t.type;
  return t.hasAttribute("data-rr-is-password") ? "password" : e ? fa(e) : null;
}
function of(t, e, n) {
  return e === "INPUT" && (n === "radio" || n === "checkbox") ? t.getAttribute("value") || "" : t.value;
}
function HM(t, e) {
  let n;
  try {
    n = new URL(t, vg(e, () => window.location.href));
  } catch {
    return null;
  }
  const r = /\.([0-9a-z]+)(?:$)/i, s = n.pathname.match(r);
  return vg(cl([s, "optionalAccess", (i) => i[1]]), () => null);
}
const gS = {};
function YM(t) {
  const e = gS[t];
  if (e)
    return e;
  const n = window.document;
  let r = window[t];
  if (n && typeof n.createElement == "function")
    try {
      const s = n.createElement("iframe");
      s.hidden = !0, n.head.appendChild(s);
      const i = s.contentWindow;
      i && i[t] && (r = i[t]), n.head.removeChild(s);
    } catch {
    }
  return gS[t] = r.bind(window);
}
function wg(...t) {
  return YM("setTimeout")(...t);
}
function GM(...t) {
  return YM("clearTimeout")(...t);
}
let vQ = 1;
const xQ = new RegExp("[^a-z0-9-_:]"), ul = -2;
function $b() {
  return vQ++;
}
function wQ(t) {
  if (t instanceof HTMLFormElement)
    return "form";
  const e = fa(t.tagName);
  return xQ.test(e) ? "div" : e;
}
function AQ(t) {
  let e = "";
  return t.indexOf("//") > -1 ? e = t.split("/").slice(0, 3).join("/") : e = t.split("/")[0], e = e.split("?")[0], e;
}
let vo, yS;
const SQ = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, EQ = /^(?:[a-z+]+:)?\/\//i, CQ = /^www\..*/i, _Q = /^(data:)([^,]*),(.*)/i;
function af(t, e) {
  return (t || "").replace(SQ, (n, r, s, i, o, a) => {
    const c = s || o || a, l = r || i || "";
    if (!c)
      return n;
    if (EQ.test(c) || CQ.test(c))
      return `url(${l}${c}${l})`;
    if (_Q.test(c))
      return `url(${l}${c}${l})`;
    if (c[0] === "/")
      return `url(${l}${AQ(e) + c}${l})`;
    const u = e.split("/"), d = c.split("/");
    u.pop();
    for (const f of d)
      f !== "." && (f === ".." ? u.pop() : u.push(f));
    return `url(${l}${u.join("/")}${l})`;
  });
}
const TQ = /^[^ \t\n\r\u000c]+/, kQ = /^[, \t\n\r\u000c]+/;
function RQ(t, e) {
  if (e.trim() === "")
    return e;
  let n = 0;
  function r(i) {
    let o;
    const a = i.exec(e.substring(n));
    return a ? (o = a[0], n += o.length, o) : "";
  }
  const s = [];
  for (; r(kQ), !(n >= e.length); ) {
    let i = r(TQ);
    if (i.slice(-1) === ",")
      i = Po(t, i.substring(0, i.length - 1)), s.push(i);
    else {
      let o = "";
      i = Po(t, i);
      let a = !1;
      for (; ; ) {
        const c = e.charAt(n);
        if (c === "") {
          s.push((i + o).trim());
          break;
        } else if (a)
          c === ")" && (a = !1);
        else if (c === ",") {
          n += 1, s.push((i + o).trim());
          break;
        } else c === "(" && (a = !0);
        o += c, n += 1;
      }
    }
  }
  return s.join(", ");
}
const bS = /* @__PURE__ */ new WeakMap();
function Po(t, e) {
  return !e || e.trim() === "" ? e : ph(t, e);
}
function MQ(t) {
  return !!(t.tagName === "svg" || t.ownerSVGElement);
}
function ph(t, e) {
  let n = bS.get(t);
  if (n || (n = t.createElement("a"), bS.set(t, n)), !e)
    e = "";
  else if (e.startsWith("blob:") || e.startsWith("data:"))
    return e;
  return n.setAttribute("href", e), n.href;
}
function KM(t, e, n, r, s, i) {
  return r && (n === "src" || n === "href" && !(e === "use" && r[0] === "#") || n === "xlink:href" && r[0] !== "#" || n === "background" && (e === "table" || e === "td" || e === "th") ? Po(t, r) : n === "srcset" ? RQ(t, r) : n === "style" ? af(r, ph(t)) : e === "object" && n === "data" ? Po(t, r) : typeof i == "function" ? i(n, r, s) : r);
}
function $M(t, e, n) {
  return (t === "video" || t === "audio") && e === "autoplay";
}
function PQ(t, e, n, r) {
  try {
    if (r && t.matches(r))
      return !1;
    if (typeof e == "string") {
      if (t.classList.contains(e))
        return !0;
    } else
      for (let s = t.classList.length; s--; ) {
        const i = t.classList[s];
        if (e.test(i))
          return !0;
      }
    if (n)
      return t.matches(n);
  } catch {
  }
  return !1;
}
function IQ(t, e) {
  for (let n = t.classList.length; n--; ) {
    const r = t.classList[n];
    if (e.test(r))
      return !0;
  }
  return !1;
}
function Mi(t, e, n = 1 / 0, r = 0) {
  return !t || t.nodeType !== t.ELEMENT_NODE || r > n ? -1 : e(t) ? r : Mi(t.parentNode, e, n, r + 1);
}
function Io(t, e) {
  return (n) => {
    const r = n;
    if (r === null)
      return !1;
    try {
      if (t) {
        if (typeof t == "string") {
          if (r.matches(`.${t}`))
            return !0;
        } else if (IQ(r, t))
          return !0;
      }
      return !!(e && r.matches(e));
    } catch {
      return !1;
    }
  };
}
function ha(t, e, n, r, s, i) {
  try {
    const o = t.nodeType === t.ELEMENT_NODE ? t : t.parentElement;
    if (o === null)
      return !1;
    if (o.tagName === "INPUT") {
      const l = o.getAttribute("autocomplete");
      if ([
        "current-password",
        "new-password",
        "cc-number",
        "cc-exp",
        "cc-exp-month",
        "cc-exp-year",
        "cc-csc"
      ].includes(l))
        return !0;
    }
    let a = -1, c = -1;
    if (i) {
      if (c = Mi(o, Io(r, s)), c < 0)
        return !0;
      a = Mi(o, Io(e, n), c >= 0 ? c : 1 / 0);
    } else {
      if (a = Mi(o, Io(e, n)), a < 0)
        return !1;
      c = Mi(o, Io(r, s), a >= 0 ? a : 1 / 0);
    }
    return a >= 0 ? c >= 0 ? a <= c : !0 : c >= 0 ? !1 : !!i;
  } catch {
  }
  return !!i;
}
function DQ(t, e, n) {
  const r = t.contentWindow;
  if (!r)
    return;
  let s = !1, i;
  try {
    i = r.document.readyState;
  } catch {
    return;
  }
  if (i !== "complete") {
    const a = wg(() => {
      s || (e(), s = !0);
    }, n);
    t.addEventListener("load", () => {
      GM(a), s = !0, e();
    });
    return;
  }
  const o = "about:blank";
  if (r.location.href !== o || t.src === o || t.src === "")
    return wg(e, 0), t.addEventListener("load", e);
  t.addEventListener("load", e);
}
function OQ(t, e, n) {
  let r = !1, s;
  try {
    s = t.sheet;
  } catch {
    return;
  }
  if (s)
    return;
  const i = wg(() => {
    r || (e(), r = !0);
  }, n);
  t.addEventListener("load", () => {
    GM(i), r = !0, e();
  });
}
function qQ(t, e) {
  const { doc: n, mirror: r, blockClass: s, blockSelector: i, unblockSelector: o, maskAllText: a, maskAttributeFn: c, maskTextClass: l, unmaskTextClass: u, maskTextSelector: d, unmaskTextSelector: f, inlineStylesheet: h, maskInputOptions: p = {}, maskTextFn: m, maskInputFn: y, dataURLOptions: b = {}, inlineImages: v, recordCanvas: w, keepIframeSrcFn: x, newlyAddedElement: A = !1 } = e, C = NQ(n, r);
  switch (t.nodeType) {
    case t.DOCUMENT_NODE:
      return t.compatMode !== "CSS1Compat" ? {
        type: Bt.Document,
        childNodes: [],
        compatMode: t.compatMode
      } : {
        type: Bt.Document,
        childNodes: []
      };
    case t.DOCUMENT_TYPE_NODE:
      return {
        type: Bt.DocumentType,
        name: t.name,
        publicId: t.publicId,
        systemId: t.systemId,
        rootId: C
      };
    case t.ELEMENT_NODE:
      return jQ(t, {
        doc: n,
        blockClass: s,
        blockSelector: i,
        unblockSelector: o,
        inlineStylesheet: h,
        maskAttributeFn: c,
        maskInputOptions: p,
        maskInputFn: y,
        dataURLOptions: b,
        inlineImages: v,
        recordCanvas: w,
        keepIframeSrcFn: x,
        newlyAddedElement: A,
        rootId: C,
        maskAllText: a,
        maskTextClass: l,
        unmaskTextClass: u,
        maskTextSelector: d,
        unmaskTextSelector: f
      });
    case t.TEXT_NODE:
      return LQ(t, {
        doc: n,
        maskAllText: a,
        maskTextClass: l,
        unmaskTextClass: u,
        maskTextSelector: d,
        unmaskTextSelector: f,
        maskTextFn: m,
        maskInputOptions: p,
        maskInputFn: y,
        rootId: C
      });
    case t.CDATA_SECTION_NODE:
      return {
        type: Bt.CDATA,
        textContent: "",
        rootId: C
      };
    case t.COMMENT_NODE:
      return {
        type: Bt.Comment,
        textContent: t.textContent || "",
        rootId: C
      };
    default:
      return !1;
  }
}
function NQ(t, e) {
  if (!e.hasNode(t))
    return;
  const n = e.getId(t);
  return n === 1 ? void 0 : n;
}
function LQ(t, e) {
  const { maskAllText: n, maskTextClass: r, unmaskTextClass: s, maskTextSelector: i, unmaskTextSelector: o, maskTextFn: a, maskInputOptions: c, maskInputFn: l, rootId: u } = e, d = t.parentNode && t.parentNode.tagName;
  let f = t.textContent;
  const h = d === "STYLE" ? !0 : void 0, p = d === "SCRIPT" ? !0 : void 0, m = d === "TEXTAREA" ? !0 : void 0;
  if (h && f) {
    try {
      t.nextSibling || t.previousSibling || cl([t, "access", (b) => b.parentNode, "access", (b) => b.sheet, "optionalAccess", (b) => b.cssRules]) && (f = sf(t.parentNode.sheet));
    } catch (b) {
      console.warn(`Cannot get CSS styles from text's parentNode. Error: ${b}`, t);
    }
    f = af(f, ph(e.doc));
  }
  p && (f = "SCRIPT_PLACEHOLDER");
  const y = ha(t, r, i, s, o, n);
  if (!h && !p && !m && f && y && (f = a ? a(f, t.parentElement) : f.replace(/[\S]/g, "*")), m && f && (c.textarea || y) && (f = l ? l(f, t.parentNode) : f.replace(/[\S]/g, "*")), d === "OPTION" && f) {
    const b = hh({
      type: null,
      tagName: d,
      maskInputOptions: c
    });
    f = ll({
      isMasked: ha(t, r, i, s, o, b),
      element: t,
      value: f,
      maskInputFn: l
    });
  }
  return {
    type: Bt.Text,
    textContent: f || "",
    isStyle: h,
    rootId: u
  };
}
function jQ(t, e) {
  const { doc: n, blockClass: r, blockSelector: s, unblockSelector: i, inlineStylesheet: o, maskInputOptions: a = {}, maskAttributeFn: c, maskInputFn: l, dataURLOptions: u = {}, inlineImages: d, recordCanvas: f, keepIframeSrcFn: h, newlyAddedElement: p = !1, rootId: m, maskAllText: y, maskTextClass: b, unmaskTextClass: v, maskTextSelector: w, unmaskTextSelector: x } = e, A = PQ(t, r, s, i), C = wQ(t);
  let S = {};
  const _ = t.attributes.length;
  for (let k = 0; k < _; k++) {
    const R = t.attributes[k];
    R.name && !$M(C, R.name, R.value) && (S[R.name] = KM(n, C, fa(R.name), R.value, t, c));
  }
  if (C === "link" && o) {
    const k = Array.from(n.styleSheets).find((P) => P.href === t.href);
    let R = null;
    k && (R = sf(k)), R && (delete S.rel, delete S.href, S._cssText = af(R, k.href));
  }
  if (C === "style" && t.sheet && !(t.innerText || t.textContent || "").trim().length) {
    const k = sf(t.sheet);
    k && (S._cssText = af(k, ph(n)));
  }
  if (C === "input" || C === "textarea" || C === "select" || C === "option") {
    const k = t, R = Kb(k), P = of(k, xg(C), R), M = k.checked;
    if (R !== "submit" && R !== "button" && P) {
      const D = ha(k, b, w, v, x, hh({
        type: R,
        tagName: xg(C),
        maskInputOptions: a
      }));
      S.value = ll({
        isMasked: D,
        element: k,
        value: P,
        maskInputFn: l
      });
    }
    M && (S.checked = M);
  }
  if (C === "option" && (t.selected && !a.select ? S.selected = !0 : delete S.selected), C === "canvas" && f) {
    if (t.__context === "2d")
      bQ(t) || (S.rr_dataURL = t.toDataURL(u.type, u.quality));
    else if (!("__context" in t)) {
      const k = t.toDataURL(u.type, u.quality), R = n.createElement("canvas");
      R.width = t.width, R.height = t.height;
      const P = R.toDataURL(u.type, u.quality);
      k !== P && (S.rr_dataURL = k);
    }
  }
  if (C === "img" && d) {
    vo || (vo = n.createElement("canvas"), yS = vo.getContext("2d"));
    const k = t, R = k.currentSrc || k.getAttribute("src") || "<unknown-src>", P = k.crossOrigin, M = () => {
      k.removeEventListener("load", M);
      try {
        vo.width = k.naturalWidth, vo.height = k.naturalHeight, yS.drawImage(k, 0, 0), S.rr_dataURL = vo.toDataURL(u.type, u.quality);
      } catch (D) {
        if (k.crossOrigin !== "anonymous") {
          k.crossOrigin = "anonymous", k.complete && k.naturalWidth !== 0 ? M() : k.addEventListener("load", M);
          return;
        } else
          console.warn(`Cannot inline img src=${R}! Error: ${D}`);
      }
      k.crossOrigin === "anonymous" && (P ? S.crossOrigin = P : k.removeAttribute("crossorigin"));
    };
    k.complete && k.naturalWidth !== 0 ? M() : k.addEventListener("load", M);
  }
  if ((C === "audio" || C === "video") && (S.rr_mediaState = t.paused ? "paused" : "played", S.rr_mediaCurrentTime = t.currentTime), p || (t.scrollLeft && (S.rr_scrollLeft = t.scrollLeft), t.scrollTop && (S.rr_scrollTop = t.scrollTop)), A) {
    const { width: k, height: R } = t.getBoundingClientRect();
    S = {
      class: S.class,
      rr_width: `${k}px`,
      rr_height: `${R}px`
    };
  }
  C === "iframe" && !h(S.src) && (!A && !t.contentDocument && (S.rr_src = S.src), delete S.src);
  let T;
  try {
    customElements.get(C) && (T = !0);
  } catch {
  }
  return {
    type: Bt.Element,
    tagName: C,
    attributes: S,
    childNodes: [],
    isSVG: MQ(t) || void 0,
    needBlock: A,
    rootId: m,
    isCustom: T
  };
}
function ct(t) {
  return t == null ? "" : t.toLowerCase();
}
function BQ(t, e) {
  if (e.comment && t.type === Bt.Comment)
    return !0;
  if (t.type === Bt.Element) {
    if (e.script && (t.tagName === "script" || t.tagName === "link" && (t.attributes.rel === "preload" || t.attributes.rel === "modulepreload") && t.attributes.as === "script" || t.tagName === "link" && t.attributes.rel === "prefetch" && typeof t.attributes.href == "string" && HM(t.attributes.href) === "js"))
      return !0;
    if (e.headFavicon && (t.tagName === "link" && t.attributes.rel === "shortcut icon" || t.tagName === "meta" && (ct(t.attributes.name).match(/^msapplication-tile(image|color)$/) || ct(t.attributes.name) === "application-name" || ct(t.attributes.rel) === "icon" || ct(t.attributes.rel) === "apple-touch-icon" || ct(t.attributes.rel) === "shortcut icon")))
      return !0;
    if (t.tagName === "meta") {
      if (e.headMetaDescKeywords && ct(t.attributes.name).match(/^description|keywords$/))
        return !0;
      if (e.headMetaSocial && (ct(t.attributes.property).match(/^(og|twitter|fb):/) || ct(t.attributes.name).match(/^(og|twitter):/) || ct(t.attributes.name) === "pinterest"))
        return !0;
      if (e.headMetaRobots && (ct(t.attributes.name) === "robots" || ct(t.attributes.name) === "googlebot" || ct(t.attributes.name) === "bingbot"))
        return !0;
      if (e.headMetaHttpEquiv && t.attributes["http-equiv"] !== void 0)
        return !0;
      if (e.headMetaAuthorship && (ct(t.attributes.name) === "author" || ct(t.attributes.name) === "generator" || ct(t.attributes.name) === "framework" || ct(t.attributes.name) === "publisher" || ct(t.attributes.name) === "progid" || ct(t.attributes.property).match(/^article:/) || ct(t.attributes.property).match(/^product:/)))
        return !0;
      if (e.headMetaVerification && (ct(t.attributes.name) === "google-site-verification" || ct(t.attributes.name) === "yandex-verification" || ct(t.attributes.name) === "csrf-token" || ct(t.attributes.name) === "p:domain_verify" || ct(t.attributes.name) === "verify-v1" || ct(t.attributes.name) === "verification" || ct(t.attributes.name) === "shopify-checkout-api-token"))
        return !0;
    }
  }
  return !1;
}
function Do(t, e) {
  const { doc: n, mirror: r, blockClass: s, blockSelector: i, unblockSelector: o, maskAllText: a, maskTextClass: c, unmaskTextClass: l, maskTextSelector: u, unmaskTextSelector: d, skipChild: f = !1, inlineStylesheet: h = !0, maskInputOptions: p = {}, maskAttributeFn: m, maskTextFn: y, maskInputFn: b, slimDOMOptions: v, dataURLOptions: w = {}, inlineImages: x = !1, recordCanvas: A = !1, onSerialize: C, onIframeLoad: S, iframeLoadTimeout: _ = 5e3, onStylesheetLoad: T, stylesheetLoadTimeout: k = 5e3, keepIframeSrcFn: R = () => !1, newlyAddedElement: P = !1 } = e;
  let { preserveWhiteSpace: M = !0 } = e;
  const D = qQ(t, {
    doc: n,
    mirror: r,
    blockClass: s,
    blockSelector: i,
    maskAllText: a,
    unblockSelector: o,
    maskTextClass: c,
    unmaskTextClass: l,
    maskTextSelector: u,
    unmaskTextSelector: d,
    inlineStylesheet: h,
    maskInputOptions: p,
    maskAttributeFn: m,
    maskTextFn: y,
    maskInputFn: b,
    dataURLOptions: w,
    inlineImages: x,
    recordCanvas: A,
    keepIframeSrcFn: R,
    newlyAddedElement: P
  });
  if (!D)
    return console.warn(t, "not serialized"), null;
  let O;
  r.hasNode(t) ? O = r.getId(t) : BQ(D, v) || !M && D.type === Bt.Text && !D.isStyle && !D.textContent.replace(/^\s+|\s+$/gm, "").length ? O = ul : O = $b();
  const q = Object.assign(D, { id: O });
  if (r.add(t, q), O === ul)
    return null;
  C && C(t);
  let L = !f;
  if (q.type === Bt.Element) {
    L = L && !q.needBlock, delete q.needBlock;
    const N = t.shadowRoot;
    N && _c(N) && (q.isShadowHost = !0);
  }
  if ((q.type === Bt.Document || q.type === Bt.Element) && L) {
    v.headWhitespace && q.type === Bt.Element && q.tagName === "head" && (M = !1);
    const N = {
      doc: n,
      mirror: r,
      blockClass: s,
      blockSelector: i,
      maskAllText: a,
      unblockSelector: o,
      maskTextClass: c,
      unmaskTextClass: l,
      maskTextSelector: u,
      unmaskTextSelector: d,
      skipChild: f,
      inlineStylesheet: h,
      maskInputOptions: p,
      maskAttributeFn: m,
      maskTextFn: y,
      maskInputFn: b,
      slimDOMOptions: v,
      dataURLOptions: w,
      inlineImages: x,
      recordCanvas: A,
      preserveWhiteSpace: M,
      onSerialize: C,
      onIframeLoad: S,
      iframeLoadTimeout: _,
      onStylesheetLoad: T,
      stylesheetLoadTimeout: k,
      keepIframeSrcFn: R
    };
    for (const j of Array.from(t.childNodes)) {
      const V = Do(j, N);
      V && q.childNodes.push(V);
    }
    if (dQ(t) && t.shadowRoot)
      for (const j of Array.from(t.shadowRoot.childNodes)) {
        const V = Do(j, N);
        V && (_c(t.shadowRoot) && (V.isShadow = !0), q.childNodes.push(V));
      }
  }
  return t.parentNode && Cc(t.parentNode) && _c(t.parentNode) && (q.isShadow = !0), q.type === Bt.Element && q.tagName === "iframe" && DQ(t, () => {
    const N = t.contentDocument;
    if (N && S) {
      const j = Do(N, {
        doc: N,
        mirror: r,
        blockClass: s,
        blockSelector: i,
        unblockSelector: o,
        maskAllText: a,
        maskTextClass: c,
        unmaskTextClass: l,
        maskTextSelector: u,
        unmaskTextSelector: d,
        skipChild: !1,
        inlineStylesheet: h,
        maskInputOptions: p,
        maskAttributeFn: m,
        maskTextFn: y,
        maskInputFn: b,
        slimDOMOptions: v,
        dataURLOptions: w,
        inlineImages: x,
        recordCanvas: A,
        preserveWhiteSpace: M,
        onSerialize: C,
        onIframeLoad: S,
        iframeLoadTimeout: _,
        onStylesheetLoad: T,
        stylesheetLoadTimeout: k,
        keepIframeSrcFn: R
      });
      j && S(t, j);
    }
  }, _), q.type === Bt.Element && q.tagName === "link" && typeof q.attributes.rel == "string" && (q.attributes.rel === "stylesheet" || q.attributes.rel === "preload" && typeof q.attributes.href == "string" && HM(q.attributes.href) === "css") && OQ(t, () => {
    if (T) {
      const N = Do(t, {
        doc: n,
        mirror: r,
        blockClass: s,
        blockSelector: i,
        unblockSelector: o,
        maskAllText: a,
        maskTextClass: c,
        unmaskTextClass: l,
        maskTextSelector: u,
        unmaskTextSelector: d,
        skipChild: !1,
        inlineStylesheet: h,
        maskInputOptions: p,
        maskAttributeFn: m,
        maskTextFn: y,
        maskInputFn: b,
        slimDOMOptions: v,
        dataURLOptions: w,
        inlineImages: x,
        recordCanvas: A,
        preserveWhiteSpace: M,
        onSerialize: C,
        onIframeLoad: S,
        iframeLoadTimeout: _,
        onStylesheetLoad: T,
        stylesheetLoadTimeout: k,
        keepIframeSrcFn: R
      });
      N && T(t, N);
    }
  }, k), q;
}
function FQ(t, e) {
  const { mirror: n = new zM(), blockClass: r = "rr-block", blockSelector: s = null, unblockSelector: i = null, maskAllText: o = !1, maskTextClass: a = "rr-mask", unmaskTextClass: c = null, maskTextSelector: l = null, unmaskTextSelector: u = null, inlineStylesheet: d = !0, inlineImages: f = !1, recordCanvas: h = !1, maskAllInputs: p = !1, maskAttributeFn: m, maskTextFn: y, maskInputFn: b, slimDOM: v = !1, dataURLOptions: w, preserveWhiteSpace: x, onSerialize: A, onIframeLoad: C, iframeLoadTimeout: S, onStylesheetLoad: _, stylesheetLoadTimeout: T, keepIframeSrcFn: k = () => !1 } = e || {};
  return Do(t, {
    doc: t,
    mirror: n,
    blockClass: r,
    blockSelector: s,
    unblockSelector: i,
    maskAllText: o,
    maskTextClass: a,
    unmaskTextClass: c,
    maskTextSelector: l,
    unmaskTextSelector: u,
    skipChild: !1,
    inlineStylesheet: d,
    maskInputOptions: p === !0 ? {
      color: !0,
      date: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0,
      textarea: !0,
      select: !0
    } : p === !1 ? {} : p,
    maskAttributeFn: m,
    maskTextFn: y,
    maskInputFn: b,
    slimDOMOptions: v === !0 || v === "all" ? {
      script: !0,
      comment: !0,
      headFavicon: !0,
      headWhitespace: !0,
      headMetaDescKeywords: v === "all",
      headMetaSocial: !0,
      headMetaRobots: !0,
      headMetaHttpEquiv: !0,
      headMetaAuthorship: !0,
      headMetaVerification: !0
    } : v === !1 ? {} : v,
    dataURLOptions: w,
    inlineImages: f,
    recordCanvas: h,
    preserveWhiteSpace: x,
    onSerialize: A,
    onIframeLoad: C,
    iframeLoadTimeout: S,
    onStylesheetLoad: _,
    stylesheetLoadTimeout: T,
    keepIframeSrcFn: k,
    newlyAddedElement: !1
  });
}
function Ps(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], i = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = i(n)) : (s === "call" || s === "optionalCall") && (n = i((...o) => n.call(e, ...o)), e = void 0);
  }
  return n;
}
function mn(t, e, n = document) {
  const r = { capture: !0, passive: !0 };
  return n.addEventListener(t, e, r), () => n.removeEventListener(t, e, r);
}
const So = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let vS = {
  map: {},
  getId() {
    return console.error(So), -1;
  },
  getNode() {
    return console.error(So), null;
  },
  removeNodeFromMap() {
    console.error(So);
  },
  has() {
    return console.error(So), !1;
  },
  reset() {
    console.error(So);
  }
};
typeof window < "u" && window.Proxy && window.Reflect && (vS = new Proxy(vS, {
  get(t, e, n) {
    return e === "map" && console.error(So), Reflect.get(t, e, n);
  }
}));
function dl(t, e, n = {}) {
  let r = null, s = 0;
  return function(...i) {
    const o = Date.now();
    !s && n.leading === !1 && (s = o);
    const a = e - (o - s), c = this;
    a <= 0 || a > e ? (r && (GQ(r), r = null), s = o, t.apply(c, i)) : !r && n.trailing !== !1 && (r = mh(() => {
      s = n.leading === !1 ? 0 : Date.now(), r = null, t.apply(c, i);
    }, a));
  };
}
function ZM(t, e, n, r, s = window) {
  const i = s.Object.getOwnPropertyDescriptor(t, e);
  return s.Object.defineProperty(t, e, r ? n : {
    set(o) {
      mh(() => {
        n.set.call(this, o);
      }, 0), i && i.set && i.set.call(this, o);
    }
  }), () => ZM(t, e, i || {}, !0);
}
function Zb(t, e, n) {
  try {
    if (!(e in t))
      return () => {
      };
    const r = t[e], s = n(r);
    return typeof s == "function" && (s.prototype = s.prototype || {}, Object.defineProperties(s, {
      __rrweb_original__: {
        enumerable: !1,
        value: r
      }
    })), t[e] = s, () => {
      t[e] = r;
    };
  } catch {
    return () => {
    };
  }
}
let cf = Date.now;
/[1-9][0-9]{12}/.test(Date.now().toString()) || (cf = () => (/* @__PURE__ */ new Date()).getTime());
function QM(t) {
  const e = t.document;
  return {
    left: e.scrollingElement ? e.scrollingElement.scrollLeft : t.pageXOffset !== void 0 ? t.pageXOffset : Ps([e, "optionalAccess", (n) => n.documentElement, "access", (n) => n.scrollLeft]) || Ps([e, "optionalAccess", (n) => n.body, "optionalAccess", (n) => n.parentElement, "optionalAccess", (n) => n.scrollLeft]) || Ps([e, "optionalAccess", (n) => n.body, "optionalAccess", (n) => n.scrollLeft]) || 0,
    top: e.scrollingElement ? e.scrollingElement.scrollTop : t.pageYOffset !== void 0 ? t.pageYOffset : Ps([e, "optionalAccess", (n) => n.documentElement, "access", (n) => n.scrollTop]) || Ps([e, "optionalAccess", (n) => n.body, "optionalAccess", (n) => n.parentElement, "optionalAccess", (n) => n.scrollTop]) || Ps([e, "optionalAccess", (n) => n.body, "optionalAccess", (n) => n.scrollTop]) || 0
  };
}
function XM() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function JM() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function eP(t) {
  return t ? t.nodeType === t.ELEMENT_NODE ? t : t.parentElement : null;
}
function Ln(t, e, n, r, s) {
  if (!t)
    return !1;
  const i = eP(t);
  if (!i)
    return !1;
  const o = Io(e, n);
  if (!s) {
    const l = r && i.matches(r);
    return o(i) && !l;
  }
  const a = Mi(i, o);
  let c = -1;
  return a < 0 ? !1 : (r && (c = Mi(i, Io(null, r))), a > -1 && c < 0 ? !0 : a < c);
}
function VQ(t, e) {
  return e.getId(t) !== -1;
}
function Op(t, e) {
  return e.getId(t) === ul;
}
function tP(t, e) {
  if (Cc(t))
    return !1;
  const n = e.getId(t);
  return e.has(n) ? t.parentNode && t.parentNode.nodeType === t.DOCUMENT_NODE ? !1 : t.parentNode ? tP(t.parentNode, e) : !0 : !0;
}
function Ag(t) {
  return !!t.changedTouches;
}
function UQ(t = window) {
  "NodeList" in t && !t.NodeList.prototype.forEach && (t.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in t && !t.DOMTokenList.prototype.forEach && (t.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = (...e) => {
    let n = e[0];
    if (!(0 in e))
      throw new TypeError("1 argument is required");
    do
      if (this === n)
        return !0;
    while (n = n && n.parentNode);
    return !1;
  });
}
function nP(t, e) {
  return !!(t.nodeName === "IFRAME" && e.getMeta(t));
}
function rP(t, e) {
  return !!(t.nodeName === "LINK" && t.nodeType === t.ELEMENT_NODE && t.getAttribute && t.getAttribute("rel") === "stylesheet" && e.getMeta(t));
}
function Sg(t) {
  return !!Ps([t, "optionalAccess", (e) => e.shadowRoot]);
}
class WQ {
  constructor() {
    this.id = 1, this.styleIDMap = /* @__PURE__ */ new WeakMap(), this.idStyleMap = /* @__PURE__ */ new Map();
  }
  getId(e) {
    return kY(this.styleIDMap.get(e), () => -1);
  }
  has(e) {
    return this.styleIDMap.has(e);
  }
  add(e, n) {
    if (this.has(e))
      return this.getId(e);
    let r;
    return n === void 0 ? r = this.id++ : r = n, this.styleIDMap.set(e, r), this.idStyleMap.set(r, e), r;
  }
  getStyle(e) {
    return this.idStyleMap.get(e) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap(), this.idStyleMap = /* @__PURE__ */ new Map(), this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function sP(t) {
  let e = null;
  return Ps([t, "access", (n) => n.getRootNode, "optionalCall", (n) => n(), "optionalAccess", (n) => n.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && t.getRootNode().host && (e = t.getRootNode().host), e;
}
function zQ(t) {
  let e = t, n;
  for (; n = sP(e); )
    e = n;
  return e;
}
function HQ(t) {
  const e = t.ownerDocument;
  if (!e)
    return !1;
  const n = zQ(t);
  return e.contains(n);
}
function iP(t) {
  const e = t.ownerDocument;
  return e ? e.contains(t) || HQ(t) : !1;
}
const xS = {};
function Qb(t) {
  const e = xS[t];
  if (e)
    return e;
  const n = window.document;
  let r = window[t];
  if (n && typeof n.createElement == "function")
    try {
      const s = n.createElement("iframe");
      s.hidden = !0, n.head.appendChild(s);
      const i = s.contentWindow;
      i && i[t] && (r = i[t]), n.head.removeChild(s);
    } catch {
    }
  return xS[t] = r.bind(window);
}
function YQ(...t) {
  return Qb("requestAnimationFrame")(...t);
}
function mh(...t) {
  return Qb("setTimeout")(...t);
}
function GQ(...t) {
  return Qb("clearTimeout")(...t);
}
var Re = /* @__PURE__ */ ((t) => (t[t.DomContentLoaded = 0] = "DomContentLoaded", t[t.Load = 1] = "Load", t[t.FullSnapshot = 2] = "FullSnapshot", t[t.IncrementalSnapshot = 3] = "IncrementalSnapshot", t[t.Meta = 4] = "Meta", t[t.Custom = 5] = "Custom", t[t.Plugin = 6] = "Plugin", t))(Re || {}), ge = /* @__PURE__ */ ((t) => (t[t.Mutation = 0] = "Mutation", t[t.MouseMove = 1] = "MouseMove", t[t.MouseInteraction = 2] = "MouseInteraction", t[t.Scroll = 3] = "Scroll", t[t.ViewportResize = 4] = "ViewportResize", t[t.Input = 5] = "Input", t[t.TouchMove = 6] = "TouchMove", t[t.MediaInteraction = 7] = "MediaInteraction", t[t.StyleSheetRule = 8] = "StyleSheetRule", t[t.CanvasMutation = 9] = "CanvasMutation", t[t.Font = 10] = "Font", t[t.Log = 11] = "Log", t[t.Drag = 12] = "Drag", t[t.StyleDeclaration = 13] = "StyleDeclaration", t[t.Selection = 14] = "Selection", t[t.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", t[t.CustomElement = 16] = "CustomElement", t))(ge || {}), hn = /* @__PURE__ */ ((t) => (t[t.MouseUp = 0] = "MouseUp", t[t.MouseDown = 1] = "MouseDown", t[t.Click = 2] = "Click", t[t.ContextMenu = 3] = "ContextMenu", t[t.DblClick = 4] = "DblClick", t[t.Focus = 5] = "Focus", t[t.Blur = 6] = "Blur", t[t.TouchStart = 7] = "TouchStart", t[t.TouchMove_Departed = 8] = "TouchMove_Departed", t[t.TouchEnd = 9] = "TouchEnd", t[t.TouchCancel = 10] = "TouchCancel", t))(hn || {}), Gr = /* @__PURE__ */ ((t) => (t[t.Mouse = 0] = "Mouse", t[t.Pen = 1] = "Pen", t[t.Touch = 2] = "Touch", t))(Gr || {});
function KQ(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], i = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = i(n)) : (s === "call" || s === "optionalCall") && (n = i((...o) => n.call(e, ...o)), e = void 0);
  }
  return n;
}
function wS(t) {
  return "__ln" in t;
}
class $Q {
  constructor() {
    this.length = 0, this.head = null, this.tail = null;
  }
  get(e) {
    if (e >= this.length)
      throw new Error("Position outside of list range");
    let n = this.head;
    for (let r = 0; r < e; r++)
      n = KQ([n, "optionalAccess", (s) => s.next]) || null;
    return n;
  }
  addNode(e) {
    const n = {
      value: e,
      previous: null,
      next: null
    };
    if (e.__ln = n, e.previousSibling && wS(e.previousSibling)) {
      const r = e.previousSibling.__ln.next;
      n.next = r, n.previous = e.previousSibling.__ln, e.previousSibling.__ln.next = n, r && (r.previous = n);
    } else if (e.nextSibling && wS(e.nextSibling) && e.nextSibling.__ln.previous) {
      const r = e.nextSibling.__ln.previous;
      n.previous = r, n.next = e.nextSibling.__ln, e.nextSibling.__ln.previous = n, r && (r.next = n);
    } else
      this.head && (this.head.previous = n), n.next = this.head, this.head = n;
    n.next === null && (this.tail = n), this.length++;
  }
  removeNode(e) {
    const n = e.__ln;
    this.head && (n.previous ? (n.previous.next = n.next, n.next ? n.next.previous = n.previous : this.tail = n.previous) : (this.head = n.next, this.head ? this.head.previous = null : this.tail = null), e.__ln && delete e.__ln, this.length--);
  }
}
const AS = (t, e) => `${t}@${e}`;
class ZQ {
  constructor() {
    this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.attributeMap = /* @__PURE__ */ new WeakMap(), this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = /* @__PURE__ */ new Set(), this.movedSet = /* @__PURE__ */ new Set(), this.droppedSet = /* @__PURE__ */ new Set(), this.processMutations = (e) => {
      e.forEach(this.processMutation), this.emit();
    }, this.emit = () => {
      if (this.frozen || this.locked)
        return;
      const e = [], n = /* @__PURE__ */ new Set(), r = new $Q(), s = (c) => {
        let l = c, u = ul;
        for (; u === ul; )
          l = l && l.nextSibling, u = l && this.mirror.getId(l);
        return u;
      }, i = (c) => {
        if (!c.parentNode || !iP(c))
          return;
        const l = Cc(c.parentNode) ? this.mirror.getId(sP(c)) : this.mirror.getId(c.parentNode), u = s(c);
        if (l === -1 || u === -1)
          return r.addNode(c);
        const d = Do(c, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskAllText: this.maskAllText,
          unblockSelector: this.unblockSelector,
          maskTextClass: this.maskTextClass,
          unmaskTextClass: this.unmaskTextClass,
          maskTextSelector: this.maskTextSelector,
          unmaskTextSelector: this.unmaskTextSelector,
          skipChild: !0,
          newlyAddedElement: !0,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskAttributeFn: this.maskAttributeFn,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          onSerialize: (f) => {
            nP(f, this.mirror) && !Ln(f, this.blockClass, this.blockSelector, this.unblockSelector, !1) && this.iframeManager.addIframe(f), rP(f, this.mirror) && this.stylesheetManager.trackLinkElement(f), Sg(c) && this.shadowDomManager.addShadowRoot(c.shadowRoot, this.doc);
          },
          onIframeLoad: (f, h) => {
            Ln(f, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (this.iframeManager.attachIframe(f, h), f.contentWindow && this.canvasManager.addWindow(f.contentWindow), this.shadowDomManager.observeAttachShadow(f));
          },
          onStylesheetLoad: (f, h) => {
            this.stylesheetManager.attachLinkElement(f, h);
          }
        });
        d && (e.push({
          parentId: l,
          nextId: u,
          node: d
        }), n.add(d.id));
      };
      for (; this.mapRemoves.length; )
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      for (const c of this.movedSet)
        SS(this.removes, c, this.mirror) && !this.movedSet.has(c.parentNode) || i(c);
      for (const c of this.addedSet)
        !ES(this.droppedSet, c) && !SS(this.removes, c, this.mirror) || ES(this.movedSet, c) ? i(c) : this.droppedSet.add(c);
      let o = null;
      for (; r.length; ) {
        let c = null;
        if (o) {
          const l = this.mirror.getId(o.value.parentNode), u = s(o.value);
          l !== -1 && u !== -1 && (c = o);
        }
        if (!c) {
          let l = r.tail;
          for (; l; ) {
            const u = l;
            if (l = l.previous, u) {
              const d = this.mirror.getId(u.value.parentNode);
              if (s(u.value) === -1)
                continue;
              if (d !== -1) {
                c = u;
                break;
              } else {
                const h = u.value;
                if (h.parentNode && h.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const p = h.parentNode.host;
                  if (this.mirror.getId(p) !== -1) {
                    c = u;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!c) {
          for (; r.head; )
            r.removeNode(r.head.value);
          break;
        }
        o = c.previous, r.removeNode(c.value), i(c.value);
      }
      const a = {
        texts: this.texts.map((c) => ({
          id: this.mirror.getId(c.node),
          value: c.value
        })).filter((c) => !n.has(c.id)).filter((c) => this.mirror.has(c.id)),
        attributes: this.attributes.map((c) => {
          const { attributes: l } = c;
          if (typeof l.style == "string") {
            const u = JSON.stringify(c.styleDiff), d = JSON.stringify(c._unchangedStyles);
            u.length < l.style.length && (u + d).split("var(").length === l.style.split("var(").length && (l.style = c.styleDiff);
          }
          return {
            id: this.mirror.getId(c.node),
            attributes: l
          };
        }).filter((c) => !n.has(c.id)).filter((c) => this.mirror.has(c.id)),
        removes: this.removes,
        adds: e
      };
      !a.texts.length && !a.attributes.length && !a.removes.length && !a.adds.length || (this.texts = [], this.attributes = [], this.attributeMap = /* @__PURE__ */ new WeakMap(), this.removes = [], this.addedSet = /* @__PURE__ */ new Set(), this.movedSet = /* @__PURE__ */ new Set(), this.droppedSet = /* @__PURE__ */ new Set(), this.movedMap = {}, this.mutationCb(a));
    }, this.processMutation = (e) => {
      if (!Op(e.target, this.mirror))
        switch (e.type) {
          case "characterData": {
            const n = e.target.textContent;
            !Ln(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) && n !== e.oldValue && this.texts.push({
              value: ha(e.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && n ? this.maskTextFn ? this.maskTextFn(n, eP(e.target)) : n.replace(/[\S]/g, "*") : n,
              node: e.target
            });
            break;
          }
          case "attributes": {
            const n = e.target;
            let r = e.attributeName, s = e.target.getAttribute(r);
            if (r === "value") {
              const o = Kb(n), a = n.tagName;
              s = of(n, a, o);
              const c = hh({
                maskInputOptions: this.maskInputOptions,
                tagName: a,
                type: o
              }), l = ha(e.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, c);
              s = ll({
                isMasked: l,
                element: n,
                value: s,
                maskInputFn: this.maskInputFn
              });
            }
            if (Ln(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || s === e.oldValue)
              return;
            let i = this.attributeMap.get(e.target);
            if (n.tagName === "IFRAME" && r === "src" && !this.keepIframeSrcFn(s))
              if (!n.contentDocument)
                r = "rr_src";
              else
                return;
            if (i || (i = {
              node: e.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            }, this.attributes.push(i), this.attributeMap.set(e.target, i)), r === "type" && n.tagName === "INPUT" && (e.oldValue || "").toLowerCase() === "password" && n.setAttribute("data-rr-is-password", "true"), !$M(n.tagName, r) && (i.attributes[r] = KM(this.doc, fa(n.tagName), fa(r), s, n, this.maskAttributeFn), r === "style")) {
              if (!this.unattachedDoc)
                try {
                  this.unattachedDoc = document.implementation.createHTMLDocument();
                } catch {
                  this.unattachedDoc = this.doc;
                }
              const o = this.unattachedDoc.createElement("span");
              e.oldValue && o.setAttribute("style", e.oldValue);
              for (const a of Array.from(n.style)) {
                const c = n.style.getPropertyValue(a), l = n.style.getPropertyPriority(a);
                c !== o.style.getPropertyValue(a) || l !== o.style.getPropertyPriority(a) ? l === "" ? i.styleDiff[a] = c : i.styleDiff[a] = [c, l] : i._unchangedStyles[a] = [c, l];
              }
              for (const a of Array.from(o.style))
                n.style.getPropertyValue(a) === "" && (i.styleDiff[a] = !1);
            }
            break;
          }
          case "childList": {
            if (Ln(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !0))
              return;
            e.addedNodes.forEach((n) => this.genAdds(n, e.target)), e.removedNodes.forEach((n) => {
              const r = this.mirror.getId(n), s = Cc(e.target) ? this.mirror.getId(e.target.host) : this.mirror.getId(e.target);
              Ln(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || Op(n, this.mirror) || !VQ(n, this.mirror) || (this.addedSet.has(n) ? (Eg(this.addedSet, n), this.droppedSet.add(n)) : this.addedSet.has(e.target) && r === -1 || tP(e.target, this.mirror) || (this.movedSet.has(n) && this.movedMap[AS(r, s)] ? Eg(this.movedSet, n) : this.removes.push({
                parentId: s,
                id: r,
                isShadow: Cc(e.target) && _c(e.target) ? !0 : void 0
              })), this.mapRemoves.push(n));
            });
            break;
          }
        }
    }, this.genAdds = (e, n) => {
      if (!this.processedNodeManager.inOtherBuffer(e, this) && !(this.addedSet.has(e) || this.movedSet.has(e))) {
        if (this.mirror.hasNode(e)) {
          if (Op(e, this.mirror))
            return;
          this.movedSet.add(e);
          let r = null;
          n && this.mirror.hasNode(n) && (r = this.mirror.getId(n)), r && r !== -1 && (this.movedMap[AS(this.mirror.getId(e), r)] = !0);
        } else
          this.addedSet.add(e), this.droppedSet.delete(e);
        Ln(e, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (e.childNodes.forEach((r) => this.genAdds(r)), Sg(e) && e.shadowRoot.childNodes.forEach((r) => {
          this.processedNodeManager.add(r, this), this.genAdds(r, e);
        }));
      }
    };
  }
  init(e) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "unblockSelector",
      "maskAllText",
      "maskTextClass",
      "unmaskTextClass",
      "maskTextSelector",
      "unmaskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskAttributeFn",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((n) => {
      this[n] = e[n];
    });
  }
  freeze() {
    this.frozen = !0, this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = !1, this.canvasManager.unfreeze(), this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = !0, this.canvasManager.lock();
  }
  unlock() {
    this.locked = !1, this.canvasManager.unlock(), this.emit();
  }
  reset() {
    this.shadowDomManager.reset(), this.canvasManager.reset();
  }
}
function Eg(t, e) {
  t.delete(e), e.childNodes.forEach((n) => Eg(t, n));
}
function SS(t, e, n) {
  return t.length === 0 ? !1 : QQ(t, e, n);
}
function QQ(t, e, n) {
  let r = e.parentNode;
  for (; r; ) {
    const s = n.getId(r);
    if (t.some((i) => i.id === s))
      return !0;
    r = r.parentNode;
  }
  return !1;
}
function ES(t, e) {
  return t.size === 0 ? !1 : oP(t, e);
}
function oP(t, e) {
  const { parentNode: n } = e;
  return n ? t.has(n) ? !0 : oP(t, n) : !1;
}
let Tc;
function XQ(t) {
  Tc = t;
}
function JQ() {
  Tc = void 0;
}
const Ne = (t) => Tc ? (...n) => {
  try {
    return t(...n);
  } catch (r) {
    if (Tc && Tc(r) === !0)
      return () => {
      };
    throw r;
  }
} : t;
function sr(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], i = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = i(n)) : (s === "call" || s === "optionalCall") && (n = i((...o) => n.call(e, ...o)), e = void 0);
  }
  return n;
}
const Oo = [];
function ql(t) {
  try {
    if ("composedPath" in t) {
      const e = t.composedPath();
      if (e.length)
        return e[0];
    } else if ("path" in t && t.path.length)
      return t.path[0];
  } catch {
  }
  return t && t.target;
}
function aP(t, e) {
  const n = new ZQ();
  Oo.push(n), n.init(t);
  let r = window.MutationObserver || window.__rrMutationObserver;
  const s = sr([window, "optionalAccess", (o) => o.Zone, "optionalAccess", (o) => o.__symbol__, "optionalCall", (o) => o("MutationObserver")]);
  s && window[s] && (r = window[s]);
  const i = new r(Ne((o) => {
    t.onMutation && t.onMutation(o) === !1 || n.processMutations.bind(n)(o);
  }));
  return i.observe(e, {
    attributes: !0,
    attributeOldValue: !0,
    characterData: !0,
    characterDataOldValue: !0,
    childList: !0,
    subtree: !0
  }), i;
}
function eX({ mousemoveCb: t, sampling: e, doc: n, mirror: r }) {
  if (e.mousemove === !1)
    return () => {
    };
  const s = typeof e.mousemove == "number" ? e.mousemove : 50, i = typeof e.mousemoveCallback == "number" ? e.mousemoveCallback : 500;
  let o = [], a;
  const c = dl(Ne((d) => {
    const f = Date.now() - a;
    t(o.map((h) => (h.timeOffset -= f, h)), d), o = [], a = null;
  }), i), l = Ne(dl(Ne((d) => {
    const f = ql(d), { clientX: h, clientY: p } = Ag(d) ? d.changedTouches[0] : d;
    a || (a = cf()), o.push({
      x: h,
      y: p,
      id: r.getId(f),
      timeOffset: cf() - a
    }), c(typeof DragEvent < "u" && d instanceof DragEvent ? ge.Drag : d instanceof MouseEvent ? ge.MouseMove : ge.TouchMove);
  }), s, {
    trailing: !1
  })), u = [
    mn("mousemove", l, n),
    mn("touchmove", l, n),
    mn("drag", l, n)
  ];
  return Ne(() => {
    u.forEach((d) => d());
  });
}
function tX({ mouseInteractionCb: t, doc: e, mirror: n, blockClass: r, blockSelector: s, unblockSelector: i, sampling: o }) {
  if (o.mouseInteraction === !1)
    return () => {
    };
  const a = o.mouseInteraction === !0 || o.mouseInteraction === void 0 ? {} : o.mouseInteraction, c = [];
  let l = null;
  const u = (d) => (f) => {
    const h = ql(f);
    if (Ln(h, r, s, i, !0))
      return;
    let p = null, m = d;
    if ("pointerType" in f) {
      switch (f.pointerType) {
        case "mouse":
          p = Gr.Mouse;
          break;
        case "touch":
          p = Gr.Touch;
          break;
        case "pen":
          p = Gr.Pen;
          break;
      }
      p === Gr.Touch ? hn[d] === hn.MouseDown ? m = "TouchStart" : hn[d] === hn.MouseUp && (m = "TouchEnd") : Gr.Pen;
    } else Ag(f) && (p = Gr.Touch);
    p !== null ? (l = p, (m.startsWith("Touch") && p === Gr.Touch || m.startsWith("Mouse") && p === Gr.Mouse) && (p = null)) : hn[d] === hn.Click && (p = l, l = null);
    const y = Ag(f) ? f.changedTouches[0] : f;
    if (!y)
      return;
    const b = n.getId(h), { clientX: v, clientY: w } = y;
    Ne(t)({
      type: hn[m],
      id: b,
      x: v,
      y: w,
      ...p !== null && { pointerType: p }
    });
  };
  return Object.keys(hn).filter((d) => Number.isNaN(Number(d)) && !d.endsWith("_Departed") && a[d] !== !1).forEach((d) => {
    let f = fa(d);
    const h = u(d);
    if (window.PointerEvent)
      switch (hn[d]) {
        case hn.MouseDown:
        case hn.MouseUp:
          f = f.replace("mouse", "pointer");
          break;
        case hn.TouchStart:
        case hn.TouchEnd:
          return;
      }
    c.push(mn(f, h, e));
  }), Ne(() => {
    c.forEach((d) => d());
  });
}
function cP({ scrollCb: t, doc: e, mirror: n, blockClass: r, blockSelector: s, unblockSelector: i, sampling: o }) {
  const a = Ne(dl(Ne((c) => {
    const l = ql(c);
    if (!l || Ln(l, r, s, i, !0))
      return;
    const u = n.getId(l);
    if (l === e && e.defaultView) {
      const d = QM(e.defaultView);
      t({
        id: u,
        x: d.left,
        y: d.top
      });
    } else
      t({
        id: u,
        x: l.scrollLeft,
        y: l.scrollTop
      });
  }), o.scroll || 100));
  return mn("scroll", a, e);
}
function nX({ viewportResizeCb: t }, { win: e }) {
  let n = -1, r = -1;
  const s = Ne(dl(Ne(() => {
    const i = XM(), o = JM();
    (n !== i || r !== o) && (t({
      width: Number(o),
      height: Number(i)
    }), n = i, r = o);
  }), 200));
  return mn("resize", s, e);
}
const rX = ["INPUT", "TEXTAREA", "SELECT"], CS = /* @__PURE__ */ new WeakMap();
function sX({ inputCb: t, doc: e, mirror: n, blockClass: r, blockSelector: s, unblockSelector: i, ignoreClass: o, ignoreSelector: a, maskInputOptions: c, maskInputFn: l, sampling: u, userTriggeredOnInput: d, maskTextClass: f, unmaskTextClass: h, maskTextSelector: p, unmaskTextSelector: m }) {
  function y(S) {
    let _ = ql(S);
    const T = S.isTrusted, k = _ && xg(_.tagName);
    if (k === "OPTION" && (_ = _.parentElement), !_ || !k || rX.indexOf(k) < 0 || Ln(_, r, s, i, !0))
      return;
    const R = _;
    if (R.classList.contains(o) || a && R.matches(a))
      return;
    const P = Kb(_);
    let M = of(R, k, P), D = !1;
    const O = hh({
      maskInputOptions: c,
      tagName: k,
      type: P
    }), q = ha(_, f, p, h, m, O);
    (P === "radio" || P === "checkbox") && (D = _.checked), M = ll({
      isMasked: q,
      element: _,
      value: M,
      maskInputFn: l
    }), b(_, d ? { text: M, isChecked: D, userTriggered: T } : { text: M, isChecked: D });
    const L = _.name;
    P === "radio" && L && D && e.querySelectorAll(`input[type="radio"][name="${L}"]`).forEach((N) => {
      if (N !== _) {
        const j = ll({
          isMasked: q,
          element: N,
          value: of(N, k, P),
          maskInputFn: l
        });
        b(N, d ? { text: j, isChecked: !D, userTriggered: !1 } : { text: j, isChecked: !D });
      }
    });
  }
  function b(S, _) {
    const T = CS.get(S);
    if (!T || T.text !== _.text || T.isChecked !== _.isChecked) {
      CS.set(S, _);
      const k = n.getId(S);
      Ne(t)({
        ..._,
        id: k
      });
    }
  }
  const w = (u.input === "last" ? ["change"] : ["input", "change"]).map((S) => mn(S, Ne(y), e)), x = e.defaultView;
  if (!x)
    return () => {
      w.forEach((S) => S());
    };
  const A = x.Object.getOwnPropertyDescriptor(x.HTMLInputElement.prototype, "value"), C = [
    [x.HTMLInputElement.prototype, "value"],
    [x.HTMLInputElement.prototype, "checked"],
    [x.HTMLSelectElement.prototype, "value"],
    [x.HTMLTextAreaElement.prototype, "value"],
    [x.HTMLSelectElement.prototype, "selectedIndex"],
    [x.HTMLOptionElement.prototype, "selected"]
  ];
  return A && A.set && w.push(...C.map((S) => ZM(S[0], S[1], {
    set() {
      Ne(y)({
        target: this,
        isTrusted: !1
      });
    }
  }, !1, x))), Ne(() => {
    w.forEach((S) => S());
  });
}
function lf(t) {
  const e = [];
  function n(r, s) {
    if (Ru("CSSGroupingRule") && r.parentRule instanceof CSSGroupingRule || Ru("CSSMediaRule") && r.parentRule instanceof CSSMediaRule || Ru("CSSSupportsRule") && r.parentRule instanceof CSSSupportsRule || Ru("CSSConditionRule") && r.parentRule instanceof CSSConditionRule) {
      const o = Array.from(r.parentRule.cssRules).indexOf(r);
      s.unshift(o);
    } else if (r.parentStyleSheet) {
      const o = Array.from(r.parentStyleSheet.cssRules).indexOf(r);
      s.unshift(o);
    }
    return s;
  }
  return n(t, e);
}
function Is(t, e, n) {
  let r, s;
  return t ? (t.ownerNode ? r = e.getId(t.ownerNode) : s = n.getId(t), {
    styleId: s,
    id: r
  }) : {};
}
function iX({ styleSheetRuleCb: t, mirror: e, stylesheetManager: n }, { win: r }) {
  if (!r.CSSStyleSheet || !r.CSSStyleSheet.prototype)
    return () => {
    };
  const s = r.CSSStyleSheet.prototype.insertRule;
  r.CSSStyleSheet.prototype.insertRule = new Proxy(s, {
    apply: Ne((u, d, f) => {
      const [h, p] = f, { id: m, styleId: y } = Is(d, e, n.styleMirror);
      return (m && m !== -1 || y && y !== -1) && t({
        id: m,
        styleId: y,
        adds: [{ rule: h, index: p }]
      }), u.apply(d, f);
    })
  });
  const i = r.CSSStyleSheet.prototype.deleteRule;
  r.CSSStyleSheet.prototype.deleteRule = new Proxy(i, {
    apply: Ne((u, d, f) => {
      const [h] = f, { id: p, styleId: m } = Is(d, e, n.styleMirror);
      return (p && p !== -1 || m && m !== -1) && t({
        id: p,
        styleId: m,
        removes: [{ index: h }]
      }), u.apply(d, f);
    })
  });
  let o;
  r.CSSStyleSheet.prototype.replace && (o = r.CSSStyleSheet.prototype.replace, r.CSSStyleSheet.prototype.replace = new Proxy(o, {
    apply: Ne((u, d, f) => {
      const [h] = f, { id: p, styleId: m } = Is(d, e, n.styleMirror);
      return (p && p !== -1 || m && m !== -1) && t({
        id: p,
        styleId: m,
        replace: h
      }), u.apply(d, f);
    })
  }));
  let a;
  r.CSSStyleSheet.prototype.replaceSync && (a = r.CSSStyleSheet.prototype.replaceSync, r.CSSStyleSheet.prototype.replaceSync = new Proxy(a, {
    apply: Ne((u, d, f) => {
      const [h] = f, { id: p, styleId: m } = Is(d, e, n.styleMirror);
      return (p && p !== -1 || m && m !== -1) && t({
        id: p,
        styleId: m,
        replaceSync: h
      }), u.apply(d, f);
    })
  }));
  const c = {};
  Mu("CSSGroupingRule") ? c.CSSGroupingRule = r.CSSGroupingRule : (Mu("CSSMediaRule") && (c.CSSMediaRule = r.CSSMediaRule), Mu("CSSConditionRule") && (c.CSSConditionRule = r.CSSConditionRule), Mu("CSSSupportsRule") && (c.CSSSupportsRule = r.CSSSupportsRule));
  const l = {};
  return Object.entries(c).forEach(([u, d]) => {
    l[u] = {
      insertRule: d.prototype.insertRule,
      deleteRule: d.prototype.deleteRule
    }, d.prototype.insertRule = new Proxy(l[u].insertRule, {
      apply: Ne((f, h, p) => {
        const [m, y] = p, { id: b, styleId: v } = Is(h.parentStyleSheet, e, n.styleMirror);
        return (b && b !== -1 || v && v !== -1) && t({
          id: b,
          styleId: v,
          adds: [
            {
              rule: m,
              index: [
                ...lf(h),
                y || 0
              ]
            }
          ]
        }), f.apply(h, p);
      })
    }), d.prototype.deleteRule = new Proxy(l[u].deleteRule, {
      apply: Ne((f, h, p) => {
        const [m] = p, { id: y, styleId: b } = Is(h.parentStyleSheet, e, n.styleMirror);
        return (y && y !== -1 || b && b !== -1) && t({
          id: y,
          styleId: b,
          removes: [
            { index: [...lf(h), m] }
          ]
        }), f.apply(h, p);
      })
    });
  }), Ne(() => {
    r.CSSStyleSheet.prototype.insertRule = s, r.CSSStyleSheet.prototype.deleteRule = i, o && (r.CSSStyleSheet.prototype.replace = o), a && (r.CSSStyleSheet.prototype.replaceSync = a), Object.entries(c).forEach(([u, d]) => {
      d.prototype.insertRule = l[u].insertRule, d.prototype.deleteRule = l[u].deleteRule;
    });
  });
}
function lP({ mirror: t, stylesheetManager: e }, n) {
  let r = null;
  n.nodeName === "#document" ? r = t.getId(n) : r = t.getId(n.host);
  const s = n.nodeName === "#document" ? sr([n, "access", (o) => o.defaultView, "optionalAccess", (o) => o.Document]) : sr([n, "access", (o) => o.ownerDocument, "optionalAccess", (o) => o.defaultView, "optionalAccess", (o) => o.ShadowRoot]), i = sr([s, "optionalAccess", (o) => o.prototype]) ? Object.getOwnPropertyDescriptor(sr([s, "optionalAccess", (o) => o.prototype]), "adoptedStyleSheets") : void 0;
  return r === null || r === -1 || !s || !i ? () => {
  } : (Object.defineProperty(n, "adoptedStyleSheets", {
    configurable: i.configurable,
    enumerable: i.enumerable,
    get() {
      return sr([i, "access", (o) => o.get, "optionalAccess", (o) => o.call, "call", (o) => o(this)]);
    },
    set(o) {
      const a = sr([i, "access", (c) => c.set, "optionalAccess", (c) => c.call, "call", (c) => c(this, o)]);
      if (r !== null && r !== -1)
        try {
          e.adoptStyleSheets(o, r);
        } catch {
        }
      return a;
    }
  }), Ne(() => {
    Object.defineProperty(n, "adoptedStyleSheets", {
      configurable: i.configurable,
      enumerable: i.enumerable,
      get: i.get,
      set: i.set
    });
  }));
}
function oX({ styleDeclarationCb: t, mirror: e, ignoreCSSAttributes: n, stylesheetManager: r }, { win: s }) {
  const i = s.CSSStyleDeclaration.prototype.setProperty;
  s.CSSStyleDeclaration.prototype.setProperty = new Proxy(i, {
    apply: Ne((a, c, l) => {
      const [u, d, f] = l;
      if (n.has(u))
        return i.apply(c, [u, d, f]);
      const { id: h, styleId: p } = Is(sr([c, "access", (m) => m.parentRule, "optionalAccess", (m) => m.parentStyleSheet]), e, r.styleMirror);
      return (h && h !== -1 || p && p !== -1) && t({
        id: h,
        styleId: p,
        set: {
          property: u,
          value: d,
          priority: f
        },
        index: lf(c.parentRule)
      }), a.apply(c, l);
    })
  });
  const o = s.CSSStyleDeclaration.prototype.removeProperty;
  return s.CSSStyleDeclaration.prototype.removeProperty = new Proxy(o, {
    apply: Ne((a, c, l) => {
      const [u] = l;
      if (n.has(u))
        return o.apply(c, [u]);
      const { id: d, styleId: f } = Is(sr([c, "access", (h) => h.parentRule, "optionalAccess", (h) => h.parentStyleSheet]), e, r.styleMirror);
      return (d && d !== -1 || f && f !== -1) && t({
        id: d,
        styleId: f,
        remove: {
          property: u
        },
        index: lf(c.parentRule)
      }), a.apply(c, l);
    })
  }), Ne(() => {
    s.CSSStyleDeclaration.prototype.setProperty = i, s.CSSStyleDeclaration.prototype.removeProperty = o;
  });
}
function aX({ mediaInteractionCb: t, blockClass: e, blockSelector: n, unblockSelector: r, mirror: s, sampling: i, doc: o }) {
  const a = Ne((l) => dl(Ne((u) => {
    const d = ql(u);
    if (!d || Ln(d, e, n, r, !0))
      return;
    const { currentTime: f, volume: h, muted: p, playbackRate: m } = d;
    t({
      type: l,
      id: s.getId(d),
      currentTime: f,
      volume: h,
      muted: p,
      playbackRate: m
    });
  }), i.media || 500)), c = [
    mn("play", a(0), o),
    mn("pause", a(1), o),
    mn("seeked", a(2), o),
    mn("volumechange", a(3), o),
    mn("ratechange", a(4), o)
  ];
  return Ne(() => {
    c.forEach((l) => l());
  });
}
function cX({ fontCb: t, doc: e }) {
  const n = e.defaultView;
  if (!n)
    return () => {
    };
  const r = [], s = /* @__PURE__ */ new WeakMap(), i = n.FontFace;
  n.FontFace = function(c, l, u) {
    const d = new i(c, l, u);
    return s.set(d, {
      family: c,
      buffer: typeof l != "string",
      descriptors: u,
      fontSource: typeof l == "string" ? l : JSON.stringify(Array.from(new Uint8Array(l)))
    }), d;
  };
  const o = Zb(e.fonts, "add", function(a) {
    return function(c) {
      return mh(Ne(() => {
        const l = s.get(c);
        l && (t(l), s.delete(c));
      }), 0), a.apply(this, [c]);
    };
  });
  return r.push(() => {
    n.FontFace = i;
  }), r.push(o), Ne(() => {
    r.forEach((a) => a());
  });
}
function lX(t) {
  const { doc: e, mirror: n, blockClass: r, blockSelector: s, unblockSelector: i, selectionCb: o } = t;
  let a = !0;
  const c = Ne(() => {
    const l = e.getSelection();
    if (!l || a && sr([l, "optionalAccess", (f) => f.isCollapsed]))
      return;
    a = l.isCollapsed || !1;
    const u = [], d = l.rangeCount || 0;
    for (let f = 0; f < d; f++) {
      const h = l.getRangeAt(f), { startContainer: p, startOffset: m, endContainer: y, endOffset: b } = h;
      Ln(p, r, s, i, !0) || Ln(y, r, s, i, !0) || u.push({
        start: n.getId(p),
        startOffset: m,
        end: n.getId(y),
        endOffset: b
      });
    }
    o({ ranges: u });
  });
  return c(), mn("selectionchange", c);
}
function uX({ doc: t, customElementCb: e }) {
  const n = t.defaultView;
  return !n || !n.customElements ? () => {
  } : Zb(n.customElements, "define", function(s) {
    return function(i, o, a) {
      try {
        e({
          define: {
            name: i
          }
        });
      } catch {
      }
      return s.apply(this, [i, o, a]);
    };
  });
}
function dX(t, e = {}) {
  const n = t.doc.defaultView;
  if (!n)
    return () => {
    };
  let r;
  t.recordDOM && (r = aP(t, t.doc));
  const s = eX(t), i = tX(t), o = cP(t), a = nX(t, {
    win: n
  }), c = sX(t), l = aX(t);
  let u = () => {
  }, d = () => {
  }, f = () => {
  }, h = () => {
  };
  t.recordDOM && (u = iX(t, { win: n }), d = lP(t, t.doc), f = oX(t, {
    win: n
  }), t.collectFonts && (h = cX(t)));
  const p = lX(t), m = uX(t), y = [];
  for (const b of t.plugins)
    y.push(b.observer(b.callback, n, b.options));
  return Ne(() => {
    Oo.forEach((b) => b.reset()), sr([r, "optionalAccess", (b) => b.disconnect, "call", (b) => b()]), s(), i(), o(), a(), c(), l(), u(), d(), f(), h(), p(), m(), y.forEach((b) => b());
  });
}
function Ru(t) {
  return typeof window[t] < "u";
}
function Mu(t) {
  return !!(typeof window[t] < "u" && window[t].prototype && "insertRule" in window[t].prototype && "deleteRule" in window[t].prototype);
}
class Cg {
  constructor(e) {
    this.generateIdFn = e, this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap(), this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
  }
  getId(e, n, r, s) {
    const i = r || this.getIdToRemoteIdMap(e), o = s || this.getRemoteIdToIdMap(e);
    let a = i.get(n);
    return a || (a = this.generateIdFn(), i.set(n, a), o.set(a, n)), a;
  }
  getIds(e, n) {
    const r = this.getIdToRemoteIdMap(e), s = this.getRemoteIdToIdMap(e);
    return n.map((i) => this.getId(e, i, r, s));
  }
  getRemoteId(e, n, r) {
    const s = r || this.getRemoteIdToIdMap(e);
    if (typeof n != "number")
      return n;
    const i = s.get(n);
    return i || -1;
  }
  getRemoteIds(e, n) {
    const r = this.getRemoteIdToIdMap(e);
    return n.map((s) => this.getRemoteId(e, s, r));
  }
  reset(e) {
    if (!e) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap(), this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(e), this.iframeRemoteIdToIdMap.delete(e);
  }
  getIdToRemoteIdMap(e) {
    let n = this.iframeIdToRemoteIdMap.get(e);
    return n || (n = /* @__PURE__ */ new Map(), this.iframeIdToRemoteIdMap.set(e, n)), n;
  }
  getRemoteIdToIdMap(e) {
    let n = this.iframeRemoteIdToIdMap.get(e);
    return n || (n = /* @__PURE__ */ new Map(), this.iframeRemoteIdToIdMap.set(e, n)), n;
  }
}
function _S(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], i = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = i(n)) : (s === "call" || s === "optionalCall") && (n = i((...o) => n.call(e, ...o)), e = void 0);
  }
  return n;
}
class fX {
  constructor() {
    this.crossOriginIframeMirror = new Cg($b), this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();
  }
  addIframe() {
  }
  addLoadListener() {
  }
  attachIframe() {
  }
}
class hX {
  constructor(e) {
    this.iframes = /* @__PURE__ */ new WeakMap(), this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap(), this.crossOriginIframeMirror = new Cg($b), this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap(), this.mutationCb = e.mutationCb, this.wrappedEmit = e.wrappedEmit, this.stylesheetManager = e.stylesheetManager, this.recordCrossOriginIframes = e.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new Cg(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)), this.mirror = e.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this));
  }
  addIframe(e) {
    this.iframes.set(e, !0), e.contentWindow && this.crossOriginIframeMap.set(e.contentWindow, e);
  }
  addLoadListener(e) {
    this.loadListener = e;
  }
  attachIframe(e, n) {
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(e),
          nextId: null,
          node: n
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: !0
    }), _S([this, "access", (r) => r.loadListener, "optionalCall", (r) => r(e)]), e.contentDocument && e.contentDocument.adoptedStyleSheets && e.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(e.contentDocument.adoptedStyleSheets, this.mirror.getId(e.contentDocument));
  }
  handleMessage(e) {
    const n = e;
    if (n.data.type !== "rrweb" || n.origin !== n.data.origin || !e.source)
      return;
    const s = this.crossOriginIframeMap.get(e.source);
    if (!s)
      return;
    const i = this.transformCrossOriginEvent(s, n.data.event);
    i && this.wrappedEmit(i, n.data.isCheckout);
  }
  transformCrossOriginEvent(e, n) {
    switch (n.type) {
      case Re.FullSnapshot: {
        this.crossOriginIframeMirror.reset(e), this.crossOriginIframeStyleMirror.reset(e), this.replaceIdOnNode(n.data.node, e);
        const r = n.data.node.id;
        return this.crossOriginIframeRootIdMap.set(e, r), this.patchRootIdOnNode(n.data.node, r), {
          timestamp: n.timestamp,
          type: Re.IncrementalSnapshot,
          data: {
            source: ge.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(e),
                nextId: null,
                node: n.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: !0
          }
        };
      }
      case Re.Meta:
      case Re.Load:
      case Re.DomContentLoaded:
        return !1;
      case Re.Plugin:
        return n;
      case Re.Custom:
        return this.replaceIds(n.data.payload, e, ["id", "parentId", "previousId", "nextId"]), n;
      case Re.IncrementalSnapshot:
        switch (n.data.source) {
          case ge.Mutation:
            return n.data.adds.forEach((r) => {
              this.replaceIds(r, e, [
                "parentId",
                "nextId",
                "previousId"
              ]), this.replaceIdOnNode(r.node, e);
              const s = this.crossOriginIframeRootIdMap.get(e);
              s && this.patchRootIdOnNode(r.node, s);
            }), n.data.removes.forEach((r) => {
              this.replaceIds(r, e, ["parentId", "id"]);
            }), n.data.attributes.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), n.data.texts.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), n;
          case ge.Drag:
          case ge.TouchMove:
          case ge.MouseMove:
            return n.data.positions.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), n;
          case ge.ViewportResize:
            return !1;
          case ge.MediaInteraction:
          case ge.MouseInteraction:
          case ge.Scroll:
          case ge.CanvasMutation:
          case ge.Input:
            return this.replaceIds(n.data, e, ["id"]), n;
          case ge.StyleSheetRule:
          case ge.StyleDeclaration:
            return this.replaceIds(n.data, e, ["id"]), this.replaceStyleIds(n.data, e, ["styleId"]), n;
          case ge.Font:
            return n;
          case ge.Selection:
            return n.data.ranges.forEach((r) => {
              this.replaceIds(r, e, ["start", "end"]);
            }), n;
          case ge.AdoptedStyleSheet:
            return this.replaceIds(n.data, e, ["id"]), this.replaceStyleIds(n.data, e, ["styleIds"]), _S([n, "access", (r) => r.data, "access", (r) => r.styles, "optionalAccess", (r) => r.forEach, "call", (r) => r((s) => {
              this.replaceStyleIds(s, e, ["styleId"]);
            })]), n;
        }
    }
    return !1;
  }
  replace(e, n, r, s) {
    for (const i of s)
      !Array.isArray(n[i]) && typeof n[i] != "number" || (Array.isArray(n[i]) ? n[i] = e.getIds(r, n[i]) : n[i] = e.getId(r, n[i]));
    return n;
  }
  replaceIds(e, n, r) {
    return this.replace(this.crossOriginIframeMirror, e, n, r);
  }
  replaceStyleIds(e, n, r) {
    return this.replace(this.crossOriginIframeStyleMirror, e, n, r);
  }
  replaceIdOnNode(e, n) {
    this.replaceIds(e, n, ["id", "rootId"]), "childNodes" in e && e.childNodes.forEach((r) => {
      this.replaceIdOnNode(r, n);
    });
  }
  patchRootIdOnNode(e, n) {
    e.type !== Bt.Document && !e.rootId && (e.rootId = n), "childNodes" in e && e.childNodes.forEach((r) => {
      this.patchRootIdOnNode(r, n);
    });
  }
}
class pX {
  init() {
  }
  addShadowRoot() {
  }
  observeAttachShadow() {
  }
  reset() {
  }
}
class mX {
  constructor(e) {
    this.shadowDoms = /* @__PURE__ */ new WeakSet(), this.restoreHandlers = [], this.mutationCb = e.mutationCb, this.scrollCb = e.scrollCb, this.bypassOptions = e.bypassOptions, this.mirror = e.mirror, this.init();
  }
  init() {
    this.reset(), this.patchAttachShadow(Element, document);
  }
  addShadowRoot(e, n) {
    if (!_c(e) || this.shadowDoms.has(e))
      return;
    this.shadowDoms.add(e), this.bypassOptions.canvasManager.addShadowRoot(e);
    const r = aP({
      ...this.bypassOptions,
      doc: n,
      mutationCb: this.mutationCb,
      mirror: this.mirror,
      shadowDomManager: this
    }, e);
    this.restoreHandlers.push(() => r.disconnect()), this.restoreHandlers.push(cP({
      ...this.bypassOptions,
      scrollCb: this.scrollCb,
      doc: e,
      mirror: this.mirror
    })), mh(() => {
      e.adoptedStyleSheets && e.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(e.adoptedStyleSheets, this.mirror.getId(e.host)), this.restoreHandlers.push(lP({
        mirror: this.mirror,
        stylesheetManager: this.bypassOptions.stylesheetManager
      }, e));
    }, 0);
  }
  observeAttachShadow(e) {
    !e.contentWindow || !e.contentDocument || this.patchAttachShadow(e.contentWindow.Element, e.contentDocument);
  }
  patchAttachShadow(e, n) {
    const r = this;
    this.restoreHandlers.push(Zb(e.prototype, "attachShadow", function(s) {
      return function(i) {
        const o = s.call(this, i);
        return this.shadowRoot && iP(this) && r.addShadowRoot(this.shadowRoot, n), o;
      };
    }));
  }
  reset() {
    this.restoreHandlers.forEach((e) => {
      try {
        e();
      } catch {
      }
    }), this.restoreHandlers = [], this.shadowDoms = /* @__PURE__ */ new WeakSet(), this.bypassOptions.canvasManager.resetShadowRoots();
  }
}
class TS {
  reset() {
  }
  freeze() {
  }
  unfreeze() {
  }
  lock() {
  }
  unlock() {
  }
  snapshot() {
  }
  addWindow() {
  }
  addShadowRoot() {
  }
  resetShadowRoots() {
  }
}
class gX {
  constructor(e) {
    this.trackedLinkElements = /* @__PURE__ */ new WeakSet(), this.styleMirror = new WQ(), this.mutationCb = e.mutationCb, this.adoptedStyleSheetCb = e.adoptedStyleSheetCb;
  }
  attachLinkElement(e, n) {
    "_cssText" in n.attributes && this.mutationCb({
      adds: [],
      removes: [],
      texts: [],
      attributes: [
        {
          id: n.id,
          attributes: n.attributes
        }
      ]
    }), this.trackLinkElement(e);
  }
  trackLinkElement(e) {
    this.trackedLinkElements.has(e) || (this.trackedLinkElements.add(e), this.trackStylesheetInLinkElement(e));
  }
  adoptStyleSheets(e, n) {
    if (e.length === 0)
      return;
    const r = {
      id: n,
      styleIds: []
    }, s = [];
    for (const i of e) {
      let o;
      this.styleMirror.has(i) ? o = this.styleMirror.getId(i) : (o = this.styleMirror.add(i), s.push({
        styleId: o,
        rules: Array.from(i.rules || CSSRule, (a, c) => ({
          rule: WM(a),
          index: c
        }))
      })), r.styleIds.push(o);
    }
    s.length > 0 && (r.styles = s), this.adoptedStyleSheetCb(r);
  }
  reset() {
    this.styleMirror.reset(), this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  trackStylesheetInLinkElement(e) {
  }
}
class yX {
  constructor() {
    this.nodeMap = /* @__PURE__ */ new WeakMap(), this.active = !1;
  }
  inOtherBuffer(e, n) {
    const r = this.nodeMap.get(e);
    return r && Array.from(r).some((s) => s !== n);
  }
  add(e, n) {
    this.active || (this.active = !0, YQ(() => {
      this.nodeMap = /* @__PURE__ */ new WeakMap(), this.active = !1;
    })), this.nodeMap.set(e, (this.nodeMap.get(e) || /* @__PURE__ */ new Set()).add(n));
  }
  destroy() {
  }
}
let At, uf;
try {
  if (Array.from([1], (t) => t * 2)[0] !== 2) {
    const t = document.createElement("iframe");
    document.body.appendChild(t), Array.from = Bn([t, "access", (e) => e.contentWindow, "optionalAccess", (e) => e.Array, "access", (e) => e.from]) || Array.from, document.body.removeChild(t);
  }
} catch (t) {
  console.debug("Unable to override Array.from", t);
}
const rr = yQ();
function cs(t = {}) {
  const { emit: e, checkoutEveryNms: n, checkoutEveryNth: r, blockClass: s = "rr-block", blockSelector: i = null, unblockSelector: o = null, ignoreClass: a = "rr-ignore", ignoreSelector: c = null, maskAllText: l = !1, maskTextClass: u = "rr-mask", unmaskTextClass: d = null, maskTextSelector: f = null, unmaskTextSelector: h = null, inlineStylesheet: p = !0, maskAllInputs: m, maskInputOptions: y, slimDOMOptions: b, maskAttributeFn: v, maskInputFn: w, maskTextFn: x, maxCanvasSize: A = null, packFn: C, sampling: S = {}, dataURLOptions: _ = {}, mousemoveWait: T, recordDOM: k = !0, recordCanvas: R = !1, recordCrossOriginIframes: P = !1, recordAfter: M = t.recordAfter === "DOMContentLoaded" ? t.recordAfter : "load", userTriggeredOnInput: D = !1, collectFonts: O = !1, inlineImages: q = !1, plugins: L, keepIframeSrcFn: N = () => !1, ignoreCSSAttributes: j = /* @__PURE__ */ new Set([]), errorHandler: V, onMutation: Z, getCanvasManager: G } = t;
  XQ(V);
  const $ = P ? window.parent === window : !0;
  let fe = !1;
  if (!$)
    try {
      window.parent.document && (fe = !1);
    } catch {
      fe = !0;
    }
  if ($ && !e)
    throw new Error("emit function is required");
  if (!$ && !fe)
    return () => {
    };
  T !== void 0 && S.mousemove === void 0 && (S.mousemove = T), rr.reset();
  const he = m === !0 ? {
    color: !0,
    date: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
    textarea: !0,
    select: !0,
    radio: !0,
    checkbox: !0
  } : y !== void 0 ? y : {}, be = b === !0 || b === "all" ? {
    script: !0,
    comment: !0,
    headFavicon: !0,
    headWhitespace: !0,
    headMetaSocial: !0,
    headMetaRobots: !0,
    headMetaHttpEquiv: !0,
    headMetaVerification: !0,
    headMetaAuthorship: b === "all",
    headMetaDescKeywords: b === "all"
  } : b || {};
  UQ();
  let He, at = 0;
  const xt = (Y) => {
    for (const ye of L || [])
      ye.eventProcessor && (Y = ye.eventProcessor(Y));
    return C && !fe && (Y = C(Y)), Y;
  };
  At = (Y, ye) => {
    const te = Y;
    if (te.timestamp = cf(), Bn([Oo, "access", (ve) => ve[0], "optionalAccess", (ve) => ve.isFrozen, "call", (ve) => ve()]) && te.type !== Re.FullSnapshot && !(te.type === Re.IncrementalSnapshot && te.data.source === ge.Mutation) && Oo.forEach((ve) => ve.unfreeze()), $)
      Bn([e, "optionalCall", (ve) => ve(xt(te), ye)]);
    else if (fe) {
      const ve = {
        type: "rrweb",
        event: xt(te),
        origin: window.location.origin,
        isCheckout: ye
      };
      window.parent.postMessage(ve, "*");
    }
    if (te.type === Re.FullSnapshot)
      He = te, at = 0;
    else if (te.type === Re.IncrementalSnapshot) {
      if (te.data.source === ge.Mutation && te.data.isAttachIframe)
        return;
      at++;
      const ve = r && at >= r, Ee = n && He && te.timestamp - He.timestamp > n;
      (ve || Ee) && Rt(!0);
    }
  };
  const tt = (Y) => {
    At({
      type: Re.IncrementalSnapshot,
      data: {
        source: ge.Mutation,
        ...Y
      }
    });
  }, wt = (Y) => At({
    type: Re.IncrementalSnapshot,
    data: {
      source: ge.Scroll,
      ...Y
    }
  }), F = (Y) => At({
    type: Re.IncrementalSnapshot,
    data: {
      source: ge.CanvasMutation,
      ...Y
    }
  }), ee = (Y) => At({
    type: Re.IncrementalSnapshot,
    data: {
      source: ge.AdoptedStyleSheet,
      ...Y
    }
  }), re = new gX({
    mutationCb: tt,
    adoptedStyleSheetCb: ee
  }), nt = typeof __RRWEB_EXCLUDE_IFRAME__ == "boolean" && __RRWEB_EXCLUDE_IFRAME__ ? new fX() : new hX({
    mirror: rr,
    mutationCb: tt,
    stylesheetManager: re,
    recordCrossOriginIframes: P,
    wrappedEmit: At
  });
  for (const Y of L || [])
    Y.getMirror && Y.getMirror({
      nodeMirror: rr,
      crossOriginIframeMirror: nt.crossOriginIframeMirror,
      crossOriginIframeStyleMirror: nt.crossOriginIframeStyleMirror
    });
  const kt = new yX(), Yn = vX(G, {
    mirror: rr,
    win: window,
    mutationCb: (Y) => At({
      type: Re.IncrementalSnapshot,
      data: {
        source: ge.CanvasMutation,
        ...Y
      }
    }),
    recordCanvas: R,
    blockClass: s,
    blockSelector: i,
    unblockSelector: o,
    maxCanvasSize: A,
    sampling: S.canvas,
    dataURLOptions: _,
    errorHandler: V
  }), Pn = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ == "boolean" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new pX() : new mX({
    mutationCb: tt,
    scrollCb: wt,
    bypassOptions: {
      onMutation: Z,
      blockClass: s,
      blockSelector: i,
      unblockSelector: o,
      maskAllText: l,
      maskTextClass: u,
      unmaskTextClass: d,
      maskTextSelector: f,
      unmaskTextSelector: h,
      inlineStylesheet: p,
      maskInputOptions: he,
      dataURLOptions: _,
      maskAttributeFn: v,
      maskTextFn: x,
      maskInputFn: w,
      recordCanvas: R,
      inlineImages: q,
      sampling: S,
      slimDOMOptions: be,
      iframeManager: nt,
      stylesheetManager: re,
      canvasManager: Yn,
      keepIframeSrcFn: N,
      processedNodeManager: kt
    },
    mirror: rr
  }), Rt = (Y = !1) => {
    if (!k)
      return;
    At({
      type: Re.Meta,
      data: {
        href: window.location.href,
        width: JM(),
        height: XM()
      }
    }, Y), re.reset(), Pn.init(), Oo.forEach((te) => te.lock());
    const ye = FQ(document, {
      mirror: rr,
      blockClass: s,
      blockSelector: i,
      unblockSelector: o,
      maskAllText: l,
      maskTextClass: u,
      unmaskTextClass: d,
      maskTextSelector: f,
      unmaskTextSelector: h,
      inlineStylesheet: p,
      maskAllInputs: he,
      maskAttributeFn: v,
      maskInputFn: w,
      maskTextFn: x,
      slimDOM: be,
      dataURLOptions: _,
      recordCanvas: R,
      inlineImages: q,
      onSerialize: (te) => {
        nP(te, rr) && nt.addIframe(te), rP(te, rr) && re.trackLinkElement(te), Sg(te) && Pn.addShadowRoot(te.shadowRoot, document);
      },
      onIframeLoad: (te, ve) => {
        nt.attachIframe(te, ve), te.contentWindow && Yn.addWindow(te.contentWindow), Pn.observeAttachShadow(te);
      },
      onStylesheetLoad: (te, ve) => {
        re.attachLinkElement(te, ve);
      },
      keepIframeSrcFn: N
    });
    if (!ye)
      return console.warn("Failed to snapshot the document");
    At({
      type: Re.FullSnapshot,
      data: {
        node: ye,
        initialOffset: QM(window)
      }
    }), Oo.forEach((te) => te.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && re.adoptStyleSheets(document.adoptedStyleSheets, rr.getId(document));
  };
  uf = Rt;
  try {
    const Y = [], ye = (ve) => Ne(dX)({
      onMutation: Z,
      mutationCb: tt,
      mousemoveCb: (Ee, xn) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: xn,
          positions: Ee
        }
      }),
      mouseInteractionCb: (Ee) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: ge.MouseInteraction,
          ...Ee
        }
      }),
      scrollCb: wt,
      viewportResizeCb: (Ee) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: ge.ViewportResize,
          ...Ee
        }
      }),
      inputCb: (Ee) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: ge.Input,
          ...Ee
        }
      }),
      mediaInteractionCb: (Ee) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: ge.MediaInteraction,
          ...Ee
        }
      }),
      styleSheetRuleCb: (Ee) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: ge.StyleSheetRule,
          ...Ee
        }
      }),
      styleDeclarationCb: (Ee) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: ge.StyleDeclaration,
          ...Ee
        }
      }),
      canvasMutationCb: F,
      fontCb: (Ee) => At({
        type: Re.IncrementalSnapshot,
        data: {
          source: ge.Font,
          ...Ee
        }
      }),
      selectionCb: (Ee) => {
        At({
          type: Re.IncrementalSnapshot,
          data: {
            source: ge.Selection,
            ...Ee
          }
        });
      },
      customElementCb: (Ee) => {
        At({
          type: Re.IncrementalSnapshot,
          data: {
            source: ge.CustomElement,
            ...Ee
          }
        });
      },
      blockClass: s,
      ignoreClass: a,
      ignoreSelector: c,
      maskAllText: l,
      maskTextClass: u,
      unmaskTextClass: d,
      maskTextSelector: f,
      unmaskTextSelector: h,
      maskInputOptions: he,
      inlineStylesheet: p,
      sampling: S,
      recordDOM: k,
      recordCanvas: R,
      inlineImages: q,
      userTriggeredOnInput: D,
      collectFonts: O,
      doc: ve,
      maskAttributeFn: v,
      maskInputFn: w,
      maskTextFn: x,
      keepIframeSrcFn: N,
      blockSelector: i,
      unblockSelector: o,
      slimDOMOptions: be,
      dataURLOptions: _,
      mirror: rr,
      iframeManager: nt,
      stylesheetManager: re,
      shadowDomManager: Pn,
      processedNodeManager: kt,
      canvasManager: Yn,
      ignoreCSSAttributes: j,
      plugins: Bn([
        L,
        "optionalAccess",
        (Ee) => Ee.filter,
        "call",
        (Ee) => Ee((xn) => xn.observer),
        "optionalAccess",
        (Ee) => Ee.map,
        "call",
        (Ee) => Ee((xn) => ({
          observer: xn.observer,
          options: xn.options,
          callback: (ao) => At({
            type: Re.Plugin,
            data: {
              plugin: xn.name,
              payload: ao
            }
          })
        }))
      ]) || []
    }, {});
    nt.addLoadListener((ve) => {
      try {
        Y.push(ye(ve.contentDocument));
      } catch (Ee) {
        console.warn(Ee);
      }
    });
    const te = () => {
      Rt(), Y.push(ye(document));
    };
    return document.readyState === "interactive" || document.readyState === "complete" ? te() : (Y.push(mn("DOMContentLoaded", () => {
      At({
        type: Re.DomContentLoaded,
        data: {}
      }), M === "DOMContentLoaded" && te();
    })), Y.push(mn("load", () => {
      At({
        type: Re.Load,
        data: {}
      }), M === "load" && te();
    }, window))), () => {
      Y.forEach((ve) => ve()), kt.destroy(), uf = void 0, JQ();
    };
  } catch (Y) {
    console.warn(Y);
  }
}
function bX(t) {
  if (!uf)
    throw new Error("please take full snapshot after start recording");
  uf(t);
}
cs.mirror = rr;
cs.takeFullSnapshot = bX;
function vX(t, e) {
  try {
    return t ? t(e) : new TS();
  } catch {
    return console.warn("Unable to initialize CanvasManager"), new TS();
  }
}
const ie = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, kS = ["info", "warn", "error", "log"], cd = "[Replay] ";
function qp(t, e = "info") {
  bs(
    {
      category: "console",
      data: {
        logger: "replay"
      },
      level: e,
      message: `${cd}${t}`
    },
    { level: e }
  );
}
function xX() {
  let t = !1, e = !1;
  const n = {
    exception: () => {
    },
    infoTick: () => {
    },
    setConfig: (r) => {
      t = r.captureExceptions, e = r.traceInternals;
    }
  };
  return ie ? (kS.forEach((r) => {
    n[r] = (...s) => {
      H[r](cd, ...s), e && qp(s.join(""), GR(r));
    };
  }), n.exception = (r, ...s) => {
    s.length && n.error && n.error(...s), H.error(cd, r), t ? uh(r) : e && qp(r, "error");
  }, n.infoTick = (...r) => {
    H.info(cd, ...r), e && setTimeout(() => qp(r[0]), 0);
  }) : kS.forEach((r) => {
    n[r] = () => {
    };
  }), n;
}
const ue = xX(), wX = 3, AX = 5;
function Xb(t) {
  return t > 9999999999 ? t : t * 1e3;
}
function Np(t) {
  return t > 9999999999 ? t / 1e3 : t;
}
function Nl(t, e) {
  e.category !== "sentry.transaction" && (["ui.click", "ui.input"].includes(e.category) ? t.triggerUserActivity() : t.checkAndHandleExpiredSession(), t.addUpdate(() => (t.throttledAddEvent({
    type: Re.Custom,
    // TODO: We were converting from ms to seconds for breadcrumbs, spans,
    // but maybe we should just keep them as milliseconds
    timestamp: (e.timestamp || 0) * 1e3,
    data: {
      tag: "breadcrumb",
      // normalize to max. 10 depth and 1_000 properties per object
      payload: xr(e, 10, 1e3)
    }
  }), e.category === "console")));
}
const SX = "button,a";
function uP(t) {
  return t.closest(SX) || t;
}
function dP(t) {
  const e = fP(t);
  return !e || !(e instanceof Element) ? e : uP(e);
}
function fP(t) {
  return EX(t) ? t.target : t;
}
function EX(t) {
  return typeof t == "object" && !!t && "target" in t;
}
let Ds;
function CX(t) {
  return Ds || (Ds = [], _X()), Ds.push(t), () => {
    const e = Ds ? Ds.indexOf(t) : -1;
    e > -1 && Ds.splice(e, 1);
  };
}
function _X() {
  _n(lt, "open", function(t) {
    return function(...e) {
      if (Ds)
        try {
          Ds.forEach((n) => n());
        } catch {
        }
      return t.apply(lt, e);
    };
  });
}
const TX = /* @__PURE__ */ new Set([
  ge.Mutation,
  ge.StyleSheetRule,
  ge.StyleDeclaration,
  ge.AdoptedStyleSheet,
  ge.CanvasMutation,
  ge.Selection,
  ge.MediaInteraction
]);
function kX(t, e, n) {
  t.handleClick(e, n);
}
class RX {
  // protected for testing
  constructor(e, n, r = Nl) {
    this._lastMutation = 0, this._lastScroll = 0, this._clicks = [], this._timeout = n.timeout / 1e3, this._threshold = n.threshold / 1e3, this._scollTimeout = n.scrollTimeout / 1e3, this._replay = e, this._ignoreSelector = n.ignoreSelector, this._addBreadcrumbEvent = r;
  }
  /** Register click detection handlers on mutation or scroll. */
  addListeners() {
    const e = CX(() => {
      this._lastMutation = RS();
    });
    this._teardown = () => {
      e(), this._clicks = [], this._lastMutation = 0, this._lastScroll = 0;
    };
  }
  /** Clean up listeners. */
  removeListeners() {
    this._teardown && this._teardown(), this._checkClickTimeout && clearTimeout(this._checkClickTimeout);
  }
  /** @inheritDoc */
  handleClick(e, n) {
    if (PX(n, this._ignoreSelector) || !IX(e))
      return;
    const r = {
      timestamp: Np(e.timestamp),
      clickBreadcrumb: e,
      // Set this to 0 so we know it originates from the click breadcrumb
      clickCount: 0,
      node: n
    };
    this._clicks.some((s) => s.node === r.node && Math.abs(s.timestamp - r.timestamp) < 1) || (this._clicks.push(r), this._clicks.length === 1 && this._scheduleCheckClicks());
  }
  /** @inheritDoc */
  registerMutation(e = Date.now()) {
    this._lastMutation = Np(e);
  }
  /** @inheritDoc */
  registerScroll(e = Date.now()) {
    this._lastScroll = Np(e);
  }
  /** @inheritDoc */
  registerClick(e) {
    const n = uP(e);
    this._handleMultiClick(n);
  }
  /** Count multiple clicks on elements. */
  _handleMultiClick(e) {
    this._getClicks(e).forEach((n) => {
      n.clickCount++;
    });
  }
  /** Get all pending clicks for a given node. */
  _getClicks(e) {
    return this._clicks.filter((n) => n.node === e);
  }
  /** Check the clicks that happened. */
  _checkClicks() {
    const e = [], n = RS();
    this._clicks.forEach((r) => {
      !r.mutationAfter && this._lastMutation && (r.mutationAfter = r.timestamp <= this._lastMutation ? this._lastMutation - r.timestamp : void 0), !r.scrollAfter && this._lastScroll && (r.scrollAfter = r.timestamp <= this._lastScroll ? this._lastScroll - r.timestamp : void 0), r.timestamp + this._timeout <= n && e.push(r);
    });
    for (const r of e) {
      const s = this._clicks.indexOf(r);
      s > -1 && (this._generateBreadcrumbs(r), this._clicks.splice(s, 1));
    }
    this._clicks.length && this._scheduleCheckClicks();
  }
  /** Generate matching breadcrumb(s) for the click. */
  _generateBreadcrumbs(e) {
    const n = this._replay, r = e.scrollAfter && e.scrollAfter <= this._scollTimeout, s = e.mutationAfter && e.mutationAfter <= this._threshold, i = !r && !s, { clickCount: o, clickBreadcrumb: a } = e;
    if (i) {
      const c = Math.min(e.mutationAfter || this._timeout, this._timeout) * 1e3, l = c < this._timeout * 1e3 ? "mutation" : "timeout", u = {
        type: "default",
        message: a.message,
        timestamp: a.timestamp,
        category: "ui.slowClickDetected",
        data: {
          ...a.data,
          url: lt.location.href,
          route: n.getCurrentRoute(),
          timeAfterClickMs: c,
          endReason: l,
          // If clickCount === 0, it means multiClick was not correctly captured here
          // - we still want to send 1 in this case
          clickCount: o || 1
        }
      };
      this._addBreadcrumbEvent(n, u);
      return;
    }
    if (o > 1) {
      const c = {
        type: "default",
        message: a.message,
        timestamp: a.timestamp,
        category: "ui.multiClick",
        data: {
          ...a.data,
          url: lt.location.href,
          route: n.getCurrentRoute(),
          clickCount: o,
          metric: !0
        }
      };
      this._addBreadcrumbEvent(n, c);
    }
  }
  /** Schedule to check current clicks. */
  _scheduleCheckClicks() {
    this._checkClickTimeout && clearTimeout(this._checkClickTimeout), this._checkClickTimeout = da(() => this._checkClicks(), 1e3);
  }
}
const MX = ["A", "BUTTON", "INPUT"];
function PX(t, e) {
  return !!(!MX.includes(t.tagName) || t.tagName === "INPUT" && !["submit", "button"].includes(t.getAttribute("type") || "") || t.tagName === "A" && (t.hasAttribute("download") || t.hasAttribute("target") && t.getAttribute("target") !== "_self") || e && t.matches(e));
}
function IX(t) {
  return !!(t.data && typeof t.data.nodeId == "number" && t.timestamp);
}
function RS() {
  return Date.now() / 1e3;
}
function DX(t, e) {
  try {
    if (!OX(e))
      return;
    const { source: n } = e.data;
    if (TX.has(n) && t.registerMutation(e.timestamp), n === ge.Scroll && t.registerScroll(e.timestamp), qX(e)) {
      const { type: r, id: s } = e.data, i = cs.mirror.getNode(s);
      i instanceof HTMLElement && r === hn.Click && t.registerClick(i);
    }
  } catch {
  }
}
function OX(t) {
  return t.type === wX;
}
function qX(t) {
  return t.data.source === ge.MouseInteraction;
}
function Er(t) {
  return {
    timestamp: Date.now() / 1e3,
    type: "default",
    ...t
  };
}
var df;
(function(t) {
  t[t.Document = 0] = "Document", t[t.DocumentType = 1] = "DocumentType", t[t.Element = 2] = "Element", t[t.Text = 3] = "Text", t[t.CDATA = 4] = "CDATA", t[t.Comment = 5] = "Comment";
})(df || (df = {}));
const NX = /* @__PURE__ */ new Set([
  "id",
  "class",
  "aria-label",
  "role",
  "name",
  "alt",
  "title",
  "data-test-id",
  "data-testid",
  "disabled",
  "aria-disabled",
  "data-sentry-component"
]);
function LX(t) {
  const e = {};
  !t["data-sentry-component"] && t["data-sentry-element"] && (t["data-sentry-component"] = t["data-sentry-element"]);
  for (const n in t)
    if (NX.has(n)) {
      let r = n;
      (n === "data-testid" || n === "data-test-id") && (r = "testId"), e[r] = t[n];
    }
  return e;
}
const jX = (t) => (e) => {
  if (!t.isEnabled())
    return;
  const n = BX(e);
  if (!n)
    return;
  const r = e.name === "click", s = r ? e.event : void 0;
  r && t.clickDetector && s && s.target && !s.altKey && !s.metaKey && !s.ctrlKey && !s.shiftKey && kX(
    t.clickDetector,
    n,
    dP(e.event)
  ), Nl(t, n);
};
function hP(t, e) {
  const n = cs.mirror.getId(t), r = n && cs.mirror.getNode(n), s = r && cs.mirror.getMeta(r), i = s && VX(s) ? s : null;
  return {
    message: e,
    data: i ? {
      nodeId: n,
      node: {
        id: n,
        tagName: i.tagName,
        textContent: Array.from(i.childNodes).map((o) => o.type === df.Text && o.textContent).filter(Boolean).map((o) => o.trim()).join(""),
        attributes: LX(i.attributes)
      }
    } : {}
  };
}
function BX(t) {
  const { target: e, message: n } = FX(t);
  return Er({
    category: `ui.${t.name}`,
    ...hP(e, n)
  });
}
function FX(t) {
  const e = t.name === "click";
  let n, r = null;
  try {
    r = e ? dP(t.event) : fP(t.event), n = ps(r, { maxStringLength: 200 }) || "<unknown>";
  } catch {
    n = "<unknown>";
  }
  return { target: r, message: n };
}
function VX(t) {
  return t.type === df.Element;
}
function UX(t, e) {
  if (!t.isEnabled())
    return;
  t.updateUserActivity();
  const n = WX(e);
  n && Nl(t, n);
}
function WX(t) {
  const { metaKey: e, shiftKey: n, ctrlKey: r, altKey: s, key: i, target: o } = t;
  if (!o || zX(o) || !i)
    return null;
  const a = e || r || s, c = i.length === 1;
  if (!a && c)
    return null;
  const l = ps(o, { maxStringLength: 200 }) || "<unknown>", u = hP(o, l);
  return Er({
    category: "ui.keyDown",
    message: l,
    data: {
      ...u.data,
      metaKey: e,
      shiftKey: n,
      ctrlKey: r,
      altKey: s,
      key: i
    }
  });
}
function zX(t) {
  return t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable;
}
const HX = {
  // @ts-expect-error TODO: entry type does not fit the create* functions entry type
  resource: ZX,
  paint: KX,
  // @ts-expect-error TODO: entry type does not fit the create* functions entry type
  navigation: $X
};
function Pu(t, e) {
  return ({ metric: n }) => void e.replayPerformanceEntries.push(t(n));
}
function YX(t) {
  return t.map(GX).filter(Boolean);
}
function GX(t) {
  const e = HX[t.entryType];
  return e ? e(t) : null;
}
function pa(t) {
  return ((vn || lt.performance.timeOrigin) + t) / 1e3;
}
function KX(t) {
  const { duration: e, entryType: n, name: r, startTime: s } = t, i = pa(s);
  return {
    type: n,
    name: r,
    start: i,
    end: i + e,
    data: void 0
  };
}
function $X(t) {
  const {
    entryType: e,
    name: n,
    decodedBodySize: r,
    duration: s,
    domComplete: i,
    encodedBodySize: o,
    domContentLoadedEventStart: a,
    domContentLoadedEventEnd: c,
    domInteractive: l,
    loadEventStart: u,
    loadEventEnd: d,
    redirectCount: f,
    startTime: h,
    transferSize: p,
    type: m
  } = t;
  return s === 0 ? null : {
    type: `${e}.${m}`,
    start: pa(h),
    end: pa(i),
    name: n,
    data: {
      size: p,
      decodedBodySize: r,
      encodedBodySize: o,
      duration: s,
      domInteractive: l,
      domContentLoadedEventStart: a,
      domContentLoadedEventEnd: c,
      loadEventStart: u,
      loadEventEnd: d,
      domComplete: i,
      redirectCount: f
    }
  };
}
function ZX(t) {
  const {
    entryType: e,
    initiatorType: n,
    name: r,
    responseEnd: s,
    startTime: i,
    decodedBodySize: o,
    encodedBodySize: a,
    responseStatus: c,
    transferSize: l
  } = t;
  return ["fetch", "xmlhttprequest"].includes(n) ? null : {
    type: `${e}.${n}`,
    start: pa(i),
    end: pa(s),
    name: r,
    data: {
      size: l,
      statusCode: c,
      decodedBodySize: o,
      encodedBodySize: a
    }
  };
}
function QX(t) {
  const e = t.entries[t.entries.length - 1], n = e && e.element ? [e.element] : void 0;
  return gh(t, "largest-contentful-paint", n);
}
function XX(t) {
  return t.sources !== void 0;
}
function JX(t) {
  const e = [], n = [];
  for (const r of t.entries)
    if (XX(r)) {
      const s = [];
      for (const i of r.sources)
        if (i.node) {
          n.push(i.node);
          const o = cs.mirror.getId(i.node);
          o && s.push(o);
        }
      e.push({ value: r.value, nodeIds: s.length ? s : void 0 });
    }
  return gh(t, "cumulative-layout-shift", n, e);
}
function eJ(t) {
  const e = t.entries[t.entries.length - 1], n = e && e.target ? [e.target] : void 0;
  return gh(t, "first-input-delay", n);
}
function tJ(t) {
  const e = t.entries[t.entries.length - 1], n = e && e.target ? [e.target] : void 0;
  return gh(t, "interaction-to-next-paint", n);
}
function gh(t, e, n, r) {
  const s = t.value, i = t.rating, o = pa(s);
  return {
    type: "web-vital",
    name: e,
    start: o,
    end: o,
    data: {
      value: s,
      size: s,
      rating: i,
      nodeIds: n ? n.map((a) => cs.mirror.getId(a)) : void 0,
      attributions: r
    }
  };
}
function nJ(t) {
  function e(s) {
    t.performanceEntries.includes(s) || t.performanceEntries.push(s);
  }
  function n({ entries: s }) {
    s.forEach(e);
  }
  const r = [];
  return ["navigation", "paint", "resource"].forEach((s) => {
    r.push(la(s, n));
  }), r.push(
    IM(Pu(QX, t)),
    Wb(Pu(JX, t)),
    DM(Pu(eJ, t)),
    OM(Pu(tJ, t))
  ), () => {
    r.forEach((s) => s());
  };
}
const rJ = 'var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),J="undefined"!=typeof TextEncoder&&new TextEncoder,K="undefined"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(J)return J.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),a=i.length;return q(i,n),j(i,a-8,r.d()),j(i,a-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&"function"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});';
function sJ() {
  const t = new Blob([rJ]);
  return URL.createObjectURL(t);
}
class Jb extends Error {
  constructor() {
    super(`Event buffer exceeded maximum size of ${Gb}.`);
  }
}
class pP {
  /** All the events that are buffered to be sent. */
  /** @inheritdoc */
  constructor() {
    this.events = [], this._totalSize = 0, this.hasCheckout = !1;
  }
  /** @inheritdoc */
  get hasEvents() {
    return this.events.length > 0;
  }
  /** @inheritdoc */
  get type() {
    return "sync";
  }
  /** @inheritdoc */
  destroy() {
    this.events = [];
  }
  /** @inheritdoc */
  async addEvent(e) {
    const n = JSON.stringify(e).length;
    if (this._totalSize += n, this._totalSize > Gb)
      throw new Jb();
    this.events.push(e);
  }
  /** @inheritdoc */
  finish() {
    return new Promise((e) => {
      const n = this.events;
      this.clear(), e(JSON.stringify(n));
    });
  }
  /** @inheritdoc */
  clear() {
    this.events = [], this._totalSize = 0, this.hasCheckout = !1;
  }
  /** @inheritdoc */
  getEarliestTimestamp() {
    const e = this.events.map((n) => n.timestamp).sort()[0];
    return e ? Xb(e) : null;
  }
}
class iJ {
  constructor(e) {
    this._worker = e, this._id = 0;
  }
  /**
   * Ensure the worker is ready (or not).
   * This will either resolve when the worker is ready, or reject if an error occured.
   */
  ensureReady() {
    return this._ensureReadyPromise ? this._ensureReadyPromise : (this._ensureReadyPromise = new Promise((e, n) => {
      this._worker.addEventListener(
        "message",
        ({ data: r }) => {
          r.success ? e() : n();
        },
        { once: !0 }
      ), this._worker.addEventListener(
        "error",
        (r) => {
          n(r);
        },
        { once: !0 }
      );
    }), this._ensureReadyPromise);
  }
  /**
   * Destroy the worker.
   */
  destroy() {
    ie && ue.info("Destroying compression worker"), this._worker.terminate();
  }
  /**
   * Post message to worker and wait for response before resolving promise.
   */
  postMessage(e, n) {
    const r = this._getAndIncrementId();
    return new Promise((s, i) => {
      const o = ({ data: a }) => {
        const c = a;
        if (c.method === e && c.id === r) {
          if (this._worker.removeEventListener("message", o), !c.success) {
            ie && ue.error("Error in compression worker: ", c.response), i(new Error("Error in compression worker"));
            return;
          }
          s(c.response);
        }
      };
      this._worker.addEventListener("message", o), this._worker.postMessage({ id: r, method: e, arg: n });
    });
  }
  /** Get the current ID and increment it for the next call. */
  _getAndIncrementId() {
    return this._id++;
  }
}
class oJ {
  /** @inheritdoc */
  constructor(e) {
    this._worker = new iJ(e), this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1;
  }
  /** @inheritdoc */
  get hasEvents() {
    return !!this._earliestTimestamp;
  }
  /** @inheritdoc */
  get type() {
    return "worker";
  }
  /**
   * Ensure the worker is ready (or not).
   * This will either resolve when the worker is ready, or reject if an error occured.
   */
  ensureReady() {
    return this._worker.ensureReady();
  }
  /**
   * Destroy the event buffer.
   */
  destroy() {
    this._worker.destroy();
  }
  /**
   * Add an event to the event buffer.
   *
   * Returns true if event was successfuly received and processed by worker.
   */
  addEvent(e) {
    const n = Xb(e.timestamp);
    (!this._earliestTimestamp || n < this._earliestTimestamp) && (this._earliestTimestamp = n);
    const r = JSON.stringify(e);
    return this._totalSize += r.length, this._totalSize > Gb ? Promise.reject(new Jb()) : this._sendEventToWorker(r);
  }
  /**
   * Finish the event buffer and return the compressed data.
   */
  finish() {
    return this._finishRequest();
  }
  /** @inheritdoc */
  clear() {
    this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1, this._worker.postMessage("clear").then(null, (e) => {
      ie && ue.exception(e, 'Sending "clear" message to worker failed', e);
    });
  }
  /** @inheritdoc */
  getEarliestTimestamp() {
    return this._earliestTimestamp;
  }
  /**
   * Send the event to the worker.
   */
  _sendEventToWorker(e) {
    return this._worker.postMessage("addEvent", e);
  }
  /**
   * Finish the request and return the compressed data from the worker.
   */
  async _finishRequest() {
    const e = await this._worker.postMessage("finish");
    return this._earliestTimestamp = null, this._totalSize = 0, e;
  }
}
class aJ {
  constructor(e) {
    this._fallback = new pP(), this._compression = new oJ(e), this._used = this._fallback, this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();
  }
  /** @inheritdoc */
  get type() {
    return this._used.type;
  }
  /** @inheritDoc */
  get hasEvents() {
    return this._used.hasEvents;
  }
  /** @inheritdoc */
  get hasCheckout() {
    return this._used.hasCheckout;
  }
  /** @inheritdoc */
  set hasCheckout(e) {
    this._used.hasCheckout = e;
  }
  /** @inheritDoc */
  destroy() {
    this._fallback.destroy(), this._compression.destroy();
  }
  /** @inheritdoc */
  clear() {
    return this._used.clear();
  }
  /** @inheritdoc */
  getEarliestTimestamp() {
    return this._used.getEarliestTimestamp();
  }
  /**
   * Add an event to the event buffer.
   *
   * Returns true if event was successfully added.
   */
  addEvent(e) {
    return this._used.addEvent(e);
  }
  /** @inheritDoc */
  async finish() {
    return await this.ensureWorkerIsLoaded(), this._used.finish();
  }
  /** Ensure the worker has loaded. */
  ensureWorkerIsLoaded() {
    return this._ensureWorkerIsLoadedPromise;
  }
  /** Actually check if the worker has been loaded. */
  async _ensureWorkerIsLoaded() {
    try {
      await this._compression.ensureReady();
    } catch (e) {
      ie && ue.exception(e, "Failed to load the compression worker, falling back to simple buffer");
      return;
    }
    await this._switchToCompressionWorker();
  }
  /** Switch the used buffer to the compression worker. */
  async _switchToCompressionWorker() {
    const { events: e, hasCheckout: n } = this._fallback, r = [];
    for (const s of e)
      r.push(this._compression.addEvent(s));
    this._compression.hasCheckout = n, this._used = this._compression;
    try {
      await Promise.all(r), this._fallback.clear();
    } catch (s) {
      ie && ue.exception(s, "Failed to add events when switching buffers.");
    }
  }
}
function cJ({
  useCompression: t,
  workerUrl: e
}) {
  if (t && // eslint-disable-next-line no-restricted-globals
  window.Worker) {
    const n = lJ(e);
    if (n)
      return n;
  }
  return ie && ue.info("Using simple buffer"), new pP();
}
function lJ(t) {
  try {
    const e = t || uJ();
    if (!e)
      return;
    ie && ue.info(`Using compression worker${t ? ` from ${t}` : ""}`);
    const n = new Worker(e);
    return new aJ(n);
  } catch (e) {
    ie && ue.exception(e, "Failed to create compression worker");
  }
}
function uJ() {
  return typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ > "u" || !__SENTRY_EXCLUDE_REPLAY_WORKER__ ? sJ() : "";
}
function e0() {
  try {
    return "sessionStorage" in lt && !!lt.sessionStorage;
  } catch {
    return !1;
  }
}
function dJ(t) {
  fJ(), t.session = void 0;
}
function fJ() {
  if (e0())
    try {
      lt.sessionStorage.removeItem(Hb);
    } catch {
    }
}
function mP(t) {
  return t === void 0 ? !1 : Math.random() < t;
}
function gP(t) {
  const e = Date.now(), n = t.id || gt(), r = t.started || e, s = t.lastActivity || e, i = t.segmentId || 0, o = t.sampled, a = t.previousSessionId;
  return {
    id: n,
    started: r,
    lastActivity: s,
    segmentId: i,
    sampled: o,
    previousSessionId: a
  };
}
function t0(t) {
  if (e0())
    try {
      lt.sessionStorage.setItem(Hb, JSON.stringify(t));
    } catch {
    }
}
function hJ(t, e) {
  return mP(t) ? "session" : e ? "buffer" : !1;
}
function MS({ sessionSampleRate: t, allowBuffering: e, stickySession: n = !1 }, { previousSessionId: r } = {}) {
  const s = hJ(t, e), i = gP({
    sampled: s,
    previousSessionId: r
  });
  return n && t0(i), i;
}
function pJ() {
  if (!e0())
    return null;
  try {
    const t = lt.sessionStorage.getItem(Hb);
    if (!t)
      return null;
    const e = JSON.parse(t);
    return ie && ue.infoTick("Loading existing session"), gP(e);
  } catch {
    return null;
  }
}
function _g(t, e, n = +/* @__PURE__ */ new Date()) {
  return t === null || e === void 0 || e < 0 ? !0 : e === 0 ? !1 : t + e <= n;
}
function yP(t, {
  maxReplayDuration: e,
  sessionIdleExpire: n,
  targetTime: r = Date.now()
}) {
  return (
    // First, check that maximum session length has not been exceeded
    _g(t.started, e, r) || // check that the idle timeout has not been exceeded (i.e. user has
    // performed an action within the last `sessionIdleExpire` ms)
    _g(t.lastActivity, n, r)
  );
}
function bP(t, { sessionIdleExpire: e, maxReplayDuration: n }) {
  return !(!yP(t, { sessionIdleExpire: e, maxReplayDuration: n }) || t.sampled === "buffer" && t.segmentId === 0);
}
function Lp({
  sessionIdleExpire: t,
  maxReplayDuration: e,
  previousSessionId: n
}, r) {
  const s = r.stickySession && pJ();
  return s ? bP(s, { sessionIdleExpire: t, maxReplayDuration: e }) ? (ie && ue.infoTick("Session in sessionStorage is expired, creating new one..."), MS(r, { previousSessionId: s.id })) : s : (ie && ue.infoTick("Creating new session"), MS(r, { previousSessionId: n }));
}
function mJ(t) {
  return t.type === Re.Custom;
}
function n0(t, e, n) {
  return xP(t, e) ? (vP(t, e, n), !0) : !1;
}
function gJ(t, e, n) {
  return xP(t, e) ? vP(t, e, n) : Promise.resolve(null);
}
async function vP(t, e, n) {
  if (!t.eventBuffer)
    return null;
  try {
    n && t.recordingMode === "buffer" && t.eventBuffer.clear(), n && (t.eventBuffer.hasCheckout = !0);
    const r = t.getOptions(), s = yJ(e, r.beforeAddRecordingEvent);
    return s ? await t.eventBuffer.addEvent(s) : void 0;
  } catch (r) {
    const s = r && r instanceof Jb ? "addEventSizeExceeded" : "addEvent";
    t.handleException(r), await t.stop({ reason: s });
    const i = ke();
    i && i.recordDroppedEvent("internal_sdk_error", "replay");
  }
}
function xP(t, e) {
  if (!t.eventBuffer || t.isPaused() || !t.isEnabled())
    return !1;
  const n = Xb(e.timestamp);
  return n + t.timeouts.sessionIdlePause < Date.now() ? !1 : n > t.getContext().initialTimestamp + t.getOptions().maxReplayDuration ? (ie && ue.infoTick(`Skipping event with timestamp ${n} because it is after maxReplayDuration`), !1) : !0;
}
function yJ(t, e) {
  try {
    if (typeof e == "function" && mJ(t))
      return e(t);
  } catch (n) {
    return ie && ue.exception(n, "An error occured in the `beforeAddRecordingEvent` callback, skipping the event..."), null;
  }
  return t;
}
function r0(t) {
  return !t.type;
}
function Tg(t) {
  return t.type === "transaction";
}
function bJ(t) {
  return t.type === "replay_event";
}
function PS(t) {
  return t.type === "feedback";
}
function vJ(t) {
  return (e, n) => {
    if (!t.isEnabled() || !r0(e) && !Tg(e))
      return;
    const r = n && n.statusCode;
    if (!(!r || r < 200 || r >= 300)) {
      if (Tg(e)) {
        xJ(t, e);
        return;
      }
      wJ(t, e);
    }
  };
}
function xJ(t, e) {
  const n = t.getContext();
  e.contexts && e.contexts.trace && e.contexts.trace.trace_id && n.traceIds.size < 100 && n.traceIds.add(e.contexts.trace.trace_id);
}
function wJ(t, e) {
  const n = t.getContext();
  if (e.event_id && n.errorIds.size < 100 && n.errorIds.add(e.event_id), t.recordingMode !== "buffer" || !e.tags || !e.tags.replayId)
    return;
  const { beforeErrorSampling: r } = t.getOptions();
  typeof r == "function" && !r(e) || da(async () => {
    try {
      await t.sendBufferedReplayOrFlush();
    } catch (s) {
      t.handleException(s);
    }
  });
}
function AJ(t) {
  return (e) => {
    !t.isEnabled() || !r0(e) || SJ(t, e);
  };
}
function SJ(t, e) {
  const n = e.exception && e.exception.values && e.exception.values[0] && e.exception.values[0].value;
  if (typeof n == "string" && // Only matches errors in production builds of react-dom
  // Example https://reactjs.org/docs/error-decoder.html?invariant=423
  // With newer React versions, the messages changed to a different website https://react.dev/errors/418
  (n.match(
    /(reactjs\.org\/docs\/error-decoder\.html\?invariant=|react\.dev\/errors\/)(418|419|422|423|425)/
  ) || // Development builds of react-dom
  // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.
  // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.
  n.match(/(does not match server-rendered HTML|Hydration failed because)/i))) {
    const r = Er({
      category: "replay.hydrate-error",
      data: {
        url: MR()
      }
    });
    Nl(t, r);
  }
}
function EJ(t) {
  const e = ke();
  e && e.on("beforeAddBreadcrumb", (n) => CJ(t, n));
}
function CJ(t, e) {
  if (!t.isEnabled() || !wP(e))
    return;
  const n = _J(e);
  n && Nl(t, n);
}
function _J(t) {
  return !wP(t) || [
    // fetch & xhr are handled separately,in handleNetworkBreadcrumbs
    "fetch",
    "xhr",
    // These two are breadcrumbs for emitted sentry events, we don't care about them
    "sentry.event",
    "sentry.transaction"
  ].includes(t.category) || // We capture UI breadcrumbs separately
  t.category.startsWith("ui.") ? null : t.category === "console" ? TJ(t) : Er(t);
}
function TJ(t) {
  const e = t.data && t.data.arguments;
  if (!Array.isArray(e) || e.length === 0)
    return Er(t);
  let n = !1;
  const r = e.map((s) => {
    if (!s)
      return s;
    if (typeof s == "string")
      return s.length > ku ? (n = !0, `${s.slice(0, ku)}`) : s;
    if (typeof s == "object")
      try {
        const i = xr(s, 7);
        return JSON.stringify(i).length > ku ? (n = !0, `${JSON.stringify(i, null, 2).slice(0, ku)}`) : i;
      } catch {
      }
    return s;
  });
  return Er({
    ...t,
    data: {
      ...t.data,
      arguments: r,
      ...n ? { _meta: { warnings: ["CONSOLE_ARG_TRUNCATED"] } } : {}
    }
  });
}
function wP(t) {
  return !!t.category;
}
function kJ(t, e) {
  return t.type || !t.exception || !t.exception.values || !t.exception.values.length ? !1 : !!(e.originalException && e.originalException.__rrweb__);
}
function RJ(t, e) {
  t.triggerUserActivity(), t.addUpdate(() => e.timestamp ? (t.throttledAddEvent({
    type: Re.Custom,
    timestamp: e.timestamp * 1e3,
    data: {
      tag: "breadcrumb",
      payload: {
        timestamp: e.timestamp,
        type: "default",
        category: "sentry.feedback",
        data: {
          feedbackId: e.event_id
        }
      }
    }
  }), !1) : !0);
}
function MJ(t, e) {
  return t.recordingMode !== "buffer" || e.message === Yb || !e.exception || e.type ? !1 : mP(t.getOptions().errorSampleRate);
}
function PJ(t) {
  return Object.assign(
    (e, n) => !t.isEnabled() || t.isPaused() ? e : bJ(e) ? (delete e.breadcrumbs, e) : !r0(e) && !Tg(e) && !PS(e) || !t.checkAndHandleExpiredSession() ? e : PS(e) ? (t.flush(), e.contexts.feedback.replay_id = t.getSessionId(), RJ(t, e), e) : kJ(e, n) && !t.getOptions()._experiments.captureExceptions ? (ie && ue.log("Ignoring error from rrweb internals", e), null) : ((MJ(t, e) || t.recordingMode === "session") && (e.tags = { ...e.tags, replayId: t.getSessionId() }), e),
    { id: "Replay" }
  );
}
function yh(t, e) {
  return e.map(({ type: n, start: r, end: s, name: i, data: o }) => {
    const a = t.throttledAddEvent({
      type: Re.Custom,
      timestamp: r,
      data: {
        tag: "performanceSpan",
        payload: {
          op: n,
          description: i,
          startTimestamp: r,
          endTimestamp: s,
          data: o
        }
      }
    });
    return typeof a == "string" ? Promise.resolve(null) : a;
  });
}
function IJ(t) {
  const { from: e, to: n } = t, r = Date.now() / 1e3;
  return {
    type: "navigation.push",
    start: r,
    end: r,
    name: n,
    data: {
      previous: e
    }
  };
}
function DJ(t) {
  return (e) => {
    if (!t.isEnabled())
      return;
    const n = IJ(e);
    n !== null && (t.getContext().urls.push(n.name), t.triggerUserActivity(), t.addUpdate(() => (yh(t, [n]), !1)));
  };
}
function OJ(t, e) {
  return ie && t.getOptions()._experiments.traceInternals ? !1 : nK(e, ke());
}
function AP(t, e) {
  t.isEnabled() && e !== null && (OJ(t, e.name) || t.addUpdate(() => (yh(t, [e]), !0)));
}
function bh(t) {
  if (!t)
    return;
  const e = new TextEncoder();
  try {
    if (typeof t == "string")
      return e.encode(t).length;
    if (t instanceof URLSearchParams)
      return e.encode(t.toString()).length;
    if (t instanceof FormData) {
      const n = _P(t);
      return e.encode(n).length;
    }
    if (t instanceof Blob)
      return t.size;
    if (t instanceof ArrayBuffer)
      return t.byteLength;
  } catch {
  }
}
function SP(t) {
  if (!t)
    return;
  const e = parseInt(t, 10);
  return isNaN(e) ? void 0 : e;
}
function EP(t) {
  try {
    if (typeof t == "string")
      return [t];
    if (t instanceof URLSearchParams)
      return [t.toString()];
    if (t instanceof FormData)
      return [_P(t)];
    if (!t)
      return [void 0];
  } catch (e) {
    return ie && ue.exception(e, "Failed to serialize body", t), [void 0, "BODY_PARSE_ERROR"];
  }
  return ie && ue.info("Skipping network body because of body type", t), [void 0, "UNPARSEABLE_BODY_TYPE"];
}
function ff(t, e) {
  if (!t)
    return {
      headers: {},
      size: void 0,
      _meta: {
        warnings: [e]
      }
    };
  const n = { ...t._meta }, r = n.warnings || [];
  return n.warnings = [...r, e], t._meta = n, t;
}
function CP(t, e) {
  if (!e)
    return null;
  const { startTimestamp: n, endTimestamp: r, url: s, method: i, statusCode: o, request: a, response: c } = e;
  return {
    type: t,
    start: n / 1e3,
    end: r / 1e3,
    name: s,
    data: Vt({
      method: i,
      statusCode: o,
      request: a,
      response: c
    })
  };
}
function fl(t) {
  return {
    headers: {},
    size: t,
    _meta: {
      warnings: ["URL_SKIPPED"]
    }
  };
}
function Hs(t, e, n) {
  if (!e && Object.keys(t).length === 0)
    return;
  if (!e)
    return {
      headers: t
    };
  if (!n)
    return {
      headers: t,
      size: e
    };
  const r = {
    headers: t,
    size: e
  }, { body: s, warnings: i } = qJ(n);
  return r.body = s, i && i.length > 0 && (r._meta = {
    warnings: i
  }), r;
}
function kg(t, e) {
  return Object.entries(t).reduce((n, [r, s]) => {
    const i = r.toLowerCase();
    return e.includes(i) && t[r] && (n[i] = s), n;
  }, {});
}
function _P(t) {
  return new URLSearchParams(t).toString();
}
function qJ(t) {
  if (!t || typeof t != "string")
    return {
      body: t
    };
  const e = t.length > hS, n = NJ(t);
  if (e) {
    const r = t.slice(0, hS);
    return n ? {
      body: r,
      warnings: ["MAYBE_JSON_TRUNCATED"]
    } : {
      body: `${r}`,
      warnings: ["TEXT_TRUNCATED"]
    };
  }
  if (n)
    try {
      return {
        body: JSON.parse(t)
      };
    } catch {
    }
  return {
    body: t
  };
}
function NJ(t) {
  const e = t[0], n = t[t.length - 1];
  return e === "[" && n === "]" || e === "{" && n === "}";
}
function hf(t, e) {
  const n = LJ(t);
  return zs(n, e);
}
function LJ(t, e = lt.document.baseURI) {
  if (t.startsWith("http://") || t.startsWith("https://") || t.startsWith(lt.location.origin))
    return t;
  const n = new URL(t, e);
  if (n.origin !== new URL(e).origin)
    return t;
  const r = n.href;
  return !t.endsWith("/") && r.endsWith("/") ? r.slice(0, -1) : r;
}
async function jJ(t, e, n) {
  try {
    const r = await FJ(t, e, n), s = CP("resource.fetch", r);
    AP(n.replay, s);
  } catch (r) {
    ie && ue.exception(r, "Failed to capture fetch breadcrumb");
  }
}
function BJ(t, e) {
  const { input: n, response: r } = e, s = n ? TP(n) : void 0, i = bh(s), o = r ? SP(r.headers.get("content-length")) : void 0;
  i !== void 0 && (t.data.request_body_size = i), o !== void 0 && (t.data.response_body_size = o);
}
async function FJ(t, e, n) {
  const r = Date.now(), { startTimestamp: s = r, endTimestamp: i = r } = e, {
    url: o,
    method: a,
    status_code: c = 0,
    request_body_size: l,
    response_body_size: u
  } = t.data, d = hf(o, n.networkDetailAllowUrls) && !hf(o, n.networkDetailDenyUrls), f = d ? VJ(n, e.input, l) : fl(l), h = await UJ(d, n, e.response, u);
  return {
    startTimestamp: s,
    endTimestamp: i,
    url: o,
    method: a,
    statusCode: c,
    request: f,
    response: h
  };
}
function VJ({ networkCaptureBodies: t, networkRequestHeaders: e }, n, r) {
  const s = n ? HJ(n, e) : {};
  if (!t)
    return Hs(s, r, void 0);
  const i = TP(n), [o, a] = EP(i), c = Hs(s, r, o);
  return a ? ff(c, a) : c;
}
async function UJ(t, {
  networkCaptureBodies: e,
  networkResponseHeaders: n
}, r, s) {
  if (!t && s !== void 0)
    return fl(s);
  const i = r ? kP(r.headers, n) : {};
  if (!r || !e && s !== void 0)
    return Hs(i, s, void 0);
  const [o, a] = await zJ(r), c = WJ(o, {
    networkCaptureBodies: e,
    responseBodySize: s,
    captureDetails: t,
    headers: i
  });
  return a ? ff(c, a) : c;
}
function WJ(t, {
  networkCaptureBodies: e,
  responseBodySize: n,
  captureDetails: r,
  headers: s
}) {
  try {
    const i = t && t.length && n === void 0 ? bh(t) : n;
    return r ? e ? Hs(s, i, t) : Hs(s, i, void 0) : fl(i);
  } catch (i) {
    return ie && ue.exception(i, "Failed to serialize response body"), Hs(s, n, void 0);
  }
}
async function zJ(t) {
  const e = YJ(t);
  if (!e)
    return [void 0, "BODY_PARSE_ERROR"];
  try {
    return [await GJ(e)];
  } catch (n) {
    return n instanceof Error && n.message.indexOf("Timeout") > -1 ? (ie && ue.warn("Parsing text body from response timed out"), [void 0, "BODY_PARSE_TIMEOUT"]) : (ie && ue.exception(n, "Failed to get text body from response"), [void 0, "BODY_PARSE_ERROR"]);
  }
}
function TP(t = []) {
  if (!(t.length !== 2 || typeof t[1] != "object"))
    return t[1].body;
}
function kP(t, e) {
  const n = {};
  return e.forEach((r) => {
    t.get(r) && (n[r] = t.get(r));
  }), n;
}
function HJ(t, e) {
  return t.length === 1 && typeof t[0] != "string" ? IS(t[0], e) : t.length === 2 ? IS(t[1], e) : {};
}
function IS(t, e) {
  if (!t)
    return {};
  const n = t.headers;
  return n ? n instanceof Headers ? kP(n, e) : Array.isArray(n) ? {} : kg(n, e) : {};
}
function YJ(t) {
  try {
    return t.clone();
  } catch (e) {
    ie && ue.exception(e, "Failed to clone response body");
  }
}
function GJ(t) {
  return new Promise((e, n) => {
    const r = da(() => n(new Error("Timeout while trying to read response body")), 500);
    KJ(t).then(
      (s) => e(s),
      (s) => n(s)
    ).finally(() => clearTimeout(r));
  });
}
async function KJ(t) {
  return await t.text();
}
async function $J(t, e, n) {
  try {
    const r = QJ(t, e, n), s = CP("resource.xhr", r);
    AP(n.replay, s);
  } catch (r) {
    ie && ue.exception(r, "Failed to capture xhr breadcrumb");
  }
}
function ZJ(t, e) {
  const { xhr: n, input: r } = e;
  if (!n)
    return;
  const s = bh(r), i = n.getResponseHeader("content-length") ? SP(n.getResponseHeader("content-length")) : tee(n.response, n.responseType);
  s !== void 0 && (t.data.request_body_size = s), i !== void 0 && (t.data.response_body_size = i);
}
function QJ(t, e, n) {
  const r = Date.now(), { startTimestamp: s = r, endTimestamp: i = r, input: o, xhr: a } = e, {
    url: c,
    method: l,
    status_code: u = 0,
    request_body_size: d,
    response_body_size: f
  } = t.data;
  if (!c)
    return null;
  if (!a || !hf(c, n.networkDetailAllowUrls) || hf(c, n.networkDetailDenyUrls)) {
    const C = fl(d), S = fl(f);
    return {
      startTimestamp: s,
      endTimestamp: i,
      url: c,
      method: l,
      statusCode: u,
      request: C,
      response: S
    };
  }
  const h = a[Ri], p = h ? kg(h.request_headers, n.networkRequestHeaders) : {}, m = kg(XJ(a), n.networkResponseHeaders), [y, b] = n.networkCaptureBodies ? EP(o) : [void 0], [v, w] = n.networkCaptureBodies ? JJ(a) : [void 0], x = Hs(p, d, y), A = Hs(m, f, v);
  return {
    startTimestamp: s,
    endTimestamp: i,
    url: c,
    method: l,
    statusCode: u,
    request: b ? ff(x, b) : x,
    response: w ? ff(A, w) : A
  };
}
function XJ(t) {
  const e = t.getAllResponseHeaders();
  return e ? e.split(`\r
`).reduce((n, r) => {
    const [s, i] = r.split(": ");
    return i && (n[s.toLowerCase()] = i), n;
  }, {}) : {};
}
function JJ(t) {
  const e = [];
  try {
    return [t.responseText];
  } catch (n) {
    e.push(n);
  }
  try {
    return eee(t.response, t.responseType);
  } catch (n) {
    e.push(n);
  }
  return ie && ue.warn("Failed to get xhr response body", ...e), [void 0];
}
function eee(t, e) {
  try {
    if (typeof t == "string")
      return [t];
    if (t instanceof Document)
      return [t.body.outerHTML];
    if (e === "json" && t && typeof t == "object")
      return [JSON.stringify(t)];
    if (!t)
      return [void 0];
  } catch (n) {
    return ie && ue.exception(n, "Failed to serialize body", t), [void 0, "BODY_PARSE_ERROR"];
  }
  return ie && ue.info("Skipping network body because of body type", t), [void 0, "UNPARSEABLE_BODY_TYPE"];
}
function tee(t, e) {
  try {
    const n = e === "json" && t && typeof t == "object" ? JSON.stringify(t) : t;
    return bh(n);
  } catch {
    return;
  }
}
function nee(t) {
  const e = ke();
  try {
    const {
      networkDetailAllowUrls: n,
      networkDetailDenyUrls: r,
      networkCaptureBodies: s,
      networkRequestHeaders: i,
      networkResponseHeaders: o
    } = t.getOptions(), a = {
      replay: t,
      networkDetailAllowUrls: n,
      networkDetailDenyUrls: r,
      networkCaptureBodies: s,
      networkRequestHeaders: i,
      networkResponseHeaders: o
    };
    e && e.on("beforeAddBreadcrumb", (c, l) => ree(a, c, l));
  } catch {
  }
}
function ree(t, e, n) {
  if (e.data)
    try {
      see(e) && oee(n) && (ZJ(e, n), $J(e, n, t)), iee(e) && aee(n) && (BJ(e, n), jJ(e, n, t));
    } catch (r) {
      ie && ue.exception(r, "Error when enriching network breadcrumb");
    }
}
function see(t) {
  return t.category === "xhr";
}
function iee(t) {
  return t.category === "fetch";
}
function oee(t) {
  return t && t.xhr;
}
function aee(t) {
  return t && t.response;
}
function cee(t) {
  const e = ke();
  jM(jX(t)), fh(DJ(t)), EJ(t), nee(t);
  const n = PJ(t);
  FG(n), e && (e.on("beforeSendEvent", AJ(t)), e.on("afterSendEvent", vJ(t)), e.on("createDsc", (r) => {
    const s = t.getSessionId();
    s && t.isEnabled() && t.recordingMode === "session" && t.checkAndHandleExpiredSession() && (r.replay_id = s);
  }), e.on("spanStart", (r) => {
    t.lastActiveSpan = r;
  }), e.on("spanEnd", (r) => {
    t.lastActiveSpan = r;
  }), e.on("beforeSendFeedback", (r, s) => {
    const i = t.getSessionId();
    s && s.includeReplay && t.isEnabled() && i && r.contexts && r.contexts.feedback && (r.contexts.feedback.replay_id = i);
  }));
}
async function lee(t) {
  try {
    return Promise.all(
      yh(t, [
        // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)
        uee(lt.performance.memory)
      ])
    );
  } catch {
    return [];
  }
}
function uee(t) {
  const { jsHeapSizeLimit: e, totalJSHeapSize: n, usedJSHeapSize: r } = t, s = Date.now() / 1e3;
  return {
    type: "memory",
    name: "memory",
    start: s,
    end: s,
    data: {
      memory: {
        jsHeapSizeLimit: e,
        totalJSHeapSize: n,
        usedJSHeapSize: r
      }
    }
  };
}
function dee(t, e, n) {
  let r, s, i;
  const o = n && n.maxWait ? Math.max(n.maxWait, e) : 0;
  function a() {
    return c(), r = t(), r;
  }
  function c() {
    s !== void 0 && clearTimeout(s), i !== void 0 && clearTimeout(i), s = i = void 0;
  }
  function l() {
    return s !== void 0 || i !== void 0 ? a() : r;
  }
  function u() {
    return s && clearTimeout(s), s = da(a, e), o && i === void 0 && (i = da(a, o)), r;
  }
  return u.cancel = c, u.flush = l, u;
}
function fee(t) {
  let e = !1;
  return (n, r) => {
    if (!t.checkAndHandleExpiredSession()) {
      ie && ue.warn("Received replay event after session expired.");
      return;
    }
    const s = r || !e;
    e = !0, t.clickDetector && DX(t.clickDetector, n), t.addUpdate(() => {
      if (t.recordingMode === "buffer" && s && t.setInitialState(), !n0(t, n, s))
        return !0;
      if (!s)
        return !1;
      const i = t.session;
      if (pee(t, s), t.recordingMode === "buffer" && i && t.eventBuffer) {
        const o = t.eventBuffer.getEarliestTimestamp();
        o && (ie && ue.info(`Updating session start time to earliest event in buffer to ${new Date(o)}`), i.started = o, t.getOptions().stickySession && t0(i));
      }
      return i && i.previousSessionId || t.recordingMode === "session" && t.flush(), !0;
    });
  };
}
function hee(t) {
  const e = t.getOptions();
  return {
    type: Re.Custom,
    timestamp: Date.now(),
    data: {
      tag: "options",
      payload: {
        shouldRecordCanvas: t.isRecordingCanvas(),
        sessionSampleRate: e.sessionSampleRate,
        errorSampleRate: e.errorSampleRate,
        useCompressionOption: e.useCompression,
        blockAllMedia: e.blockAllMedia,
        maskAllText: e.maskAllText,
        maskAllInputs: e.maskAllInputs,
        useCompression: t.eventBuffer ? t.eventBuffer.type === "worker" : !1,
        networkDetailHasUrls: e.networkDetailAllowUrls.length > 0,
        networkCaptureBodies: e.networkCaptureBodies,
        networkRequestHasHeaders: e.networkRequestHeaders.length > 0,
        networkResponseHasHeaders: e.networkResponseHeaders.length > 0
      }
    }
  };
}
function pee(t, e) {
  !e || !t.session || t.session.segmentId !== 0 || n0(t, hee(t), !1);
}
function mee() {
  const t = Fe().getPropagationContext().dsc;
  t && delete t.replay_id;
  const e = en();
  if (e) {
    const n = hi(e);
    delete n.replay_id;
  }
}
function gee(t, e, n, r) {
  return so(
    ZR(t, Pb(t), r, n),
    [
      [{ type: "replay_event" }, t],
      [
        {
          type: "replay_recording",
          // If string then we need to encode to UTF8, otherwise will have
          // wrong size. TextEncoder has similar browser support to
          // MutationObserver, although it does not accept IE11.
          length: typeof e == "string" ? new TextEncoder().encode(e).length : e.length
        },
        e
      ]
    ]
  );
}
function yee({
  recordingData: t,
  headers: e
}) {
  let n;
  const r = `${JSON.stringify(e)}
`;
  if (typeof t == "string")
    n = `${r}${t}`;
  else {
    const i = new TextEncoder().encode(r);
    n = new Uint8Array(i.length + t.length), n.set(i), n.set(t, i.length);
  }
  return n;
}
async function bee({
  client: t,
  scope: e,
  replayId: n,
  event: r
}) {
  const s = typeof t._integrations == "object" && t._integrations !== null && !Array.isArray(t._integrations) ? Object.keys(t._integrations) : void 0, i = { event_id: n, integrations: s };
  t.emit("preprocessEvent", r, i);
  const o = await pM(
    t.getOptions(),
    r,
    i,
    e,
    t,
    Ut()
  );
  if (!o)
    return null;
  o.platform = o.platform || "javascript";
  const a = t.getSdkMetadata(), { name: c, version: l } = a && a.sdk || {};
  return o.sdk = {
    ...o.sdk,
    name: c || "sentry.javascript.unknown",
    version: l || "0.0.0"
  }, o;
}
async function vee({
  recordingData: t,
  replayId: e,
  segmentId: n,
  eventContext: r,
  timestamp: s,
  session: i
}) {
  const o = yee({
    recordingData: t,
    headers: {
      segment_id: n
    }
  }), { urls: a, errorIds: c, traceIds: l, initialTimestamp: u } = r, d = ke(), f = Fe(), h = d && d.getTransport(), p = d && d.getDsn();
  if (!d || !h || !p || !i.sampled)
    return gs({});
  const m = {
    type: JZ,
    replay_start_timestamp: u / 1e3,
    timestamp: s / 1e3,
    error_ids: c,
    trace_ids: l,
    urls: a,
    replay_id: e,
    segment_id: n,
    replay_type: i.sampled
  }, y = await bee({ scope: f, client: d, replayId: e, event: m });
  if (!y)
    return d.recordDroppedEvent("event_processor", "replay", m), ie && ue.info("An event processor returned `null`, will not send event."), gs({});
  delete y.sdkProcessingMetadata;
  const b = gee(y, o, p, d.getOptions().tunnel);
  let v;
  try {
    v = await h.send(b);
  } catch (x) {
    const A = new Error(Yb);
    try {
      A.cause = x;
    } catch {
    }
    throw A;
  }
  if (typeof v.statusCode == "number" && (v.statusCode < 200 || v.statusCode >= 300))
    throw new RP(v.statusCode);
  const w = XR({}, v);
  if (QR(w, "replay"))
    throw new s0(w);
  return v;
}
class RP extends Error {
  constructor(e) {
    super(`Transport returned status code ${e}`);
  }
}
class s0 extends Error {
  constructor(e) {
    super("Rate limit hit"), this.rateLimits = e;
  }
}
async function MP(t, e = {
  count: 0,
  interval: iQ
}) {
  const { recordingData: n, onError: r } = t;
  if (n.length)
    try {
      return await vee(t), !0;
    } catch (s) {
      if (s instanceof RP || s instanceof s0)
        throw s;
      if (jb("Replays", {
        _retryCount: e.count
      }), r && r(s), e.count >= oQ) {
        const i = new Error(`${Yb} - max retries exceeded`);
        try {
          i.cause = s;
        } catch {
        }
        throw i;
      }
      return e.interval *= ++e.count, new Promise((i, o) => {
        da(async () => {
          try {
            await MP(t, e), i(!0);
          } catch (a) {
            o(a);
          }
        }, e.interval);
      });
    }
}
const PP = "__THROTTLED", xee = "__SKIPPED";
function wee(t, e, n) {
  const r = /* @__PURE__ */ new Map(), s = (a) => {
    const c = a - n;
    r.forEach((l, u) => {
      u < c && r.delete(u);
    });
  }, i = () => [...r.values()].reduce((a, c) => a + c, 0);
  let o = !1;
  return (...a) => {
    const c = Math.floor(Date.now() / 1e3);
    if (s(c), i() >= e) {
      const u = o;
      return o = !0, u ? xee : PP;
    }
    o = !1;
    const l = r.get(c) || 0;
    return r.set(c, l + 1), t(...a);
  };
}
class Os {
  /**
   * Recording can happen in one of three modes:
   *   - session: Record the whole session, sending it continuously
   *   - buffer: Always keep the last 60s of recording, requires:
   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs
   *     - or calling `flush()` to send the replay
   */
  /**
   * The current or last active span.
   * This is only available when performance is enabled.
   */
  /**
   * These are here so we can overwrite them in tests etc.
   * @hidden
   */
  /** The replay has to be manually started, because no sample rate (neither session or error) was provided. */
  /**
   * Options to pass to `rrweb.record()`
   */
  /**
   * Timestamp of the last user activity. This lives across sessions.
   */
  /**
   * Is the integration currently active?
   */
  /**
   * Paused is a state where:
   * - DOM Recording is not listening at all
   * - Nothing will be added to event buffer (e.g. core SDK events)
   */
  /**
   * Have we attached listeners to the core SDK?
   * Note we have to track this as there is no way to remove instrumentation handlers.
   */
  /**
   * Function to stop recording
   */
  /**
   * Internal use for canvas recording options
   */
  constructor({
    options: e,
    recordingOptions: n
  }) {
    Os.prototype.__init.call(this), Os.prototype.__init2.call(this), Os.prototype.__init3.call(this), Os.prototype.__init4.call(this), Os.prototype.__init5.call(this), Os.prototype.__init6.call(this), this.eventBuffer = null, this.performanceEntries = [], this.replayPerformanceEntries = [], this.recordingMode = "session", this.timeouts = {
      sessionIdlePause: eQ,
      sessionIdleExpire: tQ
    }, this._lastActivity = Date.now(), this._isEnabled = !1, this._isPaused = !1, this._requiresManualStart = !1, this._hasInitializedCoreListeners = !1, this._context = {
      errorIds: /* @__PURE__ */ new Set(),
      traceIds: /* @__PURE__ */ new Set(),
      urls: [],
      initialTimestamp: Date.now(),
      initialUrl: ""
    }, this._recordingOptions = n, this._options = e, this._debouncedFlush = dee(() => this._flush(), this._options.flushMinDelay, {
      maxWait: this._options.flushMaxDelay
    }), this._throttledAddEvent = wee(
      (o, a) => gJ(this, o, a),
      // Max 300 events...
      300,
      // ... per 5s
      5
    );
    const { slowClickTimeout: r, slowClickIgnoreSelectors: s } = this.getOptions(), i = r ? {
      threshold: Math.min(aQ, r),
      timeout: r,
      scrollTimeout: cQ,
      ignoreSelector: s ? s.join(",") : ""
    } : void 0;
    if (i && (this.clickDetector = new RX(this, i)), ie) {
      const o = e._experiments;
      ue.setConfig({
        captureExceptions: !!o.captureExceptions,
        traceInternals: !!o.traceInternals
      });
    }
  }
  /** Get the event context. */
  getContext() {
    return this._context;
  }
  /** If recording is currently enabled. */
  isEnabled() {
    return this._isEnabled;
  }
  /** If recording is currently paused. */
  isPaused() {
    return this._isPaused;
  }
  /**
   * Determine if canvas recording is enabled
   */
  isRecordingCanvas() {
    return !!this._canvas;
  }
  /** Get the replay integration options. */
  getOptions() {
    return this._options;
  }
  /** A wrapper to conditionally capture exceptions. */
  handleException(e) {
    ie && ue.exception(e), this._options.onError && this._options.onError(e);
  }
  /**
   * Initializes the plugin based on sampling configuration. Should not be
   * called outside of constructor.
   */
  initializeSampling(e) {
    const { errorSampleRate: n, sessionSampleRate: r } = this._options, s = n <= 0 && r <= 0;
    if (this._requiresManualStart = s, !s) {
      if (this._initializeSessionForSampling(e), !this.session) {
        ie && ue.exception(new Error("Unable to initialize and create session"));
        return;
      }
      this.session.sampled !== !1 && (this.recordingMode = this.session.sampled === "buffer" && this.session.segmentId === 0 ? "buffer" : "session", ie && ue.infoTick(`Starting replay in ${this.recordingMode} mode`), this._initializeRecording());
    }
  }
  /**
   * Start a replay regardless of sampling rate. Calling this will always
   * create a new session. Will log a message if replay is already in progress.
   *
   * Creates or loads a session, attaches listeners to varying events (DOM,
   * _performanceObserver, Recording, Sentry SDK, etc)
   */
  start() {
    if (this._isEnabled && this.recordingMode === "session") {
      ie && ue.info("Recording is already in progress");
      return;
    }
    if (this._isEnabled && this.recordingMode === "buffer") {
      ie && ue.info("Buffering is in progress, call `flush()` to save the replay");
      return;
    }
    ie && ue.infoTick("Starting replay in session mode"), this._updateUserActivity();
    const e = Lp(
      {
        maxReplayDuration: this._options.maxReplayDuration,
        sessionIdleExpire: this.timeouts.sessionIdleExpire
      },
      {
        stickySession: this._options.stickySession,
        // This is intentional: create a new session-based replay when calling `start()`
        sessionSampleRate: 1,
        allowBuffering: !1
      }
    );
    this.session = e, this._initializeRecording();
  }
  /**
   * Start replay buffering. Buffers until `flush()` is called or, if
   * `replaysOnErrorSampleRate` > 0, an error occurs.
   */
  startBuffering() {
    if (this._isEnabled) {
      ie && ue.info("Buffering is in progress, call `flush()` to save the replay");
      return;
    }
    ie && ue.infoTick("Starting replay in buffer mode");
    const e = Lp(
      {
        sessionIdleExpire: this.timeouts.sessionIdleExpire,
        maxReplayDuration: this._options.maxReplayDuration
      },
      {
        stickySession: this._options.stickySession,
        sessionSampleRate: 0,
        allowBuffering: !0
      }
    );
    this.session = e, this.recordingMode = "buffer", this._initializeRecording();
  }
  /**
   * Start recording.
   *
   * Note that this will cause a new DOM checkout
   */
  startRecording() {
    try {
      const e = this._canvas;
      this._stopRecording = cs({
        ...this._recordingOptions,
        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`
        // Without this, it would record forever, until an error happens, which we don't want
        // instead, we'll always keep the last 60 seconds of replay before an error happened
        ...this.recordingMode === "buffer" ? { checkoutEveryNms: sQ } : (
          // Otherwise, use experimental option w/ min checkout time of 6 minutes
          // This is to improve playback seeking as there could potentially be
          // less mutations to process in the worse cases.
          //
          // checkout by "N" events is probably ideal, but means we have less
          // control about the number of checkouts we make (which generally
          // increases replay size)
          this._options._experiments.continuousCheckout && {
            // Minimum checkout time is 6 minutes
            checkoutEveryNms: Math.max(36e4, this._options._experiments.continuousCheckout)
          }
        ),
        emit: fee(this),
        onMutation: this._onMutationHandler,
        ...e ? {
          recordCanvas: e.recordCanvas,
          getCanvasManager: e.getCanvasManager,
          sampling: e.sampling,
          dataURLOptions: e.dataURLOptions
        } : {}
      });
    } catch (e) {
      this.handleException(e);
    }
  }
  /**
   * Stops the recording, if it was running.
   *
   * Returns true if it was previously stopped, or is now stopped,
   * otherwise false.
   */
  stopRecording() {
    try {
      return this._stopRecording && (this._stopRecording(), this._stopRecording = void 0), !0;
    } catch (e) {
      return this.handleException(e), !1;
    }
  }
  /**
   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK
   * does not support a teardown
   */
  async stop({ forceFlush: e = !1, reason: n } = {}) {
    if (this._isEnabled) {
      this._isEnabled = !1;
      try {
        ie && ue.info(`Stopping Replay${n ? ` triggered by ${n}` : ""}`), mee(), this._removeListeners(), this.stopRecording(), this._debouncedFlush.cancel(), e && await this._flush({ force: !0 }), this.eventBuffer && this.eventBuffer.destroy(), this.eventBuffer = null, dJ(this);
      } catch (r) {
        this.handleException(r);
      }
    }
  }
  /**
   * Pause some replay functionality. See comments for `_isPaused`.
   * This differs from stop as this only stops DOM recording, it is
   * not as thorough of a shutdown as `stop()`.
   */
  pause() {
    this._isPaused || (this._isPaused = !0, this.stopRecording(), ie && ue.info("Pausing replay"));
  }
  /**
   * Resumes recording, see notes for `pause().
   *
   * Note that calling `startRecording()` here will cause a
   * new DOM checkout.`
   */
  resume() {
    !this._isPaused || !this._checkSession() || (this._isPaused = !1, this.startRecording(), ie && ue.info("Resuming replay"));
  }
  /**
   * If not in "session" recording mode, flush event buffer which will create a new replay.
   * Unless `continueRecording` is false, the replay will continue to record and
   * behave as a "session"-based replay.
   *
   * Otherwise, queue up a flush.
   */
  async sendBufferedReplayOrFlush({ continueRecording: e = !0 } = {}) {
    if (this.recordingMode === "session")
      return this.flushImmediate();
    const n = Date.now();
    ie && ue.info("Converting buffer to session"), await this.flushImmediate();
    const r = this.stopRecording();
    !e || !r || this.recordingMode !== "session" && (this.recordingMode = "session", this.session && (this._updateUserActivity(n), this._updateSessionActivity(n), this._maybeSaveSession()), this.startRecording());
  }
  /**
   * We want to batch uploads of replay events. Save events only if
   * `<flushMinDelay>` milliseconds have elapsed since the last event
   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.
   *
   * Accepts a callback to perform side-effects and returns true to stop batch
   * processing and hand back control to caller.
   */
  addUpdate(e) {
    const n = e();
    this.recordingMode !== "buffer" && n !== !0 && this._debouncedFlush();
  }
  /**
   * Updates the user activity timestamp and resumes recording. This should be
   * called in an event handler for a user action that we consider as the user
   * being "active" (e.g. a mouse click).
   */
  triggerUserActivity() {
    if (this._updateUserActivity(), !this._stopRecording) {
      if (!this._checkSession())
        return;
      this.resume();
      return;
    }
    this.checkAndHandleExpiredSession(), this._updateSessionActivity();
  }
  /**
   * Updates the user activity timestamp *without* resuming
   * recording. Some user events (e.g. keydown) can be create
   * low-value replays that only contain the keypress as a
   * breadcrumb. Instead this would require other events to
   * create a new replay after a session has expired.
   */
  updateUserActivity() {
    this._updateUserActivity(), this._updateSessionActivity();
  }
  /**
   * Only flush if `this.recordingMode === 'session'`
   */
  conditionalFlush() {
    return this.recordingMode === "buffer" ? Promise.resolve() : this.flushImmediate();
  }
  /**
   * Flush using debounce flush
   */
  flush() {
    return this._debouncedFlush();
  }
  /**
   * Always flush via `_debouncedFlush` so that we do not have flushes triggered
   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be
   * cases of mulitple flushes happening closely together.
   */
  flushImmediate() {
    return this._debouncedFlush(), this._debouncedFlush.flush();
  }
  /**
   * Cancels queued up flushes.
   */
  cancelFlush() {
    this._debouncedFlush.cancel();
  }
  /** Get the current sesion (=replay) ID */
  getSessionId() {
    return this.session && this.session.id;
  }
  /**
   * Checks if recording should be stopped due to user inactivity. Otherwise
   * check if session is expired and create a new session if so. Triggers a new
   * full snapshot on new session.
   *
   * Returns true if session is not expired, false otherwise.
   * @hidden
   */
  checkAndHandleExpiredSession() {
    if (this._lastActivity && _g(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === "session") {
      this.pause();
      return;
    }
    return !!this._checkSession();
  }
  /**
   * Capture some initial state that can change throughout the lifespan of the
   * replay. This is required because otherwise they would be captured at the
   * first flush.
   */
  setInitialState() {
    const e = `${lt.location.pathname}${lt.location.hash}${lt.location.search}`, n = `${lt.location.origin}${e}`;
    this.performanceEntries = [], this.replayPerformanceEntries = [], this._clearContext(), this._context.initialUrl = n, this._context.initialTimestamp = Date.now(), this._context.urls.push(n);
  }
  /**
   * Add a breadcrumb event, that may be throttled.
   * If it was throttled, we add a custom breadcrumb to indicate that.
   */
  throttledAddEvent(e, n) {
    const r = this._throttledAddEvent(e, n);
    if (r === PP) {
      const s = Er({
        category: "replay.throttled"
      });
      this.addUpdate(() => !n0(this, {
        type: AX,
        timestamp: s.timestamp || 0,
        data: {
          tag: "breadcrumb",
          payload: s,
          metric: !0
        }
      }));
    }
    return r;
  }
  /**
   * This will get the parametrized route name of the current page.
   * This is only available if performance is enabled, and if an instrumented router is used.
   */
  getCurrentRoute() {
    const e = this.lastActiveSpan || en(), n = e && Xt(e), s = (n && Be(n).data || {})[ns];
    if (!(!n || !s || !["route", "custom"].includes(s)))
      return Be(n).description;
  }
  /**
   * Initialize and start all listeners to varying events (DOM,
   * Performance Observer, Recording, Sentry SDK, etc)
   */
  _initializeRecording() {
    this.setInitialState(), this._updateSessionActivity(), this.eventBuffer = cJ({
      useCompression: this._options.useCompression,
      workerUrl: this._options.workerUrl
    }), this._removeListeners(), this._addListeners(), this._isEnabled = !0, this._isPaused = !1, this.startRecording();
  }
  /**
   * Loads (or refreshes) the current session.
   */
  _initializeSessionForSampling(e) {
    const n = this._options.errorSampleRate > 0, r = Lp(
      {
        sessionIdleExpire: this.timeouts.sessionIdleExpire,
        maxReplayDuration: this._options.maxReplayDuration,
        previousSessionId: e
      },
      {
        stickySession: this._options.stickySession,
        sessionSampleRate: this._options.sessionSampleRate,
        allowBuffering: n
      }
    );
    this.session = r;
  }
  /**
   * Checks and potentially refreshes the current session.
   * Returns false if session is not recorded.
   */
  _checkSession() {
    if (!this.session)
      return !1;
    const e = this.session;
    return bP(e, {
      sessionIdleExpire: this.timeouts.sessionIdleExpire,
      maxReplayDuration: this._options.maxReplayDuration
    }) ? (this._refreshSession(e), !1) : !0;
  }
  /**
   * Refresh a session with a new one.
   * This stops the current session (without forcing a flush, as that would never work since we are expired),
   * and then does a new sampling based on the refreshed session.
   */
  async _refreshSession(e) {
    this._isEnabled && (await this.stop({ reason: "refresh session" }), this.initializeSampling(e.id));
  }
  /**
   * Adds listeners to record events for the replay
   */
  _addListeners() {
    try {
      lt.document.addEventListener("visibilitychange", this._handleVisibilityChange), lt.addEventListener("blur", this._handleWindowBlur), lt.addEventListener("focus", this._handleWindowFocus), lt.addEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.addListeners(), this._hasInitializedCoreListeners || (cee(this), this._hasInitializedCoreListeners = !0);
    } catch (e) {
      this.handleException(e);
    }
    this._performanceCleanupCallback = nJ(this);
  }
  /**
   * Cleans up listeners that were created in `_addListeners`
   */
  _removeListeners() {
    try {
      lt.document.removeEventListener("visibilitychange", this._handleVisibilityChange), lt.removeEventListener("blur", this._handleWindowBlur), lt.removeEventListener("focus", this._handleWindowFocus), lt.removeEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.removeListeners(), this._performanceCleanupCallback && this._performanceCleanupCallback();
    } catch (e) {
      this.handleException(e);
    }
  }
  /**
   * Handle when visibility of the page content changes. Opening a new tab will
   * cause the state to change to hidden because of content of current page will
   * be hidden. Likewise, moving a different window to cover the contents of the
   * page will also trigger a change to a hidden state.
   */
  __init() {
    this._handleVisibilityChange = () => {
      lt.document.visibilityState === "visible" ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks();
    };
  }
  /**
   * Handle when page is blurred
   */
  __init2() {
    this._handleWindowBlur = () => {
      const e = Er({
        category: "ui.blur"
      });
      this._doChangeToBackgroundTasks(e);
    };
  }
  /**
   * Handle when page is focused
   */
  __init3() {
    this._handleWindowFocus = () => {
      const e = Er({
        category: "ui.focus"
      });
      this._doChangeToForegroundTasks(e);
    };
  }
  /** Ensure page remains active when a key is pressed. */
  __init4() {
    this._handleKeyboardEvent = (e) => {
      UX(this, e);
    };
  }
  /**
   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)
   */
  _doChangeToBackgroundTasks(e) {
    !this.session || yP(this.session, {
      maxReplayDuration: this._options.maxReplayDuration,
      sessionIdleExpire: this.timeouts.sessionIdleExpire
    }) || (e && this._createCustomBreadcrumb(e), this.conditionalFlush());
  }
  /**
   * Tasks to run when we consider a page to be visible (via focus and/or visibility)
   */
  _doChangeToForegroundTasks(e) {
    if (!this.session)
      return;
    if (!this.checkAndHandleExpiredSession()) {
      ie && ue.info("Document has become active, but session has expired");
      return;
    }
    e && this._createCustomBreadcrumb(e);
  }
  /**
   * Update user activity (across session lifespans)
   */
  _updateUserActivity(e = Date.now()) {
    this._lastActivity = e;
  }
  /**
   * Updates the session's last activity timestamp
   */
  _updateSessionActivity(e = Date.now()) {
    this.session && (this.session.lastActivity = e, this._maybeSaveSession());
  }
  /**
   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb
   */
  _createCustomBreadcrumb(e) {
    this.addUpdate(() => {
      this.throttledAddEvent({
        type: Re.Custom,
        timestamp: e.timestamp || 0,
        data: {
          tag: "breadcrumb",
          payload: e
        }
      });
    });
  }
  /**
   * Observed performance events are added to `this.performanceEntries`. These
   * are included in the replay event before it is finished and sent to Sentry.
   */
  _addPerformanceEntries() {
    let e = YX(this.performanceEntries).concat(this.replayPerformanceEntries);
    if (this.performanceEntries = [], this.replayPerformanceEntries = [], this._requiresManualStart) {
      const n = this._context.initialTimestamp / 1e3;
      e = e.filter((r) => r.start >= n);
    }
    return Promise.all(yh(this, e));
  }
  /**
   * Clear _context
   */
  _clearContext() {
    this._context.errorIds.clear(), this._context.traceIds.clear(), this._context.urls = [];
  }
  /** Update the initial timestamp based on the buffer content. */
  _updateInitialTimestampFromEventBuffer() {
    const { session: e, eventBuffer: n } = this;
    if (!e || !n || this._requiresManualStart || e.segmentId)
      return;
    const r = n.getEarliestTimestamp();
    r && r < this._context.initialTimestamp && (this._context.initialTimestamp = r);
  }
  /**
   * Return and clear _context
   */
  _popEventContext() {
    const e = {
      initialTimestamp: this._context.initialTimestamp,
      initialUrl: this._context.initialUrl,
      errorIds: Array.from(this._context.errorIds),
      traceIds: Array.from(this._context.traceIds),
      urls: this._context.urls
    };
    return this._clearContext(), e;
  }
  /**
   * Flushes replay event buffer to Sentry.
   *
   * Performance events are only added right before flushing - this is
   * due to the buffered performance observer events.
   *
   * Should never be called directly, only by `flush`
   */
  async _runFlush() {
    const e = this.getSessionId();
    if (!this.session || !this.eventBuffer || !e) {
      ie && ue.error("No session or eventBuffer found to flush.");
      return;
    }
    if (await this._addPerformanceEntries(), !(!this.eventBuffer || !this.eventBuffer.hasEvents) && (await lee(this), !!this.eventBuffer && e === this.getSessionId()))
      try {
        this._updateInitialTimestampFromEventBuffer();
        const n = Date.now();
        if (n - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4)
          throw new Error("Session is too long, not sending replay");
        const r = this._popEventContext(), s = this.session.segmentId++;
        this._maybeSaveSession();
        const i = await this.eventBuffer.finish();
        await MP({
          replayId: e,
          recordingData: i,
          segmentId: s,
          eventContext: r,
          session: this.session,
          timestamp: n,
          onError: (o) => this.handleException(o)
        });
      } catch (n) {
        this.handleException(n), this.stop({ reason: "sendReplay" });
        const r = ke();
        if (r) {
          const s = n instanceof s0 ? "ratelimit_backoff" : "send_error";
          r.recordDroppedEvent(s, "replay");
        }
      }
  }
  /**
   * Flush recording data to Sentry. Creates a lock so that only a single flush
   * can be active at a time. Do not call this directly.
   */
  __init5() {
    this._flush = async ({
      force: e = !1
    } = {}) => {
      if (!this._isEnabled && !e)
        return;
      if (!this.checkAndHandleExpiredSession()) {
        ie && ue.error("Attempting to finish replay event after session expired.");
        return;
      }
      if (!this.session)
        return;
      const n = this.session.started, s = Date.now() - n;
      this._debouncedFlush.cancel();
      const i = s < this._options.minReplayDuration, o = s > this._options.maxReplayDuration + 5e3;
      if (i || o) {
        ie && ue.info(
          `Session duration (${Math.floor(s / 1e3)}s) is too ${i ? "short" : "long"}, not sending replay.`
        ), i && this._debouncedFlush();
        return;
      }
      const a = this.eventBuffer;
      a && this.session.segmentId === 0 && !a.hasCheckout && ie && ue.info("Flushing initial segment without checkout.");
      const c = !!this._flushLock;
      this._flushLock || (this._flushLock = this._runFlush());
      try {
        await this._flushLock;
      } catch (l) {
        this.handleException(l);
      } finally {
        this._flushLock = void 0, c && this._debouncedFlush();
      }
    };
  }
  /** Save the session, if it is sticky */
  _maybeSaveSession() {
    this.session && this._options.stickySession && t0(this.session);
  }
  /** Handler for rrweb.record.onMutation */
  __init6() {
    this._onMutationHandler = (e) => {
      const n = e.length, r = this._options.mutationLimit, s = this._options.mutationBreadcrumbLimit, i = r && n > r;
      if (n > s || i) {
        const o = Er({
          category: "replay.mutations",
          data: {
            count: n,
            limit: i
          }
        });
        this._createCustomBreadcrumb(o);
      }
      return i ? (this.stop({ reason: "mutationLimit", forceFlush: this.recordingMode === "session" }), !1) : !0;
    };
  }
}
function tc(t, e) {
  return [
    ...t,
    // sentry defaults
    ...e
  ].join(",");
}
function Aee({ mask: t, unmask: e, block: n, unblock: r, ignore: s }) {
  const i = ['base[href="/"]'], o = tc(t, [".sentry-mask", "[data-sentry-mask]"]), a = tc(e, []);
  return {
    // We are making the decision to make text and input selectors the same
    maskTextSelector: o,
    unmaskTextSelector: a,
    blockSelector: tc(n, [".sentry-block", "[data-sentry-block]", ...i]),
    unblockSelector: tc(r, []),
    ignoreSelector: tc(s, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'])
  };
}
function See({
  el: t,
  key: e,
  maskAttributes: n,
  maskAllText: r,
  privacyOptions: s,
  value: i
}) {
  return !r || s.unmaskTextSelector && t.matches(s.unmaskTextSelector) ? i : n.includes(e) || // Need to mask `value` attribute for `<input>` if it's a button-like
  // type
  e === "value" && t.tagName === "INPUT" && ["submit", "button"].includes(t.getAttribute("type") || "") ? i.replace(/[\S]/g, "*") : i;
}
const DS = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]', Eee = ["content-length", "content-type", "accept"];
let OS = !1;
const Cee = (t) => new vh(t);
class vh {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Replay";
  }
  /**
   * @inheritDoc
   */
  /**
   * Options to pass to `rrweb.record()`
   */
  /**
   * Initial options passed to the replay integration, merged with default values.
   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they
   * can only be finally set when setupOnce() is called.
   *
   * @private
   */
  constructor({
    flushMinDelay: e = nQ,
    flushMaxDelay: n = rQ,
    minReplayDuration: r = lQ,
    maxReplayDuration: s = pS,
    stickySession: i = !0,
    useCompression: o = !0,
    workerUrl: a,
    _experiments: c = {},
    maskAllText: l = !0,
    maskAllInputs: u = !0,
    blockAllMedia: d = !0,
    mutationBreadcrumbLimit: f = 750,
    mutationLimit: h = 1e4,
    slowClickTimeout: p = 7e3,
    slowClickIgnoreSelectors: m = [],
    networkDetailAllowUrls: y = [],
    networkDetailDenyUrls: b = [],
    networkCaptureBodies: v = !0,
    networkRequestHeaders: w = [],
    networkResponseHeaders: x = [],
    mask: A = [],
    maskAttributes: C = ["title", "placeholder"],
    unmask: S = [],
    block: _ = [],
    unblock: T = [],
    ignore: k = [],
    maskFn: R,
    beforeAddRecordingEvent: P,
    beforeErrorSampling: M
  } = {}) {
    this.name = vh.id;
    const D = Aee({
      mask: A,
      unmask: S,
      block: _,
      unblock: T,
      ignore: k
    });
    if (this._recordingOptions = {
      maskAllInputs: u,
      maskAllText: l,
      maskInputOptions: { password: !0 },
      maskTextFn: R,
      maskInputFn: R,
      maskAttributeFn: (O, q, L) => See({
        maskAttributes: C,
        maskAllText: l,
        privacyOptions: D,
        key: O,
        value: q,
        el: L
      }),
      ...D,
      // Our defaults
      slimDOMOptions: "all",
      inlineStylesheet: !0,
      // Disable inline images as it will increase segment/replay size
      inlineImages: !1,
      // collect fonts, but be aware that `sentry.io` needs to be an allowed
      // origin for playback
      collectFonts: !0,
      errorHandler: (O) => {
        try {
          O.__rrweb__ = !0;
        } catch {
        }
      }
    }, this._initialOptions = {
      flushMinDelay: e,
      flushMaxDelay: n,
      minReplayDuration: Math.min(r, uQ),
      maxReplayDuration: Math.min(s, pS),
      stickySession: i,
      useCompression: o,
      workerUrl: a,
      blockAllMedia: d,
      maskAllInputs: u,
      maskAllText: l,
      mutationBreadcrumbLimit: f,
      mutationLimit: h,
      slowClickTimeout: p,
      slowClickIgnoreSelectors: m,
      networkDetailAllowUrls: y,
      networkDetailDenyUrls: b,
      networkCaptureBodies: v,
      networkRequestHeaders: qS(w),
      networkResponseHeaders: qS(x),
      beforeAddRecordingEvent: P,
      beforeErrorSampling: M,
      _experiments: c
    }, this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${DS}` : DS), this._isInitialized && MA())
      throw new Error("Multiple Sentry Session Replay instances are not supported");
    this._isInitialized = !0;
  }
  /** If replay has already been initialized */
  get _isInitialized() {
    return OS;
  }
  /** Update _isInitialized */
  set _isInitialized(e) {
    OS = e;
  }
  /**
   * Setup and initialize replay container
   */
  afterAllSetup(e) {
    !MA() || this._replay || (this._setup(e), this._initialize(e));
  }
  /**
   * Start a replay regardless of sampling rate. Calling this will always
   * create a new session. Will log a message if replay is already in progress.
   *
   * Creates or loads a session, attaches listeners to varying events (DOM,
   * PerformanceObserver, Recording, Sentry SDK, etc)
   */
  start() {
    this._replay && this._replay.start();
  }
  /**
   * Start replay buffering. Buffers until `flush()` is called or, if
   * `replaysOnErrorSampleRate` > 0, until an error occurs.
   */
  startBuffering() {
    this._replay && this._replay.startBuffering();
  }
  /**
   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK
   * does not support a teardown
   */
  stop() {
    return this._replay ? this._replay.stop({ forceFlush: this._replay.recordingMode === "session" }) : Promise.resolve();
  }
  /**
   * If not in "session" recording mode, flush event buffer which will create a new replay.
   * If replay is not enabled, a new session replay is started.
   * Unless `continueRecording` is false, the replay will continue to record and
   * behave as a "session"-based replay.
   *
   * Otherwise, queue up a flush.
   */
  flush(e) {
    return this._replay ? this._replay.isEnabled() ? this._replay.sendBufferedReplayOrFlush(e) : (this._replay.start(), Promise.resolve()) : Promise.resolve();
  }
  /**
   * Get the current session ID.
   */
  getReplayId() {
    if (!(!this._replay || !this._replay.isEnabled()))
      return this._replay.getSessionId();
  }
  /**
   * Initializes replay.
   */
  _initialize(e) {
    this._replay && (this._maybeLoadFromReplayCanvasIntegration(e), this._replay.initializeSampling());
  }
  /** Setup the integration. */
  _setup(e) {
    const n = _ee(this._initialOptions, e);
    this._replay = new Os({
      options: n,
      recordingOptions: this._recordingOptions
    });
  }
  /** Get canvas options from ReplayCanvas integration, if it is also added. */
  _maybeLoadFromReplayCanvasIntegration(e) {
    try {
      const n = e.getIntegrationByName("ReplayCanvas");
      if (!n)
        return;
      this._replay._canvas = n.getOptions();
    } catch {
    }
  }
}
vh.__initStatic();
function _ee(t, e) {
  const n = e.getOptions(), r = {
    sessionSampleRate: 0,
    errorSampleRate: 0,
    ...Vt(t)
  }, s = Jd(n.replaysSessionSampleRate), i = Jd(n.replaysOnErrorSampleRate);
  return s == null && i == null && Pa(() => {
    console.warn(
      "Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set."
    );
  }), s != null && (r.sessionSampleRate = s), i != null && (r.errorSampleRate = i), r;
}
function qS(t) {
  return [...Eee, ...t.map((e) => e.toLowerCase())];
}
const NS = /* @__PURE__ */ new WeakMap(), jp = /* @__PURE__ */ new Map(), ld = {
  traceFetch: !0,
  traceXHR: !0,
  enableHTTPTimings: !0,
  trackFetchStreamPerformance: !1
};
function Tee(t, e) {
  const {
    traceFetch: n,
    traceXHR: r,
    trackFetchStreamPerformance: s,
    shouldCreateSpanForRequest: i,
    enableHTTPTimings: o,
    tracePropagationTargets: a
  } = {
    traceFetch: ld.traceFetch,
    traceXHR: ld.traceXHR,
    trackFetchStreamPerformance: ld.trackFetchStreamPerformance,
    ...e
  }, c = typeof i == "function" ? i : (d) => !0, l = (d) => Pee(d, a), u = {};
  n && (t.addEventProcessor((d) => (d.type === "transaction" && d.spans && d.spans.forEach((f) => {
    if (f.op === "http.client") {
      const h = jp.get(f.span_id);
      h && (f.timestamp = h / 1e3, jp.delete(f.span_id));
    }
  }), d)), s && K8((d) => {
    if (d.response) {
      const f = NS.get(d.response);
      f && d.endTimestamp && jp.set(f, d.endTimestamp);
    }
  }), FR((d) => {
    const f = RK(d, c, l, u);
    if (d.response && d.fetchData.__span && NS.set(d.response, d.fetchData.__span), f) {
      const h = IP(d.fetchData.url), p = h ? Li(h).host : void 0;
      f.setAttributes({
        "http.url": h,
        "server.address": p
      });
    }
    o && f && LS(f);
  })), r && FM((d) => {
    const f = Iee(d, c, l, u);
    o && f && LS(f);
  });
}
function kee(t) {
  return t.entryType === "resource" && "initiatorType" in t && typeof t.nextHopProtocol == "string" && (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest");
}
function LS(t) {
  const { url: e } = Be(t).data || {};
  if (!e || typeof e != "string")
    return;
  const n = la("resource", ({ entries: r }) => {
    r.forEach((s) => {
      kee(s) && s.name.endsWith(e) && (Mee(s).forEach((o) => t.setAttribute(...o)), setTimeout(n));
    });
  });
}
function Ree(t) {
  let e = "unknown", n = "unknown", r = "";
  for (const s of t) {
    if (s === "/") {
      [e, n] = t.split("/");
      break;
    }
    if (!isNaN(Number(s))) {
      e = r === "h" ? "http" : r, n = t.split(r)[1];
      break;
    }
    r += s;
  }
  return r === t && (e = r), { name: e, version: n };
}
function gr(t = 0) {
  return ((vn || performance.timeOrigin) + t) / 1e3;
}
function Mee(t) {
  const { name: e, version: n } = Ree(t.nextHopProtocol), r = [];
  return r.push(["network.protocol.version", n], ["network.protocol.name", e]), vn ? [
    ...r,
    ["http.request.redirect_start", gr(t.redirectStart)],
    ["http.request.fetch_start", gr(t.fetchStart)],
    ["http.request.domain_lookup_start", gr(t.domainLookupStart)],
    ["http.request.domain_lookup_end", gr(t.domainLookupEnd)],
    ["http.request.connect_start", gr(t.connectStart)],
    ["http.request.secure_connection_start", gr(t.secureConnectionStart)],
    ["http.request.connection_end", gr(t.connectEnd)],
    ["http.request.request_start", gr(t.requestStart)],
    ["http.request.response_start", gr(t.responseStart)],
    ["http.request.response_end", gr(t.responseEnd)]
  ] : r;
}
function Pee(t, e) {
  const n = oe.location && oe.location.href;
  if (n) {
    let r, s;
    try {
      r = new URL(t, n), s = new URL(n).origin;
    } catch {
      return !1;
    }
    const i = r.origin === s;
    return e ? zs(r.toString(), e) || i && zs(r.pathname, e) : i;
  } else {
    const r = !!t.match(/^\/(?!\/)/);
    return e ? zs(t, e) : r;
  }
}
function Iee(t, e, n, r) {
  const s = t.xhr, i = s && s[Ri];
  if (!s || s.__sentry_own_request__ || !i)
    return;
  const o = ys() && e(i.url);
  if (t.endTimestamp && o) {
    const f = s.__sentry_xhr_span_id__;
    if (!f) return;
    const h = r[f];
    h && i.status_code !== void 0 && (tM(h, i.status_code), h.end(), delete r[f]);
    return;
  }
  const a = IP(i.url), c = a ? Li(a).host : void 0, l = !!en(), u = o && l ? pi({
    name: `${i.method} ${i.url}`,
    attributes: {
      type: "xhr",
      "http.method": i.method,
      "http.url": a,
      url: i.url,
      "server.address": c,
      [Gt]: "auto.http.browser",
      [Xi]: "http.client"
    }
  }) : new qa();
  s.__sentry_xhr_span_id__ = u.spanContext().spanId, r[s.__sentry_xhr_span_id__] = u;
  const d = ke();
  return s.setRequestHeader && n(i.url) && d && Dee(
    s,
    d,
    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
    // we do not want to use the span as base for the trace headers,
    // which means that the headers will be generated from the scope and the sampling decision is deferred
    ys() && l ? u : void 0
  ), u;
}
function Dee(t, e, n) {
  const r = Fe(), s = Ut(), { traceId: i, spanId: o, sampled: a, dsc: c } = {
    ...s.getPropagationContext(),
    ...r.getPropagationContext()
  }, l = n && ys() ? sM(n) : Mb(i, o, a), u = $R(
    c || (n ? hi(n) : lh(i, e))
  );
  Oee(t, l, u);
}
function Oee(t, e, n) {
  try {
    t.setRequestHeader("sentry-trace", e), n && t.setRequestHeader(Ao, n);
  } catch {
  }
}
function IP(t) {
  try {
    return new URL(t, oe.location.origin).href;
  } catch {
    return;
  }
}
function qee() {
  oe && oe.document ? oe.document.addEventListener("visibilitychange", () => {
    const t = en();
    if (!t)
      return;
    const e = Xt(t);
    if (oe.document.hidden && e) {
      const n = "cancelled", { op: r, status: s } = Be(e);
      Rn && H.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`), s || e.setStatus({ code: zt, message: n }), e.setAttribute("sentry.cancellation_reason", "document.hidden"), e.end();
    }
  }) : Rn && H.warn("[Tracing] Could not set up background tab detection due to lack of global document");
}
const Nee = "BrowserTracing", Lee = {
  ...id,
  instrumentNavigation: !0,
  instrumentPageLoad: !0,
  markBackgroundSpan: !0,
  enableLongTask: !0,
  enableLongAnimationFrame: !0,
  enableInp: !0,
  _experiments: {},
  ...ld
}, jee = (t = {}) => {
  ZY();
  const {
    enableInp: e,
    enableLongTask: n,
    enableLongAnimationFrame: r,
    _experiments: { enableInteractions: s, enableStandaloneClsSpans: i },
    beforeStartSpan: o,
    idleTimeout: a,
    finalTimeout: c,
    childSpanTimeout: l,
    markBackgroundSpan: u,
    traceFetch: d,
    traceXHR: f,
    trackFetchStreamPerformance: h,
    shouldCreateSpanForRequest: p,
    enableHTTPTimings: m,
    instrumentPageLoad: y,
    instrumentNavigation: b
  } = {
    ...Lee,
    ...t
  }, v = M$({ recordClsStandaloneSpans: i || !1 });
  e && eZ(), r && Oe.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? I$() : n && P$(), s && D$();
  const w = {
    name: void 0,
    source: void 0
  };
  function x(A, C) {
    const S = C.op === "pageload", _ = o ? o(C) : C, T = _.attributes || {};
    C.name !== _.name && (T[ns] = "custom", _.attributes = T), w.name = _.name, w.source = T[ns];
    const k = hM(_, {
      idleTimeout: a,
      finalTimeout: c,
      childSpanTimeout: l,
      // should wait for finish signal if it's a pageload transaction
      disableAutoFinish: S,
      beforeSpanEnd: (P) => {
        v(), j$(P, { recordClsOnPageloadSpan: !i });
      }
    });
    function R() {
      ["interactive", "complete"].includes(oe.document.readyState) && A.emit("idleSpanEnableAutoFinish", k);
    }
    return S && oe.document && (oe.document.addEventListener("readystatechange", () => {
      R();
    }), R()), k;
  }
  return {
    name: Nee,
    afterAllSetup(A) {
      let C, S = oe.location && oe.location.href;
      A.on("startNavigationSpan", (_) => {
        ke() === A && (C && !Be(C).timestamp && (Rn && H.log(`[Tracing] Finishing current root span with op: ${Be(C).op}`), C.end()), C = x(A, {
          op: "navigation",
          ..._
        }));
      }), A.on("startPageLoadSpan", (_, T = {}) => {
        if (ke() !== A)
          return;
        C && !Be(C).timestamp && (Rn && H.log(`[Tracing] Finishing current root span with op: ${Be(C).op}`), C.end());
        const k = T.sentryTrace || jS("sentry-trace"), R = T.baggage || jS("baggage"), P = yY(k, R);
        Fe().setPropagationContext(P), C = x(A, {
          op: "pageload",
          ..._
        });
      }), A.on("spanEnd", (_) => {
        const T = Be(_).op;
        if (_ !== Xt(_) || T !== "navigation" && T !== "pageload")
          return;
        const k = Fe(), R = k.getPropagationContext();
        k.setPropagationContext({
          ...R,
          sampled: R.sampled !== void 0 ? R.sampled : io(_),
          dsc: R.dsc || hi(_)
        });
      }), oe.location && (y && Bee(A, {
        name: oe.location.pathname,
        // pageload should always start at timeOrigin (and needs to be in s, not ms)
        startTime: vn ? vn / 1e3 : void 0,
        attributes: {
          [ns]: "url",
          [Gt]: "auto.pageload.browser"
        }
      }), b && fh(({ to: _, from: T }) => {
        if (T === void 0 && S && S.indexOf(_) !== -1) {
          S = void 0;
          return;
        }
        T !== _ && (S = void 0, Fee(A, {
          name: oe.location.pathname,
          attributes: {
            [ns]: "url",
            [Gt]: "auto.navigation.browser"
          }
        }));
      })), u && qee(), s && Vee(a, c, l, w), e && nZ(), Tee(A, {
        traceFetch: d,
        traceXHR: f,
        trackFetchStreamPerformance: h,
        tracePropagationTargets: A.getOptions().tracePropagationTargets,
        shouldCreateSpanForRequest: p,
        enableHTTPTimings: m
      });
    }
  };
};
function Bee(t, e, n) {
  t.emit("startPageLoadSpan", e, n), Fe().setTransactionName(e.name);
  const r = en();
  return (r && Be(r).op) === "pageload" ? r : void 0;
}
function Fee(t, e) {
  Ut().setPropagationContext(Qd()), Fe().setPropagationContext(Qd()), t.emit("startNavigationSpan", e), Fe().setTransactionName(e.name);
  const n = en();
  return (n && Be(n).op) === "navigation" ? n : void 0;
}
function jS(t) {
  const e = I8(`meta[name=${t}]`);
  return e ? e.getAttribute("content") : void 0;
}
function Vee(t, e, n, r) {
  let s;
  const i = () => {
    const o = "ui.action.click", a = en(), c = a && Xt(a);
    if (c) {
      const l = Be(c).op;
      if (["navigation", "pageload"].includes(l)) {
        Rn && H.warn(`[Tracing] Did not create ${o} span because a pageload or navigation span is in progress.`);
        return;
      }
    }
    if (s && (s.setAttribute(ag, "interactionInterrupted"), s.end(), s = void 0), !r.name) {
      Rn && H.warn(`[Tracing] Did not create ${o} transaction because _latestRouteName is missing.`);
      return;
    }
    s = hM(
      {
        name: r.name,
        op: o,
        attributes: {
          [ns]: r.source || "url"
        }
      },
      {
        idleTimeout: t,
        finalTimeout: e,
        childSpanTimeout: n
      }
    );
  };
  oe.document && addEventListener("click", i, { once: !1, capture: !0 });
}
function Uee(t) {
  const e = {
    ...t
  };
  return xM(e, "react"), jb("react", { version: WS }), QZ(e);
}
function Wee(t) {
  const e = t.match(/^([^.]+)/);
  return e !== null && parseInt(e[0]) >= 17;
}
function zee(t, e) {
  const n = /* @__PURE__ */ new WeakSet();
  function r(s, i) {
    if (!n.has(s)) {
      if (s.cause)
        return n.add(s), r(s.cause, i);
      s.cause = i;
    }
  }
  r(t, e);
}
function Hee(t, { componentStack: e }, n) {
  if (Wee(WS) && rh(t) && e) {
    const r = new Error(t.message);
    r.name = `React ErrorBoundary ${t.name}`, r.stack = e, zee(t, r);
  }
  return uh(t, {
    ...n,
    captureContext: {
      contexts: { react: { componentStack: e } }
    }
  });
}
var DP = { exports: {} }, Qe = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function() {
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, s = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, o = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, l = t ? Symbol.for("react.concurrent_mode") : 60111, u = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, h = t ? Symbol.for("react.memo") : 60115, p = t ? Symbol.for("react.lazy") : 60116, m = t ? Symbol.for("react.block") : 60121, y = t ? Symbol.for("react.fundamental") : 60117, b = t ? Symbol.for("react.responder") : 60118, v = t ? Symbol.for("react.scope") : 60119;
  function w(F) {
    return typeof F == "string" || typeof F == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
    F === r || F === l || F === i || F === s || F === d || F === f || typeof F == "object" && F !== null && (F.$$typeof === p || F.$$typeof === h || F.$$typeof === o || F.$$typeof === a || F.$$typeof === u || F.$$typeof === y || F.$$typeof === b || F.$$typeof === v || F.$$typeof === m);
  }
  function x(F) {
    if (typeof F == "object" && F !== null) {
      var ee = F.$$typeof;
      switch (ee) {
        case e:
          var re = F.type;
          switch (re) {
            case c:
            case l:
            case r:
            case i:
            case s:
            case d:
              return re;
            default:
              var nt = re && re.$$typeof;
              switch (nt) {
                case a:
                case u:
                case p:
                case h:
                case o:
                  return nt;
                default:
                  return ee;
              }
          }
        case n:
          return ee;
      }
    }
  }
  var A = c, C = l, S = a, _ = o, T = e, k = u, R = r, P = p, M = h, D = n, O = i, q = s, L = d, N = !1;
  function j(F) {
    return N || (N = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), V(F) || x(F) === c;
  }
  function V(F) {
    return x(F) === l;
  }
  function Z(F) {
    return x(F) === a;
  }
  function G(F) {
    return x(F) === o;
  }
  function $(F) {
    return typeof F == "object" && F !== null && F.$$typeof === e;
  }
  function fe(F) {
    return x(F) === u;
  }
  function he(F) {
    return x(F) === r;
  }
  function be(F) {
    return x(F) === p;
  }
  function He(F) {
    return x(F) === h;
  }
  function at(F) {
    return x(F) === n;
  }
  function xt(F) {
    return x(F) === i;
  }
  function tt(F) {
    return x(F) === s;
  }
  function wt(F) {
    return x(F) === d;
  }
  Qe.AsyncMode = A, Qe.ConcurrentMode = C, Qe.ContextConsumer = S, Qe.ContextProvider = _, Qe.Element = T, Qe.ForwardRef = k, Qe.Fragment = R, Qe.Lazy = P, Qe.Memo = M, Qe.Portal = D, Qe.Profiler = O, Qe.StrictMode = q, Qe.Suspense = L, Qe.isAsyncMode = j, Qe.isConcurrentMode = V, Qe.isContextConsumer = Z, Qe.isContextProvider = G, Qe.isElement = $, Qe.isForwardRef = fe, Qe.isFragment = he, Qe.isLazy = be, Qe.isMemo = He, Qe.isPortal = at, Qe.isProfiler = xt, Qe.isStrictMode = tt, Qe.isSuspense = wt, Qe.isValidElementType = w, Qe.typeOf = x;
})();
DP.exports = Qe;
var Yee = DP.exports, OP = Yee, Gee = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, Kee = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, qP = {};
qP[OP.ForwardRef] = Gee;
qP[OP.Memo] = Kee;
const $ee = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, BS = {
  componentStack: null,
  error: null,
  eventId: null
};
class i0 extends E.Component {
  constructor(e) {
    super(e), i0.prototype.__init.call(this), this.state = BS, this._openFallbackReportDialog = !0;
    const n = ke();
    n && e.showDialog && (this._openFallbackReportDialog = !1, this._cleanupHook = n.on("afterSendEvent", (r) => {
      !r.type && this._lastEventId && r.event_id === this._lastEventId && fS({ ...e.dialogOptions, eventId: this._lastEventId });
    }));
  }
  componentDidCatch(e, n) {
    const { componentStack: r } = n, s = r ?? void 0, { beforeCapture: i, onError: o, showDialog: a, dialogOptions: c } = this.props;
    Oa((l) => {
      i && i(l, e, s);
      const u = Hee(e, n, { mechanism: { handled: !!this.props.fallback } });
      o && o(e, s, u), a && (this._lastEventId = u, this._openFallbackReportDialog && fS({ ...c, eventId: u })), this.setState({ error: e, componentStack: r, eventId: u });
    });
  }
  componentDidMount() {
    const { onMount: e } = this.props;
    e && e();
  }
  componentWillUnmount() {
    const { error: e, componentStack: n, eventId: r } = this.state, { onUnmount: s } = this.props;
    s && s(e, n, r), this._cleanupHook && (this._cleanupHook(), this._cleanupHook = void 0);
  }
  __init() {
    this.resetErrorBoundary = () => {
      const { onReset: e } = this.props, { error: n, componentStack: r, eventId: s } = this.state;
      e && e(n, r, s), this.setState(BS);
    };
  }
  render() {
    const { fallback: e, children: n } = this.props, r = this.state;
    if (r.error) {
      let s;
      return typeof e == "function" ? s = E.createElement(e, {
        error: r.error,
        componentStack: r.componentStack,
        resetError: this.resetErrorBoundary,
        eventId: r.eventId
      }) : s = e, E.isValidElement(s) ? s : (e && $ee && H.warn("fallback did not produce a valid ReactElement"), null);
    }
    return typeof n == "function" ? n() : n;
  }
}
const Vs = () => {
  const t = customElements.get("blink-launcher") !== void 0, e = document.querySelector("blink-launcher") !== null;
  return t && e;
}, Rg = () => {
  const t = Hi.getState(), e = st.getState(), n = Xo.getState();
  return {
    mines: {
      gameState: {
        gameRoundId: t.gameRoundId,
        isEnded: t.isEnded,
        multiplier: t.multiplier,
        preSelectMultiplier: t.preSelectMultiplier,
        revealedCellsCount: t.revealedCells.length,
        selectedCellsCount: t.selectedCells.length,
        totalProfit: t.totalProfit,
        activeFetchCount: t.fetchingCells.length,
        boardState: t.board.map((r, s) => ({
          index: s,
          state: r,
          isRevealed: t.revealedCells.includes(s),
          isSelected: t.selectedCells.includes(s),
          isFetching: t.fetchingCells.includes(s)
        }))
      },
      gameSettings: {
        betAmount: n.betAmount
      },
      sharedState: {
        isGameActive: e.isGameActive,
        currency: e.selectedCurrency.currencyCode,
        balance: e.balance
      }
    }
  };
}, Zee = () => {
  if (!(window.__SENTRY_INITIALIZED__ || !Vs())) {
    console.log("Initializing Sentry for blink-launcher");
    try {
      Uee({
        dsn: "https://d5ae66720cc6ff5eb688e2b6db09f188@o4508206457356288.ingest.de.sentry.io/4508206460633168",
        attachStacktrace: !0,
        integrations: [
          jee(),
          Cee({
            maskAllText: !1,
            blockAllMedia: !1,
            maskAllInputs: !1
          })
        ],
        tracesSampleRate: 1,
        tracePropagationTargets: ["localhost", /^https:\/\/yourserver\.io\/api/],
        replaysSessionSampleRate: 0.1,
        replaysOnErrorSampleRate: 1,
        autoSessionTracking: !1,
        beforeSend(t) {
          if (console.log("Sentry beforeSend" + t), !Vs())
            return console.log("webComponent not present. Exiting."), null;
          const e = Rg();
          return t.contexts = {
            ...t.contexts,
            ...e,
            webComponent: {
              name: "blink-launcher",
              location: window.location.href,
              mountTime: (/* @__PURE__ */ new Date()).toISOString()
            }
          }, t;
        },
        beforeSendTransaction(t) {
          return Vs() ? t : null;
        }
      }), Ie.interceptors.response.use(
        (t) => t,
        (t) => {
          var e, n, r, s, i, o, a, c, l, u, d, f, h, p, m, y, b, v, w, x, A, C, S;
          if (Ie.isAxiosError(t) && Vs()) {
            console.log("Caught Axios error, sending to Sentry");
            const _ = Rg();
            uh(t, {
              extra: {
                url: (e = t.config) == null ? void 0 : e.url,
                method: (n = t.config) == null ? void 0 : n.method,
                baseURL: (r = t.config) == null ? void 0 : r.baseURL,
                params: (s = t.config) == null ? void 0 : s.params,
                headers: {
                  ...(i = t.config) == null ? void 0 : i.headers,
                  Authorization: "[REDACTED]"
                },
                timeout: (o = t.config) == null ? void 0 : o.timeout,
                status: (a = t.response) == null ? void 0 : a.status,
                statusText: (c = t.response) == null ? void 0 : c.statusText,
                responseData: (l = t.response) == null ? void 0 : l.data,
                responseHeaders: (u = t.response) == null ? void 0 : u.headers,
                errorName: t.name,
                errorMessage: t.message,
                errorCode: t.code,
                isNetworkError: !t.response && !t.status,
                isCancelled: Ie.isCancel(t),
                isTimeout: t.code === "ECONNABORTED",
                timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                timeoutMS: (d = t.config) == null ? void 0 : d.timeout,
                userAgent: navigator.userAgent,
                windowLocation: window.location.href,
                requestData: typeof ((f = t.config) == null ? void 0 : f.data) == "string" ? "[STRING PAYLOAD]" : (h = t.config) == null ? void 0 : h.data,
                connectionType: (p = navigator.connection) == null ? void 0 : p.effectiveType,
                connectionSpeed: (m = navigator.connection) == null ? void 0 : m.downlink
              },
              contexts: {
                ..._,
                request: {
                  url: (y = t.config) == null ? void 0 : y.url,
                  method: (b = t.config) == null ? void 0 : b.method,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                }
              },
              tags: {
                statusCode: (v = t.response) == null ? void 0 : v.status,
                errorType: t.response ? "api_error" : "network_error",
                endpoint: (x = (w = t.config) == null ? void 0 : w.url) == null ? void 0 : x.split("?")[0],
                method: (C = (A = t.config) == null ? void 0 : A.method) == null ? void 0 : C.toUpperCase()
              },
              level: ((S = t.response) == null ? void 0 : S.status) === 404 ? "warning" : "error"
            });
          }
          return Promise.reject(t);
        }
      ), window.__SENTRY_INITIALIZED__ = !0;
    } catch (t) {
      return console.error("Error initializing Sentry:", t), () => {
      };
    }
  }
}, Qee = ({ error: t, resetError: e }) => (_e(() => {
  Vs() && Oa((n) => {
    n.setContext("finalGameState", Rg()), n.setTag("errorType", "fatal_game_error"), DG("Game error triggered reset");
  });
}, []), /* @__PURE__ */ g.jsxs("div", { className: "w-full h-full flex flex-col items-center justify-center p-6 bg-gray-900 text-white", children: [
  /* @__PURE__ */ g.jsxs("div", { className: "mb-4 text-red-500 text-xl font-semibold", children: [
    "Something went wrong. Error: ",
    t.message
  ] }),
  /* @__PURE__ */ g.jsx("div", { className: "mb-4 text-gray-400 text-center max-w-md", children: "Please try refreshing the page" })
] })), Xee = ({
  children: t
}) => (_e(() => {
  const e = () => {
    const r = Vs(), s = OK().getClient();
    !r && window.__SENTRY_INITIALIZED__ ? (console.log("Disabling Sentry - web component not present"), s && (s.getOptions().enabled = !1)) : r && window.__SENTRY_INITIALIZED__ ? (console.log("Enabling Sentry - web component present"), s && (s.getOptions().enabled = !0)) : r && !window.__SENTRY_INITIALIZED__ && Zee();
  }, n = new MutationObserver(e);
  return n.observe(document.body, {
    childList: !0,
    subtree: !0
  }), e(), () => {
    n.disconnect();
  };
}, []), Vs() ? /* @__PURE__ */ g.jsx(
  i0,
  {
    fallback: Qee,
    beforeCapture: (e) => {
      if (!Vs())
        return !1;
      e.setTag("component", "BlinkLauncher"), e.setContext("page", {
        url: window.location.href,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    },
    children: t
  }
) : /* @__PURE__ */ g.jsx(g.Fragment, { children: t })), NP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ g.jsx(
  "table",
  {
    ref: n,
    className: de("w-full caption-bottom text-sm", t),
    ...e
  }
) }));
NP.displayName = "Table";
const LP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx("thead", { ref: n, className: de("[&_tr]:border-b", t), ...e }));
LP.displayName = "TableHeader";
const jP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "tbody",
  {
    ref: n,
    className: de("[&_tr:last-child]:border-0", t),
    ...e
  }
));
jP.displayName = "TableBody";
const Jee = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "tfoot",
  {
    ref: n,
    className: de(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      t
    ),
    ...e
  }
));
Jee.displayName = "TableFooter";
const Mg = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "tr",
  {
    ref: n,
    className: de(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      t
    ),
    ...e
  }
));
Mg.displayName = "TableRow";
const BP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "th",
  {
    ref: n,
    className: de(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      t
    ),
    ...e
  }
));
BP.displayName = "TableHead";
const FP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "td",
  {
    ref: n,
    className: de(
      "text-white p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      t
    ),
    ...e
  }
));
FP.displayName = "TableCell";
const ete = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "caption",
  {
    ref: n,
    className: de("mt-4 text-sm text-muted-foreground", t),
    ...e
  }
));
ete.displayName = "TableCaption";
const VP = ({ className: t, ...e }) => /* @__PURE__ */ g.jsx(
  "nav",
  {
    role: "navigation",
    "aria-label": "pagination",
    className: de("mx-auto flex w-full justify-center", t),
    ...e
  }
);
VP.displayName = "Pagination";
const UP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "ul",
  {
    ref: n,
    className: de("flex flex-row items-center gap-1", t),
    ...e
  }
));
UP.displayName = "PaginationContent";
const ud = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx("li", { ref: n, className: de("", t), ...e }));
ud.displayName = "PaginationItem";
const xh = ({
  className: t,
  isActive: e,
  size: n = "icon",
  ...r
}) => /* @__PURE__ */ g.jsx(
  "a",
  {
    "aria-current": e ? "page" : void 0,
    className: de(
      pC({
        variant: e ? "outline" : "ghost",
        size: n
      }),
      t
    ),
    ...r
  }
);
xh.displayName = "PaginationLink";
const WP = ({
  className: t,
  ...e
}) => /* @__PURE__ */ g.jsxs(
  xh,
  {
    "aria-label": "Go to previous page",
    size: "default",
    className: de("gap-1 pl-2.5 text-white", t),
    ...e,
    children: [
      /* @__PURE__ */ g.jsx(DF, { className: "h-4 w-4" }),
      /* @__PURE__ */ g.jsx("span", { children: "Previous" })
    ]
  }
);
WP.displayName = "PaginationPrevious";
const zP = ({
  className: t,
  ...e
}) => /* @__PURE__ */ g.jsxs(
  xh,
  {
    "aria-label": "Go to next page",
    size: "default",
    className: de("gap-1 pr-2.5 text-white", t),
    ...e,
    children: [
      /* @__PURE__ */ g.jsx("span", { children: "Next" }),
      /* @__PURE__ */ g.jsx(qF, { className: "h-4 w-4" })
    ]
  }
);
zP.displayName = "PaginationNext";
const o0 = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "div",
  {
    ref: n,
    className: de(
      "rounded-xl border bg-card text-card-foreground shadow",
      t
    ),
    ...e
  }
));
o0.displayName = "Card";
const HP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "div",
  {
    ref: n,
    className: de("flex flex-col space-y-1.5 p-6", t),
    ...e
  }
));
HP.displayName = "CardHeader";
const YP = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "h3",
  {
    ref: n,
    className: de("font-semibold leading-none tracking-tight", t),
    ...e
  }
));
YP.displayName = "CardTitle";
const tte = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "p",
  {
    ref: n,
    className: de("text-sm text-muted-foreground", t),
    ...e
  }
));
tte.displayName = "CardDescription";
const a0 = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx("div", { ref: n, className: de("p-6 pt-0", t), ...e }));
a0.displayName = "CardContent";
const nte = E.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g.jsx(
  "div",
  {
    ref: n,
    className: de("flex items-center p-6 pt-0", t),
    ...e
  }
));
nte.displayName = "CardFooter";
var rte = "Separator", FS = "horizontal", ste = ["horizontal", "vertical"], GP = E.forwardRef((t, e) => {
  const { decorative: n, orientation: r = FS, ...s } = t, i = ite(r) ? r : FS, a = n ? { role: "none" } : { "aria-orientation": i === "vertical" ? i : void 0, role: "separator" };
  return /* @__PURE__ */ g.jsx(
    ze.div,
    {
      "data-orientation": i,
      ...a,
      ...s,
      ref: e
    }
  );
});
GP.displayName = rte;
function ite(t) {
  return ste.includes(t);
}
var KP = GP;
const $P = E.forwardRef(
  ({ className: t, orientation: e = "horizontal", decorative: n = !0, ...r }, s) => /* @__PURE__ */ g.jsx(
    KP,
    {
      ref: s,
      decorative: n,
      orientation: e,
      className: de(
        "shrink-0 bg-border",
        e === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        t
      ),
      ...r
    }
  )
);
$P.displayName = KP.displayName;
function ote({ game: t, gameround: e, user: n }) {
  var v, w;
  const {
    fetchGameRound: r,
    gameRoundData: s,
    isGameRoundResultOpen: i,
    setIsGameRoundResultDialogOpen: o,
    isLoadingGameRoundData: a,
    theme: c
  } = st(), [l, u] = Ge(null);
  _e(() => {
    e && i && r(e);
  }, [e, r, i]), _e(() => {
    if (!a && (s != null && s.gameData))
      try {
        const x = JSON.parse(s.gameData);
        u(x);
      } catch (x) {
        console.error("Error parsing game data:", x);
      }
  }, [a, s]);
  const d = Pr(() => (x, A) => {
    const C = {
      backgroundSize: "cover",
      transition: "all 0.3s ease",
      borderWidth: c === "neobet" ? 0 : 2,
      borderStyle: "solid",
      borderColor: c === "neobet" ? void 0 : c === "betpanda" ? "rgba(31, 232, 138, 0.7)" : "rgba(220, 1, 108, 0.7)"
    };
    return A === "diamond" || A === "hidden" ? {
      ...C,
      borderColor: "#1fe88a",
      backgroundColor: "#1fe88a"
    } : A === "mine" ? {
      ...C,
      borderColor: "rgb(248, 113, 113)",
      backgroundColor: "rgb(248, 113, 113)"
    } : C;
  }, [c]), f = (x) => {
    if (!l) return null;
    const { selected: A, mines: C } = l;
    let S = "hidden";
    return A != null && A.includes(x) ? S = "diamond" : C != null && C.includes(x) && (S = "mine"), /* @__PURE__ */ g.jsx(
      pt,
      {
        style: d(x, S),
        className: `w-full h-full text-4xl rounded-sm p-3 select-none 
            ${S === "diamond" ? "bg-green-500 border-opacity-0 disabled:opacity-100" : S === "hidden" ? "bg-green-500 border-opacity-0 opacity-0" : S === "mine" ? "bg-red-400 text-white border-opacity-0 disabled:opacity-100" : "bg-pills cursor-pointer border-secondary"}
          `,
        disabled: !0,
        children: /* @__PURE__ */ g.jsx(
          "img",
          {
            src: S === "mine" ? xy : BC,
            width: 0,
            height: 0,
            alt: "",
            style: { width: "100%", height: "auto" }
          }
        )
      },
      x
    );
  }, h = (x) => {
    navigator.clipboard.writeText(x).then(
      () => {
        console.log("Copied to clipboard");
      },
      (A) => {
        console.error("Could not copy text: ", A);
      }
    );
  }, p = Pr(() => {
    if (!l) return null;
    const { face: x } = l, A = {
      width: "80%",
      height: "80%",
      maxWidth: "300px",
      maxHeight: "300px",
      borderRadius: "50%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "2rem",
      fontWeight: "bold",
      color: "white",
      textTransform: "uppercase",
      boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)"
    };
    return x === "HEADS" ? { ...A, backgroundColor: "#FFD700" } : x === "TAILS" ? { ...A, backgroundColor: "#C0C0C0" } : { ...A, borderColor: "#ffffff", borderWidth: "2px" };
  }, [l]), m = "flex items-center space-x-2 bg-primary rounded-md p-1 h-11", y = "bg-primary text-white text-base h-9 border-transparent focus-visible:ring-brand focus-visible:ring-2 focus-visible:ring-offset-0 focus-visible:border-0 transition-all", b = "text-xs text-gray-400";
  return /* @__PURE__ */ g.jsx(cb, { open: i, onOpenChange: o, children: /* @__PURE__ */ g.jsxs(Zf, { className: "round-result max-w-xl text-white bg-secondary border-slate-600 rounded-md p-4 text-sm max-h-[90vh] overflow-hidden", children: [
    /* @__PURE__ */ g.jsx(Qf, { className: "flex flex-row items-center justify-between space-y-0", children: /* @__PURE__ */ g.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ g.jsx(Xj, { className: "h-5 w-5" }),
      /* @__PURE__ */ g.jsx(Xf, { children: t })
    ] }) }),
    /* @__PURE__ */ g.jsx(Zi, { className: "h-full max-h-[calc(90vh-4rem)]", children: a ? /* @__PURE__ */ g.jsx("div", { className: "flex items-center justify-center p-8", children: /* @__PURE__ */ g.jsx(cC, { className: "h-8 w-8 animate-spin text-white" }) }) : s && l ? /* @__PURE__ */ g.jsxs("div", { className: "space-y-4 text-center p-6", children: [
      /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ g.jsxs("h2", { className: "text-2xl", children: [
          "ID ",
          e
        ] }),
        /* @__PURE__ */ g.jsxs("p", { className: "text-sm font-semibold text-gray-400", children: [
          "Placed by ",
          n,
          /* @__PURE__ */ g.jsx("br", {}),
          "on ",
          new Date(s.dateCreated).toLocaleString()
        ] })
      ] }),
      /* @__PURE__ */ g.jsx(o0, { className: "rounded-md bg-primary", children: /* @__PURE__ */ g.jsxs(a0, { className: "grid grid-cols-3 gap-2 p-4 text-center text-sm", children: [
        /* @__PURE__ */ g.jsxs("div", { children: [
          /* @__PURE__ */ g.jsx("p", { className: "text-sm font-semibold text-gray-400", children: "Bet" }),
          /* @__PURE__ */ g.jsxs("p", { className: "text-lg text-white flex flex-row items-center justify-center gap-1", children: [
            /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container", children: /* @__PURE__ */ g.jsx(
              "i",
              {
                className: "currency-icon currency-icon-" + ((v = s.currency) == null ? void 0 : v.toLowerCase())
              }
            ) }),
            " ",
            s.wagerAmount
          ] })
        ] }),
        /* @__PURE__ */ g.jsxs("div", { children: [
          /* @__PURE__ */ g.jsx("p", { className: "text-sm font-semibold text-gray-400", children: "Multiplier" }),
          /* @__PURE__ */ g.jsxs("p", { className: "text-lg text-white", children: [
            (s.winAmount / s.wagerAmount).toFixed(2),
            "x"
          ] })
        ] }),
        /* @__PURE__ */ g.jsxs("div", { children: [
          /* @__PURE__ */ g.jsx("p", { className: "text-sm font-semibold text-gray-400", children: "Payout" }),
          /* @__PURE__ */ g.jsxs(
            "p",
            {
              className: `text-lg ${s.winAmount > 0 ? "text-green-500" : "text-red-500"} flex flex-row items-center justify-center gap-1`,
              children: [
                /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container", children: /* @__PURE__ */ g.jsx(
                  "i",
                  {
                    className: "currency-icon currency-icon-" + ((w = s.currency) == null ? void 0 : w.toLowerCase())
                  }
                ) }),
                s.winAmount
              ]
            }
          )
        ] })
      ] }) }),
      /* @__PURE__ */ g.jsxs("div", { className: "relative z-10 bg-black p-3 lg:p-2 rounded-md w-full max-w-[300px] lg:max-w-[340px] aspect-square m-auto", children: [
        t === "Mines" && /* @__PURE__ */ g.jsx("div", { className: "grid grid-cols-5 gap-2", children: Array.from({ length: 25 }).map((x, A) => f(A)) }),
        t === "Coin Flip" && /* @__PURE__ */ g.jsx("div", { className: "w-full h-full flex items-center justify-center", children: /* @__PURE__ */ g.jsx("div", { style: p, children: l.face || "?" }) })
      ] }),
      /* @__PURE__ */ g.jsx($P, {}),
      /* @__PURE__ */ g.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ g.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ g.jsx(St, { htmlFor: "current-server-seed", className: b, children: "Server Seed (hash)" }),
          /* @__PURE__ */ g.jsxs("div", { className: m, children: [
            /* @__PURE__ */ g.jsx(
              qt,
              {
                id: "current-server-seed",
                value: s.hash,
                readOnly: !0,
                disabled: !0,
                className: y
              }
            ),
            /* @__PURE__ */ g.jsx(
              pt,
              {
                type: "button",
                variant: "ghost",
                size: "icon",
                onClick: () => h(s.hash),
                className: "h-8 w-8",
                children: /* @__PURE__ */ g.jsx(No, { className: "h-4 w-4" })
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ g.jsxs("div", { className: "flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4", children: [
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2 w-full sm:w-[70%]", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "current-client-seed", className: b, children: "Client Seed" }),
            /* @__PURE__ */ g.jsxs("div", { className: m, children: [
              /* @__PURE__ */ g.jsx(
                qt,
                {
                  id: "current-client-seed",
                  value: s.clientSeed,
                  readOnly: !0,
                  disabled: !0,
                  className: y
                }
              ),
              /* @__PURE__ */ g.jsx(
                pt,
                {
                  type: "button",
                  variant: "ghost",
                  size: "icon",
                  onClick: () => h(s.clientSeed),
                  className: "h-8 w-8",
                  children: /* @__PURE__ */ g.jsx(No, { className: "h-4 w-4" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ g.jsxs("div", { className: "space-y-2 w-full sm:w-[30%]", children: [
            /* @__PURE__ */ g.jsx(St, { htmlFor: "current-nonce", className: b, children: "Nonce" }),
            /* @__PURE__ */ g.jsxs("div", { className: m, children: [
              /* @__PURE__ */ g.jsx(
                qt,
                {
                  id: "current-nonce",
                  value: s.nonce,
                  readOnly: !0,
                  disabled: !0,
                  className: y
                }
              ),
              /* @__PURE__ */ g.jsx(
                pt,
                {
                  type: "button",
                  variant: "ghost",
                  size: "icon",
                  onClick: () => h(s.nonce.toString()),
                  className: "h-8 w-8",
                  children: /* @__PURE__ */ g.jsx(No, { className: "h-4 w-4" })
                }
              )
            ] })
          ] })
        ] })
      ] })
    ] }) : /* @__PURE__ */ g.jsx("div", { className: "p-4 text-center text-white", children: "No data available for this round." }) })
  ] }) });
}
const Bp = [
  { id: "game", label: "Game", minWidth: 100, align: "center" },
  { id: "roundId", label: "Round", minWidth: 100, align: "center" },
  { id: "user", label: "User", minWidth: 90, align: "center" },
  { id: "dateTime", label: "Date", minWidth: 140, align: "center" },
  { id: "betAmount", label: "Bet Amount", minWidth: 100, align: "center" },
  { id: "payout", label: "Payout", minWidth: 60, align: "center" },
  { id: "multiplier", label: "Multiplier", minWidth: 60, align: "center" }
];
function ate() {
  const [t, e] = Ge(0), n = 10, r = fr(), [s, i] = Ge(null), [o, a] = Ge(""), [c, l] = Ge(""), {
    historyTables: u,
    fetchHistory: d,
    isLoadingHistory: f,
    setIsGameRoundResultDialogOpen: h
  } = st(), { authToken: p } = ma();
  _e(() => {
    p && d(p, "mines");
  }, [p, d]);
  const m = (x) => {
    e(x);
  }, y = (x, A, C) => {
    i(x), a(A), h(!0), l(C);
  }, b = (x) => /* @__PURE__ */ g.jsxs(o0, { className: "mb-4", children: [
    /* @__PURE__ */ g.jsx(HP, { children: /* @__PURE__ */ g.jsxs(YP, { className: "text-sm font-medium", children: [
      x.game,
      " - Round ",
      x.roundId
    ] }) }),
    /* @__PURE__ */ g.jsx(a0, { children: /* @__PURE__ */ g.jsx("div", { className: "grid grid-cols-2 gap-2 text-sm", children: Bp.map((A) => {
      var C, S, _;
      return /* @__PURE__ */ g.jsxs("div", { className: "flex justify-between", children: [
        /* @__PURE__ */ g.jsxs("span", { className: "font-medium", children: [
          A.label,
          ":"
        ] }),
        /* @__PURE__ */ g.jsx("span", { className: `${A.align === "right" ? "text-right" : ""} ${A.id === "payout" ? x.payout < 0 ? "text-red-500" : "text-green-500" : ""}`, children: A.id === "payout" ? /* @__PURE__ */ g.jsxs("div", { className: "flex items-center justify-end gap-1", children: [
          /* @__PURE__ */ g.jsx("i", { className: `currency-icon currency-icon-${(C = x.currency) == null ? void 0 : C.toLowerCase()}` }),
          /* @__PURE__ */ g.jsx("span", { children: (S = x[A.id]) == null ? void 0 : S.toString() })
        ] }) : A.id === "dateTime" ? new Date(x[A.id]).toLocaleString() : (_ = x[A.id]) == null ? void 0 : _.toString() })
      ] }, A.id);
    }) }) })
  ] }, x.roundId), v = () => /* @__PURE__ */ g.jsxs(NP, { children: [
    /* @__PURE__ */ g.jsx(LP, { children: /* @__PURE__ */ g.jsx(Mg, { className: "border-b border-gray-700", children: Bp.map((x) => /* @__PURE__ */ g.jsx(
      BP,
      {
        className: `${x.align === "right" ? "text-right" : ""} ${x.align === "center" ? "text-center" : ""} bg-secondary sticky top-0`,
        style: {
          minWidth: x.minWidth,
          maxWidth: x.maxWidth
        },
        children: /* @__PURE__ */ g.jsx("span", { className: "text-sm font-semibold text-gray-400", children: x.label })
      },
      x.id
    )) }) }),
    /* @__PURE__ */ g.jsx(jP, { children: u.slice(t * n, t * n + n).map((x, A) => /* @__PURE__ */ g.jsx(Mg, { className: "border-b border-gray-700", children: Bp.map((C) => {
      const S = x[C.id], _ = x.currency, T = x.multiplier;
      return /* @__PURE__ */ g.jsx(
        FP,
        {
          className: `${C.align === "right" ? "text-right" : ""} ${C.align === "center" ? "text-center" : ""} break-words ${C.id === "payout" ? T <= 0 ? "text-red-500" : "text-green-500" : ""}`,
          onClick: () => y(x.roundId.toString(), x.game, x.user),
          children: C.id === "dateTime" ? new Date(S).toLocaleString() : C.id === "payout" || C.id === "betAmount" ? /* @__PURE__ */ g.jsxs("div", { className: "flex flex-row items-center justify-center gap-1", children: [
            /* @__PURE__ */ g.jsx("div", { className: "currency-icon-container", children: /* @__PURE__ */ g.jsx(
              "i",
              {
                className: "currency-icon currency-icon-" + (_ == null ? void 0 : _.toLocaleLowerCase())
              }
            ) }),
            /* @__PURE__ */ g.jsx("div", { children: S == null ? void 0 : S.toString() })
          ] }) : S == null ? void 0 : S.toString()
        },
        C.id
      );
    }) }, A)) })
  ] }), w = /* @__PURE__ */ g.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ g.jsx(Zi, { className: "h-[50vh] w-full rounded-md border border-gray-700", children: f ? /* @__PURE__ */ g.jsx("div", { className: "flex justify-center items-center h-full", children: /* @__PURE__ */ g.jsx(cC, { className: "animate-spin h-8 w-8 text-brand" }) }) : r ? /* @__PURE__ */ g.jsx("div", { className: "p-4", children: u.slice(t * n, t * n + n).map(b) }) : v() }),
    /* @__PURE__ */ g.jsx(VP, { children: /* @__PURE__ */ g.jsxs(UP, { children: [
      /* @__PURE__ */ g.jsx(ud, { children: /* @__PURE__ */ g.jsx(
        WP,
        {
          onClick: () => m(t - 1),
          disabled: t === 0
        }
      ) }),
      [...Array(Math.ceil(u.length / n))].map(
        (x, A) => /* @__PURE__ */ g.jsx(ud, { children: /* @__PURE__ */ g.jsx(
          xh,
          {
            onClick: () => m(A),
            isActive: t === A,
            children: A + 1
          }
        ) }, A)
      ),
      /* @__PURE__ */ g.jsx(ud, { children: /* @__PURE__ */ g.jsx(
        zP,
        {
          onClick: () => m(t + 1),
          disabled: t >= Math.ceil(u.length / n) - 1
        }
      ) })
    ] }) })
  ] });
  return /* @__PURE__ */ g.jsxs(g.Fragment, { children: [
    w,
    s && /* @__PURE__ */ g.jsx(
      ote,
      {
        game: o,
        user: c,
        gameround: s
      }
    )
  ] });
}
const cte = ({
  game: t,
  token: e,
  currency: n,
  lang: r,
  theme: s,
  currencyData: i
}) => {
  const { setAuthToken: o } = ma(), [a, c] = Ge({ status: "initializing" }), [l, u] = Ge(null), [d, f] = Ge(null), { updateSettings: h } = Xo(), { resetGame: p } = Hi(), {
    selectedCurrency: m,
    isGameActive: y,
    setCurrency: b,
    setBalance: v,
    setBetRanges: w,
    setInitializing: x,
    setActiveRoundData: A,
    setTheme: C,
    setFiatConversionRates: S,
    setShowFiat: _,
    setFiatCurrency: T,
    setIsGameActive: k,
    resetSharedStates: R
  } = st(), P = Je(async () => {
    if (!e || !t) {
      c({ status: "error", error: "Invalid parameters" });
      return;
    }
    try {
      p(), R(), k(!1), u(null), c({ status: "initializing" }), x(!0), await o(e), await aI(r);
      const O = await wB(e, t);
      O.activeRound ? (O.activeRound.currency !== n ? (b(O.activeRound.currencyDefinition), f(n)) : b(O.currencyDefinition), k(!0), A({
        ...O.activeRound,
        isRoundActive: !0
      })) : (b(O.currencyDefinition), h({ betAmount: Number(O.allowedBets[0]) }), w({
        minBet: O.allowedBets[0],
        maxBet: O.allowedBets[1]
      })), v(O.balance), c({ status: "ready" });
    } catch (O) {
      console.error("Launcher initialization failed:", O), c({
        status: "error",
        error: O instanceof Error ? O.message : "Failed to initialize launcher"
      });
    } finally {
      x(!1);
    }
  }, [
    e,
    t,
    r,
    o,
    x,
    b,
    w,
    h,
    v,
    A,
    p,
    k,
    R
  ]), M = Je(async (O) => {
    if (e)
      try {
        x(!0);
        const q = await xB(e, O);
        b(q.currencyDefinition), w({
          minBet: q.allowedBets[0],
          maxBet: q.allowedBets[1]
        }), y || h({ betAmount: Number(q.allowedBets[0]) }), v(q.balance);
      } catch (q) {
        console.error("Currency update failed:", q);
      } finally {
        x(!1);
      }
  }, [e, b, w, h, v, x]);
  if (_e(() => {
    if (!i) return;
    const O = {}, q = i.preferredExchangeCurrency;
    i.currencyDefinitions.forEach((L) => {
      L.cryptoPrices && Object.entries(L.cryptoPrices).forEach(([N, j]) => {
        O[`${L.code}_${N}`] = j.rate, q === j.currencyDefinition.code && T(j.currencyDefinition);
      });
    }), S(O), _(i.showFiat);
  }, [i, S, T, _]), _e(() => {
    P();
  }, [t, e, P]), _e(() => {
    C(s);
  }, [s, C]), _e(() => {
    a.status === "ready" && n !== m.currencyCode && (y ? u(n) : M(n));
  }, [n, m.currencyCode]), _e(() => {
    y || (d ? (M(d), f(null)) : l && (M(l), u(null)));
  }, [y, d, l]), a.status === "initializing")
    return /* @__PURE__ */ g.jsx("div", { className: "w-full h-full flex items-center justify-center", children: "Loading..." });
  if (a.status === "error")
    return /* @__PURE__ */ g.jsxs("div", { className: "w-full h-full flex items-center justify-center text-red-500", children: [
      "Error: ",
      a.error
    ] });
  const D = { token: e, currency: n, lang: r, theme: s, currencyData: i };
  switch (t) {
    case "cointoss":
      return /* @__PURE__ */ g.jsx(nF, { ...D });
    case "mines":
      return /* @__PURE__ */ g.jsx(VF, { ...D });
    default:
      return /* @__PURE__ */ g.jsx("div", { children: "Unsupported game type" });
  }
}, lte = (t) => {
  const e = Et(null), {
    selectedCurrency: n,
    balance: r
  } = st();
  return _e(() => {
    if (e.current && r !== 0) {
      const i = new CustomEvent("balanceUpdate", {
        bubbles: !0,
        composed: !0,
        detail: {
          balance: r,
          currency: n.currencyCode
        }
      });
      e.current.dispatchEvent(i), console.log("Pushing event balanceUpdate. New balance:", r);
    }
  }, [r, n.currencyCode]), _e(() => {
    if (e.current) {
      const i = e.current.getRootNode();
      if (i instanceof ShadowRoot) {
        const o = document.createElement("style");
        o.textContent = UF, i.appendChild(o);
      }
    }
  }, []), /* @__PURE__ */ g.jsx(Xee, { children: /* @__PURE__ */ g.jsx("div", { ref: e, className: "w-full lg:max-w-[1200px] md:max-w-[600px] bg-gray-900 rounded-lg shadow-2xl overflow-hidden flex flex-col", "data-theme": t.theme, children: /* @__PURE__ */ g.jsx(T2, { children: /* @__PURE__ */ g.jsxs(hB, { children: [
    /* @__PURE__ */ g.jsx("div", { className: "flex flex-col lg:flex-row h-auto lg:h-[600px]", children: /* @__PURE__ */ g.jsx(cte, { ...t }) }),
    /* @__PURE__ */ g.jsx("div", { className: "relative", children: /* @__PURE__ */ g.jsx(A8, {}) }),
    /* @__PURE__ */ g.jsxs("div", { className: "flex flex-col mt-5", children: [
      /* @__PURE__ */ g.jsx(ate, {}),
      /* @__PURE__ */ g.jsx(L6, {})
    ] })
  ] }) }) }) });
}, ute = S2(lte, {
  props: {
    game: "string",
    token: "string",
    currency: "string",
    lang: "string",
    theme: "string",
    currencyData: "json"
  },
  shadow: "open"
});
customElements.get("blink-launcher") || customElements.define("blink-launcher", ute);
export {
  ute as default
};
